// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides details about a labeling work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workteam {
    /// <p>The name of the work team.</p>
    pub workteam_name: std::option::Option<std::string::String>,
    /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify the workers that make up the work team. </p>
    /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity provider (IdP) use <code>OidcMemberDefinition</code>.</p>
    pub member_definitions: std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
    /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
    pub workforce_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Marketplace identifier for a vendor's work team.</p>
    pub product_listing_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A description of the work team.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.</p>
    pub sub_domain: std::option::Option<std::string::String>,
    /// <p>The date and time that the work team was created (timestamp).</p>
    pub create_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the work team was last updated (timestamp).</p>
    pub last_updated_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Configures SNS notifications of available or expiring work items for work teams.</p>
    pub notification_configuration: std::option::Option<crate::model::NotificationConfiguration>,
}
impl Workteam {
    /// <p>The name of the work team.</p>
    pub fn workteam_name(&self) -> std::option::Option<&str> {
        self.workteam_name.as_deref()
    }
    /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify the workers that make up the work team. </p>
    /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity provider (IdP) use <code>OidcMemberDefinition</code>.</p>
    pub fn member_definitions(&self) -> std::option::Option<&[crate::model::MemberDefinition]> {
        self.member_definitions.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
    pub fn workteam_arn(&self) -> std::option::Option<&str> {
        self.workteam_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
    pub fn workforce_arn(&self) -> std::option::Option<&str> {
        self.workforce_arn.as_deref()
    }
    /// <p>The Amazon Marketplace identifier for a vendor's work team.</p>
    pub fn product_listing_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.product_listing_ids.as_deref()
    }
    /// <p>A description of the work team.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.</p>
    pub fn sub_domain(&self) -> std::option::Option<&str> {
        self.sub_domain.as_deref()
    }
    /// <p>The date and time that the work team was created (timestamp).</p>
    pub fn create_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_date.as_ref()
    }
    /// <p>The date and time that the work team was last updated (timestamp).</p>
    pub fn last_updated_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_date.as_ref()
    }
    /// <p>Configures SNS notifications of available or expiring work items for work teams.</p>
    pub fn notification_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NotificationConfiguration> {
        self.notification_configuration.as_ref()
    }
}
impl std::fmt::Debug for Workteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workteam");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.field("member_definitions", &self.member_definitions);
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("workforce_arn", &self.workforce_arn);
        formatter.field("product_listing_ids", &self.product_listing_ids);
        formatter.field("description", &self.description);
        formatter.field("sub_domain", &self.sub_domain);
        formatter.field("create_date", &self.create_date);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.finish()
    }
}
/// See [`Workteam`](crate::model::Workteam)
pub mod workteam {

    /// A builder for [`Workteam`](crate::model::Workteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_name: std::option::Option<std::string::String>,
        pub(crate) member_definitions:
            std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) workforce_arn: std::option::Option<std::string::String>,
        pub(crate) product_listing_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sub_domain: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) notification_configuration:
            std::option::Option<crate::model::NotificationConfiguration>,
    }
    impl Builder {
        /// <p>The name of the work team.</p>
        pub fn workteam_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_name = Some(input.into());
            self
        }
        /// <p>The name of the work team.</p>
        pub fn set_workteam_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workteam_name = input;
            self
        }
        /// Appends an item to `member_definitions`.
        ///
        /// To override the contents of this collection use [`set_member_definitions`](Self::set_member_definitions).
        ///
        /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify the workers that make up the work team. </p>
        /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity provider (IdP) use <code>OidcMemberDefinition</code>.</p>
        pub fn member_definitions(mut self, input: crate::model::MemberDefinition) -> Self {
            let mut v = self.member_definitions.unwrap_or_default();
            v.push(input);
            self.member_definitions = Some(v);
            self
        }
        /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify the workers that make up the work team. </p>
        /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity provider (IdP) use <code>OidcMemberDefinition</code>.</p>
        pub fn set_member_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
        ) -> Self {
            self.member_definitions = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
        pub fn workforce_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
        pub fn set_workforce_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_arn = input;
            self
        }
        /// Appends an item to `product_listing_ids`.
        ///
        /// To override the contents of this collection use [`set_product_listing_ids`](Self::set_product_listing_ids).
        ///
        /// <p>The Amazon Marketplace identifier for a vendor's work team.</p>
        pub fn product_listing_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.product_listing_ids.unwrap_or_default();
            v.push(input.into());
            self.product_listing_ids = Some(v);
            self
        }
        /// <p>The Amazon Marketplace identifier for a vendor's work team.</p>
        pub fn set_product_listing_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.product_listing_ids = input;
            self
        }
        /// <p>A description of the work team.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the work team.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.</p>
        pub fn sub_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.sub_domain = Some(input.into());
            self
        }
        /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.</p>
        pub fn set_sub_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sub_domain = input;
            self
        }
        /// <p>The date and time that the work team was created (timestamp).</p>
        pub fn create_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_date = Some(input);
            self
        }
        /// <p>The date and time that the work team was created (timestamp).</p>
        pub fn set_create_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The date and time that the work team was last updated (timestamp).</p>
        pub fn last_updated_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_date = Some(input);
            self
        }
        /// <p>The date and time that the work team was last updated (timestamp).</p>
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>Configures SNS notifications of available or expiring work items for work teams.</p>
        pub fn notification_configuration(
            mut self,
            input: crate::model::NotificationConfiguration,
        ) -> Self {
            self.notification_configuration = Some(input);
            self
        }
        /// <p>Configures SNS notifications of available or expiring work items for work teams.</p>
        pub fn set_notification_configuration(
            mut self,
            input: std::option::Option<crate::model::NotificationConfiguration>,
        ) -> Self {
            self.notification_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Workteam`](crate::model::Workteam)
        pub fn build(self) -> crate::model::Workteam {
            crate::model::Workteam {
                workteam_name: self.workteam_name,
                member_definitions: self.member_definitions,
                workteam_arn: self.workteam_arn,
                workforce_arn: self.workforce_arn,
                product_listing_ids: self.product_listing_ids,
                description: self.description,
                sub_domain: self.sub_domain,
                create_date: self.create_date,
                last_updated_date: self.last_updated_date,
                notification_configuration: self.notification_configuration,
            }
        }
    }
}
impl Workteam {
    /// Creates a new builder-style object to manufacture [`Workteam`](crate::model::Workteam)
    pub fn builder() -> crate::model::workteam::Builder {
        crate::model::workteam::Builder::default()
    }
}

/// <p>Configures Amazon SNS notifications of available or expiring work items for work teams.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotificationConfiguration {
    /// <p>The ARN for the Amazon SNS topic to which notifications should be published.</p>
    pub notification_topic_arn: std::option::Option<std::string::String>,
}
impl NotificationConfiguration {
    /// <p>The ARN for the Amazon SNS topic to which notifications should be published.</p>
    pub fn notification_topic_arn(&self) -> std::option::Option<&str> {
        self.notification_topic_arn.as_deref()
    }
}
impl std::fmt::Debug for NotificationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotificationConfiguration");
        formatter.field("notification_topic_arn", &self.notification_topic_arn);
        formatter.finish()
    }
}
/// See [`NotificationConfiguration`](crate::model::NotificationConfiguration)
pub mod notification_configuration {

    /// A builder for [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notification_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the Amazon SNS topic to which notifications should be published.</p>
        pub fn notification_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_topic_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the Amazon SNS topic to which notifications should be published.</p>
        pub fn set_notification_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationConfiguration`](crate::model::NotificationConfiguration)
        pub fn build(self) -> crate::model::NotificationConfiguration {
            crate::model::NotificationConfiguration {
                notification_topic_arn: self.notification_topic_arn,
            }
        }
    }
}
impl NotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    pub fn builder() -> crate::model::notification_configuration::Builder {
        crate::model::notification_configuration::Builder::default()
    }
}

/// <p>Defines an Amazon Cognito or your own OIDC IdP user group that is part of a work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MemberDefinition {
    /// <p>The Amazon Cognito user group that is part of the work team.</p>
    pub cognito_member_definition: std::option::Option<crate::model::CognitoMemberDefinition>,
    /// <p>A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group are added to the work team.</p>
    pub oidc_member_definition: std::option::Option<crate::model::OidcMemberDefinition>,
}
impl MemberDefinition {
    /// <p>The Amazon Cognito user group that is part of the work team.</p>
    pub fn cognito_member_definition(
        &self,
    ) -> std::option::Option<&crate::model::CognitoMemberDefinition> {
        self.cognito_member_definition.as_ref()
    }
    /// <p>A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group are added to the work team.</p>
    pub fn oidc_member_definition(
        &self,
    ) -> std::option::Option<&crate::model::OidcMemberDefinition> {
        self.oidc_member_definition.as_ref()
    }
}
impl std::fmt::Debug for MemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MemberDefinition");
        formatter.field("cognito_member_definition", &self.cognito_member_definition);
        formatter.field("oidc_member_definition", &self.oidc_member_definition);
        formatter.finish()
    }
}
/// See [`MemberDefinition`](crate::model::MemberDefinition)
pub mod member_definition {

    /// A builder for [`MemberDefinition`](crate::model::MemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cognito_member_definition:
            std::option::Option<crate::model::CognitoMemberDefinition>,
        pub(crate) oidc_member_definition: std::option::Option<crate::model::OidcMemberDefinition>,
    }
    impl Builder {
        /// <p>The Amazon Cognito user group that is part of the work team.</p>
        pub fn cognito_member_definition(
            mut self,
            input: crate::model::CognitoMemberDefinition,
        ) -> Self {
            self.cognito_member_definition = Some(input);
            self
        }
        /// <p>The Amazon Cognito user group that is part of the work team.</p>
        pub fn set_cognito_member_definition(
            mut self,
            input: std::option::Option<crate::model::CognitoMemberDefinition>,
        ) -> Self {
            self.cognito_member_definition = input;
            self
        }
        /// <p>A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group are added to the work team.</p>
        pub fn oidc_member_definition(mut self, input: crate::model::OidcMemberDefinition) -> Self {
            self.oidc_member_definition = Some(input);
            self
        }
        /// <p>A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group are added to the work team.</p>
        pub fn set_oidc_member_definition(
            mut self,
            input: std::option::Option<crate::model::OidcMemberDefinition>,
        ) -> Self {
            self.oidc_member_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberDefinition`](crate::model::MemberDefinition)
        pub fn build(self) -> crate::model::MemberDefinition {
            crate::model::MemberDefinition {
                cognito_member_definition: self.cognito_member_definition,
                oidc_member_definition: self.oidc_member_definition,
            }
        }
    }
}
impl MemberDefinition {
    /// Creates a new builder-style object to manufacture [`MemberDefinition`](crate::model::MemberDefinition)
    pub fn builder() -> crate::model::member_definition::Builder {
        crate::model::member_definition::Builder::default()
    }
}

/// <p>A list of user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group are added to the work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcMemberDefinition {
    /// <p>A list of comma seperated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl OidcMemberDefinition {
    /// <p>A list of comma seperated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.</p>
    pub fn groups(&self) -> std::option::Option<&[std::string::String]> {
        self.groups.as_deref()
    }
}
impl std::fmt::Debug for OidcMemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcMemberDefinition");
        formatter.field("groups", &self.groups);
        formatter.finish()
    }
}
/// See [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
pub mod oidc_member_definition {

    /// A builder for [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>A list of comma seperated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.</p>
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        /// <p>A list of comma seperated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
        pub fn build(self) -> crate::model::OidcMemberDefinition {
            crate::model::OidcMemberDefinition {
                groups: self.groups,
            }
        }
    }
}
impl OidcMemberDefinition {
    /// Creates a new builder-style object to manufacture [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
    pub fn builder() -> crate::model::oidc_member_definition::Builder {
        crate::model::oidc_member_definition::Builder::default()
    }
}

/// <p>Identifies a Amazon Cognito user group. A user group can be used in on or more work teams.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoMemberDefinition {
    /// <p>An identifier for a user pool. The user pool must be in the same region as the service that you are calling.</p>
    pub user_pool: std::option::Option<std::string::String>,
    /// <p>An identifier for a user group.</p>
    pub user_group: std::option::Option<std::string::String>,
    /// <p>An identifier for an application client. You must create the app client ID using Amazon Cognito.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl CognitoMemberDefinition {
    /// <p>An identifier for a user pool. The user pool must be in the same region as the service that you are calling.</p>
    pub fn user_pool(&self) -> std::option::Option<&str> {
        self.user_pool.as_deref()
    }
    /// <p>An identifier for a user group.</p>
    pub fn user_group(&self) -> std::option::Option<&str> {
        self.user_group.as_deref()
    }
    /// <p>An identifier for an application client. You must create the app client ID using Amazon Cognito.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
}
impl std::fmt::Debug for CognitoMemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoMemberDefinition");
        formatter.field("user_pool", &self.user_pool);
        formatter.field("user_group", &self.user_group);
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}
/// See [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
pub mod cognito_member_definition {

    /// A builder for [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_pool: std::option::Option<std::string::String>,
        pub(crate) user_group: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for a user pool. The user pool must be in the same region as the service that you are calling.</p>
        pub fn user_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool = Some(input.into());
            self
        }
        /// <p>An identifier for a user pool. The user pool must be in the same region as the service that you are calling.</p>
        pub fn set_user_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool = input;
            self
        }
        /// <p>An identifier for a user group.</p>
        pub fn user_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_group = Some(input.into());
            self
        }
        /// <p>An identifier for a user group.</p>
        pub fn set_user_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_group = input;
            self
        }
        /// <p>An identifier for an application client. You must create the app client ID using Amazon Cognito.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>An identifier for an application client. You must create the app client ID using Amazon Cognito.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
        pub fn build(self) -> crate::model::CognitoMemberDefinition {
            crate::model::CognitoMemberDefinition {
                user_pool: self.user_pool,
                user_group: self.user_group,
                client_id: self.client_id,
            }
        }
    }
}
impl CognitoMemberDefinition {
    /// Creates a new builder-style object to manufacture [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
    pub fn builder() -> crate::model::cognito_member_definition::Builder {
        crate::model::cognito_member_definition::Builder::default()
    }
}

/// <p>A single private workforce, which is automatically created when you create your first private work team. You can create one private work force in each Amazon Web Services Region. By default, any workforce-related API operation used in a specific region will apply to the workforce created in that region. To learn how to create a private workforce, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-create-private.html">Create a Private Workforce</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workforce {
    /// <p>The name of the private workforce.</p>
    pub workforce_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
    pub workforce_arn: std::option::Option<std::string::String>,
    /// <p>The most recent date that was used to successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's allow list.</p>
    pub last_updated_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
    pub source_ip_config: std::option::Option<crate::model::SourceIpConfig>,
    /// <p>The subdomain for your OIDC Identity Provider.</p>
    pub sub_domain: std::option::Option<std::string::String>,
    /// <p>The configuration of an Amazon Cognito workforce. A single Cognito workforce is created using and corresponds to a single <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> Amazon Cognito user pool</a>.</p>
    pub cognito_config: std::option::Option<crate::model::CognitoConfig>,
    /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
    pub oidc_config: std::option::Option<crate::model::OidcConfigForResponse>,
    /// <p>The date that the workforce is created.</p>
    pub create_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Workforce {
    /// <p>The name of the private workforce.</p>
    pub fn workforce_name(&self) -> std::option::Option<&str> {
        self.workforce_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
    pub fn workforce_arn(&self) -> std::option::Option<&str> {
        self.workforce_arn.as_deref()
    }
    /// <p>The most recent date that was used to successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's allow list.</p>
    pub fn last_updated_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_date.as_ref()
    }
    /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
    pub fn source_ip_config(&self) -> std::option::Option<&crate::model::SourceIpConfig> {
        self.source_ip_config.as_ref()
    }
    /// <p>The subdomain for your OIDC Identity Provider.</p>
    pub fn sub_domain(&self) -> std::option::Option<&str> {
        self.sub_domain.as_deref()
    }
    /// <p>The configuration of an Amazon Cognito workforce. A single Cognito workforce is created using and corresponds to a single <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> Amazon Cognito user pool</a>.</p>
    pub fn cognito_config(&self) -> std::option::Option<&crate::model::CognitoConfig> {
        self.cognito_config.as_ref()
    }
    /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
    pub fn oidc_config(&self) -> std::option::Option<&crate::model::OidcConfigForResponse> {
        self.oidc_config.as_ref()
    }
    /// <p>The date that the workforce is created.</p>
    pub fn create_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_date.as_ref()
    }
}
impl std::fmt::Debug for Workforce {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workforce");
        formatter.field("workforce_name", &self.workforce_name);
        formatter.field("workforce_arn", &self.workforce_arn);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field("source_ip_config", &self.source_ip_config);
        formatter.field("sub_domain", &self.sub_domain);
        formatter.field("cognito_config", &self.cognito_config);
        formatter.field("oidc_config", &self.oidc_config);
        formatter.field("create_date", &self.create_date);
        formatter.finish()
    }
}
/// See [`Workforce`](crate::model::Workforce)
pub mod workforce {

    /// A builder for [`Workforce`](crate::model::Workforce)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workforce_name: std::option::Option<std::string::String>,
        pub(crate) workforce_arn: std::option::Option<std::string::String>,
        pub(crate) last_updated_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_ip_config: std::option::Option<crate::model::SourceIpConfig>,
        pub(crate) sub_domain: std::option::Option<std::string::String>,
        pub(crate) cognito_config: std::option::Option<crate::model::CognitoConfig>,
        pub(crate) oidc_config: std::option::Option<crate::model::OidcConfigForResponse>,
        pub(crate) create_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the private workforce.</p>
        pub fn workforce_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_name = Some(input.into());
            self
        }
        /// <p>The name of the private workforce.</p>
        pub fn set_workforce_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
        pub fn workforce_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
        pub fn set_workforce_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_arn = input;
            self
        }
        /// <p>The most recent date that was used to successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's allow list.</p>
        pub fn last_updated_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_date = Some(input);
            self
        }
        /// <p>The most recent date that was used to successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's allow list.</p>
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
        pub fn source_ip_config(mut self, input: crate::model::SourceIpConfig) -> Self {
            self.source_ip_config = Some(input);
            self
        }
        /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
        pub fn set_source_ip_config(
            mut self,
            input: std::option::Option<crate::model::SourceIpConfig>,
        ) -> Self {
            self.source_ip_config = input;
            self
        }
        /// <p>The subdomain for your OIDC Identity Provider.</p>
        pub fn sub_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.sub_domain = Some(input.into());
            self
        }
        /// <p>The subdomain for your OIDC Identity Provider.</p>
        pub fn set_sub_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sub_domain = input;
            self
        }
        /// <p>The configuration of an Amazon Cognito workforce. A single Cognito workforce is created using and corresponds to a single <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> Amazon Cognito user pool</a>.</p>
        pub fn cognito_config(mut self, input: crate::model::CognitoConfig) -> Self {
            self.cognito_config = Some(input);
            self
        }
        /// <p>The configuration of an Amazon Cognito workforce. A single Cognito workforce is created using and corresponds to a single <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> Amazon Cognito user pool</a>.</p>
        pub fn set_cognito_config(
            mut self,
            input: std::option::Option<crate::model::CognitoConfig>,
        ) -> Self {
            self.cognito_config = input;
            self
        }
        /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
        pub fn oidc_config(mut self, input: crate::model::OidcConfigForResponse) -> Self {
            self.oidc_config = Some(input);
            self
        }
        /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
        pub fn set_oidc_config(
            mut self,
            input: std::option::Option<crate::model::OidcConfigForResponse>,
        ) -> Self {
            self.oidc_config = input;
            self
        }
        /// <p>The date that the workforce is created.</p>
        pub fn create_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_date = Some(input);
            self
        }
        /// <p>The date that the workforce is created.</p>
        pub fn set_create_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Workforce`](crate::model::Workforce)
        pub fn build(self) -> crate::model::Workforce {
            crate::model::Workforce {
                workforce_name: self.workforce_name,
                workforce_arn: self.workforce_arn,
                last_updated_date: self.last_updated_date,
                source_ip_config: self.source_ip_config,
                sub_domain: self.sub_domain,
                cognito_config: self.cognito_config,
                oidc_config: self.oidc_config,
                create_date: self.create_date,
            }
        }
    }
}
impl Workforce {
    /// Creates a new builder-style object to manufacture [`Workforce`](crate::model::Workforce)
    pub fn builder() -> crate::model::workforce::Builder {
        crate::model::workforce::Builder::default()
    }
}

/// <p>Your OIDC IdP workforce configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcConfigForResponse {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub authorization_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub token_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub user_info_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub logout_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub jwks_uri: std::option::Option<std::string::String>,
}
impl OidcConfigForResponse {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub fn issuer(&self) -> std::option::Option<&str> {
        self.issuer.as_deref()
    }
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub fn authorization_endpoint(&self) -> std::option::Option<&str> {
        self.authorization_endpoint.as_deref()
    }
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub fn token_endpoint(&self) -> std::option::Option<&str> {
        self.token_endpoint.as_deref()
    }
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub fn user_info_endpoint(&self) -> std::option::Option<&str> {
        self.user_info_endpoint.as_deref()
    }
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub fn logout_endpoint(&self) -> std::option::Option<&str> {
        self.logout_endpoint.as_deref()
    }
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub fn jwks_uri(&self) -> std::option::Option<&str> {
        self.jwks_uri.as_deref()
    }
}
impl std::fmt::Debug for OidcConfigForResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcConfigForResponse");
        formatter.field("client_id", &self.client_id);
        formatter.field("issuer", &self.issuer);
        formatter.field("authorization_endpoint", &self.authorization_endpoint);
        formatter.field("token_endpoint", &self.token_endpoint);
        formatter.field("user_info_endpoint", &self.user_info_endpoint);
        formatter.field("logout_endpoint", &self.logout_endpoint);
        formatter.field("jwks_uri", &self.jwks_uri);
        formatter.finish()
    }
}
/// See [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
pub mod oidc_config_for_response {

    /// A builder for [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) authorization_endpoint: std::option::Option<std::string::String>,
        pub(crate) token_endpoint: std::option::Option<std::string::String>,
        pub(crate) user_info_endpoint: std::option::Option<std::string::String>,
        pub(crate) logout_endpoint: std::option::Option<std::string::String>,
        pub(crate) jwks_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn authorization_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn set_authorization_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_endpoint = input;
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn token_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn set_token_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_endpoint = input;
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn user_info_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_info_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn set_user_info_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_info_endpoint = input;
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn logout_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.logout_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn set_logout_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logout_endpoint = input;
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn jwks_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.jwks_uri = Some(input.into());
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn set_jwks_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.jwks_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
        pub fn build(self) -> crate::model::OidcConfigForResponse {
            crate::model::OidcConfigForResponse {
                client_id: self.client_id,
                issuer: self.issuer,
                authorization_endpoint: self.authorization_endpoint,
                token_endpoint: self.token_endpoint,
                user_info_endpoint: self.user_info_endpoint,
                logout_endpoint: self.logout_endpoint,
                jwks_uri: self.jwks_uri,
            }
        }
    }
}
impl OidcConfigForResponse {
    /// Creates a new builder-style object to manufacture [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
    pub fn builder() -> crate::model::oidc_config_for_response::Builder {
        crate::model::oidc_config_for_response::Builder::default()
    }
}

/// <p>Use this parameter to configure your Amazon Cognito workforce. A single Cognito workforce is created using and corresponds to a single <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> Amazon Cognito user pool</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoConfig {
    /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> user pool</a> is a user directory in Amazon Cognito. With a user pool, your users can sign in to your web or mobile app through Amazon Cognito. Your users can also sign in through social identity providers like Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
    pub user_pool: std::option::Option<std::string::String>,
    /// <p>The client ID for your Amazon Cognito user pool.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl CognitoConfig {
    /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> user pool</a> is a user directory in Amazon Cognito. With a user pool, your users can sign in to your web or mobile app through Amazon Cognito. Your users can also sign in through social identity providers like Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
    pub fn user_pool(&self) -> std::option::Option<&str> {
        self.user_pool.as_deref()
    }
    /// <p>The client ID for your Amazon Cognito user pool.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
}
impl std::fmt::Debug for CognitoConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoConfig");
        formatter.field("user_pool", &self.user_pool);
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}
/// See [`CognitoConfig`](crate::model::CognitoConfig)
pub mod cognito_config {

    /// A builder for [`CognitoConfig`](crate::model::CognitoConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_pool: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> user pool</a> is a user directory in Amazon Cognito. With a user pool, your users can sign in to your web or mobile app through Amazon Cognito. Your users can also sign in through social identity providers like Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
        pub fn user_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool = Some(input.into());
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html"> user pool</a> is a user directory in Amazon Cognito. With a user pool, your users can sign in to your web or mobile app through Amazon Cognito. Your users can also sign in through social identity providers like Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
        pub fn set_user_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool = input;
            self
        }
        /// <p>The client ID for your Amazon Cognito user pool.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>The client ID for your Amazon Cognito user pool.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoConfig`](crate::model::CognitoConfig)
        pub fn build(self) -> crate::model::CognitoConfig {
            crate::model::CognitoConfig {
                user_pool: self.user_pool,
                client_id: self.client_id,
            }
        }
    }
}
impl CognitoConfig {
    /// Creates a new builder-style object to manufacture [`CognitoConfig`](crate::model::CognitoConfig)
    pub fn builder() -> crate::model::cognito_config::Builder {
        crate::model::cognito_config::Builder::default()
    }
}

/// <p>A list of IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>). Used to create an allow list of IP addresses for a private workforce. Workers will only be able to login to their worker portal from an IP address within this range. By default, a workforce isn't restricted to specific IP addresses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceIpConfig {
    /// <p>A list of one to ten <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">Classless Inter-Domain Routing</a> (CIDR) values.</p>
    /// <p>Maximum: Ten CIDR values</p> <note>
    /// <p>The following Length Constraints apply to individual CIDR values in the CIDR value list.</p>
    /// </note>
    pub cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SourceIpConfig {
    /// <p>A list of one to ten <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">Classless Inter-Domain Routing</a> (CIDR) values.</p>
    /// <p>Maximum: Ten CIDR values</p> <note>
    /// <p>The following Length Constraints apply to individual CIDR values in the CIDR value list.</p>
    /// </note>
    pub fn cidrs(&self) -> std::option::Option<&[std::string::String]> {
        self.cidrs.as_deref()
    }
}
impl std::fmt::Debug for SourceIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceIpConfig");
        formatter.field("cidrs", &self.cidrs);
        formatter.finish()
    }
}
/// See [`SourceIpConfig`](crate::model::SourceIpConfig)
pub mod source_ip_config {

    /// A builder for [`SourceIpConfig`](crate::model::SourceIpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `cidrs`.
        ///
        /// To override the contents of this collection use [`set_cidrs`](Self::set_cidrs).
        ///
        /// <p>A list of one to ten <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">Classless Inter-Domain Routing</a> (CIDR) values.</p>
        /// <p>Maximum: Ten CIDR values</p> <note>
        /// <p>The following Length Constraints apply to individual CIDR values in the CIDR value list.</p>
        /// </note>
        pub fn cidrs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cidrs.unwrap_or_default();
            v.push(input.into());
            self.cidrs = Some(v);
            self
        }
        /// <p>A list of one to ten <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">Classless Inter-Domain Routing</a> (CIDR) values.</p>
        /// <p>Maximum: Ten CIDR values</p> <note>
        /// <p>The following Length Constraints apply to individual CIDR values in the CIDR value list.</p>
        /// </note>
        pub fn set_cidrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cidrs = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceIpConfig`](crate::model::SourceIpConfig)
        pub fn build(self) -> crate::model::SourceIpConfig {
            crate::model::SourceIpConfig { cidrs: self.cidrs }
        }
    }
}
impl SourceIpConfig {
    /// Creates a new builder-style object to manufacture [`SourceIpConfig`](crate::model::SourceIpConfig)
    pub fn builder() -> crate::model::source_ip_config::Builder {
        crate::model::source_ip_config::Builder::default()
    }
}

/// <p>Use this parameter to configure your OIDC Identity Provider (IdP).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcConfig {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
    pub client_secret: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub authorization_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub token_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub user_info_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub logout_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub jwks_uri: std::option::Option<std::string::String>,
}
impl OidcConfig {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
    pub fn client_secret(&self) -> std::option::Option<&str> {
        self.client_secret.as_deref()
    }
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub fn issuer(&self) -> std::option::Option<&str> {
        self.issuer.as_deref()
    }
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub fn authorization_endpoint(&self) -> std::option::Option<&str> {
        self.authorization_endpoint.as_deref()
    }
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub fn token_endpoint(&self) -> std::option::Option<&str> {
        self.token_endpoint.as_deref()
    }
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub fn user_info_endpoint(&self) -> std::option::Option<&str> {
        self.user_info_endpoint.as_deref()
    }
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub fn logout_endpoint(&self) -> std::option::Option<&str> {
        self.logout_endpoint.as_deref()
    }
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub fn jwks_uri(&self) -> std::option::Option<&str> {
        self.jwks_uri.as_deref()
    }
}
impl std::fmt::Debug for OidcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcConfig");
        formatter.field("client_id", &self.client_id);
        formatter.field("client_secret", &"*** Sensitive Data Redacted ***");
        formatter.field("issuer", &self.issuer);
        formatter.field("authorization_endpoint", &self.authorization_endpoint);
        formatter.field("token_endpoint", &self.token_endpoint);
        formatter.field("user_info_endpoint", &self.user_info_endpoint);
        formatter.field("logout_endpoint", &self.logout_endpoint);
        formatter.field("jwks_uri", &self.jwks_uri);
        formatter.finish()
    }
}
/// See [`OidcConfig`](crate::model::OidcConfig)
pub mod oidc_config {

    /// A builder for [`OidcConfig`](crate::model::OidcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) client_secret: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) authorization_endpoint: std::option::Option<std::string::String>,
        pub(crate) token_endpoint: std::option::Option<std::string::String>,
        pub(crate) user_info_endpoint: std::option::Option<std::string::String>,
        pub(crate) logout_endpoint: std::option::Option<std::string::String>,
        pub(crate) jwks_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
        pub fn client_secret(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_secret = Some(input.into());
            self
        }
        /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
        pub fn set_client_secret(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_secret = input;
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn authorization_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn set_authorization_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_endpoint = input;
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn token_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn set_token_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_endpoint = input;
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn user_info_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_info_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn set_user_info_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_info_endpoint = input;
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn logout_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.logout_endpoint = Some(input.into());
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn set_logout_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logout_endpoint = input;
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn jwks_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.jwks_uri = Some(input.into());
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn set_jwks_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.jwks_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcConfig`](crate::model::OidcConfig)
        pub fn build(self) -> crate::model::OidcConfig {
            crate::model::OidcConfig {
                client_id: self.client_id,
                client_secret: self.client_secret,
                issuer: self.issuer,
                authorization_endpoint: self.authorization_endpoint,
                token_endpoint: self.token_endpoint,
                user_info_endpoint: self.user_info_endpoint,
                logout_endpoint: self.logout_endpoint,
                jwks_uri: self.jwks_uri,
            }
        }
    }
}
impl OidcConfig {
    /// Creates a new builder-style object to manufacture [`OidcConfig`](crate::model::OidcConfig)
    pub fn builder() -> crate::model::oidc_config::Builder {
        crate::model::oidc_config::Builder::default()
    }
}

/// <p>A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the <code>CreateUserProfile</code> API is called, and as <code>DefaultUserSettings</code> when the <code>CreateDomain</code> API is called.</p>
/// <p> <code>SecurityGroups</code> is aggregated when specified in both calls. For all other settings in <code>UserSettings</code>, the values specified in <code>CreateUserProfile</code> take precedence over those specified in <code>CreateDomain</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSettings {
    /// <p>The execution role for the user.</p>
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
    /// <p>Optional when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>PublicInternetOnly</code>.</p>
    /// <p>Required when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>VpcOnly</code>.</p>
    /// <p>Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the number of security groups that you can specify is one less than the maximum number shown.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
    pub sharing_settings: std::option::Option<crate::model::SharingSettings>,
    /// <p>The Jupyter server's app settings.</p>
    pub jupyter_server_app_settings: std::option::Option<crate::model::JupyterServerAppSettings>,
    /// <p>The kernel gateway app settings.</p>
    pub kernel_gateway_app_settings: std::option::Option<crate::model::KernelGatewayAppSettings>,
    /// <p>The TensorBoard app settings.</p>
    pub tensor_board_app_settings: std::option::Option<crate::model::TensorBoardAppSettings>,
    /// <p>A collection of settings that configure user interaction with the <code>RStudioServerPro</code> app.</p>
    pub r_studio_server_pro_app_settings:
        std::option::Option<crate::model::RStudioServerProAppSettings>,
    /// <p>A collection of settings that configure the <code>RSessionGateway</code> app.</p>
    pub r_session_app_settings: std::option::Option<crate::model::RSessionAppSettings>,
}
impl UserSettings {
    /// <p>The execution role for the user.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
    /// <p>Optional when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>PublicInternetOnly</code>.</p>
    /// <p>Required when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>VpcOnly</code>.</p>
    /// <p>Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the number of security groups that you can specify is one less than the maximum number shown.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
    pub fn sharing_settings(&self) -> std::option::Option<&crate::model::SharingSettings> {
        self.sharing_settings.as_ref()
    }
    /// <p>The Jupyter server's app settings.</p>
    pub fn jupyter_server_app_settings(
        &self,
    ) -> std::option::Option<&crate::model::JupyterServerAppSettings> {
        self.jupyter_server_app_settings.as_ref()
    }
    /// <p>The kernel gateway app settings.</p>
    pub fn kernel_gateway_app_settings(
        &self,
    ) -> std::option::Option<&crate::model::KernelGatewayAppSettings> {
        self.kernel_gateway_app_settings.as_ref()
    }
    /// <p>The TensorBoard app settings.</p>
    pub fn tensor_board_app_settings(
        &self,
    ) -> std::option::Option<&crate::model::TensorBoardAppSettings> {
        self.tensor_board_app_settings.as_ref()
    }
    /// <p>A collection of settings that configure user interaction with the <code>RStudioServerPro</code> app.</p>
    pub fn r_studio_server_pro_app_settings(
        &self,
    ) -> std::option::Option<&crate::model::RStudioServerProAppSettings> {
        self.r_studio_server_pro_app_settings.as_ref()
    }
    /// <p>A collection of settings that configure the <code>RSessionGateway</code> app.</p>
    pub fn r_session_app_settings(
        &self,
    ) -> std::option::Option<&crate::model::RSessionAppSettings> {
        self.r_session_app_settings.as_ref()
    }
}
impl std::fmt::Debug for UserSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSettings");
        formatter.field("execution_role", &self.execution_role);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("sharing_settings", &self.sharing_settings);
        formatter.field(
            "jupyter_server_app_settings",
            &self.jupyter_server_app_settings,
        );
        formatter.field(
            "kernel_gateway_app_settings",
            &self.kernel_gateway_app_settings,
        );
        formatter.field("tensor_board_app_settings", &self.tensor_board_app_settings);
        formatter.field(
            "r_studio_server_pro_app_settings",
            &self.r_studio_server_pro_app_settings,
        );
        formatter.field("r_session_app_settings", &self.r_session_app_settings);
        formatter.finish()
    }
}
/// See [`UserSettings`](crate::model::UserSettings)
pub mod user_settings {

    /// A builder for [`UserSettings`](crate::model::UserSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sharing_settings: std::option::Option<crate::model::SharingSettings>,
        pub(crate) jupyter_server_app_settings:
            std::option::Option<crate::model::JupyterServerAppSettings>,
        pub(crate) kernel_gateway_app_settings:
            std::option::Option<crate::model::KernelGatewayAppSettings>,
        pub(crate) tensor_board_app_settings:
            std::option::Option<crate::model::TensorBoardAppSettings>,
        pub(crate) r_studio_server_pro_app_settings:
            std::option::Option<crate::model::RStudioServerProAppSettings>,
        pub(crate) r_session_app_settings: std::option::Option<crate::model::RSessionAppSettings>,
    }
    impl Builder {
        /// <p>The execution role for the user.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The execution role for the user.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
        /// <p>Optional when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>PublicInternetOnly</code>.</p>
        /// <p>Required when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>VpcOnly</code>.</p>
        /// <p>Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the number of security groups that you can specify is one less than the maximum number shown.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
        /// <p>Optional when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>PublicInternetOnly</code>.</p>
        /// <p>Required when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to <code>VpcOnly</code>.</p>
        /// <p>Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the number of security groups that you can specify is one less than the maximum number shown.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
        pub fn sharing_settings(mut self, input: crate::model::SharingSettings) -> Self {
            self.sharing_settings = Some(input);
            self
        }
        /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
        pub fn set_sharing_settings(
            mut self,
            input: std::option::Option<crate::model::SharingSettings>,
        ) -> Self {
            self.sharing_settings = input;
            self
        }
        /// <p>The Jupyter server's app settings.</p>
        pub fn jupyter_server_app_settings(
            mut self,
            input: crate::model::JupyterServerAppSettings,
        ) -> Self {
            self.jupyter_server_app_settings = Some(input);
            self
        }
        /// <p>The Jupyter server's app settings.</p>
        pub fn set_jupyter_server_app_settings(
            mut self,
            input: std::option::Option<crate::model::JupyterServerAppSettings>,
        ) -> Self {
            self.jupyter_server_app_settings = input;
            self
        }
        /// <p>The kernel gateway app settings.</p>
        pub fn kernel_gateway_app_settings(
            mut self,
            input: crate::model::KernelGatewayAppSettings,
        ) -> Self {
            self.kernel_gateway_app_settings = Some(input);
            self
        }
        /// <p>The kernel gateway app settings.</p>
        pub fn set_kernel_gateway_app_settings(
            mut self,
            input: std::option::Option<crate::model::KernelGatewayAppSettings>,
        ) -> Self {
            self.kernel_gateway_app_settings = input;
            self
        }
        /// <p>The TensorBoard app settings.</p>
        pub fn tensor_board_app_settings(
            mut self,
            input: crate::model::TensorBoardAppSettings,
        ) -> Self {
            self.tensor_board_app_settings = Some(input);
            self
        }
        /// <p>The TensorBoard app settings.</p>
        pub fn set_tensor_board_app_settings(
            mut self,
            input: std::option::Option<crate::model::TensorBoardAppSettings>,
        ) -> Self {
            self.tensor_board_app_settings = input;
            self
        }
        /// <p>A collection of settings that configure user interaction with the <code>RStudioServerPro</code> app.</p>
        pub fn r_studio_server_pro_app_settings(
            mut self,
            input: crate::model::RStudioServerProAppSettings,
        ) -> Self {
            self.r_studio_server_pro_app_settings = Some(input);
            self
        }
        /// <p>A collection of settings that configure user interaction with the <code>RStudioServerPro</code> app.</p>
        pub fn set_r_studio_server_pro_app_settings(
            mut self,
            input: std::option::Option<crate::model::RStudioServerProAppSettings>,
        ) -> Self {
            self.r_studio_server_pro_app_settings = input;
            self
        }
        /// <p>A collection of settings that configure the <code>RSessionGateway</code> app.</p>
        pub fn r_session_app_settings(mut self, input: crate::model::RSessionAppSettings) -> Self {
            self.r_session_app_settings = Some(input);
            self
        }
        /// <p>A collection of settings that configure the <code>RSessionGateway</code> app.</p>
        pub fn set_r_session_app_settings(
            mut self,
            input: std::option::Option<crate::model::RSessionAppSettings>,
        ) -> Self {
            self.r_session_app_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSettings`](crate::model::UserSettings)
        pub fn build(self) -> crate::model::UserSettings {
            crate::model::UserSettings {
                execution_role: self.execution_role,
                security_groups: self.security_groups,
                sharing_settings: self.sharing_settings,
                jupyter_server_app_settings: self.jupyter_server_app_settings,
                kernel_gateway_app_settings: self.kernel_gateway_app_settings,
                tensor_board_app_settings: self.tensor_board_app_settings,
                r_studio_server_pro_app_settings: self.r_studio_server_pro_app_settings,
                r_session_app_settings: self.r_session_app_settings,
            }
        }
    }
}
impl UserSettings {
    /// Creates a new builder-style object to manufacture [`UserSettings`](crate::model::UserSettings)
    pub fn builder() -> crate::model::user_settings::Builder {
        crate::model::user_settings::Builder::default()
    }
}

/// <p>A collection of settings that apply to an <code>RSessionGateway</code> app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RSessionAppSettings {
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    /// <p>A list of custom SageMaker images that are configured to run as a RSession app.</p>
    pub custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
}
impl RSessionAppSettings {
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
    /// <p>A list of custom SageMaker images that are configured to run as a RSession app.</p>
    pub fn custom_images(&self) -> std::option::Option<&[crate::model::CustomImage]> {
        self.custom_images.as_deref()
    }
}
impl std::fmt::Debug for RSessionAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RSessionAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.field("custom_images", &self.custom_images);
        formatter.finish()
    }
}
/// See [`RSessionAppSettings`](crate::model::RSessionAppSettings)
pub mod r_session_app_settings {

    /// A builder for [`RSessionAppSettings`](crate::model::RSessionAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
        pub(crate) custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
    }
    impl Builder {
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Appends an item to `custom_images`.
        ///
        /// To override the contents of this collection use [`set_custom_images`](Self::set_custom_images).
        ///
        /// <p>A list of custom SageMaker images that are configured to run as a RSession app.</p>
        pub fn custom_images(mut self, input: crate::model::CustomImage) -> Self {
            let mut v = self.custom_images.unwrap_or_default();
            v.push(input);
            self.custom_images = Some(v);
            self
        }
        /// <p>A list of custom SageMaker images that are configured to run as a RSession app.</p>
        pub fn set_custom_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
        ) -> Self {
            self.custom_images = input;
            self
        }
        /// Consumes the builder and constructs a [`RSessionAppSettings`](crate::model::RSessionAppSettings)
        pub fn build(self) -> crate::model::RSessionAppSettings {
            crate::model::RSessionAppSettings {
                default_resource_spec: self.default_resource_spec,
                custom_images: self.custom_images,
            }
        }
    }
}
impl RSessionAppSettings {
    /// Creates a new builder-style object to manufacture [`RSessionAppSettings`](crate::model::RSessionAppSettings)
    pub fn builder() -> crate::model::r_session_app_settings::Builder {
        crate::model::r_session_app_settings::Builder::default()
    }
}

/// <p>A custom SageMaker image. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio-byoi.html">Bring your own SageMaker image</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomImage {
    /// <p>The name of the CustomImage. Must be unique to your account.</p>
    pub image_name: std::option::Option<std::string::String>,
    /// <p>The version number of the CustomImage.</p>
    pub image_version_number: std::option::Option<i32>,
    /// <p>The name of the AppImageConfig.</p>
    pub app_image_config_name: std::option::Option<std::string::String>,
}
impl CustomImage {
    /// <p>The name of the CustomImage. Must be unique to your account.</p>
    pub fn image_name(&self) -> std::option::Option<&str> {
        self.image_name.as_deref()
    }
    /// <p>The version number of the CustomImage.</p>
    pub fn image_version_number(&self) -> std::option::Option<i32> {
        self.image_version_number
    }
    /// <p>The name of the AppImageConfig.</p>
    pub fn app_image_config_name(&self) -> std::option::Option<&str> {
        self.app_image_config_name.as_deref()
    }
}
impl std::fmt::Debug for CustomImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomImage");
        formatter.field("image_name", &self.image_name);
        formatter.field("image_version_number", &self.image_version_number);
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.finish()
    }
}
/// See [`CustomImage`](crate::model::CustomImage)
pub mod custom_image {

    /// A builder for [`CustomImage`](crate::model::CustomImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_name: std::option::Option<std::string::String>,
        pub(crate) image_version_number: std::option::Option<i32>,
        pub(crate) app_image_config_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the CustomImage. Must be unique to your account.</p>
        pub fn image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_name = Some(input.into());
            self
        }
        /// <p>The name of the CustomImage. Must be unique to your account.</p>
        pub fn set_image_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_name = input;
            self
        }
        /// <p>The version number of the CustomImage.</p>
        pub fn image_version_number(mut self, input: i32) -> Self {
            self.image_version_number = Some(input);
            self
        }
        /// <p>The version number of the CustomImage.</p>
        pub fn set_image_version_number(mut self, input: std::option::Option<i32>) -> Self {
            self.image_version_number = input;
            self
        }
        /// <p>The name of the AppImageConfig.</p>
        pub fn app_image_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_name = Some(input.into());
            self
        }
        /// <p>The name of the AppImageConfig.</p>
        pub fn set_app_image_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomImage`](crate::model::CustomImage)
        pub fn build(self) -> crate::model::CustomImage {
            crate::model::CustomImage {
                image_name: self.image_name,
                image_version_number: self.image_version_number,
                app_image_config_name: self.app_image_config_name,
            }
        }
    }
}
impl CustomImage {
    /// Creates a new builder-style object to manufacture [`CustomImage`](crate::model::CustomImage)
    pub fn builder() -> crate::model::custom_image::Builder {
        crate::model::custom_image::Builder::default()
    }
}

/// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceSpec {
    /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
    pub sage_maker_image_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the image version created on the instance.</p>
    pub sage_maker_image_version_arn: std::option::Option<std::string::String>,
    /// <p>The instance type that the image version runs on.</p> <note>
    /// <p>JupyterServer Apps only support the <code>system</code> value. KernelGateway Apps do not support the <code>system</code> value, but support all other values for available instance types.</p>
    /// </note>
    pub instance_type: std::option::Option<crate::model::AppInstanceType>,
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.</p>
    pub lifecycle_config_arn: std::option::Option<std::string::String>,
}
impl ResourceSpec {
    /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
    pub fn sage_maker_image_arn(&self) -> std::option::Option<&str> {
        self.sage_maker_image_arn.as_deref()
    }
    /// <p>The ARN of the image version created on the instance.</p>
    pub fn sage_maker_image_version_arn(&self) -> std::option::Option<&str> {
        self.sage_maker_image_version_arn.as_deref()
    }
    /// <p>The instance type that the image version runs on.</p> <note>
    /// <p>JupyterServer Apps only support the <code>system</code> value. KernelGateway Apps do not support the <code>system</code> value, but support all other values for available instance types.</p>
    /// </note>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::AppInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.</p>
    pub fn lifecycle_config_arn(&self) -> std::option::Option<&str> {
        self.lifecycle_config_arn.as_deref()
    }
}
impl std::fmt::Debug for ResourceSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceSpec");
        formatter.field("sage_maker_image_arn", &self.sage_maker_image_arn);
        formatter.field(
            "sage_maker_image_version_arn",
            &self.sage_maker_image_version_arn,
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.field("lifecycle_config_arn", &self.lifecycle_config_arn);
        formatter.finish()
    }
}
/// See [`ResourceSpec`](crate::model::ResourceSpec)
pub mod resource_spec {

    /// A builder for [`ResourceSpec`](crate::model::ResourceSpec)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sage_maker_image_arn: std::option::Option<std::string::String>,
        pub(crate) sage_maker_image_version_arn: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::AppInstanceType>,
        pub(crate) lifecycle_config_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
        pub fn sage_maker_image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sage_maker_image_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
        pub fn set_sage_maker_image_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sage_maker_image_arn = input;
            self
        }
        /// <p>The ARN of the image version created on the instance.</p>
        pub fn sage_maker_image_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.sage_maker_image_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the image version created on the instance.</p>
        pub fn set_sage_maker_image_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sage_maker_image_version_arn = input;
            self
        }
        /// <p>The instance type that the image version runs on.</p> <note>
        /// <p>JupyterServer Apps only support the <code>system</code> value. KernelGateway Apps do not support the <code>system</code> value, but support all other values for available instance types.</p>
        /// </note>
        pub fn instance_type(mut self, input: crate::model::AppInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type that the image version runs on.</p> <note>
        /// <p>JupyterServer Apps only support the <code>system</code> value. KernelGateway Apps do not support the <code>system</code> value, but support all other values for available instance types.</p>
        /// </note>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::AppInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.</p>
        pub fn lifecycle_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_config_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.</p>
        pub fn set_lifecycle_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_config_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceSpec`](crate::model::ResourceSpec)
        pub fn build(self) -> crate::model::ResourceSpec {
            crate::model::ResourceSpec {
                sage_maker_image_arn: self.sage_maker_image_arn,
                sage_maker_image_version_arn: self.sage_maker_image_version_arn,
                instance_type: self.instance_type,
                lifecycle_config_arn: self.lifecycle_config_arn,
            }
        }
    }
}
impl ResourceSpec {
    /// Creates a new builder-style object to manufacture [`ResourceSpec`](crate::model::ResourceSpec)
    pub fn builder() -> crate::model::resource_spec::Builder {
        crate::model::resource_spec::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG548Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DLarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP3Dn24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Large,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Micro,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Small,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    System,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c5.12xlarge" => AppInstanceType::MlC512Xlarge,
            "ml.c5.18xlarge" => AppInstanceType::MlC518Xlarge,
            "ml.c5.24xlarge" => AppInstanceType::MlC524Xlarge,
            "ml.c5.2xlarge" => AppInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => AppInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => AppInstanceType::MlC59Xlarge,
            "ml.c5.large" => AppInstanceType::MlC5Large,
            "ml.c5.xlarge" => AppInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => AppInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => AppInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => AppInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => AppInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => AppInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => AppInstanceType::MlG4DnXlarge,
            "ml.g5.12xlarge" => AppInstanceType::MlG512Xlarge,
            "ml.g5.16xlarge" => AppInstanceType::MlG516Xlarge,
            "ml.g5.24xlarge" => AppInstanceType::MlG524Xlarge,
            "ml.g5.2xlarge" => AppInstanceType::MlG52Xlarge,
            "ml.g5.48xlarge" => AppInstanceType::MlG548Xlarge,
            "ml.g5.4xlarge" => AppInstanceType::MlG54Xlarge,
            "ml.g5.8xlarge" => AppInstanceType::MlG58Xlarge,
            "ml.g5.xlarge" => AppInstanceType::MlG5Xlarge,
            "ml.m5.12xlarge" => AppInstanceType::MlM512Xlarge,
            "ml.m5.16xlarge" => AppInstanceType::MlM516Xlarge,
            "ml.m5.24xlarge" => AppInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => AppInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => AppInstanceType::MlM54Xlarge,
            "ml.m5.8xlarge" => AppInstanceType::MlM58Xlarge,
            "ml.m5.large" => AppInstanceType::MlM5Large,
            "ml.m5.xlarge" => AppInstanceType::MlM5Xlarge,
            "ml.m5d.12xlarge" => AppInstanceType::MlM5D12Xlarge,
            "ml.m5d.16xlarge" => AppInstanceType::MlM5D16Xlarge,
            "ml.m5d.24xlarge" => AppInstanceType::MlM5D24Xlarge,
            "ml.m5d.2xlarge" => AppInstanceType::MlM5D2Xlarge,
            "ml.m5d.4xlarge" => AppInstanceType::MlM5D4Xlarge,
            "ml.m5d.8xlarge" => AppInstanceType::MlM5D8Xlarge,
            "ml.m5d.large" => AppInstanceType::MlM5DLarge,
            "ml.m5d.xlarge" => AppInstanceType::MlM5DXlarge,
            "ml.p3.16xlarge" => AppInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => AppInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => AppInstanceType::MlP38Xlarge,
            "ml.p3dn.24xlarge" => AppInstanceType::MlP3Dn24Xlarge,
            "ml.r5.12xlarge" => AppInstanceType::MlR512Xlarge,
            "ml.r5.16xlarge" => AppInstanceType::MlR516Xlarge,
            "ml.r5.24xlarge" => AppInstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => AppInstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => AppInstanceType::MlR54Xlarge,
            "ml.r5.8xlarge" => AppInstanceType::MlR58Xlarge,
            "ml.r5.large" => AppInstanceType::MlR5Large,
            "ml.r5.xlarge" => AppInstanceType::MlR5Xlarge,
            "ml.t3.2xlarge" => AppInstanceType::MlT32Xlarge,
            "ml.t3.large" => AppInstanceType::MlT3Large,
            "ml.t3.medium" => AppInstanceType::MlT3Medium,
            "ml.t3.micro" => AppInstanceType::MlT3Micro,
            "ml.t3.small" => AppInstanceType::MlT3Small,
            "ml.t3.xlarge" => AppInstanceType::MlT3Xlarge,
            "system" => AppInstanceType::System,
            other => AppInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppInstanceType::from(s))
    }
}
impl AppInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppInstanceType::MlC512Xlarge => "ml.c5.12xlarge",
            AppInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            AppInstanceType::MlC524Xlarge => "ml.c5.24xlarge",
            AppInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            AppInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            AppInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            AppInstanceType::MlC5Large => "ml.c5.large",
            AppInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            AppInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            AppInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            AppInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            AppInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            AppInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            AppInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            AppInstanceType::MlG512Xlarge => "ml.g5.12xlarge",
            AppInstanceType::MlG516Xlarge => "ml.g5.16xlarge",
            AppInstanceType::MlG524Xlarge => "ml.g5.24xlarge",
            AppInstanceType::MlG52Xlarge => "ml.g5.2xlarge",
            AppInstanceType::MlG548Xlarge => "ml.g5.48xlarge",
            AppInstanceType::MlG54Xlarge => "ml.g5.4xlarge",
            AppInstanceType::MlG58Xlarge => "ml.g5.8xlarge",
            AppInstanceType::MlG5Xlarge => "ml.g5.xlarge",
            AppInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            AppInstanceType::MlM516Xlarge => "ml.m5.16xlarge",
            AppInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            AppInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            AppInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            AppInstanceType::MlM58Xlarge => "ml.m5.8xlarge",
            AppInstanceType::MlM5Large => "ml.m5.large",
            AppInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            AppInstanceType::MlM5D12Xlarge => "ml.m5d.12xlarge",
            AppInstanceType::MlM5D16Xlarge => "ml.m5d.16xlarge",
            AppInstanceType::MlM5D24Xlarge => "ml.m5d.24xlarge",
            AppInstanceType::MlM5D2Xlarge => "ml.m5d.2xlarge",
            AppInstanceType::MlM5D4Xlarge => "ml.m5d.4xlarge",
            AppInstanceType::MlM5D8Xlarge => "ml.m5d.8xlarge",
            AppInstanceType::MlM5DLarge => "ml.m5d.large",
            AppInstanceType::MlM5DXlarge => "ml.m5d.xlarge",
            AppInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            AppInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            AppInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            AppInstanceType::MlP3Dn24Xlarge => "ml.p3dn.24xlarge",
            AppInstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            AppInstanceType::MlR516Xlarge => "ml.r5.16xlarge",
            AppInstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            AppInstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            AppInstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            AppInstanceType::MlR58Xlarge => "ml.r5.8xlarge",
            AppInstanceType::MlR5Large => "ml.r5.large",
            AppInstanceType::MlR5Xlarge => "ml.r5.xlarge",
            AppInstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            AppInstanceType::MlT3Large => "ml.t3.large",
            AppInstanceType::MlT3Medium => "ml.t3.medium",
            AppInstanceType::MlT3Micro => "ml.t3.micro",
            AppInstanceType::MlT3Small => "ml.t3.small",
            AppInstanceType::MlT3Xlarge => "ml.t3.xlarge",
            AppInstanceType::System => "system",
            AppInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c5.12xlarge",
            "ml.c5.18xlarge",
            "ml.c5.24xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.large",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.g5.12xlarge",
            "ml.g5.16xlarge",
            "ml.g5.24xlarge",
            "ml.g5.2xlarge",
            "ml.g5.48xlarge",
            "ml.g5.4xlarge",
            "ml.g5.8xlarge",
            "ml.g5.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.16xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.8xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.m5d.12xlarge",
            "ml.m5d.16xlarge",
            "ml.m5d.24xlarge",
            "ml.m5d.2xlarge",
            "ml.m5d.4xlarge",
            "ml.m5d.8xlarge",
            "ml.m5d.large",
            "ml.m5d.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.p3dn.24xlarge",
            "ml.r5.12xlarge",
            "ml.r5.16xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.8xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.micro",
            "ml.t3.small",
            "ml.t3.xlarge",
            "system",
        ]
    }
}
impl AsRef<str> for AppInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of settings that configure user interaction with the <code>RStudioServerPro</code> app. <code>RStudioServerProAppSettings</code> cannot be updated. The <code>RStudioServerPro</code> app must be deleted and a new one created to make any changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RStudioServerProAppSettings {
    /// <p>Indicates whether the current user has access to the <code>RStudioServerPro</code> app.</p>
    pub access_status: std::option::Option<crate::model::RStudioServerProAccessStatus>,
    /// <p>The level of permissions that the user has within the <code>RStudioServerPro</code> app. This value defaults to `User`. The `Admin` value allows the user access to the RStudio Administrative Dashboard.</p>
    pub user_group: std::option::Option<crate::model::RStudioServerProUserGroup>,
}
impl RStudioServerProAppSettings {
    /// <p>Indicates whether the current user has access to the <code>RStudioServerPro</code> app.</p>
    pub fn access_status(
        &self,
    ) -> std::option::Option<&crate::model::RStudioServerProAccessStatus> {
        self.access_status.as_ref()
    }
    /// <p>The level of permissions that the user has within the <code>RStudioServerPro</code> app. This value defaults to `User`. The `Admin` value allows the user access to the RStudio Administrative Dashboard.</p>
    pub fn user_group(&self) -> std::option::Option<&crate::model::RStudioServerProUserGroup> {
        self.user_group.as_ref()
    }
}
impl std::fmt::Debug for RStudioServerProAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RStudioServerProAppSettings");
        formatter.field("access_status", &self.access_status);
        formatter.field("user_group", &self.user_group);
        formatter.finish()
    }
}
/// See [`RStudioServerProAppSettings`](crate::model::RStudioServerProAppSettings)
pub mod r_studio_server_pro_app_settings {

    /// A builder for [`RStudioServerProAppSettings`](crate::model::RStudioServerProAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_status: std::option::Option<crate::model::RStudioServerProAccessStatus>,
        pub(crate) user_group: std::option::Option<crate::model::RStudioServerProUserGroup>,
    }
    impl Builder {
        /// <p>Indicates whether the current user has access to the <code>RStudioServerPro</code> app.</p>
        pub fn access_status(mut self, input: crate::model::RStudioServerProAccessStatus) -> Self {
            self.access_status = Some(input);
            self
        }
        /// <p>Indicates whether the current user has access to the <code>RStudioServerPro</code> app.</p>
        pub fn set_access_status(
            mut self,
            input: std::option::Option<crate::model::RStudioServerProAccessStatus>,
        ) -> Self {
            self.access_status = input;
            self
        }
        /// <p>The level of permissions that the user has within the <code>RStudioServerPro</code> app. This value defaults to `User`. The `Admin` value allows the user access to the RStudio Administrative Dashboard.</p>
        pub fn user_group(mut self, input: crate::model::RStudioServerProUserGroup) -> Self {
            self.user_group = Some(input);
            self
        }
        /// <p>The level of permissions that the user has within the <code>RStudioServerPro</code> app. This value defaults to `User`. The `Admin` value allows the user access to the RStudio Administrative Dashboard.</p>
        pub fn set_user_group(
            mut self,
            input: std::option::Option<crate::model::RStudioServerProUserGroup>,
        ) -> Self {
            self.user_group = input;
            self
        }
        /// Consumes the builder and constructs a [`RStudioServerProAppSettings`](crate::model::RStudioServerProAppSettings)
        pub fn build(self) -> crate::model::RStudioServerProAppSettings {
            crate::model::RStudioServerProAppSettings {
                access_status: self.access_status,
                user_group: self.user_group,
            }
        }
    }
}
impl RStudioServerProAppSettings {
    /// Creates a new builder-style object to manufacture [`RStudioServerProAppSettings`](crate::model::RStudioServerProAppSettings)
    pub fn builder() -> crate::model::r_studio_server_pro_app_settings::Builder {
        crate::model::r_studio_server_pro_app_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RStudioServerProUserGroup {
    #[allow(missing_docs)] // documentation missing in model
    Admin,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RStudioServerProUserGroup {
    fn from(s: &str) -> Self {
        match s {
            "R_STUDIO_ADMIN" => RStudioServerProUserGroup::Admin,
            "R_STUDIO_USER" => RStudioServerProUserGroup::User,
            other => RStudioServerProUserGroup::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RStudioServerProUserGroup {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RStudioServerProUserGroup::from(s))
    }
}
impl RStudioServerProUserGroup {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RStudioServerProUserGroup::Admin => "R_STUDIO_ADMIN",
            RStudioServerProUserGroup::User => "R_STUDIO_USER",
            RStudioServerProUserGroup::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["R_STUDIO_ADMIN", "R_STUDIO_USER"]
    }
}
impl AsRef<str> for RStudioServerProUserGroup {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RStudioServerProAccessStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RStudioServerProAccessStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => RStudioServerProAccessStatus::Disabled,
            "ENABLED" => RStudioServerProAccessStatus::Enabled,
            other => RStudioServerProAccessStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RStudioServerProAccessStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RStudioServerProAccessStatus::from(s))
    }
}
impl RStudioServerProAccessStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RStudioServerProAccessStatus::Disabled => "DISABLED",
            RStudioServerProAccessStatus::Enabled => "ENABLED",
            RStudioServerProAccessStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for RStudioServerProAccessStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The TensorBoard app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TensorBoardAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl TensorBoardAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
}
impl std::fmt::Debug for TensorBoardAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TensorBoardAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.finish()
    }
}
/// See [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
pub mod tensor_board_app_settings {

    /// A builder for [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Consumes the builder and constructs a [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
        pub fn build(self) -> crate::model::TensorBoardAppSettings {
            crate::model::TensorBoardAppSettings {
                default_resource_spec: self.default_resource_spec,
            }
        }
    }
}
impl TensorBoardAppSettings {
    /// Creates a new builder-style object to manufacture [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
    pub fn builder() -> crate::model::tensor_board_app_settings::Builder {
        crate::model::tensor_board_app_settings::Builder::default()
    }
}

/// <p>The KernelGateway app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelGatewayAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p> <note>
    /// <p>The Amazon SageMaker Studio UI does not use the default instance type value set here. The default instance type set here is used when Apps are created using the Amazon Web Services Command Line Interface or Amazon Web Services CloudFormation and the instance type parameter value is not passed.</p>
    /// </note>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    /// <p>A list of custom SageMaker images that are configured to run as a KernelGateway app.</p>
    pub custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the the user profile or domain.</p> <note>
    /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
    /// </note>
    pub lifecycle_config_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl KernelGatewayAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p> <note>
    /// <p>The Amazon SageMaker Studio UI does not use the default instance type value set here. The default instance type set here is used when Apps are created using the Amazon Web Services Command Line Interface or Amazon Web Services CloudFormation and the instance type parameter value is not passed.</p>
    /// </note>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
    /// <p>A list of custom SageMaker images that are configured to run as a KernelGateway app.</p>
    pub fn custom_images(&self) -> std::option::Option<&[crate::model::CustomImage]> {
        self.custom_images.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the the user profile or domain.</p> <note>
    /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
    /// </note>
    pub fn lifecycle_config_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.lifecycle_config_arns.as_deref()
    }
}
impl std::fmt::Debug for KernelGatewayAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelGatewayAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.field("custom_images", &self.custom_images);
        formatter.field("lifecycle_config_arns", &self.lifecycle_config_arns);
        formatter.finish()
    }
}
/// See [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
pub mod kernel_gateway_app_settings {

    /// A builder for [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
        pub(crate) custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
        pub(crate) lifecycle_config_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p> <note>
        /// <p>The Amazon SageMaker Studio UI does not use the default instance type value set here. The default instance type set here is used when Apps are created using the Amazon Web Services Command Line Interface or Amazon Web Services CloudFormation and the instance type parameter value is not passed.</p>
        /// </note>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p> <note>
        /// <p>The Amazon SageMaker Studio UI does not use the default instance type value set here. The default instance type set here is used when Apps are created using the Amazon Web Services Command Line Interface or Amazon Web Services CloudFormation and the instance type parameter value is not passed.</p>
        /// </note>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Appends an item to `custom_images`.
        ///
        /// To override the contents of this collection use [`set_custom_images`](Self::set_custom_images).
        ///
        /// <p>A list of custom SageMaker images that are configured to run as a KernelGateway app.</p>
        pub fn custom_images(mut self, input: crate::model::CustomImage) -> Self {
            let mut v = self.custom_images.unwrap_or_default();
            v.push(input);
            self.custom_images = Some(v);
            self
        }
        /// <p>A list of custom SageMaker images that are configured to run as a KernelGateway app.</p>
        pub fn set_custom_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
        ) -> Self {
            self.custom_images = input;
            self
        }
        /// Appends an item to `lifecycle_config_arns`.
        ///
        /// To override the contents of this collection use [`set_lifecycle_config_arns`](Self::set_lifecycle_config_arns).
        ///
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the the user profile or domain.</p> <note>
        /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
        /// </note>
        pub fn lifecycle_config_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lifecycle_config_arns.unwrap_or_default();
            v.push(input.into());
            self.lifecycle_config_arns = Some(v);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the the user profile or domain.</p> <note>
        /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
        /// </note>
        pub fn set_lifecycle_config_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lifecycle_config_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
        pub fn build(self) -> crate::model::KernelGatewayAppSettings {
            crate::model::KernelGatewayAppSettings {
                default_resource_spec: self.default_resource_spec,
                custom_images: self.custom_images,
                lifecycle_config_arns: self.lifecycle_config_arns,
            }
        }
    }
}
impl KernelGatewayAppSettings {
    /// Creates a new builder-style object to manufacture [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
    pub fn builder() -> crate::model::kernel_gateway_app_settings::Builder {
        crate::model::kernel_gateway_app_settings::Builder::default()
    }
}

/// <p>The JupyterServer app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JupyterServerAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the <code>LifecycleConfigArns</code> parameter, then this parameter is also required.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the JupyterServerApp. If you use this parameter, the <code>DefaultResourceSpec</code> parameter is also required.</p> <note>
    /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
    /// </note>
    pub lifecycle_config_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl JupyterServerAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the <code>LifecycleConfigArns</code> parameter, then this parameter is also required.</p>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the JupyterServerApp. If you use this parameter, the <code>DefaultResourceSpec</code> parameter is also required.</p> <note>
    /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
    /// </note>
    pub fn lifecycle_config_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.lifecycle_config_arns.as_deref()
    }
}
impl std::fmt::Debug for JupyterServerAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JupyterServerAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.field("lifecycle_config_arns", &self.lifecycle_config_arns);
        formatter.finish()
    }
}
/// See [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
pub mod jupyter_server_app_settings {

    /// A builder for [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
        pub(crate) lifecycle_config_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the <code>LifecycleConfigArns</code> parameter, then this parameter is also required.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the <code>LifecycleConfigArns</code> parameter, then this parameter is also required.</p>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Appends an item to `lifecycle_config_arns`.
        ///
        /// To override the contents of this collection use [`set_lifecycle_config_arns`](Self::set_lifecycle_config_arns).
        ///
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the JupyterServerApp. If you use this parameter, the <code>DefaultResourceSpec</code> parameter is also required.</p> <note>
        /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
        /// </note>
        pub fn lifecycle_config_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lifecycle_config_arns.unwrap_or_default();
            v.push(input.into());
            self.lifecycle_config_arns = Some(v);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the JupyterServerApp. If you use this parameter, the <code>DefaultResourceSpec</code> parameter is also required.</p> <note>
        /// <p>To remove a Lifecycle Config, you must set <code>LifecycleConfigArns</code> to an empty list.</p>
        /// </note>
        pub fn set_lifecycle_config_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lifecycle_config_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
        pub fn build(self) -> crate::model::JupyterServerAppSettings {
            crate::model::JupyterServerAppSettings {
                default_resource_spec: self.default_resource_spec,
                lifecycle_config_arns: self.lifecycle_config_arns,
            }
        }
    }
}
impl JupyterServerAppSettings {
    /// Creates a new builder-style object to manufacture [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
    pub fn builder() -> crate::model::jupyter_server_app_settings::Builder {
        crate::model::jupyter_server_app_settings::Builder::default()
    }
}

/// <p>Specifies options for sharing SageMaker Studio notebooks. These settings are specified as part of <code>DefaultUserSettings</code> when the <code>CreateDomain</code> API is called, and as part of <code>UserSettings</code> when the <code>CreateUserProfile</code> API is called. When <code>SharingSettings</code> is not specified, notebook sharing isn't allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharingSettings {
    /// <p>Whether to include the notebook cell output when sharing the notebook. The default is <code>Disabled</code>.</p>
    pub notebook_output_option: std::option::Option<crate::model::NotebookOutputOption>,
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used to store the shared notebook snapshots.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
    pub s3_kms_key_id: std::option::Option<std::string::String>,
}
impl SharingSettings {
    /// <p>Whether to include the notebook cell output when sharing the notebook. The default is <code>Disabled</code>.</p>
    pub fn notebook_output_option(
        &self,
    ) -> std::option::Option<&crate::model::NotebookOutputOption> {
        self.notebook_output_option.as_ref()
    }
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used to store the shared notebook snapshots.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
    pub fn s3_kms_key_id(&self) -> std::option::Option<&str> {
        self.s3_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for SharingSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharingSettings");
        formatter.field("notebook_output_option", &self.notebook_output_option);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("s3_kms_key_id", &self.s3_kms_key_id);
        formatter.finish()
    }
}
/// See [`SharingSettings`](crate::model::SharingSettings)
pub mod sharing_settings {

    /// A builder for [`SharingSettings`](crate::model::SharingSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_output_option: std::option::Option<crate::model::NotebookOutputOption>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) s3_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to include the notebook cell output when sharing the notebook. The default is <code>Disabled</code>.</p>
        pub fn notebook_output_option(mut self, input: crate::model::NotebookOutputOption) -> Self {
            self.notebook_output_option = Some(input);
            self
        }
        /// <p>Whether to include the notebook cell output when sharing the notebook. The default is <code>Disabled</code>.</p>
        pub fn set_notebook_output_option(
            mut self,
            input: std::option::Option<crate::model::NotebookOutputOption>,
        ) -> Self {
            self.notebook_output_option = input;
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used to store the shared notebook snapshots.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used to store the shared notebook snapshots.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
        pub fn s3_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_kms_key_id = Some(input.into());
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
        pub fn set_s3_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SharingSettings`](crate::model::SharingSettings)
        pub fn build(self) -> crate::model::SharingSettings {
            crate::model::SharingSettings {
                notebook_output_option: self.notebook_output_option,
                s3_output_path: self.s3_output_path,
                s3_kms_key_id: self.s3_kms_key_id,
            }
        }
    }
}
impl SharingSettings {
    /// Creates a new builder-style object to manufacture [`SharingSettings`](crate::model::SharingSettings)
    pub fn builder() -> crate::model::sharing_settings::Builder {
        crate::model::sharing_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookOutputOption {
    #[allow(missing_docs)] // documentation missing in model
    Allowed,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookOutputOption {
    fn from(s: &str) -> Self {
        match s {
            "Allowed" => NotebookOutputOption::Allowed,
            "Disabled" => NotebookOutputOption::Disabled,
            other => NotebookOutputOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookOutputOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookOutputOption::from(s))
    }
}
impl NotebookOutputOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookOutputOption::Allowed => "Allowed",
            NotebookOutputOption::Disabled => "Disabled",
            NotebookOutputOption::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Allowed", "Disabled"]
    }
}
impl AsRef<str> for NotebookOutputOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents an input or output artifact of a trial component. You specify <code>TrialComponentArtifact</code> as part of the <code>InputArtifacts</code> and <code>OutputArtifacts</code> parameters in the <code>CreateTrialComponent</code> request.</p>
/// <p>Examples of input artifacts are datasets, algorithms, hyperparameters, source code, and instance types. Examples of output artifacts are metrics, snapshots, logs, and images.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentArtifact {
    /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The media type consists of a <i>type</i> and a <i>subtype</i> concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The type specifies the category of the media. The subtype specifies the kind of data.</p>
    pub media_type: std::option::Option<std::string::String>,
    /// <p>The location of the artifact.</p>
    pub value: std::option::Option<std::string::String>,
}
impl TrialComponentArtifact {
    /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The media type consists of a <i>type</i> and a <i>subtype</i> concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The type specifies the category of the media. The subtype specifies the kind of data.</p>
    pub fn media_type(&self) -> std::option::Option<&str> {
        self.media_type.as_deref()
    }
    /// <p>The location of the artifact.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for TrialComponentArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentArtifact");
        formatter.field("media_type", &self.media_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
pub mod trial_component_artifact {

    /// A builder for [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The media type consists of a <i>type</i> and a <i>subtype</i> concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The type specifies the category of the media. The subtype specifies the kind of data.</p>
        pub fn media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_type = Some(input.into());
            self
        }
        /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The media type consists of a <i>type</i> and a <i>subtype</i> concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The type specifies the category of the media. The subtype specifies the kind of data.</p>
        pub fn set_media_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_type = input;
            self
        }
        /// <p>The location of the artifact.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The location of the artifact.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
        pub fn build(self) -> crate::model::TrialComponentArtifact {
            crate::model::TrialComponentArtifact {
                media_type: self.media_type,
                value: self.value,
            }
        }
    }
}
impl TrialComponentArtifact {
    /// Creates a new builder-style object to manufacture [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
    pub fn builder() -> crate::model::trial_component_artifact::Builder {
        crate::model::trial_component_artifact::Builder::default()
    }
}

/// <p>The value of a hyperparameter. Only one of <code>NumberValue</code> or <code>StringValue</code> can be specified.</p>
/// <p>This object is specified in the <code>CreateTrialComponent</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum TrialComponentParameterValue {
    /// <p>The numeric value of a numeric hyperparameter. If you specify a value for this parameter, you can't specify the <code>StringValue</code> parameter.</p>
    NumberValue(f64),
    /// <p>The string value of a categorical hyperparameter. If you specify a value for this parameter, you can't specify the <code>NumberValue</code> parameter.</p>
    StringValue(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl TrialComponentParameterValue {
    /// Tries to convert the enum instance into [`NumberValue`](crate::model::TrialComponentParameterValue::NumberValue), extracting the inner [`f64`](f64).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_number_value(&self) -> std::result::Result<&f64, &Self> {
        if let TrialComponentParameterValue::NumberValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`NumberValue`](crate::model::TrialComponentParameterValue::NumberValue).
    pub fn is_number_value(&self) -> bool {
        self.as_number_value().is_ok()
    }
    /// Tries to convert the enum instance into [`StringValue`](crate::model::TrialComponentParameterValue::StringValue), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string_value(&self) -> std::result::Result<&std::string::String, &Self> {
        if let TrialComponentParameterValue::StringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StringValue`](crate::model::TrialComponentParameterValue::StringValue).
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The status of the trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentStatus {
    /// <p>The status of the trial component.</p>
    pub primary_status: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
    /// <p>If the component failed, a message describing why.</p>
    pub message: std::option::Option<std::string::String>,
}
impl TrialComponentStatus {
    /// <p>The status of the trial component.</p>
    pub fn primary_status(
        &self,
    ) -> std::option::Option<&crate::model::TrialComponentPrimaryStatus> {
        self.primary_status.as_ref()
    }
    /// <p>If the component failed, a message describing why.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for TrialComponentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentStatus");
        formatter.field("primary_status", &self.primary_status);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`TrialComponentStatus`](crate::model::TrialComponentStatus)
pub mod trial_component_status {

    /// A builder for [`TrialComponentStatus`](crate::model::TrialComponentStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_status: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the trial component.</p>
        pub fn primary_status(mut self, input: crate::model::TrialComponentPrimaryStatus) -> Self {
            self.primary_status = Some(input);
            self
        }
        /// <p>The status of the trial component.</p>
        pub fn set_primary_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
        ) -> Self {
            self.primary_status = input;
            self
        }
        /// <p>If the component failed, a message describing why.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If the component failed, a message describing why.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentStatus`](crate::model::TrialComponentStatus)
        pub fn build(self) -> crate::model::TrialComponentStatus {
            crate::model::TrialComponentStatus {
                primary_status: self.primary_status,
                message: self.message,
            }
        }
    }
}
impl TrialComponentStatus {
    /// Creates a new builder-style object to manufacture [`TrialComponentStatus`](crate::model::TrialComponentStatus)
    pub fn builder() -> crate::model::trial_component_status::Builder {
        crate::model::trial_component_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrialComponentPrimaryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrialComponentPrimaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TrialComponentPrimaryStatus::Completed,
            "Failed" => TrialComponentPrimaryStatus::Failed,
            "InProgress" => TrialComponentPrimaryStatus::InProgress,
            "Stopped" => TrialComponentPrimaryStatus::Stopped,
            "Stopping" => TrialComponentPrimaryStatus::Stopping,
            other => TrialComponentPrimaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrialComponentPrimaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrialComponentPrimaryStatus::from(s))
    }
}
impl TrialComponentPrimaryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrialComponentPrimaryStatus::Completed => "Completed",
            TrialComponentPrimaryStatus::Failed => "Failed",
            TrialComponentPrimaryStatus::InProgress => "InProgress",
            TrialComponentPrimaryStatus::Stopped => "Stopped",
            TrialComponentPrimaryStatus::Stopping => "Stopping",
            TrialComponentPrimaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TrialComponentPrimaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for profiling rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub rule_evaluator_image: std::option::Option<std::string::String>,
    /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub volume_size_in_gb: i32,
    /// <p>Runtime configuration for rule container.</p>
    pub rule_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ProfilerRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
    pub fn rule_configuration_name(&self) -> std::option::Option<&str> {
        self.rule_configuration_name.as_deref()
    }
    /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub fn rule_evaluator_image(&self) -> std::option::Option<&str> {
        self.rule_evaluator_image.as_deref()
    }
    /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::ProcessingInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub fn volume_size_in_gb(&self) -> i32 {
        self.volume_size_in_gb
    }
    /// <p>Runtime configuration for rule container.</p>
    pub fn rule_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.rule_parameters.as_ref()
    }
}
impl std::fmt::Debug for ProfilerRuleConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerRuleConfiguration");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("rule_evaluator_image", &self.rule_evaluator_image);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("rule_parameters", &self.rule_parameters);
        formatter.finish()
    }
}
/// See [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
pub mod profiler_rule_configuration {

    /// A builder for [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) rule_evaluator_image: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) rule_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn rule_evaluator_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluator_image = Some(input.into());
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn set_rule_evaluator_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluator_image = input;
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// Adds a key-value pair to `rule_parameters`.
        ///
        /// To override the contents of this collection use [`set_rule_parameters`](Self::set_rule_parameters).
        ///
        /// <p>Runtime configuration for rule container.</p>
        pub fn rule_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.rule_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.rule_parameters = Some(hash_map);
            self
        }
        /// <p>Runtime configuration for rule container.</p>
        pub fn set_rule_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.rule_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
        pub fn build(self) -> crate::model::ProfilerRuleConfiguration {
            crate::model::ProfilerRuleConfiguration {
                rule_configuration_name: self.rule_configuration_name,
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                rule_evaluator_image: self.rule_evaluator_image,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                rule_parameters: self.rule_parameters,
            }
        }
    }
}
impl ProfilerRuleConfiguration {
    /// Creates a new builder-style object to manufacture [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
    pub fn builder() -> crate::model::profiler_rule_configuration::Builder {
        crate::model::profiler_rule_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC48Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM410Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM416Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP216Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP28Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Large,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => ProcessingInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => ProcessingInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => ProcessingInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => ProcessingInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => ProcessingInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => ProcessingInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => ProcessingInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => ProcessingInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => ProcessingInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => ProcessingInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => ProcessingInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => ProcessingInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => ProcessingInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => ProcessingInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => ProcessingInstanceType::MlG4DnXlarge,
            "ml.m4.10xlarge" => ProcessingInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => ProcessingInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => ProcessingInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => ProcessingInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => ProcessingInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => ProcessingInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => ProcessingInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => ProcessingInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => ProcessingInstanceType::MlM54Xlarge,
            "ml.m5.large" => ProcessingInstanceType::MlM5Large,
            "ml.m5.xlarge" => ProcessingInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => ProcessingInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => ProcessingInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => ProcessingInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => ProcessingInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => ProcessingInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => ProcessingInstanceType::MlP38Xlarge,
            "ml.r5.12xlarge" => ProcessingInstanceType::MlR512Xlarge,
            "ml.r5.16xlarge" => ProcessingInstanceType::MlR516Xlarge,
            "ml.r5.24xlarge" => ProcessingInstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => ProcessingInstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => ProcessingInstanceType::MlR54Xlarge,
            "ml.r5.8xlarge" => ProcessingInstanceType::MlR58Xlarge,
            "ml.r5.large" => ProcessingInstanceType::MlR5Large,
            "ml.r5.xlarge" => ProcessingInstanceType::MlR5Xlarge,
            "ml.t3.2xlarge" => ProcessingInstanceType::MlT32Xlarge,
            "ml.t3.large" => ProcessingInstanceType::MlT3Large,
            "ml.t3.medium" => ProcessingInstanceType::MlT3Medium,
            "ml.t3.xlarge" => ProcessingInstanceType::MlT3Xlarge,
            other => ProcessingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingInstanceType::from(s))
    }
}
impl ProcessingInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            ProcessingInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            ProcessingInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            ProcessingInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            ProcessingInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            ProcessingInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            ProcessingInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            ProcessingInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            ProcessingInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            ProcessingInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            ProcessingInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            ProcessingInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            ProcessingInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            ProcessingInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            ProcessingInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            ProcessingInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            ProcessingInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            ProcessingInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            ProcessingInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            ProcessingInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            ProcessingInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            ProcessingInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            ProcessingInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            ProcessingInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            ProcessingInstanceType::MlM5Large => "ml.m5.large",
            ProcessingInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            ProcessingInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            ProcessingInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            ProcessingInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            ProcessingInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            ProcessingInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            ProcessingInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            ProcessingInstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            ProcessingInstanceType::MlR516Xlarge => "ml.r5.16xlarge",
            ProcessingInstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            ProcessingInstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            ProcessingInstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            ProcessingInstanceType::MlR58Xlarge => "ml.r5.8xlarge",
            ProcessingInstanceType::MlR5Large => "ml.r5.large",
            ProcessingInstanceType::MlR5Xlarge => "ml.r5.xlarge",
            ProcessingInstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            ProcessingInstanceType::MlT3Large => "ml.t3.large",
            ProcessingInstanceType::MlT3Medium => "ml.t3.medium",
            ProcessingInstanceType::MlT3Xlarge => "ml.t3.xlarge",
            ProcessingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.r5.12xlarge",
            "ml.r5.16xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.8xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.xlarge",
        ]
    }
}
impl AsRef<str> for ProcessingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for updating the Debugger profile parameters, system and framework metrics configurations, and storage paths.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerConfigForUpdate {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub profiling_interval_in_milliseconds: std::option::Option<i64>,
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub profiling_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
    pub disable_profiler: bool,
}
impl ProfilerConfigForUpdate {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub fn profiling_interval_in_milliseconds(&self) -> std::option::Option<i64> {
        self.profiling_interval_in_milliseconds
    }
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub fn profiling_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.profiling_parameters.as_ref()
    }
    /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
    pub fn disable_profiler(&self) -> bool {
        self.disable_profiler
    }
}
impl std::fmt::Debug for ProfilerConfigForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerConfigForUpdate");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field(
            "profiling_interval_in_milliseconds",
            &self.profiling_interval_in_milliseconds,
        );
        formatter.field("profiling_parameters", &self.profiling_parameters);
        formatter.field("disable_profiler", &self.disable_profiler);
        formatter.finish()
    }
}
/// See [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
pub mod profiler_config_for_update {

    /// A builder for [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) profiling_interval_in_milliseconds: std::option::Option<i64>,
        pub(crate) profiling_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) disable_profiler: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn profiling_interval_in_milliseconds(mut self, input: i64) -> Self {
            self.profiling_interval_in_milliseconds = Some(input);
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn set_profiling_interval_in_milliseconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.profiling_interval_in_milliseconds = input;
            self
        }
        /// Adds a key-value pair to `profiling_parameters`.
        ///
        /// To override the contents of this collection use [`set_profiling_parameters`](Self::set_profiling_parameters).
        ///
        /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn profiling_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.profiling_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.profiling_parameters = Some(hash_map);
            self
        }
        /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn set_profiling_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.profiling_parameters = input;
            self
        }
        /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
        pub fn disable_profiler(mut self, input: bool) -> Self {
            self.disable_profiler = Some(input);
            self
        }
        /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
        pub fn set_disable_profiler(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_profiler = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
        pub fn build(self) -> crate::model::ProfilerConfigForUpdate {
            crate::model::ProfilerConfigForUpdate {
                s3_output_path: self.s3_output_path,
                profiling_interval_in_milliseconds: self.profiling_interval_in_milliseconds,
                profiling_parameters: self.profiling_parameters,
                disable_profiler: self.disable_profiler.unwrap_or_default(),
            }
        }
    }
}
impl ProfilerConfigForUpdate {
    /// Creates a new builder-style object to manufacture [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
    pub fn builder() -> crate::model::profiler_config_for_update::Builder {
        crate::model::profiler_config_for_update::Builder::default()
    }
}

/// <p>A tag object that consists of a key and an optional value, used to manage metadata for SageMaker Amazon Web Services resources.</p>
/// <p>You can add tags to notebook instances, training jobs, hyperparameter tuning jobs, batch transform jobs, models, labeling jobs, work teams, endpoint configurations, and endpoints. For more information on adding tags to SageMaker resources, see <code>AddTags</code>.</p>
/// <p>For more information on adding metadata to your Amazon Web Services resources with tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a>. For advice on best practices for managing Amazon Web Services resources with tagging, see <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging Best Practices: Implement an Effective Amazon Web Services Resource Tagging Strategy</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The tag key. Tag keys must be unique per resource.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag key. Tag keys must be unique per resource.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key. Tag keys must be unique per resource.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key. Tag keys must be unique per resource.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceCatalogProvisioningUpdateDetails {
    /// <p>The ID of the provisioning artifact.</p>
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>A list of key value pairs that you specify when you provision a product.</p>
    pub provisioning_parameters:
        std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
}
impl ServiceCatalogProvisioningUpdateDetails {
    /// <p>The ID of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>A list of key value pairs that you specify when you provision a product.</p>
    pub fn provisioning_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ProvisioningParameter]> {
        self.provisioning_parameters.as_deref()
    }
}
impl std::fmt::Debug for ServiceCatalogProvisioningUpdateDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceCatalogProvisioningUpdateDetails");
        formatter.field("provisioning_artifact_id", &self.provisioning_artifact_id);
        formatter.field("provisioning_parameters", &self.provisioning_parameters);
        formatter.finish()
    }
}
/// See [`ServiceCatalogProvisioningUpdateDetails`](crate::model::ServiceCatalogProvisioningUpdateDetails)
pub mod service_catalog_provisioning_update_details {

    /// A builder for [`ServiceCatalogProvisioningUpdateDetails`](crate::model::ServiceCatalogProvisioningUpdateDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_parameters:
            std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
    }
    impl Builder {
        /// <p>The ID of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The ID of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// Appends an item to `provisioning_parameters`.
        ///
        /// To override the contents of this collection use [`set_provisioning_parameters`](Self::set_provisioning_parameters).
        ///
        /// <p>A list of key value pairs that you specify when you provision a product.</p>
        pub fn provisioning_parameters(
            mut self,
            input: crate::model::ProvisioningParameter,
        ) -> Self {
            let mut v = self.provisioning_parameters.unwrap_or_default();
            v.push(input);
            self.provisioning_parameters = Some(v);
            self
        }
        /// <p>A list of key value pairs that you specify when you provision a product.</p>
        pub fn set_provisioning_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
        ) -> Self {
            self.provisioning_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceCatalogProvisioningUpdateDetails`](crate::model::ServiceCatalogProvisioningUpdateDetails)
        pub fn build(self) -> crate::model::ServiceCatalogProvisioningUpdateDetails {
            crate::model::ServiceCatalogProvisioningUpdateDetails {
                provisioning_artifact_id: self.provisioning_artifact_id,
                provisioning_parameters: self.provisioning_parameters,
            }
        }
    }
}
impl ServiceCatalogProvisioningUpdateDetails {
    /// Creates a new builder-style object to manufacture [`ServiceCatalogProvisioningUpdateDetails`](crate::model::ServiceCatalogProvisioningUpdateDetails)
    pub fn builder() -> crate::model::service_catalog_provisioning_update_details::Builder {
        crate::model::service_catalog_provisioning_update_details::Builder::default()
    }
}

/// <p>A key value pair used when you provision a project as a service catalog product. For information, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisioningParameter {
    /// <p>The key that identifies a provisioning parameter.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the provisioning parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl ProvisioningParameter {
    /// <p>The key that identifies a provisioning parameter.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the provisioning parameter.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ProvisioningParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisioningParameter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ProvisioningParameter`](crate::model::ProvisioningParameter)
pub mod provisioning_parameter {

    /// A builder for [`ProvisioningParameter`](crate::model::ProvisioningParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key that identifies a provisioning parameter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key that identifies a provisioning parameter.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the provisioning parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the provisioning parameter.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningParameter`](crate::model::ProvisioningParameter)
        pub fn build(self) -> crate::model::ProvisioningParameter {
            crate::model::ProvisioningParameter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ProvisioningParameter {
    /// Creates a new builder-style object to manufacture [`ProvisioningParameter`](crate::model::ProvisioningParameter)
    pub fn builder() -> crate::model::provisioning_parameter::Builder {
        crate::model::provisioning_parameter::Builder::default()
    }
}

/// <p>Configuration that controls the parallelism of the pipeline. By default, the parallelism configuration specified applies to all executions of the pipeline unless overridden.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParallelismConfiguration {
    /// <p>The max number of steps that can be executed in parallel. </p>
    pub max_parallel_execution_steps: i32,
}
impl ParallelismConfiguration {
    /// <p>The max number of steps that can be executed in parallel. </p>
    pub fn max_parallel_execution_steps(&self) -> i32 {
        self.max_parallel_execution_steps
    }
}
impl std::fmt::Debug for ParallelismConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParallelismConfiguration");
        formatter.field(
            "max_parallel_execution_steps",
            &self.max_parallel_execution_steps,
        );
        formatter.finish()
    }
}
/// See [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
pub mod parallelism_configuration {

    /// A builder for [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_parallel_execution_steps: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The max number of steps that can be executed in parallel. </p>
        pub fn max_parallel_execution_steps(mut self, input: i32) -> Self {
            self.max_parallel_execution_steps = Some(input);
            self
        }
        /// <p>The max number of steps that can be executed in parallel. </p>
        pub fn set_max_parallel_execution_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parallel_execution_steps = input;
            self
        }
        /// Consumes the builder and constructs a [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
        pub fn build(self) -> crate::model::ParallelismConfiguration {
            crate::model::ParallelismConfiguration {
                max_parallel_execution_steps: self.max_parallel_execution_steps.unwrap_or_default(),
            }
        }
    }
}
impl ParallelismConfiguration {
    /// Creates a new builder-style object to manufacture [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
    pub fn builder() -> crate::model::parallelism_configuration::Builder {
        crate::model::parallelism_configuration::Builder::default()
    }
}

/// <p>The location of the pipeline definition stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineDefinitionS3Location {
    /// <p>Name of the S3 bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The object key (or key name) uniquely identifies the object in an S3 bucket. </p>
    pub object_key: std::option::Option<std::string::String>,
    /// <p>Version Id of the pipeline definition file. If not specified, Amazon SageMaker will retrieve the latest version.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl PipelineDefinitionS3Location {
    /// <p>Name of the S3 bucket.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The object key (or key name) uniquely identifies the object in an S3 bucket. </p>
    pub fn object_key(&self) -> std::option::Option<&str> {
        self.object_key.as_deref()
    }
    /// <p>Version Id of the pipeline definition file. If not specified, Amazon SageMaker will retrieve the latest version.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
}
impl std::fmt::Debug for PipelineDefinitionS3Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineDefinitionS3Location");
        formatter.field("bucket", &self.bucket);
        formatter.field("object_key", &self.object_key);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}
/// See [`PipelineDefinitionS3Location`](crate::model::PipelineDefinitionS3Location)
pub mod pipeline_definition_s3_location {

    /// A builder for [`PipelineDefinitionS3Location`](crate::model::PipelineDefinitionS3Location)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) object_key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>Name of the S3 bucket.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The object key (or key name) uniquely identifies the object in an S3 bucket. </p>
        pub fn object_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_key = Some(input.into());
            self
        }
        /// <p>The object key (or key name) uniquely identifies the object in an S3 bucket. </p>
        pub fn set_object_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_key = input;
            self
        }
        /// <p>Version Id of the pipeline definition file. If not specified, Amazon SageMaker will retrieve the latest version.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>Version Id of the pipeline definition file. If not specified, Amazon SageMaker will retrieve the latest version.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineDefinitionS3Location`](crate::model::PipelineDefinitionS3Location)
        pub fn build(self) -> crate::model::PipelineDefinitionS3Location {
            crate::model::PipelineDefinitionS3Location {
                bucket: self.bucket,
                object_key: self.object_key,
                version_id: self.version_id,
            }
        }
    }
}
impl PipelineDefinitionS3Location {
    /// Creates a new builder-style object to manufacture [`PipelineDefinitionS3Location`](crate::model::PipelineDefinitionS3Location)
    pub fn builder() -> crate::model::pipeline_definition_s3_location::Builder {
        crate::model::pipeline_definition_s3_location::Builder::default()
    }
}

/// <p>Contains the notebook instance lifecycle configuration script.</p>
/// <p>Each lifecycle configuration script has a limit of 16384 characters.</p>
/// <p>The value of the <code>$PATH</code> environment variable that is available to both scripts is <code>/sbin:bin:/usr/sbin:/usr/bin</code>.</p>
/// <p>View CloudWatch Logs for notebook instance lifecycle configurations in log group <code>/aws/sagemaker/NotebookInstances</code> in log stream <code>[notebook-instance-name]/[LifecycleConfigHook]</code>.</p>
/// <p>Lifecycle configuration scripts cannot run for longer than 5 minutes. If a script runs for longer than 5 minutes, it fails and the notebook instance is not created or started.</p>
/// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceLifecycleHook {
    /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.</p>
    pub content: std::option::Option<std::string::String>,
}
impl NotebookInstanceLifecycleHook {
    /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl std::fmt::Debug for NotebookInstanceLifecycleHook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceLifecycleHook");
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
pub mod notebook_instance_lifecycle_hook {

    /// A builder for [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
        pub fn build(self) -> crate::model::NotebookInstanceLifecycleHook {
            crate::model::NotebookInstanceLifecycleHook {
                content: self.content,
            }
        }
    }
}
impl NotebookInstanceLifecycleHook {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
    pub fn builder() -> crate::model::notebook_instance_lifecycle_hook::Builder {
        crate::model::notebook_instance_lifecycle_hook::Builder::default()
    }
}

/// <p>Information on the IMDS configuration of the notebook instance</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMetadataServiceConfiguration {
    /// <p>Indicates the minimum IMDS version that the notebook instance supports. When passed as part of <code>CreateNotebookInstance</code>, if no value is selected, then it defaults to IMDSv1. This means that both IMDSv1 and IMDSv2 are supported. If passed as part of <code>UpdateNotebookInstance</code>, there is no default.</p>
    pub minimum_instance_metadata_service_version: std::option::Option<std::string::String>,
}
impl InstanceMetadataServiceConfiguration {
    /// <p>Indicates the minimum IMDS version that the notebook instance supports. When passed as part of <code>CreateNotebookInstance</code>, if no value is selected, then it defaults to IMDSv1. This means that both IMDSv1 and IMDSv2 are supported. If passed as part of <code>UpdateNotebookInstance</code>, there is no default.</p>
    pub fn minimum_instance_metadata_service_version(&self) -> std::option::Option<&str> {
        self.minimum_instance_metadata_service_version.as_deref()
    }
}
impl std::fmt::Debug for InstanceMetadataServiceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMetadataServiceConfiguration");
        formatter.field(
            "minimum_instance_metadata_service_version",
            &self.minimum_instance_metadata_service_version,
        );
        formatter.finish()
    }
}
/// See [`InstanceMetadataServiceConfiguration`](crate::model::InstanceMetadataServiceConfiguration)
pub mod instance_metadata_service_configuration {

    /// A builder for [`InstanceMetadataServiceConfiguration`](crate::model::InstanceMetadataServiceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_instance_metadata_service_version:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates the minimum IMDS version that the notebook instance supports. When passed as part of <code>CreateNotebookInstance</code>, if no value is selected, then it defaults to IMDSv1. This means that both IMDSv1 and IMDSv2 are supported. If passed as part of <code>UpdateNotebookInstance</code>, there is no default.</p>
        pub fn minimum_instance_metadata_service_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.minimum_instance_metadata_service_version = Some(input.into());
            self
        }
        /// <p>Indicates the minimum IMDS version that the notebook instance supports. When passed as part of <code>CreateNotebookInstance</code>, if no value is selected, then it defaults to IMDSv1. This means that both IMDSv1 and IMDSv2 are supported. If passed as part of <code>UpdateNotebookInstance</code>, there is no default.</p>
        pub fn set_minimum_instance_metadata_service_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.minimum_instance_metadata_service_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMetadataServiceConfiguration`](crate::model::InstanceMetadataServiceConfiguration)
        pub fn build(self) -> crate::model::InstanceMetadataServiceConfiguration {
            crate::model::InstanceMetadataServiceConfiguration {
                minimum_instance_metadata_service_version: self
                    .minimum_instance_metadata_service_version,
            }
        }
    }
}
impl InstanceMetadataServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`InstanceMetadataServiceConfiguration`](crate::model::InstanceMetadataServiceConfiguration)
    pub fn builder() -> crate::model::instance_metadata_service_configuration::Builder {
        crate::model::instance_metadata_service_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RootAccess {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RootAccess {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => RootAccess::Disabled,
            "Enabled" => RootAccess::Enabled,
            other => RootAccess::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RootAccess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RootAccess::from(s))
    }
}
impl RootAccess {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RootAccess::Disabled => "Disabled",
            RootAccess::Enabled => "Enabled",
            RootAccess::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for RootAccess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceAcceleratorType {
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Large,
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Large,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceAcceleratorType {
    fn from(s: &str) -> Self {
        match s {
            "ml.eia1.large" => NotebookInstanceAcceleratorType::MlEia1Large,
            "ml.eia1.medium" => NotebookInstanceAcceleratorType::MlEia1Medium,
            "ml.eia1.xlarge" => NotebookInstanceAcceleratorType::MlEia1Xlarge,
            "ml.eia2.large" => NotebookInstanceAcceleratorType::MlEia2Large,
            "ml.eia2.medium" => NotebookInstanceAcceleratorType::MlEia2Medium,
            "ml.eia2.xlarge" => NotebookInstanceAcceleratorType::MlEia2Xlarge,
            other => NotebookInstanceAcceleratorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceAcceleratorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceAcceleratorType::from(s))
    }
}
impl NotebookInstanceAcceleratorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceAcceleratorType::MlEia1Large => "ml.eia1.large",
            NotebookInstanceAcceleratorType::MlEia1Medium => "ml.eia1.medium",
            NotebookInstanceAcceleratorType::MlEia1Xlarge => "ml.eia1.xlarge",
            NotebookInstanceAcceleratorType::MlEia2Large => "ml.eia2.large",
            NotebookInstanceAcceleratorType::MlEia2Medium => "ml.eia2.medium",
            NotebookInstanceAcceleratorType::MlEia2Xlarge => "ml.eia2.xlarge",
            NotebookInstanceAcceleratorType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.eia1.large",
            "ml.eia1.medium",
            "ml.eia1.xlarge",
            "ml.eia2.large",
            "ml.eia2.medium",
            "ml.eia2.xlarge",
        ]
    }
}
impl AsRef<str> for NotebookInstanceAcceleratorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC48Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D18Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D9Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG548Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM410Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM416Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DLarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP216Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP28Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP3Dn24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT22Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Large,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Large,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlT3Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => InstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => InstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => InstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => InstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => InstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => InstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => InstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => InstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => InstanceType::MlC5Xlarge,
            "ml.c5d.18xlarge" => InstanceType::MlC5D18Xlarge,
            "ml.c5d.2xlarge" => InstanceType::MlC5D2Xlarge,
            "ml.c5d.4xlarge" => InstanceType::MlC5D4Xlarge,
            "ml.c5d.9xlarge" => InstanceType::MlC5D9Xlarge,
            "ml.c5d.xlarge" => InstanceType::MlC5DXlarge,
            "ml.g4dn.12xlarge" => InstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => InstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => InstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => InstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => InstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => InstanceType::MlG4DnXlarge,
            "ml.g5.12xlarge" => InstanceType::MlG512Xlarge,
            "ml.g5.16xlarge" => InstanceType::MlG516Xlarge,
            "ml.g5.24xlarge" => InstanceType::MlG524Xlarge,
            "ml.g5.2xlarge" => InstanceType::MlG52Xlarge,
            "ml.g5.48xlarge" => InstanceType::MlG548Xlarge,
            "ml.g5.4xlarge" => InstanceType::MlG54Xlarge,
            "ml.g5.8xlarge" => InstanceType::MlG58Xlarge,
            "ml.g5.xlarge" => InstanceType::MlG5Xlarge,
            "ml.m4.10xlarge" => InstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => InstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => InstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => InstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => InstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => InstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => InstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => InstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => InstanceType::MlM54Xlarge,
            "ml.m5.xlarge" => InstanceType::MlM5Xlarge,
            "ml.m5d.12xlarge" => InstanceType::MlM5D12Xlarge,
            "ml.m5d.16xlarge" => InstanceType::MlM5D16Xlarge,
            "ml.m5d.24xlarge" => InstanceType::MlM5D24Xlarge,
            "ml.m5d.2xlarge" => InstanceType::MlM5D2Xlarge,
            "ml.m5d.4xlarge" => InstanceType::MlM5D4Xlarge,
            "ml.m5d.8xlarge" => InstanceType::MlM5D8Xlarge,
            "ml.m5d.large" => InstanceType::MlM5DLarge,
            "ml.m5d.xlarge" => InstanceType::MlM5DXlarge,
            "ml.p2.16xlarge" => InstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => InstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => InstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => InstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => InstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => InstanceType::MlP38Xlarge,
            "ml.p3dn.24xlarge" => InstanceType::MlP3Dn24Xlarge,
            "ml.r5.12xlarge" => InstanceType::MlR512Xlarge,
            "ml.r5.16xlarge" => InstanceType::MlR516Xlarge,
            "ml.r5.24xlarge" => InstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => InstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => InstanceType::MlR54Xlarge,
            "ml.r5.8xlarge" => InstanceType::MlR58Xlarge,
            "ml.r5.large" => InstanceType::MlR5Large,
            "ml.r5.xlarge" => InstanceType::MlR5Xlarge,
            "ml.t2.2xlarge" => InstanceType::MlT22Xlarge,
            "ml.t2.large" => InstanceType::MlT2Large,
            "ml.t2.medium" => InstanceType::MlT2Medium,
            "ml.t2.xlarge" => InstanceType::MlT2Xlarge,
            "ml.t3.2xlarge" => InstanceType::MlT32Xlarge,
            "ml.t3.large" => InstanceType::MlT3Large,
            "ml.t3.medium" => InstanceType::MlT3Medium,
            "ml.t3.xlarge" => InstanceType::MlT3Xlarge,
            other => InstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceType::from(s))
    }
}
impl InstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            InstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            InstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            InstanceType::MlC4Xlarge => "ml.c4.xlarge",
            InstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            InstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            InstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            InstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            InstanceType::MlC5Xlarge => "ml.c5.xlarge",
            InstanceType::MlC5D18Xlarge => "ml.c5d.18xlarge",
            InstanceType::MlC5D2Xlarge => "ml.c5d.2xlarge",
            InstanceType::MlC5D4Xlarge => "ml.c5d.4xlarge",
            InstanceType::MlC5D9Xlarge => "ml.c5d.9xlarge",
            InstanceType::MlC5DXlarge => "ml.c5d.xlarge",
            InstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            InstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            InstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            InstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            InstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            InstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            InstanceType::MlG512Xlarge => "ml.g5.12xlarge",
            InstanceType::MlG516Xlarge => "ml.g5.16xlarge",
            InstanceType::MlG524Xlarge => "ml.g5.24xlarge",
            InstanceType::MlG52Xlarge => "ml.g5.2xlarge",
            InstanceType::MlG548Xlarge => "ml.g5.48xlarge",
            InstanceType::MlG54Xlarge => "ml.g5.4xlarge",
            InstanceType::MlG58Xlarge => "ml.g5.8xlarge",
            InstanceType::MlG5Xlarge => "ml.g5.xlarge",
            InstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            InstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            InstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            InstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            InstanceType::MlM4Xlarge => "ml.m4.xlarge",
            InstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            InstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            InstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            InstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            InstanceType::MlM5Xlarge => "ml.m5.xlarge",
            InstanceType::MlM5D12Xlarge => "ml.m5d.12xlarge",
            InstanceType::MlM5D16Xlarge => "ml.m5d.16xlarge",
            InstanceType::MlM5D24Xlarge => "ml.m5d.24xlarge",
            InstanceType::MlM5D2Xlarge => "ml.m5d.2xlarge",
            InstanceType::MlM5D4Xlarge => "ml.m5d.4xlarge",
            InstanceType::MlM5D8Xlarge => "ml.m5d.8xlarge",
            InstanceType::MlM5DLarge => "ml.m5d.large",
            InstanceType::MlM5DXlarge => "ml.m5d.xlarge",
            InstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            InstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            InstanceType::MlP2Xlarge => "ml.p2.xlarge",
            InstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            InstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            InstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            InstanceType::MlP3Dn24Xlarge => "ml.p3dn.24xlarge",
            InstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            InstanceType::MlR516Xlarge => "ml.r5.16xlarge",
            InstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            InstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            InstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            InstanceType::MlR58Xlarge => "ml.r5.8xlarge",
            InstanceType::MlR5Large => "ml.r5.large",
            InstanceType::MlR5Xlarge => "ml.r5.xlarge",
            InstanceType::MlT22Xlarge => "ml.t2.2xlarge",
            InstanceType::MlT2Large => "ml.t2.large",
            InstanceType::MlT2Medium => "ml.t2.medium",
            InstanceType::MlT2Xlarge => "ml.t2.xlarge",
            InstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            InstanceType::MlT3Large => "ml.t3.large",
            InstanceType::MlT3Medium => "ml.t3.medium",
            InstanceType::MlT3Xlarge => "ml.t3.xlarge",
            InstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.c5d.18xlarge",
            "ml.c5d.2xlarge",
            "ml.c5d.4xlarge",
            "ml.c5d.9xlarge",
            "ml.c5d.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.g5.12xlarge",
            "ml.g5.16xlarge",
            "ml.g5.24xlarge",
            "ml.g5.2xlarge",
            "ml.g5.48xlarge",
            "ml.g5.4xlarge",
            "ml.g5.8xlarge",
            "ml.g5.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.xlarge",
            "ml.m5d.12xlarge",
            "ml.m5d.16xlarge",
            "ml.m5d.24xlarge",
            "ml.m5d.2xlarge",
            "ml.m5d.4xlarge",
            "ml.m5d.8xlarge",
            "ml.m5d.large",
            "ml.m5d.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.p3dn.24xlarge",
            "ml.r5.12xlarge",
            "ml.r5.16xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.8xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.t2.2xlarge",
            "ml.t2.large",
            "ml.t2.medium",
            "ml.t2.xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.xlarge",
        ]
    }
}
impl AsRef<str> for InstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configures the monitoring schedule and defines the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringScheduleConfig {
    /// <p>Configures the monitoring schedule.</p>
    pub schedule_config: std::option::Option<crate::model::ScheduleConfig>,
    /// <p>Defines the monitoring job.</p>
    pub monitoring_job_definition: std::option::Option<crate::model::MonitoringJobDefinition>,
    /// <p>The name of the monitoring job definition to schedule.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl MonitoringScheduleConfig {
    /// <p>Configures the monitoring schedule.</p>
    pub fn schedule_config(&self) -> std::option::Option<&crate::model::ScheduleConfig> {
        self.schedule_config.as_ref()
    }
    /// <p>Defines the monitoring job.</p>
    pub fn monitoring_job_definition(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringJobDefinition> {
        self.monitoring_job_definition.as_ref()
    }
    /// <p>The name of the monitoring job definition to schedule.</p>
    pub fn monitoring_job_definition_name(&self) -> std::option::Option<&str> {
        self.monitoring_job_definition_name.as_deref()
    }
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub fn monitoring_type(&self) -> std::option::Option<&crate::model::MonitoringType> {
        self.monitoring_type.as_ref()
    }
}
impl std::fmt::Debug for MonitoringScheduleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringScheduleConfig");
        formatter.field("schedule_config", &self.schedule_config);
        formatter.field("monitoring_job_definition", &self.monitoring_job_definition);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
pub mod monitoring_schedule_config {

    /// A builder for [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_config: std::option::Option<crate::model::ScheduleConfig>,
        pub(crate) monitoring_job_definition:
            std::option::Option<crate::model::MonitoringJobDefinition>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>Configures the monitoring schedule.</p>
        pub fn schedule_config(mut self, input: crate::model::ScheduleConfig) -> Self {
            self.schedule_config = Some(input);
            self
        }
        /// <p>Configures the monitoring schedule.</p>
        pub fn set_schedule_config(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfig>,
        ) -> Self {
            self.schedule_config = input;
            self
        }
        /// <p>Defines the monitoring job.</p>
        pub fn monitoring_job_definition(
            mut self,
            input: crate::model::MonitoringJobDefinition,
        ) -> Self {
            self.monitoring_job_definition = Some(input);
            self
        }
        /// <p>Defines the monitoring job.</p>
        pub fn set_monitoring_job_definition(
            mut self,
            input: std::option::Option<crate::model::MonitoringJobDefinition>,
        ) -> Self {
            self.monitoring_job_definition = input;
            self
        }
        /// <p>The name of the monitoring job definition to schedule.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring job definition to schedule.</p>
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
        pub fn build(self) -> crate::model::MonitoringScheduleConfig {
            crate::model::MonitoringScheduleConfig {
                schedule_config: self.schedule_config,
                monitoring_job_definition: self.monitoring_job_definition,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringScheduleConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
    pub fn builder() -> crate::model::monitoring_schedule_config::Builder {
        crate::model::monitoring_schedule_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringType {
    #[allow(missing_docs)] // documentation missing in model
    DataQuality,
    #[allow(missing_docs)] // documentation missing in model
    ModelBias,
    #[allow(missing_docs)] // documentation missing in model
    ModelExplainability,
    #[allow(missing_docs)] // documentation missing in model
    ModelQuality,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringType {
    fn from(s: &str) -> Self {
        match s {
            "DataQuality" => MonitoringType::DataQuality,
            "ModelBias" => MonitoringType::ModelBias,
            "ModelExplainability" => MonitoringType::ModelExplainability,
            "ModelQuality" => MonitoringType::ModelQuality,
            other => MonitoringType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringType::from(s))
    }
}
impl MonitoringType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringType::DataQuality => "DataQuality",
            MonitoringType::ModelBias => "ModelBias",
            MonitoringType::ModelExplainability => "ModelExplainability",
            MonitoringType::ModelQuality => "ModelQuality",
            MonitoringType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DataQuality",
            "ModelBias",
            "ModelExplainability",
            "ModelQuality",
        ]
    }
}
impl AsRef<str> for MonitoringType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringJobDefinition {
    /// <p>Baseline configuration used to validate that the data conforms to the specified constraints and statistics</p>
    pub baseline_config: std::option::Option<crate::model::MonitoringBaselineConfig>,
    /// <p>The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.</p>
    pub monitoring_inputs: std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
    /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage Service (Amazon S3).</p>
    pub monitoring_output_config: std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.</p>
    pub monitoring_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>Configures the monitoring job to run a specified Docker container image.</p>
    pub monitoring_app_specification: std::option::Option<crate::model::MonitoringAppSpecification>,
    /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies networking options for an monitoring job.</p>
    pub network_config: std::option::Option<crate::model::NetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl MonitoringJobDefinition {
    /// <p>Baseline configuration used to validate that the data conforms to the specified constraints and statistics</p>
    pub fn baseline_config(&self) -> std::option::Option<&crate::model::MonitoringBaselineConfig> {
        self.baseline_config.as_ref()
    }
    /// <p>The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.</p>
    pub fn monitoring_inputs(&self) -> std::option::Option<&[crate::model::MonitoringInput]> {
        self.monitoring_inputs.as_deref()
    }
    /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage Service (Amazon S3).</p>
    pub fn monitoring_output_config(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringOutputConfig> {
        self.monitoring_output_config.as_ref()
    }
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.</p>
    pub fn monitoring_resources(&self) -> std::option::Option<&crate::model::MonitoringResources> {
        self.monitoring_resources.as_ref()
    }
    /// <p>Configures the monitoring job to run a specified Docker container image.</p>
    pub fn monitoring_app_specification(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringAppSpecification> {
        self.monitoring_app_specification.as_ref()
    }
    /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
    pub fn stopping_condition(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringStoppingCondition> {
        self.stopping_condition.as_ref()
    }
    /// <p>Sets the environment variables in the Docker container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>Specifies networking options for an monitoring job.</p>
    pub fn network_config(&self) -> std::option::Option<&crate::model::NetworkConfig> {
        self.network_config.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for MonitoringJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringJobDefinition");
        formatter.field("baseline_config", &self.baseline_config);
        formatter.field("monitoring_inputs", &self.monitoring_inputs);
        formatter.field("monitoring_output_config", &self.monitoring_output_config);
        formatter.field("monitoring_resources", &self.monitoring_resources);
        formatter.field(
            "monitoring_app_specification",
            &self.monitoring_app_specification,
        );
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
pub mod monitoring_job_definition {

    /// A builder for [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baseline_config: std::option::Option<crate::model::MonitoringBaselineConfig>,
        pub(crate) monitoring_inputs:
            std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
        pub(crate) monitoring_output_config:
            std::option::Option<crate::model::MonitoringOutputConfig>,
        pub(crate) monitoring_resources: std::option::Option<crate::model::MonitoringResources>,
        pub(crate) monitoring_app_specification:
            std::option::Option<crate::model::MonitoringAppSpecification>,
        pub(crate) stopping_condition:
            std::option::Option<crate::model::MonitoringStoppingCondition>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) network_config: std::option::Option<crate::model::NetworkConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Baseline configuration used to validate that the data conforms to the specified constraints and statistics</p>
        pub fn baseline_config(mut self, input: crate::model::MonitoringBaselineConfig) -> Self {
            self.baseline_config = Some(input);
            self
        }
        /// <p>Baseline configuration used to validate that the data conforms to the specified constraints and statistics</p>
        pub fn set_baseline_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringBaselineConfig>,
        ) -> Self {
            self.baseline_config = input;
            self
        }
        /// Appends an item to `monitoring_inputs`.
        ///
        /// To override the contents of this collection use [`set_monitoring_inputs`](Self::set_monitoring_inputs).
        ///
        /// <p>The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.</p>
        pub fn monitoring_inputs(mut self, input: crate::model::MonitoringInput) -> Self {
            let mut v = self.monitoring_inputs.unwrap_or_default();
            v.push(input);
            self.monitoring_inputs = Some(v);
            self
        }
        /// <p>The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.</p>
        pub fn set_monitoring_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
        ) -> Self {
            self.monitoring_inputs = input;
            self
        }
        /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage Service (Amazon S3).</p>
        pub fn monitoring_output_config(
            mut self,
            input: crate::model::MonitoringOutputConfig,
        ) -> Self {
            self.monitoring_output_config = Some(input);
            self
        }
        /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage Service (Amazon S3).</p>
        pub fn set_monitoring_output_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringOutputConfig>,
        ) -> Self {
            self.monitoring_output_config = input;
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.</p>
        pub fn monitoring_resources(mut self, input: crate::model::MonitoringResources) -> Self {
            self.monitoring_resources = Some(input);
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.</p>
        pub fn set_monitoring_resources(
            mut self,
            input: std::option::Option<crate::model::MonitoringResources>,
        ) -> Self {
            self.monitoring_resources = input;
            self
        }
        /// <p>Configures the monitoring job to run a specified Docker container image.</p>
        pub fn monitoring_app_specification(
            mut self,
            input: crate::model::MonitoringAppSpecification,
        ) -> Self {
            self.monitoring_app_specification = Some(input);
            self
        }
        /// <p>Configures the monitoring job to run a specified Docker container image.</p>
        pub fn set_monitoring_app_specification(
            mut self,
            input: std::option::Option<crate::model::MonitoringAppSpecification>,
        ) -> Self {
            self.monitoring_app_specification = input;
            self
        }
        /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
        pub fn stopping_condition(
            mut self,
            input: crate::model::MonitoringStoppingCondition,
        ) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::MonitoringStoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Specifies networking options for an monitoring job.</p>
        pub fn network_config(mut self, input: crate::model::NetworkConfig) -> Self {
            self.network_config = Some(input);
            self
        }
        /// <p>Specifies networking options for an monitoring job.</p>
        pub fn set_network_config(
            mut self,
            input: std::option::Option<crate::model::NetworkConfig>,
        ) -> Self {
            self.network_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
        pub fn build(self) -> crate::model::MonitoringJobDefinition {
            crate::model::MonitoringJobDefinition {
                baseline_config: self.baseline_config,
                monitoring_inputs: self.monitoring_inputs,
                monitoring_output_config: self.monitoring_output_config,
                monitoring_resources: self.monitoring_resources,
                monitoring_app_specification: self.monitoring_app_specification,
                stopping_condition: self.stopping_condition,
                environment: self.environment,
                network_config: self.network_config,
                role_arn: self.role_arn,
            }
        }
    }
}
impl MonitoringJobDefinition {
    /// Creates a new builder-style object to manufacture [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
    pub fn builder() -> crate::model::monitoring_job_definition::Builder {
        crate::model::monitoring_job_definition::Builder::default()
    }
}

/// <p>Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkConfig {
    /// <p>Whether to encrypt all communications between distributed processing jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the processing job.</p>
    pub enable_network_isolation: bool,
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl NetworkConfig {
    /// <p>Whether to encrypt all communications between distributed processing jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.</p>
    pub fn enable_inter_container_traffic_encryption(&self) -> bool {
        self.enable_inter_container_traffic_encryption
    }
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the processing job.</p>
    pub fn enable_network_isolation(&self) -> bool {
        self.enable_network_isolation
    }
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
impl std::fmt::Debug for NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkConfig");
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`NetworkConfig`](crate::model::NetworkConfig)
pub mod network_config {

    /// A builder for [`NetworkConfig`](crate::model::NetworkConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>Whether to encrypt all communications between distributed processing jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        /// <p>Whether to encrypt all communications between distributed processing jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.</p>
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the processing job.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the processing job.</p>
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConfig`](crate::model::NetworkConfig)
        pub fn build(self) -> crate::model::NetworkConfig {
            crate::model::NetworkConfig {
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl NetworkConfig {
    /// Creates a new builder-style object to manufacture [`NetworkConfig`](crate::model::NetworkConfig)
    pub fn builder() -> crate::model::network_config::Builder {
        crate::model::network_config::Builder::default()
    }
}

/// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfig {
    /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the subnets in the VPC to which you want to connect your training job or model. For information about the availability of specific instance types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">Supported Instance Types and Availability Zones</a>.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfig {
    /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The ID of the subnets in the VPC to which you want to connect your training job or model. For information about the availability of specific instance types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">Supported Instance Types and Availability Zones</a>.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
}
impl std::fmt::Debug for VpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfig");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig)
pub mod vpc_config {

    /// A builder for [`VpcConfig`](crate::model::VpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>The ID of the subnets in the VPC to which you want to connect your training job or model. For information about the availability of specific instance types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">Supported Instance Types and Availability Zones</a>.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>The ID of the subnets in the VPC to which you want to connect your training job or model. For information about the availability of specific instance types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">Supported Instance Types and Availability Zones</a>.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig)
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                security_group_ids: self.security_group_ids,
                subnets: self.subnets,
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig)
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringStoppingCondition {
    /// <p>The maximum runtime allowed in seconds.</p> <note>
    /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and model explainability, this can be up to 3600 seconds for an hourly schedule. For model bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
    /// </note>
    pub max_runtime_in_seconds: i32,
}
impl MonitoringStoppingCondition {
    /// <p>The maximum runtime allowed in seconds.</p> <note>
    /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and model explainability, this can be up to 3600 seconds for an hourly schedule. For model bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
    /// </note>
    pub fn max_runtime_in_seconds(&self) -> i32 {
        self.max_runtime_in_seconds
    }
}
impl std::fmt::Debug for MonitoringStoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringStoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.finish()
    }
}
/// See [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
pub mod monitoring_stopping_condition {

    /// A builder for [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum runtime allowed in seconds.</p> <note>
        /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and model explainability, this can be up to 3600 seconds for an hourly schedule. For model bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
        /// </note>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        /// <p>The maximum runtime allowed in seconds.</p> <note>
        /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and model explainability, this can be up to 3600 seconds for an hourly schedule. For model bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
        /// </note>
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
        pub fn build(self) -> crate::model::MonitoringStoppingCondition {
            crate::model::MonitoringStoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
            }
        }
    }
}
impl MonitoringStoppingCondition {
    /// Creates a new builder-style object to manufacture [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
    pub fn builder() -> crate::model::monitoring_stopping_condition::Builder {
        crate::model::monitoring_stopping_condition::Builder::default()
    }
}

/// <p>Container image configuration object for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringAppSpecification {
    /// <p>The container image to be run by the monitoring job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the entrypoint for a container used to run the monitoring job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
}
impl MonitoringAppSpecification {
    /// <p>The container image to be run by the monitoring job.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>Specifies the entrypoint for a container used to run the monitoring job.</p>
    pub fn container_entrypoint(&self) -> std::option::Option<&[std::string::String]> {
        self.container_entrypoint.as_deref()
    }
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub fn container_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.container_arguments.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub fn record_preprocessor_source_uri(&self) -> std::option::Option<&str> {
        self.record_preprocessor_source_uri.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub fn post_analytics_processor_source_uri(&self) -> std::option::Option<&str> {
        self.post_analytics_processor_source_uri.as_deref()
    }
}
impl std::fmt::Debug for MonitoringAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.finish()
    }
}
/// See [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
pub mod monitoring_app_specification {

    /// A builder for [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The container image to be run by the monitoring job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The container image to be run by the monitoring job.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Appends an item to `container_entrypoint`.
        ///
        /// To override the contents of this collection use [`set_container_entrypoint`](Self::set_container_entrypoint).
        ///
        /// <p>Specifies the entrypoint for a container used to run the monitoring job.</p>
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        /// <p>Specifies the entrypoint for a container used to run the monitoring job.</p>
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        /// Appends an item to `container_arguments`.
        ///
        /// To override the contents of this collection use [`set_container_arguments`](Self::set_container_arguments).
        ///
        /// <p>An array of arguments for the container used to run the monitoring job.</p>
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        /// <p>An array of arguments for the container used to run the monitoring job.</p>
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
        pub fn build(self) -> crate::model::MonitoringAppSpecification {
            crate::model::MonitoringAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
            }
        }
    }
}
impl MonitoringAppSpecification {
    /// Creates a new builder-style object to manufacture [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
    pub fn builder() -> crate::model::monitoring_app_specification::Builder {
        crate::model::monitoring_app_specification::Builder::default()
    }
}

/// <p>Identifies the resources to deploy for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringResources {
    /// <p>The configuration for the cluster resources used to run the processing job.</p>
    pub cluster_config: std::option::Option<crate::model::MonitoringClusterConfig>,
}
impl MonitoringResources {
    /// <p>The configuration for the cluster resources used to run the processing job.</p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::MonitoringClusterConfig> {
        self.cluster_config.as_ref()
    }
}
impl std::fmt::Debug for MonitoringResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringResources");
        formatter.field("cluster_config", &self.cluster_config);
        formatter.finish()
    }
}
/// See [`MonitoringResources`](crate::model::MonitoringResources)
pub mod monitoring_resources {

    /// A builder for [`MonitoringResources`](crate::model::MonitoringResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_config: std::option::Option<crate::model::MonitoringClusterConfig>,
    }
    impl Builder {
        /// <p>The configuration for the cluster resources used to run the processing job.</p>
        pub fn cluster_config(mut self, input: crate::model::MonitoringClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>The configuration for the cluster resources used to run the processing job.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringResources`](crate::model::MonitoringResources)
        pub fn build(self) -> crate::model::MonitoringResources {
            crate::model::MonitoringResources {
                cluster_config: self.cluster_config,
            }
        }
    }
}
impl MonitoringResources {
    /// Creates a new builder-style object to manufacture [`MonitoringResources`](crate::model::MonitoringResources)
    pub fn builder() -> crate::model::monitoring_resources::Builder {
        crate::model::monitoring_resources::Builder::default()
    }
}

/// <p>Configuration for the cluster used to run model monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringClusterConfig {
    /// <p>The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type for the processing job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.</p>
    pub volume_size_in_gb: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.</p>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl MonitoringClusterConfig {
    /// <p>The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>The ML compute instance type for the processing job.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::ProcessingInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.</p>
    pub fn volume_size_in_gb(&self) -> std::option::Option<i32> {
        self.volume_size_in_gb
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.</p>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for MonitoringClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringClusterConfig");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
pub mod monitoring_cluster_config {

    /// A builder for [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.</p>
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.</p>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.</p>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
        pub fn build(self) -> crate::model::MonitoringClusterConfig {
            crate::model::MonitoringClusterConfig {
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl MonitoringClusterConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
    pub fn builder() -> crate::model::monitoring_cluster_config::Builder {
        crate::model::monitoring_cluster_config::Builder::default()
    }
}

/// <p>The output configuration for monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringOutputConfig {
    /// <p>Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.</p>
    pub monitoring_outputs: std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl MonitoringOutputConfig {
    /// <p>Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.</p>
    pub fn monitoring_outputs(&self) -> std::option::Option<&[crate::model::MonitoringOutput]> {
        self.monitoring_outputs.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for MonitoringOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringOutputConfig");
        formatter.field("monitoring_outputs", &self.monitoring_outputs);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
pub mod monitoring_output_config {

    /// A builder for [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_outputs:
            std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `monitoring_outputs`.
        ///
        /// To override the contents of this collection use [`set_monitoring_outputs`](Self::set_monitoring_outputs).
        ///
        /// <p>Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.</p>
        pub fn monitoring_outputs(mut self, input: crate::model::MonitoringOutput) -> Self {
            let mut v = self.monitoring_outputs.unwrap_or_default();
            v.push(input);
            self.monitoring_outputs = Some(v);
            self
        }
        /// <p>Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.</p>
        pub fn set_monitoring_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
        ) -> Self {
            self.monitoring_outputs = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
        pub fn build(self) -> crate::model::MonitoringOutputConfig {
            crate::model::MonitoringOutputConfig {
                monitoring_outputs: self.monitoring_outputs,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl MonitoringOutputConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
    pub fn builder() -> crate::model::monitoring_output_config::Builder {
        crate::model::monitoring_output_config::Builder::default()
    }
}

/// <p>The output object for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringOutput {
    /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
    pub s3_output: std::option::Option<crate::model::MonitoringS3Output>,
}
impl MonitoringOutput {
    /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
    pub fn s3_output(&self) -> std::option::Option<&crate::model::MonitoringS3Output> {
        self.s3_output.as_ref()
    }
}
impl std::fmt::Debug for MonitoringOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringOutput");
        formatter.field("s3_output", &self.s3_output);
        formatter.finish()
    }
}
/// See [`MonitoringOutput`](crate::model::MonitoringOutput)
pub mod monitoring_output {

    /// A builder for [`MonitoringOutput`](crate::model::MonitoringOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output: std::option::Option<crate::model::MonitoringS3Output>,
    }
    impl Builder {
        /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
        pub fn s3_output(mut self, input: crate::model::MonitoringS3Output) -> Self {
            self.s3_output = Some(input);
            self
        }
        /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
        pub fn set_s3_output(
            mut self,
            input: std::option::Option<crate::model::MonitoringS3Output>,
        ) -> Self {
            self.s3_output = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringOutput`](crate::model::MonitoringOutput)
        pub fn build(self) -> crate::model::MonitoringOutput {
            crate::model::MonitoringOutput {
                s3_output: self.s3_output,
            }
        }
    }
}
impl MonitoringOutput {
    /// Creates a new builder-style object to manufacture [`MonitoringOutput`](crate::model::MonitoringOutput)
    pub fn builder() -> crate::model::monitoring_output::Builder {
        crate::model::monitoring_output::Builder::default()
    }
}

/// <p>Information about where and how you want to store the results of a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringS3Output {
    /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether to upload the results of the monitoring job continuously or after the job completes.</p>
    pub s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
}
impl MonitoringS3Output {
    /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Whether to upload the results of the monitoring job continuously or after the job completes.</p>
    pub fn s3_upload_mode(&self) -> std::option::Option<&crate::model::ProcessingS3UploadMode> {
        self.s3_upload_mode.as_ref()
    }
}
impl std::fmt::Debug for MonitoringS3Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringS3Output");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_upload_mode", &self.s3_upload_mode);
        formatter.finish()
    }
}
/// See [`MonitoringS3Output`](crate::model::MonitoringS3Output)
pub mod monitoring_s3_output {

    /// A builder for [`MonitoringS3Output`](crate::model::MonitoringS3Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
    }
    impl Builder {
        /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether to upload the results of the monitoring job continuously or after the job completes.</p>
        pub fn s3_upload_mode(mut self, input: crate::model::ProcessingS3UploadMode) -> Self {
            self.s3_upload_mode = Some(input);
            self
        }
        /// <p>Whether to upload the results of the monitoring job continuously or after the job completes.</p>
        pub fn set_s3_upload_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3UploadMode>,
        ) -> Self {
            self.s3_upload_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringS3Output`](crate::model::MonitoringS3Output)
        pub fn build(self) -> crate::model::MonitoringS3Output {
            crate::model::MonitoringS3Output {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_upload_mode: self.s3_upload_mode,
            }
        }
    }
}
impl MonitoringS3Output {
    /// Creates a new builder-style object to manufacture [`MonitoringS3Output`](crate::model::MonitoringS3Output)
    pub fn builder() -> crate::model::monitoring_s3_output::Builder {
        crate::model::monitoring_s3_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3UploadMode {
    #[allow(missing_docs)] // documentation missing in model
    Continuous,
    #[allow(missing_docs)] // documentation missing in model
    EndOfJob,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3UploadMode {
    fn from(s: &str) -> Self {
        match s {
            "Continuous" => ProcessingS3UploadMode::Continuous,
            "EndOfJob" => ProcessingS3UploadMode::EndOfJob,
            other => ProcessingS3UploadMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3UploadMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3UploadMode::from(s))
    }
}
impl ProcessingS3UploadMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3UploadMode::Continuous => "Continuous",
            ProcessingS3UploadMode::EndOfJob => "EndOfJob",
            ProcessingS3UploadMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Continuous", "EndOfJob"]
    }
}
impl AsRef<str> for ProcessingS3UploadMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The inputs for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringInput {
    /// <p>The endpoint for a monitoring job.</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl MonitoringInput {
    /// <p>The endpoint for a monitoring job.</p>
    pub fn endpoint_input(&self) -> std::option::Option<&crate::model::EndpointInput> {
        self.endpoint_input.as_ref()
    }
}
impl std::fmt::Debug for MonitoringInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`MonitoringInput`](crate::model::MonitoringInput)
pub mod monitoring_input {

    /// A builder for [`MonitoringInput`](crate::model::MonitoringInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>The endpoint for a monitoring job.</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        /// <p>The endpoint for a monitoring job.</p>
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringInput`](crate::model::MonitoringInput)
        pub fn build(self) -> crate::model::MonitoringInput {
            crate::model::MonitoringInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl MonitoringInput {
    /// Creates a new builder-style object to manufacture [`MonitoringInput`](crate::model::MonitoringInput)
    pub fn builder() -> crate::model::monitoring_input::Builder {
        crate::model::monitoring_input::Builder::default()
    }
}

/// <p>Input object for the endpoint</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointInput {
    /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code> enabled.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for transferring data for the monitoring job. <code>Pipe</code> mode is recommended for large datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to <code>File</code>.</p>
    pub s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
    /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to <code>FullyReplicated</code> </p>
    pub s3_data_distribution_type:
        std::option::Option<crate::model::ProcessingS3DataDistributionType>,
    /// <p>The attributes of the input data that are the input features.</p>
    pub features_attribute: std::option::Option<std::string::String>,
    /// <p>The attribute of the input data that represents the ground truth label.</p>
    pub inference_attribute: std::option::Option<std::string::String>,
    /// <p>In a classification problem, the attribute that represents the class probability.</p>
    pub probability_attribute: std::option::Option<std::string::String>,
    /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
    pub probability_threshold_attribute: std::option::Option<f64>,
    /// <p>If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
    pub start_time_offset: std::option::Option<std::string::String>,
    /// <p>If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
    pub end_time_offset: std::option::Option<std::string::String>,
}
impl EndpointInput {
    /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code> enabled.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for transferring data for the monitoring job. <code>Pipe</code> mode is recommended for large datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to <code>File</code>.</p>
    pub fn s3_input_mode(&self) -> std::option::Option<&crate::model::ProcessingS3InputMode> {
        self.s3_input_mode.as_ref()
    }
    /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to <code>FullyReplicated</code> </p>
    pub fn s3_data_distribution_type(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingS3DataDistributionType> {
        self.s3_data_distribution_type.as_ref()
    }
    /// <p>The attributes of the input data that are the input features.</p>
    pub fn features_attribute(&self) -> std::option::Option<&str> {
        self.features_attribute.as_deref()
    }
    /// <p>The attribute of the input data that represents the ground truth label.</p>
    pub fn inference_attribute(&self) -> std::option::Option<&str> {
        self.inference_attribute.as_deref()
    }
    /// <p>In a classification problem, the attribute that represents the class probability.</p>
    pub fn probability_attribute(&self) -> std::option::Option<&str> {
        self.probability_attribute.as_deref()
    }
    /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
    pub fn probability_threshold_attribute(&self) -> std::option::Option<f64> {
        self.probability_threshold_attribute
    }
    /// <p>If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
    pub fn start_time_offset(&self) -> std::option::Option<&str> {
        self.start_time_offset.as_deref()
    }
    /// <p>If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
    pub fn end_time_offset(&self) -> std::option::Option<&str> {
        self.end_time_offset.as_deref()
    }
}
impl std::fmt::Debug for EndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointInput");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_input_mode", &self.s3_input_mode);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("features_attribute", &self.features_attribute);
        formatter.field("inference_attribute", &self.inference_attribute);
        formatter.field("probability_attribute", &self.probability_attribute);
        formatter.field(
            "probability_threshold_attribute",
            &self.probability_threshold_attribute,
        );
        formatter.field("start_time_offset", &self.start_time_offset);
        formatter.field("end_time_offset", &self.end_time_offset);
        formatter.finish()
    }
}
/// See [`EndpointInput`](crate::model::EndpointInput)
pub mod endpoint_input {

    /// A builder for [`EndpointInput`](crate::model::EndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
        pub(crate) s3_data_distribution_type:
            std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        pub(crate) features_attribute: std::option::Option<std::string::String>,
        pub(crate) inference_attribute: std::option::Option<std::string::String>,
        pub(crate) probability_attribute: std::option::Option<std::string::String>,
        pub(crate) probability_threshold_attribute: std::option::Option<f64>,
        pub(crate) start_time_offset: std::option::Option<std::string::String>,
        pub(crate) end_time_offset: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code> enabled.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code> enabled.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for transferring data for the monitoring job. <code>Pipe</code> mode is recommended for large datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to <code>File</code>.</p>
        pub fn s3_input_mode(mut self, input: crate::model::ProcessingS3InputMode) -> Self {
            self.s3_input_mode = Some(input);
            self
        }
        /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for transferring data for the monitoring job. <code>Pipe</code> mode is recommended for large datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to <code>File</code>.</p>
        pub fn set_s3_input_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3InputMode>,
        ) -> Self {
            self.s3_input_mode = input;
            self
        }
        /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to <code>FullyReplicated</code> </p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::ProcessingS3DataDistributionType,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to <code>FullyReplicated</code> </p>
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        /// <p>The attributes of the input data that are the input features.</p>
        pub fn features_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.features_attribute = Some(input.into());
            self
        }
        /// <p>The attributes of the input data that are the input features.</p>
        pub fn set_features_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.features_attribute = input;
            self
        }
        /// <p>The attribute of the input data that represents the ground truth label.</p>
        pub fn inference_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.inference_attribute = Some(input.into());
            self
        }
        /// <p>The attribute of the input data that represents the ground truth label.</p>
        pub fn set_inference_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inference_attribute = input;
            self
        }
        /// <p>In a classification problem, the attribute that represents the class probability.</p>
        pub fn probability_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.probability_attribute = Some(input.into());
            self
        }
        /// <p>In a classification problem, the attribute that represents the class probability.</p>
        pub fn set_probability_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.probability_attribute = input;
            self
        }
        /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
        pub fn probability_threshold_attribute(mut self, input: f64) -> Self {
            self.probability_threshold_attribute = Some(input);
            self
        }
        /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
        pub fn set_probability_threshold_attribute(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.probability_threshold_attribute = input;
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
        pub fn start_time_offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time_offset = Some(input.into());
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
        pub fn set_start_time_offset(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_time_offset = input;
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
        pub fn end_time_offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_time_offset = Some(input.into());
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model Quality Monitoring Jobs</a>.</p>
        pub fn set_end_time_offset(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_time_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointInput`](crate::model::EndpointInput)
        pub fn build(self) -> crate::model::EndpointInput {
            crate::model::EndpointInput {
                endpoint_name: self.endpoint_name,
                local_path: self.local_path,
                s3_input_mode: self.s3_input_mode,
                s3_data_distribution_type: self.s3_data_distribution_type,
                features_attribute: self.features_attribute,
                inference_attribute: self.inference_attribute,
                probability_attribute: self.probability_attribute,
                probability_threshold_attribute: self.probability_threshold_attribute,
                start_time_offset: self.start_time_offset,
                end_time_offset: self.end_time_offset,
            }
        }
    }
}
impl EndpointInput {
    /// Creates a new builder-style object to manufacture [`EndpointInput`](crate::model::EndpointInput)
    pub fn builder() -> crate::model::endpoint_input::Builder {
        crate::model::endpoint_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3DataDistributionType {
    #[allow(missing_docs)] // documentation missing in model
    Fullyreplicated,
    #[allow(missing_docs)] // documentation missing in model
    Shardedbys3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3DataDistributionType {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => ProcessingS3DataDistributionType::Fullyreplicated,
            "ShardedByS3Key" => ProcessingS3DataDistributionType::Shardedbys3Key,
            other => ProcessingS3DataDistributionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3DataDistributionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3DataDistributionType::from(s))
    }
}
impl ProcessingS3DataDistributionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3DataDistributionType::Fullyreplicated => "FullyReplicated",
            ProcessingS3DataDistributionType::Shardedbys3Key => "ShardedByS3Key",
            ProcessingS3DataDistributionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for ProcessingS3DataDistributionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3InputMode {
    #[allow(missing_docs)] // documentation missing in model
    File,
    #[allow(missing_docs)] // documentation missing in model
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3InputMode {
    fn from(s: &str) -> Self {
        match s {
            "File" => ProcessingS3InputMode::File,
            "Pipe" => ProcessingS3InputMode::Pipe,
            other => ProcessingS3InputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3InputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3InputMode::from(s))
    }
}
impl ProcessingS3InputMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3InputMode::File => "File",
            ProcessingS3InputMode::Pipe => "Pipe",
            ProcessingS3InputMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["File", "Pipe"]
    }
}
impl AsRef<str> for ProcessingS3InputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should validated against.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
    /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.</p>
    pub statistics_resource: std::option::Option<crate::model::MonitoringStatisticsResource>,
}
impl MonitoringBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub fn baselining_job_name(&self) -> std::option::Option<&str> {
        self.baselining_job_name.as_deref()
    }
    /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should validated against.</p>
    pub fn constraints_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConstraintsResource> {
        self.constraints_resource.as_ref()
    }
    /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.</p>
    pub fn statistics_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringStatisticsResource> {
        self.statistics_resource.as_ref()
    }
}
impl std::fmt::Debug for MonitoringBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.field("statistics_resource", &self.statistics_resource);
        formatter.finish()
    }
}
/// See [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
pub mod monitoring_baseline_config {

    /// A builder for [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
        pub(crate) statistics_resource:
            std::option::Option<crate::model::MonitoringStatisticsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should validated against.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should validated against.</p>
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.</p>
        pub fn statistics_resource(
            mut self,
            input: crate::model::MonitoringStatisticsResource,
        ) -> Self {
            self.statistics_resource = Some(input);
            self
        }
        /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.</p>
        pub fn set_statistics_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringStatisticsResource>,
        ) -> Self {
            self.statistics_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
        pub fn build(self) -> crate::model::MonitoringBaselineConfig {
            crate::model::MonitoringBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
                statistics_resource: self.statistics_resource,
            }
        }
    }
}
impl MonitoringBaselineConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
    pub fn builder() -> crate::model::monitoring_baseline_config::Builder {
        crate::model::monitoring_baseline_config::Builder::default()
    }
}

/// <p>The statistics resource for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringStatisticsResource {
    /// <p>The Amazon S3 URI for the statistics resource.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl MonitoringStatisticsResource {
    /// <p>The Amazon S3 URI for the statistics resource.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for MonitoringStatisticsResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringStatisticsResource");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
pub mod monitoring_statistics_resource {

    /// A builder for [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 URI for the statistics resource.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI for the statistics resource.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
        pub fn build(self) -> crate::model::MonitoringStatisticsResource {
            crate::model::MonitoringStatisticsResource {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringStatisticsResource {
    /// Creates a new builder-style object to manufacture [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
    pub fn builder() -> crate::model::monitoring_statistics_resource::Builder {
        crate::model::monitoring_statistics_resource::Builder::default()
    }
}

/// <p>The constraints resource for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConstraintsResource {
    /// <p>The Amazon S3 URI for the constraints resource.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl MonitoringConstraintsResource {
    /// <p>The Amazon S3 URI for the constraints resource.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for MonitoringConstraintsResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConstraintsResource");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
pub mod monitoring_constraints_resource {

    /// A builder for [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 URI for the constraints resource.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI for the constraints resource.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
        pub fn build(self) -> crate::model::MonitoringConstraintsResource {
            crate::model::MonitoringConstraintsResource {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringConstraintsResource {
    /// Creates a new builder-style object to manufacture [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
    pub fn builder() -> crate::model::monitoring_constraints_resource::Builder {
        crate::model::monitoring_constraints_resource::Builder::default()
    }
}

/// <p>Configuration details about the monitoring schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduleConfig {
    /// <p>A cron expression that describes details about the monitoring schedule.</p>
    /// <p>Currently the only supported cron expressions are:</p>
    /// <ul>
    /// <li> <p>If you want to set the job to start every hour, please use the following:</p> <p> <code>Hourly: cron(0 * ? * * *)</code> </p> </li>
    /// <li> <p>If you want to start the job daily:</p> <p> <code>cron(0 [00-23] ? * * *)</code> </p> </li>
    /// </ul>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li> <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code> </p> </li>
    /// <li> <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code> </p> </li>
    /// </ul>
    /// <p>To support running every 6, 12 hours, the following are also supported:</p>
    /// <p> <code>cron(0 [00-23]/[01-24] ? * * *)</code> </p>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li> <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code> </p> </li>
    /// <li> <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code> </p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>Even though the cron expression is set to start at 5PM UTC, note that there could be a delay of 0-20 minutes from the actual requested time to run the execution. </p> </li>
    /// <li> <p>We recommend that if you would like a daily schedule, you do not provide this parameter. Amazon SageMaker will pick a time for running every day.</p> </li>
    /// </ul>
    /// </note>
    pub schedule_expression: std::option::Option<std::string::String>,
}
impl ScheduleConfig {
    /// <p>A cron expression that describes details about the monitoring schedule.</p>
    /// <p>Currently the only supported cron expressions are:</p>
    /// <ul>
    /// <li> <p>If you want to set the job to start every hour, please use the following:</p> <p> <code>Hourly: cron(0 * ? * * *)</code> </p> </li>
    /// <li> <p>If you want to start the job daily:</p> <p> <code>cron(0 [00-23] ? * * *)</code> </p> </li>
    /// </ul>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li> <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code> </p> </li>
    /// <li> <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code> </p> </li>
    /// </ul>
    /// <p>To support running every 6, 12 hours, the following are also supported:</p>
    /// <p> <code>cron(0 [00-23]/[01-24] ? * * *)</code> </p>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li> <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code> </p> </li>
    /// <li> <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code> </p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>Even though the cron expression is set to start at 5PM UTC, note that there could be a delay of 0-20 minutes from the actual requested time to run the execution. </p> </li>
    /// <li> <p>We recommend that if you would like a daily schedule, you do not provide this parameter. Amazon SageMaker will pick a time for running every day.</p> </li>
    /// </ul>
    /// </note>
    pub fn schedule_expression(&self) -> std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
}
impl std::fmt::Debug for ScheduleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduleConfig");
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.finish()
    }
}
/// See [`ScheduleConfig`](crate::model::ScheduleConfig)
pub mod schedule_config {

    /// A builder for [`ScheduleConfig`](crate::model::ScheduleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A cron expression that describes details about the monitoring schedule.</p>
        /// <p>Currently the only supported cron expressions are:</p>
        /// <ul>
        /// <li> <p>If you want to set the job to start every hour, please use the following:</p> <p> <code>Hourly: cron(0 * ? * * *)</code> </p> </li>
        /// <li> <p>If you want to start the job daily:</p> <p> <code>cron(0 [00-23] ? * * *)</code> </p> </li>
        /// </ul>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li> <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code> </p> </li>
        /// <li> <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code> </p> </li>
        /// </ul>
        /// <p>To support running every 6, 12 hours, the following are also supported:</p>
        /// <p> <code>cron(0 [00-23]/[01-24] ? * * *)</code> </p>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li> <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code> </p> </li>
        /// <li> <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code> </p> </li>
        /// </ul> <note>
        /// <ul>
        /// <li> <p>Even though the cron expression is set to start at 5PM UTC, note that there could be a delay of 0-20 minutes from the actual requested time to run the execution. </p> </li>
        /// <li> <p>We recommend that if you would like a daily schedule, you do not provide this parameter. Amazon SageMaker will pick a time for running every day.</p> </li>
        /// </ul>
        /// </note>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        /// <p>A cron expression that describes details about the monitoring schedule.</p>
        /// <p>Currently the only supported cron expressions are:</p>
        /// <ul>
        /// <li> <p>If you want to set the job to start every hour, please use the following:</p> <p> <code>Hourly: cron(0 * ? * * *)</code> </p> </li>
        /// <li> <p>If you want to start the job daily:</p> <p> <code>cron(0 [00-23] ? * * *)</code> </p> </li>
        /// </ul>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li> <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code> </p> </li>
        /// <li> <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code> </p> </li>
        /// </ul>
        /// <p>To support running every 6, 12 hours, the following are also supported:</p>
        /// <p> <code>cron(0 [00-23]/[01-24] ? * * *)</code> </p>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li> <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code> </p> </li>
        /// <li> <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code> </p> </li>
        /// </ul> <note>
        /// <ul>
        /// <li> <p>Even though the cron expression is set to start at 5PM UTC, note that there could be a delay of 0-20 minutes from the actual requested time to run the execution. </p> </li>
        /// <li> <p>We recommend that if you would like a daily schedule, you do not provide this parameter. Amazon SageMaker will pick a time for running every day.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleConfig`](crate::model::ScheduleConfig)
        pub fn build(self) -> crate::model::ScheduleConfig {
            crate::model::ScheduleConfig {
                schedule_expression: self.schedule_expression,
            }
        }
    }
}
impl ScheduleConfig {
    /// Creates a new builder-style object to manufacture [`ScheduleConfig`](crate::model::ScheduleConfig)
    pub fn builder() -> crate::model::schedule_config::Builder {
        crate::model::schedule_config::Builder::default()
    }
}

/// <p>A structure of additional Inference Specification. Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdditionalInferenceSpecificationDefinition {
    /// <p>A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the additional Inference specification</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
    pub containers:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
    /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
    pub supported_transform_instance_types:
        std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
    /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
    pub supported_realtime_inference_instance_types:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
    /// <p>The supported MIME types for the input data.</p>
    pub supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The supported MIME types for the output data.</p>
    pub supported_response_mime_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AdditionalInferenceSpecificationDefinition {
    /// <p>A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the additional Inference specification</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
    pub fn containers(
        &self,
    ) -> std::option::Option<&[crate::model::ModelPackageContainerDefinition]> {
        self.containers.as_deref()
    }
    /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
    pub fn supported_transform_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::TransformInstanceType]> {
        self.supported_transform_instance_types.as_deref()
    }
    /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
    pub fn supported_realtime_inference_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::ProductionVariantInstanceType]> {
        self.supported_realtime_inference_instance_types.as_deref()
    }
    /// <p>The supported MIME types for the input data.</p>
    pub fn supported_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_content_types.as_deref()
    }
    /// <p>The supported MIME types for the output data.</p>
    pub fn supported_response_mime_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_response_mime_types.as_deref()
    }
}
impl std::fmt::Debug for AdditionalInferenceSpecificationDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdditionalInferenceSpecificationDefinition");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("containers", &self.containers);
        formatter.field(
            "supported_transform_instance_types",
            &self.supported_transform_instance_types,
        );
        formatter.field(
            "supported_realtime_inference_instance_types",
            &self.supported_realtime_inference_instance_types,
        );
        formatter.field("supported_content_types", &self.supported_content_types);
        formatter.field(
            "supported_response_mime_types",
            &self.supported_response_mime_types,
        );
        formatter.finish()
    }
}
/// See [`AdditionalInferenceSpecificationDefinition`](crate::model::AdditionalInferenceSpecificationDefinition)
pub mod additional_inference_specification_definition {

    /// A builder for [`AdditionalInferenceSpecificationDefinition`](crate::model::AdditionalInferenceSpecificationDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) containers:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
        pub(crate) supported_transform_instance_types:
            std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        pub(crate) supported_realtime_inference_instance_types:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        pub(crate) supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supported_response_mime_types:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the additional Inference specification</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the additional Inference specification</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `containers`.
        ///
        /// To override the contents of this collection use [`set_containers`](Self::set_containers).
        ///
        /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
        pub fn containers(mut self, input: crate::model::ModelPackageContainerDefinition) -> Self {
            let mut v = self.containers.unwrap_or_default();
            v.push(input);
            self.containers = Some(v);
            self
        }
        /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
        pub fn set_containers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ModelPackageContainerDefinition>,
            >,
        ) -> Self {
            self.containers = input;
            self
        }
        /// Appends an item to `supported_transform_instance_types`.
        ///
        /// To override the contents of this collection use [`set_supported_transform_instance_types`](Self::set_supported_transform_instance_types).
        ///
        /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
        pub fn supported_transform_instance_types(
            mut self,
            input: crate::model::TransformInstanceType,
        ) -> Self {
            let mut v = self.supported_transform_instance_types.unwrap_or_default();
            v.push(input);
            self.supported_transform_instance_types = Some(v);
            self
        }
        /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
        pub fn set_supported_transform_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        ) -> Self {
            self.supported_transform_instance_types = input;
            self
        }
        /// Appends an item to `supported_realtime_inference_instance_types`.
        ///
        /// To override the contents of this collection use [`set_supported_realtime_inference_instance_types`](Self::set_supported_realtime_inference_instance_types).
        ///
        /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
        pub fn supported_realtime_inference_instance_types(
            mut self,
            input: crate::model::ProductionVariantInstanceType,
        ) -> Self {
            let mut v = self
                .supported_realtime_inference_instance_types
                .unwrap_or_default();
            v.push(input);
            self.supported_realtime_inference_instance_types = Some(v);
            self
        }
        /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
        pub fn set_supported_realtime_inference_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        ) -> Self {
            self.supported_realtime_inference_instance_types = input;
            self
        }
        /// Appends an item to `supported_content_types`.
        ///
        /// To override the contents of this collection use [`set_supported_content_types`](Self::set_supported_content_types).
        ///
        /// <p>The supported MIME types for the input data.</p>
        pub fn supported_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supported_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_content_types = Some(v);
            self
        }
        /// <p>The supported MIME types for the input data.</p>
        pub fn set_supported_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_content_types = input;
            self
        }
        /// Appends an item to `supported_response_mime_types`.
        ///
        /// To override the contents of this collection use [`set_supported_response_mime_types`](Self::set_supported_response_mime_types).
        ///
        /// <p>The supported MIME types for the output data.</p>
        pub fn supported_response_mime_types(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.supported_response_mime_types.unwrap_or_default();
            v.push(input.into());
            self.supported_response_mime_types = Some(v);
            self
        }
        /// <p>The supported MIME types for the output data.</p>
        pub fn set_supported_response_mime_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_response_mime_types = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalInferenceSpecificationDefinition`](crate::model::AdditionalInferenceSpecificationDefinition)
        pub fn build(self) -> crate::model::AdditionalInferenceSpecificationDefinition {
            crate::model::AdditionalInferenceSpecificationDefinition {
                name: self.name,
                description: self.description,
                containers: self.containers,
                supported_transform_instance_types: self.supported_transform_instance_types,
                supported_realtime_inference_instance_types: self
                    .supported_realtime_inference_instance_types,
                supported_content_types: self.supported_content_types,
                supported_response_mime_types: self.supported_response_mime_types,
            }
        }
    }
}
impl AdditionalInferenceSpecificationDefinition {
    /// Creates a new builder-style object to manufacture [`AdditionalInferenceSpecificationDefinition`](crate::model::AdditionalInferenceSpecificationDefinition)
    pub fn builder() -> crate::model::additional_inference_specification_definition::Builder {
        crate::model::additional_inference_specification_definition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductionVariantInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC48Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Large,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D18Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5D9Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5DLarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlInf124Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlInf12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlInf16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlInf1Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM410Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM416Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DLarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP216Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP28Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlR5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5D12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5D24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5D2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5D4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5DLarge,
    #[allow(missing_docs)] // documentation missing in model
    MlR5DXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT22Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Large,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlT2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProductionVariantInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => ProductionVariantInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => ProductionVariantInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => ProductionVariantInstanceType::MlC48Xlarge,
            "ml.c4.large" => ProductionVariantInstanceType::MlC4Large,
            "ml.c4.xlarge" => ProductionVariantInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => ProductionVariantInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => ProductionVariantInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => ProductionVariantInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => ProductionVariantInstanceType::MlC59Xlarge,
            "ml.c5.large" => ProductionVariantInstanceType::MlC5Large,
            "ml.c5.xlarge" => ProductionVariantInstanceType::MlC5Xlarge,
            "ml.c5d.18xlarge" => ProductionVariantInstanceType::MlC5D18Xlarge,
            "ml.c5d.2xlarge" => ProductionVariantInstanceType::MlC5D2Xlarge,
            "ml.c5d.4xlarge" => ProductionVariantInstanceType::MlC5D4Xlarge,
            "ml.c5d.9xlarge" => ProductionVariantInstanceType::MlC5D9Xlarge,
            "ml.c5d.large" => ProductionVariantInstanceType::MlC5DLarge,
            "ml.c5d.xlarge" => ProductionVariantInstanceType::MlC5DXlarge,
            "ml.g4dn.12xlarge" => ProductionVariantInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => ProductionVariantInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => ProductionVariantInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => ProductionVariantInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => ProductionVariantInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => ProductionVariantInstanceType::MlG4DnXlarge,
            "ml.inf1.24xlarge" => ProductionVariantInstanceType::MlInf124Xlarge,
            "ml.inf1.2xlarge" => ProductionVariantInstanceType::MlInf12Xlarge,
            "ml.inf1.6xlarge" => ProductionVariantInstanceType::MlInf16Xlarge,
            "ml.inf1.xlarge" => ProductionVariantInstanceType::MlInf1Xlarge,
            "ml.m4.10xlarge" => ProductionVariantInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => ProductionVariantInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => ProductionVariantInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => ProductionVariantInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => ProductionVariantInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => ProductionVariantInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => ProductionVariantInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => ProductionVariantInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => ProductionVariantInstanceType::MlM54Xlarge,
            "ml.m5.large" => ProductionVariantInstanceType::MlM5Large,
            "ml.m5.xlarge" => ProductionVariantInstanceType::MlM5Xlarge,
            "ml.m5d.12xlarge" => ProductionVariantInstanceType::MlM5D12Xlarge,
            "ml.m5d.24xlarge" => ProductionVariantInstanceType::MlM5D24Xlarge,
            "ml.m5d.2xlarge" => ProductionVariantInstanceType::MlM5D2Xlarge,
            "ml.m5d.4xlarge" => ProductionVariantInstanceType::MlM5D4Xlarge,
            "ml.m5d.large" => ProductionVariantInstanceType::MlM5DLarge,
            "ml.m5d.xlarge" => ProductionVariantInstanceType::MlM5DXlarge,
            "ml.p2.16xlarge" => ProductionVariantInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => ProductionVariantInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => ProductionVariantInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => ProductionVariantInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => ProductionVariantInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => ProductionVariantInstanceType::MlP38Xlarge,
            "ml.r5.12xlarge" => ProductionVariantInstanceType::MlR512Xlarge,
            "ml.r5.24xlarge" => ProductionVariantInstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => ProductionVariantInstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => ProductionVariantInstanceType::MlR54Xlarge,
            "ml.r5.large" => ProductionVariantInstanceType::MlR5Large,
            "ml.r5.xlarge" => ProductionVariantInstanceType::MlR5Xlarge,
            "ml.r5d.12xlarge" => ProductionVariantInstanceType::MlR5D12Xlarge,
            "ml.r5d.24xlarge" => ProductionVariantInstanceType::MlR5D24Xlarge,
            "ml.r5d.2xlarge" => ProductionVariantInstanceType::MlR5D2Xlarge,
            "ml.r5d.4xlarge" => ProductionVariantInstanceType::MlR5D4Xlarge,
            "ml.r5d.large" => ProductionVariantInstanceType::MlR5DLarge,
            "ml.r5d.xlarge" => ProductionVariantInstanceType::MlR5DXlarge,
            "ml.t2.2xlarge" => ProductionVariantInstanceType::MlT22Xlarge,
            "ml.t2.large" => ProductionVariantInstanceType::MlT2Large,
            "ml.t2.medium" => ProductionVariantInstanceType::MlT2Medium,
            "ml.t2.xlarge" => ProductionVariantInstanceType::MlT2Xlarge,
            other => ProductionVariantInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProductionVariantInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductionVariantInstanceType::from(s))
    }
}
impl ProductionVariantInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductionVariantInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            ProductionVariantInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            ProductionVariantInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            ProductionVariantInstanceType::MlC4Large => "ml.c4.large",
            ProductionVariantInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            ProductionVariantInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            ProductionVariantInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            ProductionVariantInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            ProductionVariantInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            ProductionVariantInstanceType::MlC5Large => "ml.c5.large",
            ProductionVariantInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            ProductionVariantInstanceType::MlC5D18Xlarge => "ml.c5d.18xlarge",
            ProductionVariantInstanceType::MlC5D2Xlarge => "ml.c5d.2xlarge",
            ProductionVariantInstanceType::MlC5D4Xlarge => "ml.c5d.4xlarge",
            ProductionVariantInstanceType::MlC5D9Xlarge => "ml.c5d.9xlarge",
            ProductionVariantInstanceType::MlC5DLarge => "ml.c5d.large",
            ProductionVariantInstanceType::MlC5DXlarge => "ml.c5d.xlarge",
            ProductionVariantInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            ProductionVariantInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            ProductionVariantInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            ProductionVariantInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            ProductionVariantInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            ProductionVariantInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            ProductionVariantInstanceType::MlInf124Xlarge => "ml.inf1.24xlarge",
            ProductionVariantInstanceType::MlInf12Xlarge => "ml.inf1.2xlarge",
            ProductionVariantInstanceType::MlInf16Xlarge => "ml.inf1.6xlarge",
            ProductionVariantInstanceType::MlInf1Xlarge => "ml.inf1.xlarge",
            ProductionVariantInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            ProductionVariantInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            ProductionVariantInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            ProductionVariantInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            ProductionVariantInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            ProductionVariantInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            ProductionVariantInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            ProductionVariantInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            ProductionVariantInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            ProductionVariantInstanceType::MlM5Large => "ml.m5.large",
            ProductionVariantInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            ProductionVariantInstanceType::MlM5D12Xlarge => "ml.m5d.12xlarge",
            ProductionVariantInstanceType::MlM5D24Xlarge => "ml.m5d.24xlarge",
            ProductionVariantInstanceType::MlM5D2Xlarge => "ml.m5d.2xlarge",
            ProductionVariantInstanceType::MlM5D4Xlarge => "ml.m5d.4xlarge",
            ProductionVariantInstanceType::MlM5DLarge => "ml.m5d.large",
            ProductionVariantInstanceType::MlM5DXlarge => "ml.m5d.xlarge",
            ProductionVariantInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            ProductionVariantInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            ProductionVariantInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            ProductionVariantInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            ProductionVariantInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            ProductionVariantInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            ProductionVariantInstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            ProductionVariantInstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            ProductionVariantInstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            ProductionVariantInstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            ProductionVariantInstanceType::MlR5Large => "ml.r5.large",
            ProductionVariantInstanceType::MlR5Xlarge => "ml.r5.xlarge",
            ProductionVariantInstanceType::MlR5D12Xlarge => "ml.r5d.12xlarge",
            ProductionVariantInstanceType::MlR5D24Xlarge => "ml.r5d.24xlarge",
            ProductionVariantInstanceType::MlR5D2Xlarge => "ml.r5d.2xlarge",
            ProductionVariantInstanceType::MlR5D4Xlarge => "ml.r5d.4xlarge",
            ProductionVariantInstanceType::MlR5DLarge => "ml.r5d.large",
            ProductionVariantInstanceType::MlR5DXlarge => "ml.r5d.xlarge",
            ProductionVariantInstanceType::MlT22Xlarge => "ml.t2.2xlarge",
            ProductionVariantInstanceType::MlT2Large => "ml.t2.large",
            ProductionVariantInstanceType::MlT2Medium => "ml.t2.medium",
            ProductionVariantInstanceType::MlT2Xlarge => "ml.t2.xlarge",
            ProductionVariantInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.large",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.large",
            "ml.c5.xlarge",
            "ml.c5d.18xlarge",
            "ml.c5d.2xlarge",
            "ml.c5d.4xlarge",
            "ml.c5d.9xlarge",
            "ml.c5d.large",
            "ml.c5d.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.inf1.24xlarge",
            "ml.inf1.2xlarge",
            "ml.inf1.6xlarge",
            "ml.inf1.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.m5d.12xlarge",
            "ml.m5d.24xlarge",
            "ml.m5d.2xlarge",
            "ml.m5d.4xlarge",
            "ml.m5d.large",
            "ml.m5d.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.r5.12xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.r5d.12xlarge",
            "ml.r5d.24xlarge",
            "ml.r5d.2xlarge",
            "ml.r5d.4xlarge",
            "ml.r5d.large",
            "ml.r5d.xlarge",
            "ml.t2.2xlarge",
            "ml.t2.large",
            "ml.t2.medium",
            "ml.t2.xlarge",
        ]
    }
}
impl AsRef<str> for ProductionVariantInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC48Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM410Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM416Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP216Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP28Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransformInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => TransformInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => TransformInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => TransformInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => TransformInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => TransformInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => TransformInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => TransformInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => TransformInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => TransformInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => TransformInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => TransformInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => TransformInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => TransformInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => TransformInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => TransformInstanceType::MlG4DnXlarge,
            "ml.m4.10xlarge" => TransformInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => TransformInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => TransformInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => TransformInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => TransformInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => TransformInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => TransformInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => TransformInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => TransformInstanceType::MlM54Xlarge,
            "ml.m5.large" => TransformInstanceType::MlM5Large,
            "ml.m5.xlarge" => TransformInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => TransformInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => TransformInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => TransformInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => TransformInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => TransformInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => TransformInstanceType::MlP38Xlarge,
            other => TransformInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransformInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformInstanceType::from(s))
    }
}
impl TransformInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            TransformInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            TransformInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            TransformInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            TransformInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            TransformInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            TransformInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            TransformInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            TransformInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            TransformInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            TransformInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            TransformInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            TransformInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            TransformInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            TransformInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            TransformInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            TransformInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            TransformInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            TransformInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            TransformInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            TransformInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            TransformInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            TransformInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            TransformInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            TransformInstanceType::MlM5Large => "ml.m5.large",
            TransformInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            TransformInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            TransformInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            TransformInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            TransformInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            TransformInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            TransformInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            TransformInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
        ]
    }
}
impl AsRef<str> for TransformInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Docker container for the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageContainerDefinition {
    /// <p>The DNS host name for the Docker container.</p>
    pub container_hostname: std::option::Option<std::string::String>,
    /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
    /// <p>If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
    pub image: std::option::Option<std::string::String>,
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model package.</p>
    /// </note>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A structure with Model Input details.</p>
    pub model_input: std::option::Option<crate::model::ModelInput>,
    /// <p>The machine learning framework of the model package container image.</p>
    pub framework: std::option::Option<std::string::String>,
    /// <p>The framework version of the Model Package Container Image.</p>
    pub framework_version: std::option::Option<std::string::String>,
    /// <p>The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model. You can find a list of benchmarked models by calling <code>ListModelMetadata</code>.</p>
    pub nearest_model_name: std::option::Option<std::string::String>,
}
impl ModelPackageContainerDefinition {
    /// <p>The DNS host name for the Docker container.</p>
    pub fn container_hostname(&self) -> std::option::Option<&str> {
        self.container_hostname.as_deref()
    }
    /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
    /// <p>If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
    pub fn image_digest(&self) -> std::option::Option<&str> {
        self.image_digest.as_deref()
    }
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model package.</p>
    /// </note>
    pub fn model_data_url(&self) -> std::option::Option<&str> {
        self.model_data_url.as_deref()
    }
    /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>A structure with Model Input details.</p>
    pub fn model_input(&self) -> std::option::Option<&crate::model::ModelInput> {
        self.model_input.as_ref()
    }
    /// <p>The machine learning framework of the model package container image.</p>
    pub fn framework(&self) -> std::option::Option<&str> {
        self.framework.as_deref()
    }
    /// <p>The framework version of the Model Package Container Image.</p>
    pub fn framework_version(&self) -> std::option::Option<&str> {
        self.framework_version.as_deref()
    }
    /// <p>The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model. You can find a list of benchmarked models by calling <code>ListModelMetadata</code>.</p>
    pub fn nearest_model_name(&self) -> std::option::Option<&str> {
        self.nearest_model_name.as_deref()
    }
}
impl std::fmt::Debug for ModelPackageContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageContainerDefinition");
        formatter.field("container_hostname", &self.container_hostname);
        formatter.field("image", &self.image);
        formatter.field("image_digest", &self.image_digest);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("product_id", &self.product_id);
        formatter.field("environment", &self.environment);
        formatter.field("model_input", &self.model_input);
        formatter.field("framework", &self.framework);
        formatter.field("framework_version", &self.framework_version);
        formatter.field("nearest_model_name", &self.nearest_model_name);
        formatter.finish()
    }
}
/// See [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
pub mod model_package_container_definition {

    /// A builder for [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_hostname: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) model_input: std::option::Option<crate::model::ModelInput>,
        pub(crate) framework: std::option::Option<std::string::String>,
        pub(crate) framework_version: std::option::Option<std::string::String>,
        pub(crate) nearest_model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The DNS host name for the Docker container.</p>
        pub fn container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_hostname = Some(input.into());
            self
        }
        /// <p>The DNS host name for the Docker container.</p>
        pub fn set_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_hostname = input;
            self
        }
        /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
        /// <p>If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
        /// <p>If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model package.</p>
        /// </note>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model package.</p>
        /// </note>
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>A structure with Model Input details.</p>
        pub fn model_input(mut self, input: crate::model::ModelInput) -> Self {
            self.model_input = Some(input);
            self
        }
        /// <p>A structure with Model Input details.</p>
        pub fn set_model_input(
            mut self,
            input: std::option::Option<crate::model::ModelInput>,
        ) -> Self {
            self.model_input = input;
            self
        }
        /// <p>The machine learning framework of the model package container image.</p>
        pub fn framework(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework = Some(input.into());
            self
        }
        /// <p>The machine learning framework of the model package container image.</p>
        pub fn set_framework(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework = input;
            self
        }
        /// <p>The framework version of the Model Package Container Image.</p>
        pub fn framework_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_version = Some(input.into());
            self
        }
        /// <p>The framework version of the Model Package Container Image.</p>
        pub fn set_framework_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.framework_version = input;
            self
        }
        /// <p>The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model. You can find a list of benchmarked models by calling <code>ListModelMetadata</code>.</p>
        pub fn nearest_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.nearest_model_name = Some(input.into());
            self
        }
        /// <p>The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model. You can find a list of benchmarked models by calling <code>ListModelMetadata</code>.</p>
        pub fn set_nearest_model_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nearest_model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
        pub fn build(self) -> crate::model::ModelPackageContainerDefinition {
            crate::model::ModelPackageContainerDefinition {
                container_hostname: self.container_hostname,
                image: self.image,
                image_digest: self.image_digest,
                model_data_url: self.model_data_url,
                product_id: self.product_id,
                environment: self.environment,
                model_input: self.model_input,
                framework: self.framework,
                framework_version: self.framework_version,
                nearest_model_name: self.nearest_model_name,
            }
        }
    }
}
impl ModelPackageContainerDefinition {
    /// Creates a new builder-style object to manufacture [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
    pub fn builder() -> crate::model::model_package_container_definition::Builder {
        crate::model::model_package_container_definition::Builder::default()
    }
}

/// <p>Input object for the model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelInput {
    /// <p>The input configuration object for the model.</p>
    pub data_input_config: std::option::Option<std::string::String>,
}
impl ModelInput {
    /// <p>The input configuration object for the model.</p>
    pub fn data_input_config(&self) -> std::option::Option<&str> {
        self.data_input_config.as_deref()
    }
}
impl std::fmt::Debug for ModelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelInput");
        formatter.field("data_input_config", &self.data_input_config);
        formatter.finish()
    }
}
/// See [`ModelInput`](crate::model::ModelInput)
pub mod model_input {

    /// A builder for [`ModelInput`](crate::model::ModelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_input_config: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The input configuration object for the model.</p>
        pub fn data_input_config(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_input_config = Some(input.into());
            self
        }
        /// <p>The input configuration object for the model.</p>
        pub fn set_data_input_config(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_input_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelInput`](crate::model::ModelInput)
        pub fn build(self) -> crate::model::ModelInput {
            crate::model::ModelInput {
                data_input_config: self.data_input_config,
            }
        }
    }
}
impl ModelInput {
    /// Creates a new builder-style object to manufacture [`ModelInput`](crate::model::ModelInput)
    pub fn builder() -> crate::model::model_input::Builder {
        crate::model::model_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelApprovalStatus {
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    PendingManualApproval,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelApprovalStatus {
    fn from(s: &str) -> Self {
        match s {
            "Approved" => ModelApprovalStatus::Approved,
            "PendingManualApproval" => ModelApprovalStatus::PendingManualApproval,
            "Rejected" => ModelApprovalStatus::Rejected,
            other => ModelApprovalStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelApprovalStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelApprovalStatus::from(s))
    }
}
impl ModelApprovalStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelApprovalStatus::Approved => "Approved",
            ModelApprovalStatus::PendingManualApproval => "PendingManualApproval",
            ModelApprovalStatus::Rejected => "Rejected",
            ModelApprovalStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Approved", "PendingManualApproval", "Rejected"]
    }
}
impl AsRef<str> for ModelApprovalStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies weight and capacity values for a production variant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DesiredWeightAndCapacity {
    /// <p>The name of the variant to update.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>The variant's weight.</p>
    pub desired_weight: std::option::Option<f32>,
    /// <p>The variant's capacity.</p>
    pub desired_instance_count: std::option::Option<i32>,
}
impl DesiredWeightAndCapacity {
    /// <p>The name of the variant to update.</p>
    pub fn variant_name(&self) -> std::option::Option<&str> {
        self.variant_name.as_deref()
    }
    /// <p>The variant's weight.</p>
    pub fn desired_weight(&self) -> std::option::Option<f32> {
        self.desired_weight
    }
    /// <p>The variant's capacity.</p>
    pub fn desired_instance_count(&self) -> std::option::Option<i32> {
        self.desired_instance_count
    }
}
impl std::fmt::Debug for DesiredWeightAndCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DesiredWeightAndCapacity");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("desired_weight", &self.desired_weight);
        formatter.field("desired_instance_count", &self.desired_instance_count);
        formatter.finish()
    }
}
/// See [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
pub mod desired_weight_and_capacity {

    /// A builder for [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) desired_weight: std::option::Option<f32>,
        pub(crate) desired_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the variant to update.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        /// <p>The name of the variant to update.</p>
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// <p>The variant's weight.</p>
        pub fn desired_weight(mut self, input: f32) -> Self {
            self.desired_weight = Some(input);
            self
        }
        /// <p>The variant's weight.</p>
        pub fn set_desired_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.desired_weight = input;
            self
        }
        /// <p>The variant's capacity.</p>
        pub fn desired_instance_count(mut self, input: i32) -> Self {
            self.desired_instance_count = Some(input);
            self
        }
        /// <p>The variant's capacity.</p>
        pub fn set_desired_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
        pub fn build(self) -> crate::model::DesiredWeightAndCapacity {
            crate::model::DesiredWeightAndCapacity {
                variant_name: self.variant_name,
                desired_weight: self.desired_weight,
                desired_instance_count: self.desired_instance_count,
            }
        }
    }
}
impl DesiredWeightAndCapacity {
    /// Creates a new builder-style object to manufacture [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
    pub fn builder() -> crate::model::desired_weight_and_capacity::Builder {
        crate::model::desired_weight_and_capacity::Builder::default()
    }
}

/// <p>The deployment configuration for an endpoint, which contains the desired deployment strategy and rollback configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentConfig {
    /// <p>Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.</p>
    pub blue_green_update_policy: std::option::Option<crate::model::BlueGreenUpdatePolicy>,
    /// <p>Automatic rollback configuration for handling endpoint deployment failures and recovery.</p>
    pub auto_rollback_configuration: std::option::Option<crate::model::AutoRollbackConfig>,
}
impl DeploymentConfig {
    /// <p>Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.</p>
    pub fn blue_green_update_policy(
        &self,
    ) -> std::option::Option<&crate::model::BlueGreenUpdatePolicy> {
        self.blue_green_update_policy.as_ref()
    }
    /// <p>Automatic rollback configuration for handling endpoint deployment failures and recovery.</p>
    pub fn auto_rollback_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AutoRollbackConfig> {
        self.auto_rollback_configuration.as_ref()
    }
}
impl std::fmt::Debug for DeploymentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentConfig");
        formatter.field("blue_green_update_policy", &self.blue_green_update_policy);
        formatter.field(
            "auto_rollback_configuration",
            &self.auto_rollback_configuration,
        );
        formatter.finish()
    }
}
/// See [`DeploymentConfig`](crate::model::DeploymentConfig)
pub mod deployment_config {

    /// A builder for [`DeploymentConfig`](crate::model::DeploymentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blue_green_update_policy:
            std::option::Option<crate::model::BlueGreenUpdatePolicy>,
        pub(crate) auto_rollback_configuration:
            std::option::Option<crate::model::AutoRollbackConfig>,
    }
    impl Builder {
        /// <p>Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.</p>
        pub fn blue_green_update_policy(
            mut self,
            input: crate::model::BlueGreenUpdatePolicy,
        ) -> Self {
            self.blue_green_update_policy = Some(input);
            self
        }
        /// <p>Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.</p>
        pub fn set_blue_green_update_policy(
            mut self,
            input: std::option::Option<crate::model::BlueGreenUpdatePolicy>,
        ) -> Self {
            self.blue_green_update_policy = input;
            self
        }
        /// <p>Automatic rollback configuration for handling endpoint deployment failures and recovery.</p>
        pub fn auto_rollback_configuration(
            mut self,
            input: crate::model::AutoRollbackConfig,
        ) -> Self {
            self.auto_rollback_configuration = Some(input);
            self
        }
        /// <p>Automatic rollback configuration for handling endpoint deployment failures and recovery.</p>
        pub fn set_auto_rollback_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoRollbackConfig>,
        ) -> Self {
            self.auto_rollback_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfig`](crate::model::DeploymentConfig)
        pub fn build(self) -> crate::model::DeploymentConfig {
            crate::model::DeploymentConfig {
                blue_green_update_policy: self.blue_green_update_policy,
                auto_rollback_configuration: self.auto_rollback_configuration,
            }
        }
    }
}
impl DeploymentConfig {
    /// Creates a new builder-style object to manufacture [`DeploymentConfig`](crate::model::DeploymentConfig)
    pub fn builder() -> crate::model::deployment_config::Builder {
        crate::model::deployment_config::Builder::default()
    }
}

/// <p>Automatic rollback configuration for handling endpoint deployment failures and recovery.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoRollbackConfig {
    /// <p>List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment.</p>
    pub alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
}
impl AutoRollbackConfig {
    /// <p>List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment.</p>
    pub fn alarms(&self) -> std::option::Option<&[crate::model::Alarm]> {
        self.alarms.as_deref()
    }
}
impl std::fmt::Debug for AutoRollbackConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoRollbackConfig");
        formatter.field("alarms", &self.alarms);
        formatter.finish()
    }
}
/// See [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
pub mod auto_rollback_config {

    /// A builder for [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
    }
    impl Builder {
        /// Appends an item to `alarms`.
        ///
        /// To override the contents of this collection use [`set_alarms`](Self::set_alarms).
        ///
        /// <p>List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment.</p>
        pub fn alarms(mut self, input: crate::model::Alarm) -> Self {
            let mut v = self.alarms.unwrap_or_default();
            v.push(input);
            self.alarms = Some(v);
            self
        }
        /// <p>List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment.</p>
        pub fn set_alarms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
        ) -> Self {
            self.alarms = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
        pub fn build(self) -> crate::model::AutoRollbackConfig {
            crate::model::AutoRollbackConfig {
                alarms: self.alarms,
            }
        }
    }
}
impl AutoRollbackConfig {
    /// Creates a new builder-style object to manufacture [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
    pub fn builder() -> crate::model::auto_rollback_config::Builder {
        crate::model::auto_rollback_config::Builder::default()
    }
}

/// <p>An Amazon CloudWatch alarm configured to monitor metrics on an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Alarm {
    /// <p>The name of a CloudWatch alarm in your account.</p>
    pub alarm_name: std::option::Option<std::string::String>,
}
impl Alarm {
    /// <p>The name of a CloudWatch alarm in your account.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
}
impl std::fmt::Debug for Alarm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Alarm");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.finish()
    }
}
/// See [`Alarm`](crate::model::Alarm)
pub mod alarm {

    /// A builder for [`Alarm`](crate::model::Alarm)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a CloudWatch alarm in your account.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of a CloudWatch alarm in your account.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Alarm`](crate::model::Alarm)
        pub fn build(self) -> crate::model::Alarm {
            crate::model::Alarm {
                alarm_name: self.alarm_name,
            }
        }
    }
}
impl Alarm {
    /// Creates a new builder-style object to manufacture [`Alarm`](crate::model::Alarm)
    pub fn builder() -> crate::model::alarm::Builder {
        crate::model::alarm::Builder::default()
    }
}

/// <p>Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlueGreenUpdatePolicy {
    /// <p>Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment.</p>
    pub traffic_routing_configuration: std::option::Option<crate::model::TrafficRoutingConfig>,
    /// <p>Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is 0.</p>
    pub termination_wait_in_seconds: std::option::Option<i32>,
    /// <p>Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in <code>TerminationWaitInSeconds</code> and <code>WaitIntervalInSeconds</code>.</p>
    pub maximum_execution_timeout_in_seconds: std::option::Option<i32>,
}
impl BlueGreenUpdatePolicy {
    /// <p>Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment.</p>
    pub fn traffic_routing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TrafficRoutingConfig> {
        self.traffic_routing_configuration.as_ref()
    }
    /// <p>Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is 0.</p>
    pub fn termination_wait_in_seconds(&self) -> std::option::Option<i32> {
        self.termination_wait_in_seconds
    }
    /// <p>Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in <code>TerminationWaitInSeconds</code> and <code>WaitIntervalInSeconds</code>.</p>
    pub fn maximum_execution_timeout_in_seconds(&self) -> std::option::Option<i32> {
        self.maximum_execution_timeout_in_seconds
    }
}
impl std::fmt::Debug for BlueGreenUpdatePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlueGreenUpdatePolicy");
        formatter.field(
            "traffic_routing_configuration",
            &self.traffic_routing_configuration,
        );
        formatter.field(
            "termination_wait_in_seconds",
            &self.termination_wait_in_seconds,
        );
        formatter.field(
            "maximum_execution_timeout_in_seconds",
            &self.maximum_execution_timeout_in_seconds,
        );
        formatter.finish()
    }
}
/// See [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
pub mod blue_green_update_policy {

    /// A builder for [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_routing_configuration:
            std::option::Option<crate::model::TrafficRoutingConfig>,
        pub(crate) termination_wait_in_seconds: std::option::Option<i32>,
        pub(crate) maximum_execution_timeout_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment.</p>
        pub fn traffic_routing_configuration(
            mut self,
            input: crate::model::TrafficRoutingConfig,
        ) -> Self {
            self.traffic_routing_configuration = Some(input);
            self
        }
        /// <p>Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment.</p>
        pub fn set_traffic_routing_configuration(
            mut self,
            input: std::option::Option<crate::model::TrafficRoutingConfig>,
        ) -> Self {
            self.traffic_routing_configuration = input;
            self
        }
        /// <p>Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is 0.</p>
        pub fn termination_wait_in_seconds(mut self, input: i32) -> Self {
            self.termination_wait_in_seconds = Some(input);
            self
        }
        /// <p>Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is 0.</p>
        pub fn set_termination_wait_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.termination_wait_in_seconds = input;
            self
        }
        /// <p>Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in <code>TerminationWaitInSeconds</code> and <code>WaitIntervalInSeconds</code>.</p>
        pub fn maximum_execution_timeout_in_seconds(mut self, input: i32) -> Self {
            self.maximum_execution_timeout_in_seconds = Some(input);
            self
        }
        /// <p>Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in <code>TerminationWaitInSeconds</code> and <code>WaitIntervalInSeconds</code>.</p>
        pub fn set_maximum_execution_timeout_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.maximum_execution_timeout_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
        pub fn build(self) -> crate::model::BlueGreenUpdatePolicy {
            crate::model::BlueGreenUpdatePolicy {
                traffic_routing_configuration: self.traffic_routing_configuration,
                termination_wait_in_seconds: self.termination_wait_in_seconds,
                maximum_execution_timeout_in_seconds: self.maximum_execution_timeout_in_seconds,
            }
        }
    }
}
impl BlueGreenUpdatePolicy {
    /// Creates a new builder-style object to manufacture [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
    pub fn builder() -> crate::model::blue_green_update_policy::Builder {
        crate::model::blue_green_update_policy::Builder::default()
    }
}

/// <p>Defines the traffic routing strategy during an endpoint deployment to shift traffic from the old fleet to the new fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficRoutingConfig {
    /// <p>Traffic routing strategy type.</p>
    /// <ul>
    /// <li> <p> <code>ALL_AT_ONCE</code>: Endpoint traffic shifts to the new fleet in a single step. </p> </li>
    /// <li> <p> <code>CANARY</code>: Endpoint traffic shifts to the new fleet in two steps. The first step is the canary, which is a small portion of the traffic. The second step is the remainder of the traffic. </p> </li>
    /// <li> <p> <code>LINEAR</code>: Endpoint traffic shifts to the new fleet in n steps of a configurable size. </p> </li>
    /// </ul>
    pub r#type: std::option::Option<crate::model::TrafficRoutingConfigType>,
    /// <p>The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet.</p>
    pub wait_interval_in_seconds: std::option::Option<i32>,
    /// <p>Batch size for the first step to turn on traffic on the new endpoint fleet. <code>Value</code> must be less than or equal to 50% of the variant's total instance count.</p>
    pub canary_size: std::option::Option<crate::model::CapacitySize>,
    /// <p>Batch size for each step to turn on traffic on the new endpoint fleet. <code>Value</code> must be 10-50% of the variant's total instance count.</p>
    pub linear_step_size: std::option::Option<crate::model::CapacitySize>,
}
impl TrafficRoutingConfig {
    /// <p>Traffic routing strategy type.</p>
    /// <ul>
    /// <li> <p> <code>ALL_AT_ONCE</code>: Endpoint traffic shifts to the new fleet in a single step. </p> </li>
    /// <li> <p> <code>CANARY</code>: Endpoint traffic shifts to the new fleet in two steps. The first step is the canary, which is a small portion of the traffic. The second step is the remainder of the traffic. </p> </li>
    /// <li> <p> <code>LINEAR</code>: Endpoint traffic shifts to the new fleet in n steps of a configurable size. </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TrafficRoutingConfigType> {
        self.r#type.as_ref()
    }
    /// <p>The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet.</p>
    pub fn wait_interval_in_seconds(&self) -> std::option::Option<i32> {
        self.wait_interval_in_seconds
    }
    /// <p>Batch size for the first step to turn on traffic on the new endpoint fleet. <code>Value</code> must be less than or equal to 50% of the variant's total instance count.</p>
    pub fn canary_size(&self) -> std::option::Option<&crate::model::CapacitySize> {
        self.canary_size.as_ref()
    }
    /// <p>Batch size for each step to turn on traffic on the new endpoint fleet. <code>Value</code> must be 10-50% of the variant's total instance count.</p>
    pub fn linear_step_size(&self) -> std::option::Option<&crate::model::CapacitySize> {
        self.linear_step_size.as_ref()
    }
}
impl std::fmt::Debug for TrafficRoutingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficRoutingConfig");
        formatter.field("r#type", &self.r#type);
        formatter.field("wait_interval_in_seconds", &self.wait_interval_in_seconds);
        formatter.field("canary_size", &self.canary_size);
        formatter.field("linear_step_size", &self.linear_step_size);
        formatter.finish()
    }
}
/// See [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
pub mod traffic_routing_config {

    /// A builder for [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::TrafficRoutingConfigType>,
        pub(crate) wait_interval_in_seconds: std::option::Option<i32>,
        pub(crate) canary_size: std::option::Option<crate::model::CapacitySize>,
        pub(crate) linear_step_size: std::option::Option<crate::model::CapacitySize>,
    }
    impl Builder {
        /// <p>Traffic routing strategy type.</p>
        /// <ul>
        /// <li> <p> <code>ALL_AT_ONCE</code>: Endpoint traffic shifts to the new fleet in a single step. </p> </li>
        /// <li> <p> <code>CANARY</code>: Endpoint traffic shifts to the new fleet in two steps. The first step is the canary, which is a small portion of the traffic. The second step is the remainder of the traffic. </p> </li>
        /// <li> <p> <code>LINEAR</code>: Endpoint traffic shifts to the new fleet in n steps of a configurable size. </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::TrafficRoutingConfigType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Traffic routing strategy type.</p>
        /// <ul>
        /// <li> <p> <code>ALL_AT_ONCE</code>: Endpoint traffic shifts to the new fleet in a single step. </p> </li>
        /// <li> <p> <code>CANARY</code>: Endpoint traffic shifts to the new fleet in two steps. The first step is the canary, which is a small portion of the traffic. The second step is the remainder of the traffic. </p> </li>
        /// <li> <p> <code>LINEAR</code>: Endpoint traffic shifts to the new fleet in n steps of a configurable size. </p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TrafficRoutingConfigType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet.</p>
        pub fn wait_interval_in_seconds(mut self, input: i32) -> Self {
            self.wait_interval_in_seconds = Some(input);
            self
        }
        /// <p>The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet.</p>
        pub fn set_wait_interval_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.wait_interval_in_seconds = input;
            self
        }
        /// <p>Batch size for the first step to turn on traffic on the new endpoint fleet. <code>Value</code> must be less than or equal to 50% of the variant's total instance count.</p>
        pub fn canary_size(mut self, input: crate::model::CapacitySize) -> Self {
            self.canary_size = Some(input);
            self
        }
        /// <p>Batch size for the first step to turn on traffic on the new endpoint fleet. <code>Value</code> must be less than or equal to 50% of the variant's total instance count.</p>
        pub fn set_canary_size(
            mut self,
            input: std::option::Option<crate::model::CapacitySize>,
        ) -> Self {
            self.canary_size = input;
            self
        }
        /// <p>Batch size for each step to turn on traffic on the new endpoint fleet. <code>Value</code> must be 10-50% of the variant's total instance count.</p>
        pub fn linear_step_size(mut self, input: crate::model::CapacitySize) -> Self {
            self.linear_step_size = Some(input);
            self
        }
        /// <p>Batch size for each step to turn on traffic on the new endpoint fleet. <code>Value</code> must be 10-50% of the variant's total instance count.</p>
        pub fn set_linear_step_size(
            mut self,
            input: std::option::Option<crate::model::CapacitySize>,
        ) -> Self {
            self.linear_step_size = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
        pub fn build(self) -> crate::model::TrafficRoutingConfig {
            crate::model::TrafficRoutingConfig {
                r#type: self.r#type,
                wait_interval_in_seconds: self.wait_interval_in_seconds,
                canary_size: self.canary_size,
                linear_step_size: self.linear_step_size,
            }
        }
    }
}
impl TrafficRoutingConfig {
    /// Creates a new builder-style object to manufacture [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
    pub fn builder() -> crate::model::traffic_routing_config::Builder {
        crate::model::traffic_routing_config::Builder::default()
    }
}

/// <p>Specifies the endpoint capacity to activate for production.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacitySize {
    /// <p>Specifies the endpoint capacity type.</p>
    /// <ul>
    /// <li> <p> <code>INSTANCE_COUNT</code>: The endpoint activates based on the number of instances.</p> </li>
    /// <li> <p> <code>CAPACITY_PERCENT</code>: The endpoint activates based on the specified percentage of capacity.</p> </li>
    /// </ul>
    pub r#type: std::option::Option<crate::model::CapacitySizeType>,
    /// <p>Defines the capacity size, either as a number of instances or a capacity percentage.</p>
    pub value: std::option::Option<i32>,
}
impl CapacitySize {
    /// <p>Specifies the endpoint capacity type.</p>
    /// <ul>
    /// <li> <p> <code>INSTANCE_COUNT</code>: The endpoint activates based on the number of instances.</p> </li>
    /// <li> <p> <code>CAPACITY_PERCENT</code>: The endpoint activates based on the specified percentage of capacity.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::CapacitySizeType> {
        self.r#type.as_ref()
    }
    /// <p>Defines the capacity size, either as a number of instances or a capacity percentage.</p>
    pub fn value(&self) -> std::option::Option<i32> {
        self.value
    }
}
impl std::fmt::Debug for CapacitySize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacitySize");
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CapacitySize`](crate::model::CapacitySize)
pub mod capacity_size {

    /// A builder for [`CapacitySize`](crate::model::CapacitySize)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::CapacitySizeType>,
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies the endpoint capacity type.</p>
        /// <ul>
        /// <li> <p> <code>INSTANCE_COUNT</code>: The endpoint activates based on the number of instances.</p> </li>
        /// <li> <p> <code>CAPACITY_PERCENT</code>: The endpoint activates based on the specified percentage of capacity.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::CapacitySizeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Specifies the endpoint capacity type.</p>
        /// <ul>
        /// <li> <p> <code>INSTANCE_COUNT</code>: The endpoint activates based on the number of instances.</p> </li>
        /// <li> <p> <code>CAPACITY_PERCENT</code>: The endpoint activates based on the specified percentage of capacity.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CapacitySizeType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Defines the capacity size, either as a number of instances or a capacity percentage.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Defines the capacity size, either as a number of instances or a capacity percentage.</p>
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacitySize`](crate::model::CapacitySize)
        pub fn build(self) -> crate::model::CapacitySize {
            crate::model::CapacitySize {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl CapacitySize {
    /// Creates a new builder-style object to manufacture [`CapacitySize`](crate::model::CapacitySize)
    pub fn builder() -> crate::model::capacity_size::Builder {
        crate::model::capacity_size::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacitySizeType {
    #[allow(missing_docs)] // documentation missing in model
    CapacityPercent,
    #[allow(missing_docs)] // documentation missing in model
    InstanceCount,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacitySizeType {
    fn from(s: &str) -> Self {
        match s {
            "CAPACITY_PERCENT" => CapacitySizeType::CapacityPercent,
            "INSTANCE_COUNT" => CapacitySizeType::InstanceCount,
            other => CapacitySizeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacitySizeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacitySizeType::from(s))
    }
}
impl CapacitySizeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CapacitySizeType::CapacityPercent => "CAPACITY_PERCENT",
            CapacitySizeType::InstanceCount => "INSTANCE_COUNT",
            CapacitySizeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CAPACITY_PERCENT", "INSTANCE_COUNT"]
    }
}
impl AsRef<str> for CapacitySizeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficRoutingConfigType {
    #[allow(missing_docs)] // documentation missing in model
    AllAtOnce,
    #[allow(missing_docs)] // documentation missing in model
    Canary,
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficRoutingConfigType {
    fn from(s: &str) -> Self {
        match s {
            "ALL_AT_ONCE" => TrafficRoutingConfigType::AllAtOnce,
            "CANARY" => TrafficRoutingConfigType::Canary,
            "LINEAR" => TrafficRoutingConfigType::Linear,
            other => TrafficRoutingConfigType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficRoutingConfigType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficRoutingConfigType::from(s))
    }
}
impl TrafficRoutingConfigType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrafficRoutingConfigType::AllAtOnce => "ALL_AT_ONCE",
            TrafficRoutingConfigType::Canary => "CANARY",
            TrafficRoutingConfigType::Linear => "LINEAR",
            TrafficRoutingConfigType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL_AT_ONCE", "CANARY", "LINEAR"]
    }
}
impl AsRef<str> for TrafficRoutingConfigType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a production variant property type for an Endpoint.</p>
/// <p>If you are updating an endpoint with the <code>UpdateEndpointInput$RetainAllVariantProperties</code> option set to <code>true</code>, the <code>VariantProperty</code> objects listed in <code>UpdateEndpointInput$ExcludeRetainedVariantProperties</code> override the existing variant properties of the endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VariantProperty {
    /// <p>The type of variant property. The supported values are:</p>
    /// <ul>
    /// <li> <p> <code>DesiredInstanceCount</code>: Overrides the existing variant instance counts using the <code>ProductionVariant$InitialInstanceCount</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
    /// <li> <p> <code>DesiredWeight</code>: Overrides the existing variant weights using the <code>ProductionVariant$InitialVariantWeight</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
    /// <li> <p> <code>DataCaptureConfig</code>: (Not currently supported.)</p> </li>
    /// </ul>
    pub variant_property_type: std::option::Option<crate::model::VariantPropertyType>,
}
impl VariantProperty {
    /// <p>The type of variant property. The supported values are:</p>
    /// <ul>
    /// <li> <p> <code>DesiredInstanceCount</code>: Overrides the existing variant instance counts using the <code>ProductionVariant$InitialInstanceCount</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
    /// <li> <p> <code>DesiredWeight</code>: Overrides the existing variant weights using the <code>ProductionVariant$InitialVariantWeight</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
    /// <li> <p> <code>DataCaptureConfig</code>: (Not currently supported.)</p> </li>
    /// </ul>
    pub fn variant_property_type(&self) -> std::option::Option<&crate::model::VariantPropertyType> {
        self.variant_property_type.as_ref()
    }
}
impl std::fmt::Debug for VariantProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VariantProperty");
        formatter.field("variant_property_type", &self.variant_property_type);
        formatter.finish()
    }
}
/// See [`VariantProperty`](crate::model::VariantProperty)
pub mod variant_property {

    /// A builder for [`VariantProperty`](crate::model::VariantProperty)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_property_type: std::option::Option<crate::model::VariantPropertyType>,
    }
    impl Builder {
        /// <p>The type of variant property. The supported values are:</p>
        /// <ul>
        /// <li> <p> <code>DesiredInstanceCount</code>: Overrides the existing variant instance counts using the <code>ProductionVariant$InitialInstanceCount</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
        /// <li> <p> <code>DesiredWeight</code>: Overrides the existing variant weights using the <code>ProductionVariant$InitialVariantWeight</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
        /// <li> <p> <code>DataCaptureConfig</code>: (Not currently supported.)</p> </li>
        /// </ul>
        pub fn variant_property_type(mut self, input: crate::model::VariantPropertyType) -> Self {
            self.variant_property_type = Some(input);
            self
        }
        /// <p>The type of variant property. The supported values are:</p>
        /// <ul>
        /// <li> <p> <code>DesiredInstanceCount</code>: Overrides the existing variant instance counts using the <code>ProductionVariant$InitialInstanceCount</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
        /// <li> <p> <code>DesiredWeight</code>: Overrides the existing variant weights using the <code>ProductionVariant$InitialVariantWeight</code> values in the <code>CreateEndpointConfigInput$ProductionVariants</code>.</p> </li>
        /// <li> <p> <code>DataCaptureConfig</code>: (Not currently supported.)</p> </li>
        /// </ul>
        pub fn set_variant_property_type(
            mut self,
            input: std::option::Option<crate::model::VariantPropertyType>,
        ) -> Self {
            self.variant_property_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantProperty`](crate::model::VariantProperty)
        pub fn build(self) -> crate::model::VariantProperty {
            crate::model::VariantProperty {
                variant_property_type: self.variant_property_type,
            }
        }
    }
}
impl VariantProperty {
    /// Creates a new builder-style object to manufacture [`VariantProperty`](crate::model::VariantProperty)
    pub fn builder() -> crate::model::variant_property::Builder {
        crate::model::variant_property::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VariantPropertyType {
    #[allow(missing_docs)] // documentation missing in model
    DataCaptureConfig,
    #[allow(missing_docs)] // documentation missing in model
    DesiredInstanceCount,
    #[allow(missing_docs)] // documentation missing in model
    DesiredWeight,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VariantPropertyType {
    fn from(s: &str) -> Self {
        match s {
            "DataCaptureConfig" => VariantPropertyType::DataCaptureConfig,
            "DesiredInstanceCount" => VariantPropertyType::DesiredInstanceCount,
            "DesiredWeight" => VariantPropertyType::DesiredWeight,
            other => VariantPropertyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VariantPropertyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VariantPropertyType::from(s))
    }
}
impl VariantPropertyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VariantPropertyType::DataCaptureConfig => "DataCaptureConfig",
            VariantPropertyType::DesiredInstanceCount => "DesiredInstanceCount",
            VariantPropertyType::DesiredWeight => "DesiredWeight",
            VariantPropertyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DataCaptureConfig", "DesiredInstanceCount", "DesiredWeight"]
    }
}
impl AsRef<str> for VariantPropertyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of <code>Domain</code> configuration settings to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainSettingsForUpdate {
    /// <p>A collection of <code>RStudioServerPro</code> Domain-level app settings to update.</p>
    pub r_studio_server_pro_domain_settings_for_update:
        std::option::Option<crate::model::RStudioServerProDomainSettingsForUpdate>,
}
impl DomainSettingsForUpdate {
    /// <p>A collection of <code>RStudioServerPro</code> Domain-level app settings to update.</p>
    pub fn r_studio_server_pro_domain_settings_for_update(
        &self,
    ) -> std::option::Option<&crate::model::RStudioServerProDomainSettingsForUpdate> {
        self.r_studio_server_pro_domain_settings_for_update.as_ref()
    }
}
impl std::fmt::Debug for DomainSettingsForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainSettingsForUpdate");
        formatter.field(
            "r_studio_server_pro_domain_settings_for_update",
            &self.r_studio_server_pro_domain_settings_for_update,
        );
        formatter.finish()
    }
}
/// See [`DomainSettingsForUpdate`](crate::model::DomainSettingsForUpdate)
pub mod domain_settings_for_update {

    /// A builder for [`DomainSettingsForUpdate`](crate::model::DomainSettingsForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r_studio_server_pro_domain_settings_for_update:
            std::option::Option<crate::model::RStudioServerProDomainSettingsForUpdate>,
    }
    impl Builder {
        /// <p>A collection of <code>RStudioServerPro</code> Domain-level app settings to update.</p>
        pub fn r_studio_server_pro_domain_settings_for_update(
            mut self,
            input: crate::model::RStudioServerProDomainSettingsForUpdate,
        ) -> Self {
            self.r_studio_server_pro_domain_settings_for_update = Some(input);
            self
        }
        /// <p>A collection of <code>RStudioServerPro</code> Domain-level app settings to update.</p>
        pub fn set_r_studio_server_pro_domain_settings_for_update(
            mut self,
            input: std::option::Option<crate::model::RStudioServerProDomainSettingsForUpdate>,
        ) -> Self {
            self.r_studio_server_pro_domain_settings_for_update = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainSettingsForUpdate`](crate::model::DomainSettingsForUpdate)
        pub fn build(self) -> crate::model::DomainSettingsForUpdate {
            crate::model::DomainSettingsForUpdate {
                r_studio_server_pro_domain_settings_for_update: self
                    .r_studio_server_pro_domain_settings_for_update,
            }
        }
    }
}
impl DomainSettingsForUpdate {
    /// Creates a new builder-style object to manufacture [`DomainSettingsForUpdate`](crate::model::DomainSettingsForUpdate)
    pub fn builder() -> crate::model::domain_settings_for_update::Builder {
        crate::model::domain_settings_for_update::Builder::default()
    }
}

/// <p>A collection of settings that update the current configuration for the <code>RStudioServerPro</code> Domain-level app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RStudioServerProDomainSettingsForUpdate {
    /// <p>The execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
    pub domain_execution_role_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl RStudioServerProDomainSettingsForUpdate {
    /// <p>The execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
    pub fn domain_execution_role_arn(&self) -> std::option::Option<&str> {
        self.domain_execution_role_arn.as_deref()
    }
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
}
impl std::fmt::Debug for RStudioServerProDomainSettingsForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RStudioServerProDomainSettingsForUpdate");
        formatter.field("domain_execution_role_arn", &self.domain_execution_role_arn);
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.finish()
    }
}
/// See [`RStudioServerProDomainSettingsForUpdate`](crate::model::RStudioServerProDomainSettingsForUpdate)
pub mod r_studio_server_pro_domain_settings_for_update {

    /// A builder for [`RStudioServerProDomainSettingsForUpdate`](crate::model::RStudioServerProDomainSettingsForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    }
    impl Builder {
        /// <p>The execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn domain_execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_execution_role_arn = Some(input.into());
            self
        }
        /// <p>The execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn set_domain_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_execution_role_arn = input;
            self
        }
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Consumes the builder and constructs a [`RStudioServerProDomainSettingsForUpdate`](crate::model::RStudioServerProDomainSettingsForUpdate)
        pub fn build(self) -> crate::model::RStudioServerProDomainSettingsForUpdate {
            crate::model::RStudioServerProDomainSettingsForUpdate {
                domain_execution_role_arn: self.domain_execution_role_arn,
                default_resource_spec: self.default_resource_spec,
            }
        }
    }
}
impl RStudioServerProDomainSettingsForUpdate {
    /// Creates a new builder-style object to manufacture [`RStudioServerProDomainSettingsForUpdate`](crate::model::RStudioServerProDomainSettingsForUpdate)
    pub fn builder() -> crate::model::r_studio_server_pro_domain_settings_for_update::Builder {
        crate::model::r_studio_server_pro_domain_settings_for_update::Builder::default()
    }
}

/// <p>Information of a particular device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Device {
    /// <p>The name of the device.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Description of the device.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
    pub iot_thing_name: std::option::Option<std::string::String>,
}
impl Device {
    /// <p>The name of the device.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>Description of the device.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
    pub fn iot_thing_name(&self) -> std::option::Option<&str> {
        self.iot_thing_name.as_deref()
    }
}
impl std::fmt::Debug for Device {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Device");
        formatter.field("device_name", &self.device_name);
        formatter.field("description", &self.description);
        formatter.field("iot_thing_name", &self.iot_thing_name);
        formatter.finish()
    }
}
/// See [`Device`](crate::model::Device)
pub mod device {

    /// A builder for [`Device`](crate::model::Device)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) iot_thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The name of the device.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Description of the device.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description of the device.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
        pub fn iot_thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.iot_thing_name = Some(input.into());
            self
        }
        /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
        pub fn set_iot_thing_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iot_thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Device`](crate::model::Device)
        pub fn build(self) -> crate::model::Device {
            crate::model::Device {
                device_name: self.device_name,
                description: self.description,
                iot_thing_name: self.iot_thing_name,
            }
        }
    }
}
impl Device {
    /// Creates a new builder-style object to manufacture [`Device`](crate::model::Device)
    pub fn builder() -> crate::model::device::Builder {
        crate::model::device::Builder::default()
    }
}

/// <p>The output configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeOutputConfig {
    /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
    pub s3_output_location: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The deployment type SageMaker Edge Manager will create. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub preset_deployment_type: std::option::Option<crate::model::EdgePresetDeploymentType>,
    /// <p>The configuration used to create deployment artifacts. Specify configuration options with a JSON string. The available configuration options for each type are:</p>
    /// <ul>
    /// <li> <p> <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified, the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager packaging job.</p> </li>
    /// <li> <p> <code>ComponentDescription</code> (optional) - Description of the component.</p> </li>
    /// <li> <p> <code>ComponentVersion</code> (optional) - The version of the component.</p> <note>
    /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i> major.minor.patch</i> number system. For example, version 1.0.0 represents the first major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
    /// </note> </li>
    /// <li> <p> <code>PlatformOS</code> (optional) - The name of the operating system for the platform. Supported platforms include Windows and Linux.</p> </li>
    /// <li> <p> <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p> <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p> <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p> </li>
    /// </ul>
    pub preset_deployment_config: std::option::Option<std::string::String>,
}
impl EdgeOutputConfig {
    /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
    pub fn s3_output_location(&self) -> std::option::Option<&str> {
        self.s3_output_location.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The deployment type SageMaker Edge Manager will create. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub fn preset_deployment_type(
        &self,
    ) -> std::option::Option<&crate::model::EdgePresetDeploymentType> {
        self.preset_deployment_type.as_ref()
    }
    /// <p>The configuration used to create deployment artifacts. Specify configuration options with a JSON string. The available configuration options for each type are:</p>
    /// <ul>
    /// <li> <p> <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified, the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager packaging job.</p> </li>
    /// <li> <p> <code>ComponentDescription</code> (optional) - Description of the component.</p> </li>
    /// <li> <p> <code>ComponentVersion</code> (optional) - The version of the component.</p> <note>
    /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i> major.minor.patch</i> number system. For example, version 1.0.0 represents the first major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
    /// </note> </li>
    /// <li> <p> <code>PlatformOS</code> (optional) - The name of the operating system for the platform. Supported platforms include Windows and Linux.</p> </li>
    /// <li> <p> <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p> <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p> <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p> </li>
    /// </ul>
    pub fn preset_deployment_config(&self) -> std::option::Option<&str> {
        self.preset_deployment_config.as_deref()
    }
}
impl std::fmt::Debug for EdgeOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeOutputConfig");
        formatter.field("s3_output_location", &self.s3_output_location);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("preset_deployment_type", &self.preset_deployment_type);
        formatter.field("preset_deployment_config", &self.preset_deployment_config);
        formatter.finish()
    }
}
/// See [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
pub mod edge_output_config {

    /// A builder for [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_location: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) preset_deployment_type:
            std::option::Option<crate::model::EdgePresetDeploymentType>,
        pub(crate) preset_deployment_config: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
        pub fn s3_output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_location = Some(input.into());
            self
        }
        /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
        pub fn set_s3_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_location = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The deployment type SageMaker Edge Manager will create. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn preset_deployment_type(
            mut self,
            input: crate::model::EdgePresetDeploymentType,
        ) -> Self {
            self.preset_deployment_type = Some(input);
            self
        }
        /// <p>The deployment type SageMaker Edge Manager will create. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn set_preset_deployment_type(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentType>,
        ) -> Self {
            self.preset_deployment_type = input;
            self
        }
        /// <p>The configuration used to create deployment artifacts. Specify configuration options with a JSON string. The available configuration options for each type are:</p>
        /// <ul>
        /// <li> <p> <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified, the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager packaging job.</p> </li>
        /// <li> <p> <code>ComponentDescription</code> (optional) - Description of the component.</p> </li>
        /// <li> <p> <code>ComponentVersion</code> (optional) - The version of the component.</p> <note>
        /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i> major.minor.patch</i> number system. For example, version 1.0.0 represents the first major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
        /// </note> </li>
        /// <li> <p> <code>PlatformOS</code> (optional) - The name of the operating system for the platform. Supported platforms include Windows and Linux.</p> </li>
        /// <li> <p> <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p> <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p> <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p> </li>
        /// </ul>
        pub fn preset_deployment_config(mut self, input: impl Into<std::string::String>) -> Self {
            self.preset_deployment_config = Some(input.into());
            self
        }
        /// <p>The configuration used to create deployment artifacts. Specify configuration options with a JSON string. The available configuration options for each type are:</p>
        /// <ul>
        /// <li> <p> <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified, the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager packaging job.</p> </li>
        /// <li> <p> <code>ComponentDescription</code> (optional) - Description of the component.</p> </li>
        /// <li> <p> <code>ComponentVersion</code> (optional) - The version of the component.</p> <note>
        /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i> major.minor.patch</i> number system. For example, version 1.0.0 represents the first major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
        /// </note> </li>
        /// <li> <p> <code>PlatformOS</code> (optional) - The name of the operating system for the platform. Supported platforms include Windows and Linux.</p> </li>
        /// <li> <p> <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p> <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p> <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p> </li>
        /// </ul>
        pub fn set_preset_deployment_config(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preset_deployment_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
        pub fn build(self) -> crate::model::EdgeOutputConfig {
            crate::model::EdgeOutputConfig {
                s3_output_location: self.s3_output_location,
                kms_key_id: self.kms_key_id,
                preset_deployment_type: self.preset_deployment_type,
                preset_deployment_config: self.preset_deployment_config,
            }
        }
    }
}
impl EdgeOutputConfig {
    /// Creates a new builder-style object to manufacture [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
    pub fn builder() -> crate::model::edge_output_config::Builder {
        crate::model::edge_output_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePresetDeploymentType {
    #[allow(missing_docs)] // documentation missing in model
    GreengrassV2Component,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePresetDeploymentType {
    fn from(s: &str) -> Self {
        match s {
            "GreengrassV2Component" => EdgePresetDeploymentType::GreengrassV2Component,
            other => EdgePresetDeploymentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePresetDeploymentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePresetDeploymentType::from(s))
    }
}
impl EdgePresetDeploymentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EdgePresetDeploymentType::GreengrassV2Component => "GreengrassV2Component",
            EdgePresetDeploymentType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["GreengrassV2Component"]
    }
}
impl AsRef<str> for EdgePresetDeploymentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies configuration details for a Git repository when the repository is updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GitConfigForUpdate {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
    pub secret_arn: std::option::Option<std::string::String>,
}
impl GitConfigForUpdate {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
impl std::fmt::Debug for GitConfigForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GitConfigForUpdate");
        formatter.field("secret_arn", &self.secret_arn);
        formatter.finish()
    }
}
/// See [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
pub mod git_config_for_update {

    /// A builder for [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
        pub fn build(self) -> crate::model::GitConfigForUpdate {
            crate::model::GitConfigForUpdate {
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl GitConfigForUpdate {
    /// Creates a new builder-style object to manufacture [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
    pub fn builder() -> crate::model::git_config_for_update::Builder {
        crate::model::git_config_for_update::Builder::default()
    }
}

/// <p>The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelGatewayImageConfig {
    /// <p>The specification of the Jupyter kernels in the image.</p>
    pub kernel_specs: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
    /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
    pub file_system_config: std::option::Option<crate::model::FileSystemConfig>,
}
impl KernelGatewayImageConfig {
    /// <p>The specification of the Jupyter kernels in the image.</p>
    pub fn kernel_specs(&self) -> std::option::Option<&[crate::model::KernelSpec]> {
        self.kernel_specs.as_deref()
    }
    /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
    pub fn file_system_config(&self) -> std::option::Option<&crate::model::FileSystemConfig> {
        self.file_system_config.as_ref()
    }
}
impl std::fmt::Debug for KernelGatewayImageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelGatewayImageConfig");
        formatter.field("kernel_specs", &self.kernel_specs);
        formatter.field("file_system_config", &self.file_system_config);
        formatter.finish()
    }
}
/// See [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
pub mod kernel_gateway_image_config {

    /// A builder for [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kernel_specs: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
        pub(crate) file_system_config: std::option::Option<crate::model::FileSystemConfig>,
    }
    impl Builder {
        /// Appends an item to `kernel_specs`.
        ///
        /// To override the contents of this collection use [`set_kernel_specs`](Self::set_kernel_specs).
        ///
        /// <p>The specification of the Jupyter kernels in the image.</p>
        pub fn kernel_specs(mut self, input: crate::model::KernelSpec) -> Self {
            let mut v = self.kernel_specs.unwrap_or_default();
            v.push(input);
            self.kernel_specs = Some(v);
            self
        }
        /// <p>The specification of the Jupyter kernels in the image.</p>
        pub fn set_kernel_specs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
        ) -> Self {
            self.kernel_specs = input;
            self
        }
        /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
        pub fn file_system_config(mut self, input: crate::model::FileSystemConfig) -> Self {
            self.file_system_config = Some(input);
            self
        }
        /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
        pub fn set_file_system_config(
            mut self,
            input: std::option::Option<crate::model::FileSystemConfig>,
        ) -> Self {
            self.file_system_config = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
        pub fn build(self) -> crate::model::KernelGatewayImageConfig {
            crate::model::KernelGatewayImageConfig {
                kernel_specs: self.kernel_specs,
                file_system_config: self.file_system_config,
            }
        }
    }
}
impl KernelGatewayImageConfig {
    /// Creates a new builder-style object to manufacture [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
    pub fn builder() -> crate::model::kernel_gateway_image_config::Builder {
        crate::model::kernel_gateway_image_config::Builder::default()
    }
}

/// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemConfig {
    /// <p>The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
    pub mount_path: std::option::Option<std::string::String>,
    /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
    pub default_uid: std::option::Option<i32>,
    /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
    pub default_gid: std::option::Option<i32>,
}
impl FileSystemConfig {
    /// <p>The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
    pub fn mount_path(&self) -> std::option::Option<&str> {
        self.mount_path.as_deref()
    }
    /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
    pub fn default_uid(&self) -> std::option::Option<i32> {
        self.default_uid
    }
    /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
    pub fn default_gid(&self) -> std::option::Option<i32> {
        self.default_gid
    }
}
impl std::fmt::Debug for FileSystemConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemConfig");
        formatter.field("mount_path", &self.mount_path);
        formatter.field("default_uid", &self.default_uid);
        formatter.field("default_gid", &self.default_gid);
        formatter.finish()
    }
}
/// See [`FileSystemConfig`](crate::model::FileSystemConfig)
pub mod file_system_config {

    /// A builder for [`FileSystemConfig`](crate::model::FileSystemConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mount_path: std::option::Option<std::string::String>,
        pub(crate) default_uid: std::option::Option<i32>,
        pub(crate) default_gid: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
        pub fn mount_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_path = Some(input.into());
            self
        }
        /// <p>The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
        pub fn set_mount_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_path = input;
            self
        }
        /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
        pub fn default_uid(mut self, input: i32) -> Self {
            self.default_uid = Some(input);
            self
        }
        /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
        pub fn set_default_uid(mut self, input: std::option::Option<i32>) -> Self {
            self.default_uid = input;
            self
        }
        /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
        pub fn default_gid(mut self, input: i32) -> Self {
            self.default_gid = Some(input);
            self
        }
        /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
        pub fn set_default_gid(mut self, input: std::option::Option<i32>) -> Self {
            self.default_gid = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemConfig`](crate::model::FileSystemConfig)
        pub fn build(self) -> crate::model::FileSystemConfig {
            crate::model::FileSystemConfig {
                mount_path: self.mount_path,
                default_uid: self.default_uid,
                default_gid: self.default_gid,
            }
        }
    }
}
impl FileSystemConfig {
    /// Creates a new builder-style object to manufacture [`FileSystemConfig`](crate::model::FileSystemConfig)
    pub fn builder() -> crate::model::file_system_config::Builder {
        crate::model::file_system_config::Builder::default()
    }
}

/// <p>The specification of a Jupyter kernel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelSpec {
    /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The display name of the kernel.</p>
    pub display_name: std::option::Option<std::string::String>,
}
impl KernelSpec {
    /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The display name of the kernel.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
impl std::fmt::Debug for KernelSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelSpec");
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}
/// See [`KernelSpec`](crate::model::KernelSpec)
pub mod kernel_spec {

    /// A builder for [`KernelSpec`](crate::model::KernelSpec)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The display name of the kernel.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The display name of the kernel.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelSpec`](crate::model::KernelSpec)
        pub fn build(self) -> crate::model::KernelSpec {
            crate::model::KernelSpec {
                name: self.name,
                display_name: self.display_name,
            }
        }
    }
}
impl KernelSpec {
    /// Creates a new builder-style object to manufacture [`KernelSpec`](crate::model::KernelSpec)
    pub fn builder() -> crate::model::kernel_spec::Builder {
        crate::model::kernel_spec::Builder::default()
    }
}

/// _Note: `ActionStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ActionStatus::Completed,
            "Failed" => ActionStatus::Failed,
            "InProgress" => ActionStatus::InProgress,
            "Stopped" => ActionStatus::Stopped,
            "Stopping" => ActionStatus::Stopping,
            "Unknown" => ActionStatus::UnknownValue,
            other => ActionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionStatus::from(s))
    }
}
impl ActionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionStatus::Completed => "Completed",
            ActionStatus::Failed => "Failed",
            ActionStatus::InProgress => "InProgress",
            ActionStatus::Stopped => "Stopped",
            ActionStatus::Stopping => "Stopping",
            ActionStatus::UnknownValue => "Unknown",
            ActionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Failed",
            "InProgress",
            "Stopped",
            "Stopping",
            "Unknown",
        ]
    }
}
impl AsRef<str> for ActionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Assigns a value to a named Pipeline parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parameter {
    /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The literal value for the parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Parameter {
    /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The literal value for the parameter.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Parameter`](crate::model::Parameter)
pub mod parameter {

    /// A builder for [`Parameter`](crate::model::Parameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The literal value for the parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The literal value for the parameter.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter)
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter)
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

/// <p>An output parameter of a pipeline step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputParameter {
    /// <p>The name of the output parameter.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the output parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl OutputParameter {
    /// <p>The name of the output parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the output parameter.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for OutputParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputParameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`OutputParameter`](crate::model::OutputParameter)
pub mod output_parameter {

    /// A builder for [`OutputParameter`](crate::model::OutputParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the output parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the output parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the output parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the output parameter.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputParameter`](crate::model::OutputParameter)
        pub fn build(self) -> crate::model::OutputParameter {
            crate::model::OutputParameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl OutputParameter {
    /// Creates a new builder-style object to manufacture [`OutputParameter`](crate::model::OutputParameter)
    pub fn builder() -> crate::model::output_parameter::Builder {
        crate::model::output_parameter::Builder::default()
    }
}

/// <p>A single resource returned as part of the <code>Search</code> API response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchRecord {
    /// <p>The properties of a training job.</p>
    pub training_job: std::option::Option<crate::model::TrainingJob>,
    /// <p>The properties of an experiment.</p>
    pub experiment: std::option::Option<crate::model::Experiment>,
    /// <p>The properties of a trial.</p>
    pub trial: std::option::Option<crate::model::Trial>,
    /// <p>The properties of a trial component.</p>
    pub trial_component: std::option::Option<crate::model::TrialComponent>,
    /// <p>A hosted endpoint for real-time inference.</p>
    pub endpoint: std::option::Option<crate::model::Endpoint>,
    /// <p>A versioned model that can be deployed for SageMaker inference.</p>
    pub model_package: std::option::Option<crate::model::ModelPackage>,
    /// <p>A group of versioned models in the model registry.</p>
    pub model_package_group: std::option::Option<crate::model::ModelPackageGroup>,
    /// <p>A SageMaker Model Building Pipeline instance.</p>
    pub pipeline: std::option::Option<crate::model::Pipeline>,
    /// <p>An execution of a pipeline.</p>
    pub pipeline_execution: std::option::Option<crate::model::PipelineExecution>,
    /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group. A Feature Group can be visualized as a table which has rows, with a unique identifier for each row where each column in the table is a feature. In principle, a Feature Group is composed of features and values per features.</p>
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,
    /// <p>The properties of a project.</p>
    pub project: std::option::Option<crate::model::Project>,
}
impl SearchRecord {
    /// <p>The properties of a training job.</p>
    pub fn training_job(&self) -> std::option::Option<&crate::model::TrainingJob> {
        self.training_job.as_ref()
    }
    /// <p>The properties of an experiment.</p>
    pub fn experiment(&self) -> std::option::Option<&crate::model::Experiment> {
        self.experiment.as_ref()
    }
    /// <p>The properties of a trial.</p>
    pub fn trial(&self) -> std::option::Option<&crate::model::Trial> {
        self.trial.as_ref()
    }
    /// <p>The properties of a trial component.</p>
    pub fn trial_component(&self) -> std::option::Option<&crate::model::TrialComponent> {
        self.trial_component.as_ref()
    }
    /// <p>A hosted endpoint for real-time inference.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::Endpoint> {
        self.endpoint.as_ref()
    }
    /// <p>A versioned model that can be deployed for SageMaker inference.</p>
    pub fn model_package(&self) -> std::option::Option<&crate::model::ModelPackage> {
        self.model_package.as_ref()
    }
    /// <p>A group of versioned models in the model registry.</p>
    pub fn model_package_group(&self) -> std::option::Option<&crate::model::ModelPackageGroup> {
        self.model_package_group.as_ref()
    }
    /// <p>A SageMaker Model Building Pipeline instance.</p>
    pub fn pipeline(&self) -> std::option::Option<&crate::model::Pipeline> {
        self.pipeline.as_ref()
    }
    /// <p>An execution of a pipeline.</p>
    pub fn pipeline_execution(&self) -> std::option::Option<&crate::model::PipelineExecution> {
        self.pipeline_execution.as_ref()
    }
    /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group. A Feature Group can be visualized as a table which has rows, with a unique identifier for each row where each column in the table is a feature. In principle, a Feature Group is composed of features and values per features.</p>
    pub fn feature_group(&self) -> std::option::Option<&crate::model::FeatureGroup> {
        self.feature_group.as_ref()
    }
    /// <p>The properties of a project.</p>
    pub fn project(&self) -> std::option::Option<&crate::model::Project> {
        self.project.as_ref()
    }
}
impl std::fmt::Debug for SearchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchRecord");
        formatter.field("training_job", &self.training_job);
        formatter.field("experiment", &self.experiment);
        formatter.field("trial", &self.trial);
        formatter.field("trial_component", &self.trial_component);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("model_package", &self.model_package);
        formatter.field("model_package_group", &self.model_package_group);
        formatter.field("pipeline", &self.pipeline);
        formatter.field("pipeline_execution", &self.pipeline_execution);
        formatter.field("feature_group", &self.feature_group);
        formatter.field("project", &self.project);
        formatter.finish()
    }
}
/// See [`SearchRecord`](crate::model::SearchRecord)
pub mod search_record {

    /// A builder for [`SearchRecord`](crate::model::SearchRecord)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job: std::option::Option<crate::model::TrainingJob>,
        pub(crate) experiment: std::option::Option<crate::model::Experiment>,
        pub(crate) trial: std::option::Option<crate::model::Trial>,
        pub(crate) trial_component: std::option::Option<crate::model::TrialComponent>,
        pub(crate) endpoint: std::option::Option<crate::model::Endpoint>,
        pub(crate) model_package: std::option::Option<crate::model::ModelPackage>,
        pub(crate) model_package_group: std::option::Option<crate::model::ModelPackageGroup>,
        pub(crate) pipeline: std::option::Option<crate::model::Pipeline>,
        pub(crate) pipeline_execution: std::option::Option<crate::model::PipelineExecution>,
        pub(crate) feature_group: std::option::Option<crate::model::FeatureGroup>,
        pub(crate) project: std::option::Option<crate::model::Project>,
    }
    impl Builder {
        /// <p>The properties of a training job.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJob) -> Self {
            self.training_job = Some(input);
            self
        }
        /// <p>The properties of a training job.</p>
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJob>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>The properties of an experiment.</p>
        pub fn experiment(mut self, input: crate::model::Experiment) -> Self {
            self.experiment = Some(input);
            self
        }
        /// <p>The properties of an experiment.</p>
        pub fn set_experiment(
            mut self,
            input: std::option::Option<crate::model::Experiment>,
        ) -> Self {
            self.experiment = input;
            self
        }
        /// <p>The properties of a trial.</p>
        pub fn trial(mut self, input: crate::model::Trial) -> Self {
            self.trial = Some(input);
            self
        }
        /// <p>The properties of a trial.</p>
        pub fn set_trial(mut self, input: std::option::Option<crate::model::Trial>) -> Self {
            self.trial = input;
            self
        }
        /// <p>The properties of a trial component.</p>
        pub fn trial_component(mut self, input: crate::model::TrialComponent) -> Self {
            self.trial_component = Some(input);
            self
        }
        /// <p>The properties of a trial component.</p>
        pub fn set_trial_component(
            mut self,
            input: std::option::Option<crate::model::TrialComponent>,
        ) -> Self {
            self.trial_component = input;
            self
        }
        /// <p>A hosted endpoint for real-time inference.</p>
        pub fn endpoint(mut self, input: crate::model::Endpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>A hosted endpoint for real-time inference.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<crate::model::Endpoint>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>A versioned model that can be deployed for SageMaker inference.</p>
        pub fn model_package(mut self, input: crate::model::ModelPackage) -> Self {
            self.model_package = Some(input);
            self
        }
        /// <p>A versioned model that can be deployed for SageMaker inference.</p>
        pub fn set_model_package(
            mut self,
            input: std::option::Option<crate::model::ModelPackage>,
        ) -> Self {
            self.model_package = input;
            self
        }
        /// <p>A group of versioned models in the model registry.</p>
        pub fn model_package_group(mut self, input: crate::model::ModelPackageGroup) -> Self {
            self.model_package_group = Some(input);
            self
        }
        /// <p>A group of versioned models in the model registry.</p>
        pub fn set_model_package_group(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroup>,
        ) -> Self {
            self.model_package_group = input;
            self
        }
        /// <p>A SageMaker Model Building Pipeline instance.</p>
        pub fn pipeline(mut self, input: crate::model::Pipeline) -> Self {
            self.pipeline = Some(input);
            self
        }
        /// <p>A SageMaker Model Building Pipeline instance.</p>
        pub fn set_pipeline(mut self, input: std::option::Option<crate::model::Pipeline>) -> Self {
            self.pipeline = input;
            self
        }
        /// <p>An execution of a pipeline.</p>
        pub fn pipeline_execution(mut self, input: crate::model::PipelineExecution) -> Self {
            self.pipeline_execution = Some(input);
            self
        }
        /// <p>An execution of a pipeline.</p>
        pub fn set_pipeline_execution(
            mut self,
            input: std::option::Option<crate::model::PipelineExecution>,
        ) -> Self {
            self.pipeline_execution = input;
            self
        }
        /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group. A Feature Group can be visualized as a table which has rows, with a unique identifier for each row where each column in the table is a feature. In principle, a Feature Group is composed of features and values per features.</p>
        pub fn feature_group(mut self, input: crate::model::FeatureGroup) -> Self {
            self.feature_group = Some(input);
            self
        }
        /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group. A Feature Group can be visualized as a table which has rows, with a unique identifier for each row where each column in the table is a feature. In principle, a Feature Group is composed of features and values per features.</p>
        pub fn set_feature_group(
            mut self,
            input: std::option::Option<crate::model::FeatureGroup>,
        ) -> Self {
            self.feature_group = input;
            self
        }
        /// <p>The properties of a project.</p>
        pub fn project(mut self, input: crate::model::Project) -> Self {
            self.project = Some(input);
            self
        }
        /// <p>The properties of a project.</p>
        pub fn set_project(mut self, input: std::option::Option<crate::model::Project>) -> Self {
            self.project = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchRecord`](crate::model::SearchRecord)
        pub fn build(self) -> crate::model::SearchRecord {
            crate::model::SearchRecord {
                training_job: self.training_job,
                experiment: self.experiment,
                trial: self.trial,
                trial_component: self.trial_component,
                endpoint: self.endpoint,
                model_package: self.model_package,
                model_package_group: self.model_package_group,
                pipeline: self.pipeline,
                pipeline_execution: self.pipeline_execution,
                feature_group: self.feature_group,
                project: self.project,
            }
        }
    }
}
impl SearchRecord {
    /// Creates a new builder-style object to manufacture [`SearchRecord`](crate::model::SearchRecord)
    pub fn builder() -> crate::model::search_record::Builder {
        crate::model::search_record::Builder::default()
    }
}

/// <p>The properties of a project as returned by the Search API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Project {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The ID of the project.</p>
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The description of the project.</p>
    pub project_description: std::option::Option<std::string::String>,
    /// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
    pub service_catalog_provisioning_details:
        std::option::Option<crate::model::ServiceCatalogProvisioningDetails>,
    /// <p>Details of a provisioned service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
    pub service_catalog_provisioned_product_details:
        std::option::Option<crate::model::ServiceCatalogProvisionedProductDetails>,
    /// <p>The status of the project.</p>
    pub project_status: std::option::Option<crate::model::ProjectStatus>,
    /// <p>Who created the project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>A timestamp specifying when the project was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A timestamp container for when the project was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl Project {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub fn project_arn(&self) -> std::option::Option<&str> {
        self.project_arn.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<&str> {
        self.project_id.as_deref()
    }
    /// <p>The description of the project.</p>
    pub fn project_description(&self) -> std::option::Option<&str> {
        self.project_description.as_deref()
    }
    /// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
    pub fn service_catalog_provisioning_details(
        &self,
    ) -> std::option::Option<&crate::model::ServiceCatalogProvisioningDetails> {
        self.service_catalog_provisioning_details.as_ref()
    }
    /// <p>Details of a provisioned service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
    pub fn service_catalog_provisioned_product_details(
        &self,
    ) -> std::option::Option<&crate::model::ServiceCatalogProvisionedProductDetails> {
        self.service_catalog_provisioned_product_details.as_ref()
    }
    /// <p>The status of the project.</p>
    pub fn project_status(&self) -> std::option::Option<&crate::model::ProjectStatus> {
        self.project_status.as_ref()
    }
    /// <p>Who created the project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>A timestamp specifying when the project was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>A timestamp container for when the project was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
}
impl std::fmt::Debug for Project {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Project");
        formatter.field("project_arn", &self.project_arn);
        formatter.field("project_name", &self.project_name);
        formatter.field("project_id", &self.project_id);
        formatter.field("project_description", &self.project_description);
        formatter.field(
            "service_catalog_provisioning_details",
            &self.service_catalog_provisioning_details,
        );
        formatter.field(
            "service_catalog_provisioned_product_details",
            &self.service_catalog_provisioned_product_details,
        );
        formatter.field("project_status", &self.project_status);
        formatter.field("created_by", &self.created_by);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &self.tags);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}
/// See [`Project`](crate::model::Project)
pub mod project {

    /// A builder for [`Project`](crate::model::Project)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) project_description: std::option::Option<std::string::String>,
        pub(crate) service_catalog_provisioning_details:
            std::option::Option<crate::model::ServiceCatalogProvisioningDetails>,
        pub(crate) service_catalog_provisioned_product_details:
            std::option::Option<crate::model::ServiceCatalogProvisionedProductDetails>,
        pub(crate) project_status: std::option::Option<crate::model::ProjectStatus>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input;
            self
        }
        /// <p>The description of the project.</p>
        pub fn project_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_description = Some(input.into());
            self
        }
        /// <p>The description of the project.</p>
        pub fn set_project_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_description = input;
            self
        }
        /// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
        pub fn service_catalog_provisioning_details(
            mut self,
            input: crate::model::ServiceCatalogProvisioningDetails,
        ) -> Self {
            self.service_catalog_provisioning_details = Some(input);
            self
        }
        /// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
        pub fn set_service_catalog_provisioning_details(
            mut self,
            input: std::option::Option<crate::model::ServiceCatalogProvisioningDetails>,
        ) -> Self {
            self.service_catalog_provisioning_details = input;
            self
        }
        /// <p>Details of a provisioned service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
        pub fn service_catalog_provisioned_product_details(
            mut self,
            input: crate::model::ServiceCatalogProvisionedProductDetails,
        ) -> Self {
            self.service_catalog_provisioned_product_details = Some(input);
            self
        }
        /// <p>Details of a provisioned service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
        pub fn set_service_catalog_provisioned_product_details(
            mut self,
            input: std::option::Option<crate::model::ServiceCatalogProvisionedProductDetails>,
        ) -> Self {
            self.service_catalog_provisioned_product_details = input;
            self
        }
        /// <p>The status of the project.</p>
        pub fn project_status(mut self, input: crate::model::ProjectStatus) -> Self {
            self.project_status = Some(input);
            self
        }
        /// <p>The status of the project.</p>
        pub fn set_project_status(
            mut self,
            input: std::option::Option<crate::model::ProjectStatus>,
        ) -> Self {
            self.project_status = input;
            self
        }
        /// <p>Who created the project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Who created the project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A timestamp specifying when the project was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp specifying when the project was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A timestamp container for when the project was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp container for when the project was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Consumes the builder and constructs a [`Project`](crate::model::Project)
        pub fn build(self) -> crate::model::Project {
            crate::model::Project {
                project_arn: self.project_arn,
                project_name: self.project_name,
                project_id: self.project_id,
                project_description: self.project_description,
                service_catalog_provisioning_details: self.service_catalog_provisioning_details,
                service_catalog_provisioned_product_details: self
                    .service_catalog_provisioned_product_details,
                project_status: self.project_status,
                created_by: self.created_by,
                creation_time: self.creation_time,
                tags: self.tags,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
            }
        }
    }
}
impl Project {
    /// Creates a new builder-style object to manufacture [`Project`](crate::model::Project)
    pub fn builder() -> crate::model::project::Builder {
        crate::model::project::Builder::default()
    }
}

/// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserContext {
    /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
    pub user_profile_arn: std::option::Option<std::string::String>,
    /// <p>The name of the user's profile.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The domain associated with the user.</p>
    pub domain_id: std::option::Option<std::string::String>,
}
impl UserContext {
    /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
    pub fn user_profile_arn(&self) -> std::option::Option<&str> {
        self.user_profile_arn.as_deref()
    }
    /// <p>The name of the user's profile.</p>
    pub fn user_profile_name(&self) -> std::option::Option<&str> {
        self.user_profile_name.as_deref()
    }
    /// <p>The domain associated with the user.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
}
impl std::fmt::Debug for UserContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserContext");
        formatter.field("user_profile_arn", &self.user_profile_arn);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("domain_id", &self.domain_id);
        formatter.finish()
    }
}
/// See [`UserContext`](crate::model::UserContext)
pub mod user_context {

    /// A builder for [`UserContext`](crate::model::UserContext)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_profile_arn: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
        pub fn user_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
        pub fn set_user_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_arn = input;
            self
        }
        /// <p>The name of the user's profile.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the user's profile.</p>
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The domain associated with the user.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The domain associated with the user.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserContext`](crate::model::UserContext)
        pub fn build(self) -> crate::model::UserContext {
            crate::model::UserContext {
                user_profile_arn: self.user_profile_arn,
                user_profile_name: self.user_profile_name,
                domain_id: self.domain_id,
            }
        }
    }
}
impl UserContext {
    /// Creates a new builder-style object to manufacture [`UserContext`](crate::model::UserContext)
    pub fn builder() -> crate::model::user_context::Builder {
        crate::model::user_context::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateCompleted,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteCompleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    UpdateCompleted,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectStatus {
    fn from(s: &str) -> Self {
        match s {
            "CreateCompleted" => ProjectStatus::CreateCompleted,
            "CreateFailed" => ProjectStatus::CreateFailed,
            "CreateInProgress" => ProjectStatus::CreateInProgress,
            "DeleteCompleted" => ProjectStatus::DeleteCompleted,
            "DeleteFailed" => ProjectStatus::DeleteFailed,
            "DeleteInProgress" => ProjectStatus::DeleteInProgress,
            "Pending" => ProjectStatus::Pending,
            "UpdateCompleted" => ProjectStatus::UpdateCompleted,
            "UpdateFailed" => ProjectStatus::UpdateFailed,
            "UpdateInProgress" => ProjectStatus::UpdateInProgress,
            other => ProjectStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectStatus::from(s))
    }
}
impl ProjectStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProjectStatus::CreateCompleted => "CreateCompleted",
            ProjectStatus::CreateFailed => "CreateFailed",
            ProjectStatus::CreateInProgress => "CreateInProgress",
            ProjectStatus::DeleteCompleted => "DeleteCompleted",
            ProjectStatus::DeleteFailed => "DeleteFailed",
            ProjectStatus::DeleteInProgress => "DeleteInProgress",
            ProjectStatus::Pending => "Pending",
            ProjectStatus::UpdateCompleted => "UpdateCompleted",
            ProjectStatus::UpdateFailed => "UpdateFailed",
            ProjectStatus::UpdateInProgress => "UpdateInProgress",
            ProjectStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CreateCompleted",
            "CreateFailed",
            "CreateInProgress",
            "DeleteCompleted",
            "DeleteFailed",
            "DeleteInProgress",
            "Pending",
            "UpdateCompleted",
            "UpdateFailed",
            "UpdateInProgress",
        ]
    }
}
impl AsRef<str> for ProjectStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of a provisioned service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceCatalogProvisionedProductDetails {
    /// <p>The ID of the provisioned product.</p>
    pub provisioned_product_id: std::option::Option<std::string::String>,
    /// <p>The current status of the product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p> </li>
    /// </ul>
    pub provisioned_product_status_message: std::option::Option<std::string::String>,
}
impl ServiceCatalogProvisionedProductDetails {
    /// <p>The ID of the provisioned product.</p>
    pub fn provisioned_product_id(&self) -> std::option::Option<&str> {
        self.provisioned_product_id.as_deref()
    }
    /// <p>The current status of the product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p> </li>
    /// </ul>
    pub fn provisioned_product_status_message(&self) -> std::option::Option<&str> {
        self.provisioned_product_status_message.as_deref()
    }
}
impl std::fmt::Debug for ServiceCatalogProvisionedProductDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceCatalogProvisionedProductDetails");
        formatter.field("provisioned_product_id", &self.provisioned_product_id);
        formatter.field(
            "provisioned_product_status_message",
            &self.provisioned_product_status_message,
        );
        formatter.finish()
    }
}
/// See [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
pub mod service_catalog_provisioned_product_details {

    /// A builder for [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provisioned_product_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_product_status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the provisioned product.</p>
        pub fn provisioned_product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned_product_id = Some(input.into());
            self
        }
        /// <p>The ID of the provisioned product.</p>
        pub fn set_provisioned_product_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_id = input;
            self
        }
        /// <p>The current status of the product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p> </li>
        /// </ul>
        pub fn provisioned_product_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.provisioned_product_status_message = Some(input.into());
            self
        }
        /// <p>The current status of the product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p> </li>
        /// </ul>
        pub fn set_provisioned_product_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
        pub fn build(self) -> crate::model::ServiceCatalogProvisionedProductDetails {
            crate::model::ServiceCatalogProvisionedProductDetails {
                provisioned_product_id: self.provisioned_product_id,
                provisioned_product_status_message: self.provisioned_product_status_message,
            }
        }
    }
}
impl ServiceCatalogProvisionedProductDetails {
    /// Creates a new builder-style object to manufacture [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
    pub fn builder() -> crate::model::service_catalog_provisioned_product_details::Builder {
        crate::model::service_catalog_provisioned_product_details::Builder::default()
    }
}

/// <p>Details that you specify to provision a service catalog product. For information about service catalog, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceCatalogProvisioningDetails {
    /// <p>The ID of the product to provision.</p>
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The ID of the provisioning artifact.</p>
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
    pub path_id: std::option::Option<std::string::String>,
    /// <p>A list of key value pairs that you specify when you provision a product.</p>
    pub provisioning_parameters:
        std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
}
impl ServiceCatalogProvisioningDetails {
    /// <p>The ID of the product to provision.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The ID of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
    pub fn path_id(&self) -> std::option::Option<&str> {
        self.path_id.as_deref()
    }
    /// <p>A list of key value pairs that you specify when you provision a product.</p>
    pub fn provisioning_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ProvisioningParameter]> {
        self.provisioning_parameters.as_deref()
    }
}
impl std::fmt::Debug for ServiceCatalogProvisioningDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceCatalogProvisioningDetails");
        formatter.field("product_id", &self.product_id);
        formatter.field("provisioning_artifact_id", &self.provisioning_artifact_id);
        formatter.field("path_id", &self.path_id);
        formatter.field("provisioning_parameters", &self.provisioning_parameters);
        formatter.finish()
    }
}
/// See [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
pub mod service_catalog_provisioning_details {

    /// A builder for [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) path_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_parameters:
            std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
    }
    impl Builder {
        /// <p>The ID of the product to provision.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The ID of the product to provision.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The ID of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The ID of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
        pub fn path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.path_id = Some(input.into());
            self
        }
        /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
        pub fn set_path_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path_id = input;
            self
        }
        /// Appends an item to `provisioning_parameters`.
        ///
        /// To override the contents of this collection use [`set_provisioning_parameters`](Self::set_provisioning_parameters).
        ///
        /// <p>A list of key value pairs that you specify when you provision a product.</p>
        pub fn provisioning_parameters(
            mut self,
            input: crate::model::ProvisioningParameter,
        ) -> Self {
            let mut v = self.provisioning_parameters.unwrap_or_default();
            v.push(input);
            self.provisioning_parameters = Some(v);
            self
        }
        /// <p>A list of key value pairs that you specify when you provision a product.</p>
        pub fn set_provisioning_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
        ) -> Self {
            self.provisioning_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
        pub fn build(self) -> crate::model::ServiceCatalogProvisioningDetails {
            crate::model::ServiceCatalogProvisioningDetails {
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
                path_id: self.path_id,
                provisioning_parameters: self.provisioning_parameters,
            }
        }
    }
}
impl ServiceCatalogProvisioningDetails {
    /// Creates a new builder-style object to manufacture [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
    pub fn builder() -> crate::model::service_catalog_provisioning_details::Builder {
        crate::model::service_catalog_provisioning_details::Builder::default()
    }
}

/// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group. A Feature Group can be visualized as a table which has rows, with a unique identifier for each row where each column in the table is a feature. In principle, a Feature Group is composed of features and values per features.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureGroup {
    /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
    pub feature_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the <code>FeatureGroup</code>.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the <code>Feature</code> whose value uniquely identifies a <code>Record</code> defined in the <code>FeatureGroup</code> <code>FeatureDefinitions</code>.</p>
    pub record_identifier_feature_name: std::option::Option<std::string::String>,
    /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a <code>FeatureGroup</code>.</p>
    /// <p>A <code>EventTime</code> is point in time when a new event occurs that corresponds to the creation or update of a <code>Record</code> in <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code> must have a corresponding <code>EventTime</code>.</p>
    pub event_time_feature_name: std::option::Option<std::string::String>,
    /// <p>A list of <code>Feature</code>s. Each <code>Feature</code> must include a <code>FeatureName</code> and a <code>FeatureType</code>. </p>
    /// <p>Valid <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
    /// <p> <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
    /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per <code>FeatureGroup</code>.</p>
    pub feature_definitions: std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
    /// <p>The time a <code>FeatureGroup</code> was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or <code>KMSKeyId</code>, for at rest data encryption. You can turn <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag at General Assembly; the default value is <code>False</code>.</p>
    pub online_store_config: std::option::Option<crate::model::OnlineStoreConfig>,
    /// <p>The configuration of an <code>OfflineStore</code>.</p>
    /// <p>Provide an <code>OfflineStoreConfig</code> in a request to <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
    /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key Management Service (KMS) key ID, or <code>KMSKeyId</code>, in <code>S3StorageConfig</code>.</p>
    pub offline_store_config: std::option::Option<crate::model::OfflineStoreConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature group.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A <code>FeatureGroup</code> status.</p>
    pub feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>The status of <code>OfflineStore</code>.</p>
    pub offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
    /// <p>The reason that the <code>FeatureGroup</code> failed to be replicated in the <code>OfflineStore</code>. This is failure may be due to a failure to create a <code>FeatureGroup</code> in or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>A free form description of a <code>FeatureGroup</code>.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Tags used to define a <code>FeatureGroup</code>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl FeatureGroup {
    /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
    pub fn feature_group_arn(&self) -> std::option::Option<&str> {
        self.feature_group_arn.as_deref()
    }
    /// <p>The name of the <code>FeatureGroup</code>.</p>
    pub fn feature_group_name(&self) -> std::option::Option<&str> {
        self.feature_group_name.as_deref()
    }
    /// <p>The name of the <code>Feature</code> whose value uniquely identifies a <code>Record</code> defined in the <code>FeatureGroup</code> <code>FeatureDefinitions</code>.</p>
    pub fn record_identifier_feature_name(&self) -> std::option::Option<&str> {
        self.record_identifier_feature_name.as_deref()
    }
    /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a <code>FeatureGroup</code>.</p>
    /// <p>A <code>EventTime</code> is point in time when a new event occurs that corresponds to the creation or update of a <code>Record</code> in <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code> must have a corresponding <code>EventTime</code>.</p>
    pub fn event_time_feature_name(&self) -> std::option::Option<&str> {
        self.event_time_feature_name.as_deref()
    }
    /// <p>A list of <code>Feature</code>s. Each <code>Feature</code> must include a <code>FeatureName</code> and a <code>FeatureType</code>. </p>
    /// <p>Valid <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
    /// <p> <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
    /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per <code>FeatureGroup</code>.</p>
    pub fn feature_definitions(&self) -> std::option::Option<&[crate::model::FeatureDefinition]> {
        self.feature_definitions.as_deref()
    }
    /// <p>The time a <code>FeatureGroup</code> was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or <code>KMSKeyId</code>, for at rest data encryption. You can turn <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag at General Assembly; the default value is <code>False</code>.</p>
    pub fn online_store_config(&self) -> std::option::Option<&crate::model::OnlineStoreConfig> {
        self.online_store_config.as_ref()
    }
    /// <p>The configuration of an <code>OfflineStore</code>.</p>
    /// <p>Provide an <code>OfflineStoreConfig</code> in a request to <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
    /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key Management Service (KMS) key ID, or <code>KMSKeyId</code>, in <code>S3StorageConfig</code>.</p>
    pub fn offline_store_config(&self) -> std::option::Option<&crate::model::OfflineStoreConfig> {
        self.offline_store_config.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature group.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>A <code>FeatureGroup</code> status.</p>
    pub fn feature_group_status(&self) -> std::option::Option<&crate::model::FeatureGroupStatus> {
        self.feature_group_status.as_ref()
    }
    /// <p>The status of <code>OfflineStore</code>.</p>
    pub fn offline_store_status(&self) -> std::option::Option<&crate::model::OfflineStoreStatus> {
        self.offline_store_status.as_ref()
    }
    /// <p>The reason that the <code>FeatureGroup</code> failed to be replicated in the <code>OfflineStore</code>. This is failure may be due to a failure to create a <code>FeatureGroup</code> in or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>A free form description of a <code>FeatureGroup</code>.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Tags used to define a <code>FeatureGroup</code>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for FeatureGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureGroup");
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field(
            "record_identifier_feature_name",
            &self.record_identifier_feature_name,
        );
        formatter.field("event_time_feature_name", &self.event_time_feature_name);
        formatter.field("feature_definitions", &self.feature_definitions);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("online_store_config", &self.online_store_config);
        formatter.field("offline_store_config", &self.offline_store_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("feature_group_status", &self.feature_group_status);
        formatter.field("offline_store_status", &self.offline_store_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`FeatureGroup`](crate::model::FeatureGroup)
pub mod feature_group {

    /// A builder for [`FeatureGroup`](crate::model::FeatureGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_arn: std::option::Option<std::string::String>,
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
        pub(crate) record_identifier_feature_name: std::option::Option<std::string::String>,
        pub(crate) event_time_feature_name: std::option::Option<std::string::String>,
        pub(crate) feature_definitions:
            std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) online_store_config: std::option::Option<crate::model::OnlineStoreConfig>,
        pub(crate) offline_store_config: std::option::Option<crate::model::OfflineStoreConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
        pub(crate) offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
        pub fn feature_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
        pub fn set_feature_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_arn = input;
            self
        }
        /// <p>The name of the <code>FeatureGroup</code>.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        /// <p>The name of the <code>FeatureGroup</code>.</p>
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// <p>The name of the <code>Feature</code> whose value uniquely identifies a <code>Record</code> defined in the <code>FeatureGroup</code> <code>FeatureDefinitions</code>.</p>
        pub fn record_identifier_feature_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_identifier_feature_name = Some(input.into());
            self
        }
        /// <p>The name of the <code>Feature</code> whose value uniquely identifies a <code>Record</code> defined in the <code>FeatureGroup</code> <code>FeatureDefinitions</code>.</p>
        pub fn set_record_identifier_feature_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_identifier_feature_name = input;
            self
        }
        /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a <code>FeatureGroup</code>.</p>
        /// <p>A <code>EventTime</code> is point in time when a new event occurs that corresponds to the creation or update of a <code>Record</code> in <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code> must have a corresponding <code>EventTime</code>.</p>
        pub fn event_time_feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_time_feature_name = Some(input.into());
            self
        }
        /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a <code>FeatureGroup</code>.</p>
        /// <p>A <code>EventTime</code> is point in time when a new event occurs that corresponds to the creation or update of a <code>Record</code> in <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code> must have a corresponding <code>EventTime</code>.</p>
        pub fn set_event_time_feature_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_time_feature_name = input;
            self
        }
        /// Appends an item to `feature_definitions`.
        ///
        /// To override the contents of this collection use [`set_feature_definitions`](Self::set_feature_definitions).
        ///
        /// <p>A list of <code>Feature</code>s. Each <code>Feature</code> must include a <code>FeatureName</code> and a <code>FeatureType</code>. </p>
        /// <p>Valid <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
        /// <p> <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
        /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per <code>FeatureGroup</code>.</p>
        pub fn feature_definitions(mut self, input: crate::model::FeatureDefinition) -> Self {
            let mut v = self.feature_definitions.unwrap_or_default();
            v.push(input);
            self.feature_definitions = Some(v);
            self
        }
        /// <p>A list of <code>Feature</code>s. Each <code>Feature</code> must include a <code>FeatureName</code> and a <code>FeatureType</code>. </p>
        /// <p>Valid <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
        /// <p> <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
        /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per <code>FeatureGroup</code>.</p>
        pub fn set_feature_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
        ) -> Self {
            self.feature_definitions = input;
            self
        }
        /// <p>The time a <code>FeatureGroup</code> was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time a <code>FeatureGroup</code> was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or <code>KMSKeyId</code>, for at rest data encryption. You can turn <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag at General Assembly; the default value is <code>False</code>.</p>
        pub fn online_store_config(mut self, input: crate::model::OnlineStoreConfig) -> Self {
            self.online_store_config = Some(input);
            self
        }
        /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or <code>KMSKeyId</code>, for at rest data encryption. You can turn <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag at General Assembly; the default value is <code>False</code>.</p>
        pub fn set_online_store_config(
            mut self,
            input: std::option::Option<crate::model::OnlineStoreConfig>,
        ) -> Self {
            self.online_store_config = input;
            self
        }
        /// <p>The configuration of an <code>OfflineStore</code>.</p>
        /// <p>Provide an <code>OfflineStoreConfig</code> in a request to <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
        /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key Management Service (KMS) key ID, or <code>KMSKeyId</code>, in <code>S3StorageConfig</code>.</p>
        pub fn offline_store_config(mut self, input: crate::model::OfflineStoreConfig) -> Self {
            self.offline_store_config = Some(input);
            self
        }
        /// <p>The configuration of an <code>OfflineStore</code>.</p>
        /// <p>Provide an <code>OfflineStoreConfig</code> in a request to <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
        /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key Management Service (KMS) key ID, or <code>KMSKeyId</code>, in <code>S3StorageConfig</code>.</p>
        pub fn set_offline_store_config(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreConfig>,
        ) -> Self {
            self.offline_store_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature group.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature group.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>A <code>FeatureGroup</code> status.</p>
        pub fn feature_group_status(mut self, input: crate::model::FeatureGroupStatus) -> Self {
            self.feature_group_status = Some(input);
            self
        }
        /// <p>A <code>FeatureGroup</code> status.</p>
        pub fn set_feature_group_status(
            mut self,
            input: std::option::Option<crate::model::FeatureGroupStatus>,
        ) -> Self {
            self.feature_group_status = input;
            self
        }
        /// <p>The status of <code>OfflineStore</code>.</p>
        pub fn offline_store_status(mut self, input: crate::model::OfflineStoreStatus) -> Self {
            self.offline_store_status = Some(input);
            self
        }
        /// <p>The status of <code>OfflineStore</code>.</p>
        pub fn set_offline_store_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatus>,
        ) -> Self {
            self.offline_store_status = input;
            self
        }
        /// <p>The reason that the <code>FeatureGroup</code> failed to be replicated in the <code>OfflineStore</code>. This is failure may be due to a failure to create a <code>FeatureGroup</code> in or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason that the <code>FeatureGroup</code> failed to be replicated in the <code>OfflineStore</code>. This is failure may be due to a failure to create a <code>FeatureGroup</code> in or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>A free form description of a <code>FeatureGroup</code>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A free form description of a <code>FeatureGroup</code>.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags used to define a <code>FeatureGroup</code>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags used to define a <code>FeatureGroup</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureGroup`](crate::model::FeatureGroup)
        pub fn build(self) -> crate::model::FeatureGroup {
            crate::model::FeatureGroup {
                feature_group_arn: self.feature_group_arn,
                feature_group_name: self.feature_group_name,
                record_identifier_feature_name: self.record_identifier_feature_name,
                event_time_feature_name: self.event_time_feature_name,
                feature_definitions: self.feature_definitions,
                creation_time: self.creation_time,
                online_store_config: self.online_store_config,
                offline_store_config: self.offline_store_config,
                role_arn: self.role_arn,
                feature_group_status: self.feature_group_status,
                offline_store_status: self.offline_store_status,
                failure_reason: self.failure_reason,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl FeatureGroup {
    /// Creates a new builder-style object to manufacture [`FeatureGroup`](crate::model::FeatureGroup)
    pub fn builder() -> crate::model::feature_group::Builder {
        crate::model::feature_group::Builder::default()
    }
}

/// <p>The status of <code>OfflineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OfflineStoreStatus {
    /// <p>An <code>OfflineStore</code> status.</p>
    pub status: std::option::Option<crate::model::OfflineStoreStatusValue>,
    /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
    pub blocked_reason: std::option::Option<std::string::String>,
}
impl OfflineStoreStatus {
    /// <p>An <code>OfflineStore</code> status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OfflineStoreStatusValue> {
        self.status.as_ref()
    }
    /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
    pub fn blocked_reason(&self) -> std::option::Option<&str> {
        self.blocked_reason.as_deref()
    }
}
impl std::fmt::Debug for OfflineStoreStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OfflineStoreStatus");
        formatter.field("status", &self.status);
        formatter.field("blocked_reason", &self.blocked_reason);
        formatter.finish()
    }
}
/// See [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
pub mod offline_store_status {

    /// A builder for [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::OfflineStoreStatusValue>,
        pub(crate) blocked_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An <code>OfflineStore</code> status.</p>
        pub fn status(mut self, input: crate::model::OfflineStoreStatusValue) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>An <code>OfflineStore</code> status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatusValue>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
        pub fn blocked_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.blocked_reason = Some(input.into());
            self
        }
        /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
        pub fn set_blocked_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blocked_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
        pub fn build(self) -> crate::model::OfflineStoreStatus {
            crate::model::OfflineStoreStatus {
                status: self.status,
                blocked_reason: self.blocked_reason,
            }
        }
    }
}
impl OfflineStoreStatus {
    /// Creates a new builder-style object to manufacture [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
    pub fn builder() -> crate::model::offline_store_status::Builder {
        crate::model::offline_store_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OfflineStoreStatusValue {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Blocked,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OfflineStoreStatusValue {
    fn from(s: &str) -> Self {
        match s {
            "Active" => OfflineStoreStatusValue::Active,
            "Blocked" => OfflineStoreStatusValue::Blocked,
            "Disabled" => OfflineStoreStatusValue::Disabled,
            other => OfflineStoreStatusValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OfflineStoreStatusValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OfflineStoreStatusValue::from(s))
    }
}
impl OfflineStoreStatusValue {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OfflineStoreStatusValue::Active => "Active",
            OfflineStoreStatusValue::Blocked => "Blocked",
            OfflineStoreStatusValue::Disabled => "Disabled",
            OfflineStoreStatusValue::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Blocked", "Disabled"]
    }
}
impl AsRef<str> for OfflineStoreStatusValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "CreateFailed" => FeatureGroupStatus::CreateFailed,
            "Created" => FeatureGroupStatus::Created,
            "Creating" => FeatureGroupStatus::Creating,
            "DeleteFailed" => FeatureGroupStatus::DeleteFailed,
            "Deleting" => FeatureGroupStatus::Deleting,
            other => FeatureGroupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupStatus::from(s))
    }
}
impl FeatureGroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupStatus::CreateFailed => "CreateFailed",
            FeatureGroupStatus::Created => "Created",
            FeatureGroupStatus::Creating => "Creating",
            FeatureGroupStatus::DeleteFailed => "DeleteFailed",
            FeatureGroupStatus::Deleting => "Deleting",
            FeatureGroupStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CreateFailed",
            "Created",
            "Creating",
            "DeleteFailed",
            "Deleting",
        ]
    }
}
impl AsRef<str> for FeatureGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of an <code>OfflineStore</code>.</p>
/// <p>Provide an <code>OfflineStoreConfig</code> in a request to <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
/// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key Management Service (KMS) key ID, or <code>KMSKeyId</code>, in <code>S3StorageConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OfflineStoreConfig {
    /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
    pub s3_storage_config: std::option::Option<crate::model::S3StorageConfig>,
    /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when configuring an <code>OfflineStore</code>.</p>
    pub disable_glue_table_creation: bool,
    /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code> is created. </p>
    pub data_catalog_config: std::option::Option<crate::model::DataCatalogConfig>,
}
impl OfflineStoreConfig {
    /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
    pub fn s3_storage_config(&self) -> std::option::Option<&crate::model::S3StorageConfig> {
        self.s3_storage_config.as_ref()
    }
    /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when configuring an <code>OfflineStore</code>.</p>
    pub fn disable_glue_table_creation(&self) -> bool {
        self.disable_glue_table_creation
    }
    /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code> is created. </p>
    pub fn data_catalog_config(&self) -> std::option::Option<&crate::model::DataCatalogConfig> {
        self.data_catalog_config.as_ref()
    }
}
impl std::fmt::Debug for OfflineStoreConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OfflineStoreConfig");
        formatter.field("s3_storage_config", &self.s3_storage_config);
        formatter.field(
            "disable_glue_table_creation",
            &self.disable_glue_table_creation,
        );
        formatter.field("data_catalog_config", &self.data_catalog_config);
        formatter.finish()
    }
}
/// See [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
pub mod offline_store_config {

    /// A builder for [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_storage_config: std::option::Option<crate::model::S3StorageConfig>,
        pub(crate) disable_glue_table_creation: std::option::Option<bool>,
        pub(crate) data_catalog_config: std::option::Option<crate::model::DataCatalogConfig>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
        pub fn s3_storage_config(mut self, input: crate::model::S3StorageConfig) -> Self {
            self.s3_storage_config = Some(input);
            self
        }
        /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
        pub fn set_s3_storage_config(
            mut self,
            input: std::option::Option<crate::model::S3StorageConfig>,
        ) -> Self {
            self.s3_storage_config = input;
            self
        }
        /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when configuring an <code>OfflineStore</code>.</p>
        pub fn disable_glue_table_creation(mut self, input: bool) -> Self {
            self.disable_glue_table_creation = Some(input);
            self
        }
        /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when configuring an <code>OfflineStore</code>.</p>
        pub fn set_disable_glue_table_creation(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_glue_table_creation = input;
            self
        }
        /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code> is created. </p>
        pub fn data_catalog_config(mut self, input: crate::model::DataCatalogConfig) -> Self {
            self.data_catalog_config = Some(input);
            self
        }
        /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code> is created. </p>
        pub fn set_data_catalog_config(
            mut self,
            input: std::option::Option<crate::model::DataCatalogConfig>,
        ) -> Self {
            self.data_catalog_config = input;
            self
        }
        /// Consumes the builder and constructs a [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
        pub fn build(self) -> crate::model::OfflineStoreConfig {
            crate::model::OfflineStoreConfig {
                s3_storage_config: self.s3_storage_config,
                disable_glue_table_creation: self.disable_glue_table_creation.unwrap_or_default(),
                data_catalog_config: self.data_catalog_config,
            }
        }
    }
}
impl OfflineStoreConfig {
    /// Creates a new builder-style object to manufacture [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
    pub fn builder() -> crate::model::offline_store_config::Builder {
        crate::model::offline_store_config::Builder::default()
    }
}

/// <p>The meta data of the Glue table which serves as data catalog for the <code>OfflineStore</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCatalogConfig {
    /// <p>The name of the Glue table.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the Glue table catalog.</p>
    pub catalog: std::option::Option<std::string::String>,
    /// <p>The name of the Glue table database.</p>
    pub database: std::option::Option<std::string::String>,
}
impl DataCatalogConfig {
    /// <p>The name of the Glue table.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the Glue table catalog.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
    /// <p>The name of the Glue table database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
impl std::fmt::Debug for DataCatalogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCatalogConfig");
        formatter.field("table_name", &self.table_name);
        formatter.field("catalog", &self.catalog);
        formatter.field("database", &self.database);
        formatter.finish()
    }
}
/// See [`DataCatalogConfig`](crate::model::DataCatalogConfig)
pub mod data_catalog_config {

    /// A builder for [`DataCatalogConfig`](crate::model::DataCatalogConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) catalog: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Glue table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the Glue table.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the Glue table catalog.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>The name of the Glue table catalog.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The name of the Glue table database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the Glue table database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalogConfig`](crate::model::DataCatalogConfig)
        pub fn build(self) -> crate::model::DataCatalogConfig {
            crate::model::DataCatalogConfig {
                table_name: self.table_name,
                catalog: self.catalog,
                database: self.database,
            }
        }
    }
}
impl DataCatalogConfig {
    /// Creates a new builder-style object to manufacture [`DataCatalogConfig`](crate::model::DataCatalogConfig)
    pub fn builder() -> crate::model::data_catalog_config::Builder {
        crate::model::data_catalog_config::Builder::default()
    }
}

/// <p>The Amazon Simple Storage (Amazon S3) location and and security configuration for <code>OfflineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3StorageConfig {
    /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
    /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects written into the <code>OfflineStore</code> S3 location.</p>
    /// <p>The IAM <code>roleARN</code> that is passed as a parameter to <code>CreateFeatureGroup</code> must have below permissions to the <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The S3 path where offline records are written.</p>
    pub resolved_output_s3_uri: std::option::Option<std::string::String>,
}
impl S3StorageConfig {
    /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
    /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects written into the <code>OfflineStore</code> S3 location.</p>
    /// <p>The IAM <code>roleARN</code> that is passed as a parameter to <code>CreateFeatureGroup</code> must have below permissions to the <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The S3 path where offline records are written.</p>
    pub fn resolved_output_s3_uri(&self) -> std::option::Option<&str> {
        self.resolved_output_s3_uri.as_deref()
    }
}
impl std::fmt::Debug for S3StorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3StorageConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("resolved_output_s3_uri", &self.resolved_output_s3_uri);
        formatter.finish()
    }
}
/// See [`S3StorageConfig`](crate::model::S3StorageConfig)
pub mod s3_storage_config {

    /// A builder for [`S3StorageConfig`](crate::model::S3StorageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) resolved_output_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
        /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
        /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects written into the <code>OfflineStore</code> S3 location.</p>
        /// <p>The IAM <code>roleARN</code> that is passed as a parameter to <code>CreateFeatureGroup</code> must have below permissions to the <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects written into the <code>OfflineStore</code> S3 location.</p>
        /// <p>The IAM <code>roleARN</code> that is passed as a parameter to <code>CreateFeatureGroup</code> must have below permissions to the <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The S3 path where offline records are written.</p>
        pub fn resolved_output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_output_s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 path where offline records are written.</p>
        pub fn set_resolved_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_output_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`S3StorageConfig`](crate::model::S3StorageConfig)
        pub fn build(self) -> crate::model::S3StorageConfig {
            crate::model::S3StorageConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
                resolved_output_s3_uri: self.resolved_output_s3_uri,
            }
        }
    }
}
impl S3StorageConfig {
    /// Creates a new builder-style object to manufacture [`S3StorageConfig`](crate::model::S3StorageConfig)
    pub fn builder() -> crate::model::s3_storage_config::Builder {
        crate::model::s3_storage_config::Builder::default()
    }
}

/// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or <code>KMSKeyId</code>, for at rest data encryption. You can turn <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag at General Assembly; the default value is <code>False</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnlineStoreConfig {
    /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your <code>OnlineStore</code>.</p>
    pub security_config: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
    /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code> for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code> on by specifying <code>True</code> for the <code>EnableOnlineStore</code> flag. </p>
    /// <p>The default value is <code>False</code>.</p>
    pub enable_online_store: bool,
}
impl OnlineStoreConfig {
    /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your <code>OnlineStore</code>.</p>
    pub fn security_config(&self) -> std::option::Option<&crate::model::OnlineStoreSecurityConfig> {
        self.security_config.as_ref()
    }
    /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code> for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code> on by specifying <code>True</code> for the <code>EnableOnlineStore</code> flag. </p>
    /// <p>The default value is <code>False</code>.</p>
    pub fn enable_online_store(&self) -> bool {
        self.enable_online_store
    }
}
impl std::fmt::Debug for OnlineStoreConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnlineStoreConfig");
        formatter.field("security_config", &self.security_config);
        formatter.field("enable_online_store", &self.enable_online_store);
        formatter.finish()
    }
}
/// See [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
pub mod online_store_config {

    /// A builder for [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_config: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
        pub(crate) enable_online_store: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your <code>OnlineStore</code>.</p>
        pub fn security_config(mut self, input: crate::model::OnlineStoreSecurityConfig) -> Self {
            self.security_config = Some(input);
            self
        }
        /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your <code>OnlineStore</code>.</p>
        pub fn set_security_config(
            mut self,
            input: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
        ) -> Self {
            self.security_config = input;
            self
        }
        /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code> for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code> on by specifying <code>True</code> for the <code>EnableOnlineStore</code> flag. </p>
        /// <p>The default value is <code>False</code>.</p>
        pub fn enable_online_store(mut self, input: bool) -> Self {
            self.enable_online_store = Some(input);
            self
        }
        /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code> for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code> on by specifying <code>True</code> for the <code>EnableOnlineStore</code> flag. </p>
        /// <p>The default value is <code>False</code>.</p>
        pub fn set_enable_online_store(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_online_store = input;
            self
        }
        /// Consumes the builder and constructs a [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
        pub fn build(self) -> crate::model::OnlineStoreConfig {
            crate::model::OnlineStoreConfig {
                security_config: self.security_config,
                enable_online_store: self.enable_online_store.unwrap_or_default(),
            }
        }
    }
}
impl OnlineStoreConfig {
    /// Creates a new builder-style object to manufacture [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
    pub fn builder() -> crate::model::online_store_config::Builder {
        crate::model::online_store_config::Builder::default()
    }
}

/// <p>The security configuration for <code>OnlineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnlineStoreSecurityConfig {
    /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
    /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have below permissions to the <code>OnlineStore</code> <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:Encrypt"</code> </p> </li>
    /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
    /// <li> <p> <code>"kms:DescribeKey"</code> </p> </li>
    /// <li> <p> <code>"kms:CreateGrant"</code> </p> </li>
    /// <li> <p> <code>"kms:RetireGrant"</code> </p> </li>
    /// <li> <p> <code>"kms:ReEncryptFrom"</code> </p> </li>
    /// <li> <p> <code>"kms:ReEncryptTo"</code> </p> </li>
    /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
    /// <li> <p> <code>"kms:ListAliases"</code> </p> </li>
    /// <li> <p> <code>"kms:ListGrants"</code> </p> </li>
    /// <li> <p> <code>"kms:RevokeGrant"</code> </p> </li>
    /// </ul>
    /// <p>The caller (either IAM user or IAM role) to all DataPlane operations (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have the following permissions to the <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl OnlineStoreSecurityConfig {
    /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
    /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have below permissions to the <code>OnlineStore</code> <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:Encrypt"</code> </p> </li>
    /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
    /// <li> <p> <code>"kms:DescribeKey"</code> </p> </li>
    /// <li> <p> <code>"kms:CreateGrant"</code> </p> </li>
    /// <li> <p> <code>"kms:RetireGrant"</code> </p> </li>
    /// <li> <p> <code>"kms:ReEncryptFrom"</code> </p> </li>
    /// <li> <p> <code>"kms:ReEncryptTo"</code> </p> </li>
    /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
    /// <li> <p> <code>"kms:ListAliases"</code> </p> </li>
    /// <li> <p> <code>"kms:ListGrants"</code> </p> </li>
    /// <li> <p> <code>"kms:RevokeGrant"</code> </p> </li>
    /// </ul>
    /// <p>The caller (either IAM user or IAM role) to all DataPlane operations (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have the following permissions to the <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for OnlineStoreSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnlineStoreSecurityConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
pub mod online_store_security_config {

    /// A builder for [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
        /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have below permissions to the <code>OnlineStore</code> <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:Encrypt"</code> </p> </li>
        /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
        /// <li> <p> <code>"kms:DescribeKey"</code> </p> </li>
        /// <li> <p> <code>"kms:CreateGrant"</code> </p> </li>
        /// <li> <p> <code>"kms:RetireGrant"</code> </p> </li>
        /// <li> <p> <code>"kms:ReEncryptFrom"</code> </p> </li>
        /// <li> <p> <code>"kms:ReEncryptTo"</code> </p> </li>
        /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
        /// <li> <p> <code>"kms:ListAliases"</code> </p> </li>
        /// <li> <p> <code>"kms:ListGrants"</code> </p> </li>
        /// <li> <p> <code>"kms:RevokeGrant"</code> </p> </li>
        /// </ul>
        /// <p>The caller (either IAM user or IAM role) to all DataPlane operations (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have the following permissions to the <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
        /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have below permissions to the <code>OnlineStore</code> <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:Encrypt"</code> </p> </li>
        /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
        /// <li> <p> <code>"kms:DescribeKey"</code> </p> </li>
        /// <li> <p> <code>"kms:CreateGrant"</code> </p> </li>
        /// <li> <p> <code>"kms:RetireGrant"</code> </p> </li>
        /// <li> <p> <code>"kms:ReEncryptFrom"</code> </p> </li>
        /// <li> <p> <code>"kms:ReEncryptTo"</code> </p> </li>
        /// <li> <p> <code>"kms:GenerateDataKey"</code> </p> </li>
        /// <li> <p> <code>"kms:ListAliases"</code> </p> </li>
        /// <li> <p> <code>"kms:ListGrants"</code> </p> </li>
        /// <li> <p> <code>"kms:RevokeGrant"</code> </p> </li>
        /// </ul>
        /// <p>The caller (either IAM user or IAM role) to all DataPlane operations (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have the following permissions to the <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li> <p> <code>"kms:Decrypt"</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
        pub fn build(self) -> crate::model::OnlineStoreSecurityConfig {
            crate::model::OnlineStoreSecurityConfig {
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl OnlineStoreSecurityConfig {
    /// Creates a new builder-style object to manufacture [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
    pub fn builder() -> crate::model::online_store_security_config::Builder {
        crate::model::online_store_security_config::Builder::default()
    }
}

/// <p>A list of features. You must include <code>FeatureName</code> and <code>FeatureType</code>. Valid feature <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureDefinition {
    /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
    pub feature_name: std::option::Option<std::string::String>,
    /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
    pub feature_type: std::option::Option<crate::model::FeatureType>,
}
impl FeatureDefinition {
    /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
    pub fn feature_name(&self) -> std::option::Option<&str> {
        self.feature_name.as_deref()
    }
    /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
    pub fn feature_type(&self) -> std::option::Option<&crate::model::FeatureType> {
        self.feature_type.as_ref()
    }
}
impl std::fmt::Debug for FeatureDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureDefinition");
        formatter.field("feature_name", &self.feature_name);
        formatter.field("feature_type", &self.feature_type);
        formatter.finish()
    }
}
/// See [`FeatureDefinition`](crate::model::FeatureDefinition)
pub mod feature_definition {

    /// A builder for [`FeatureDefinition`](crate::model::FeatureDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_name: std::option::Option<std::string::String>,
        pub(crate) feature_type: std::option::Option<crate::model::FeatureType>,
    }
    impl Builder {
        /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
        pub fn feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_name = Some(input.into());
            self
        }
        /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any of the following: <code>is_deleted</code>, <code>write_time</code>, <code>api_invocation_time</code>.</p>
        pub fn set_feature_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.feature_name = input;
            self
        }
        /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
        pub fn feature_type(mut self, input: crate::model::FeatureType) -> Self {
            self.feature_type = Some(input);
            self
        }
        /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
        pub fn set_feature_type(
            mut self,
            input: std::option::Option<crate::model::FeatureType>,
        ) -> Self {
            self.feature_type = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureDefinition`](crate::model::FeatureDefinition)
        pub fn build(self) -> crate::model::FeatureDefinition {
            crate::model::FeatureDefinition {
                feature_name: self.feature_name,
                feature_type: self.feature_type,
            }
        }
    }
}
impl FeatureDefinition {
    /// Creates a new builder-style object to manufacture [`FeatureDefinition`](crate::model::FeatureDefinition)
    pub fn builder() -> crate::model::feature_definition::Builder {
        crate::model::feature_definition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureType {
    #[allow(missing_docs)] // documentation missing in model
    Fractional,
    #[allow(missing_docs)] // documentation missing in model
    Integral,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureType {
    fn from(s: &str) -> Self {
        match s {
            "Fractional" => FeatureType::Fractional,
            "Integral" => FeatureType::Integral,
            "String" => FeatureType::String,
            other => FeatureType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureType::from(s))
    }
}
impl FeatureType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FeatureType::Fractional => "Fractional",
            FeatureType::Integral => "Integral",
            FeatureType::String => "String",
            FeatureType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Fractional", "Integral", "String"]
    }
}
impl AsRef<str> for FeatureType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An execution of a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecution {
    /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline status.</p>
    pub pipeline_execution_status: std::option::Option<crate::model::PipelineExecutionStatus>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: std::option::Option<std::string::String>,
    /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
    pub pipeline_experiment_config: std::option::Option<crate::model::PipelineExperimentConfig>,
    /// <p>If the execution failed, a message describing why.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The creation time of the pipeline execution.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the pipeline execution was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The parallelism configuration applied to the pipeline execution.</p>
    pub parallelism_configuration: std::option::Option<crate::model::ParallelismConfiguration>,
    /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
    pub pipeline_parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
}
impl PipelineExecution {
    /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
    pub fn pipeline_arn(&self) -> std::option::Option<&str> {
        self.pipeline_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub fn pipeline_execution_arn(&self) -> std::option::Option<&str> {
        self.pipeline_execution_arn.as_deref()
    }
    /// <p>The display name of the pipeline execution.</p>
    pub fn pipeline_execution_display_name(&self) -> std::option::Option<&str> {
        self.pipeline_execution_display_name.as_deref()
    }
    /// <p>The status of the pipeline status.</p>
    pub fn pipeline_execution_status(
        &self,
    ) -> std::option::Option<&crate::model::PipelineExecutionStatus> {
        self.pipeline_execution_status.as_ref()
    }
    /// <p>The description of the pipeline execution.</p>
    pub fn pipeline_execution_description(&self) -> std::option::Option<&str> {
        self.pipeline_execution_description.as_deref()
    }
    /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
    pub fn pipeline_experiment_config(
        &self,
    ) -> std::option::Option<&crate::model::PipelineExperimentConfig> {
        self.pipeline_experiment_config.as_ref()
    }
    /// <p>If the execution failed, a message describing why.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The creation time of the pipeline execution.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that the pipeline execution was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>The parallelism configuration applied to the pipeline execution.</p>
    pub fn parallelism_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ParallelismConfiguration> {
        self.parallelism_configuration.as_ref()
    }
    /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
    pub fn pipeline_parameters(&self) -> std::option::Option<&[crate::model::Parameter]> {
        self.pipeline_parameters.as_deref()
    }
}
impl std::fmt::Debug for PipelineExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecution");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.field("pipeline_execution_status", &self.pipeline_execution_status);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_experiment_config",
            &self.pipeline_experiment_config,
        );
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("parallelism_configuration", &self.parallelism_configuration);
        formatter.field("pipeline_parameters", &self.pipeline_parameters);
        formatter.finish()
    }
}
/// See [`PipelineExecution`](crate::model::PipelineExecution)
pub mod pipeline_execution {

    /// A builder for [`PipelineExecution`](crate::model::PipelineExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_status:
            std::option::Option<crate::model::PipelineExecutionStatus>,
        pub(crate) pipeline_execution_description: std::option::Option<std::string::String>,
        pub(crate) pipeline_experiment_config:
            std::option::Option<crate::model::PipelineExperimentConfig>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) parallelism_configuration:
            std::option::Option<crate::model::ParallelismConfiguration>,
        pub(crate) pipeline_parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn pipeline_execution_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_execution_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn set_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_arn = input;
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn pipeline_execution_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn set_pipeline_execution_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = input;
            self
        }
        /// <p>The status of the pipeline status.</p>
        pub fn pipeline_execution_status(
            mut self,
            input: crate::model::PipelineExecutionStatus,
        ) -> Self {
            self.pipeline_execution_status = Some(input);
            self
        }
        /// <p>The status of the pipeline status.</p>
        pub fn set_pipeline_execution_status(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStatus>,
        ) -> Self {
            self.pipeline_execution_status = input;
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn pipeline_execution_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = Some(input.into());
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn set_pipeline_execution_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = input;
            self
        }
        /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
        pub fn pipeline_experiment_config(
            mut self,
            input: crate::model::PipelineExperimentConfig,
        ) -> Self {
            self.pipeline_experiment_config = Some(input);
            self
        }
        /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
        pub fn set_pipeline_experiment_config(
            mut self,
            input: std::option::Option<crate::model::PipelineExperimentConfig>,
        ) -> Self {
            self.pipeline_experiment_config = input;
            self
        }
        /// <p>If the execution failed, a message describing why.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the execution failed, a message describing why.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The creation time of the pipeline execution.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the pipeline execution.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline execution was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time that the pipeline execution was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The parallelism configuration applied to the pipeline execution.</p>
        pub fn parallelism_configuration(
            mut self,
            input: crate::model::ParallelismConfiguration,
        ) -> Self {
            self.parallelism_configuration = Some(input);
            self
        }
        /// <p>The parallelism configuration applied to the pipeline execution.</p>
        pub fn set_parallelism_configuration(
            mut self,
            input: std::option::Option<crate::model::ParallelismConfiguration>,
        ) -> Self {
            self.parallelism_configuration = input;
            self
        }
        /// Appends an item to `pipeline_parameters`.
        ///
        /// To override the contents of this collection use [`set_pipeline_parameters`](Self::set_pipeline_parameters).
        ///
        /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
        pub fn pipeline_parameters(mut self, input: crate::model::Parameter) -> Self {
            let mut v = self.pipeline_parameters.unwrap_or_default();
            v.push(input);
            self.pipeline_parameters = Some(v);
            self
        }
        /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
        pub fn set_pipeline_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.pipeline_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecution`](crate::model::PipelineExecution)
        pub fn build(self) -> crate::model::PipelineExecution {
            crate::model::PipelineExecution {
                pipeline_arn: self.pipeline_arn,
                pipeline_execution_arn: self.pipeline_execution_arn,
                pipeline_execution_display_name: self.pipeline_execution_display_name,
                pipeline_execution_status: self.pipeline_execution_status,
                pipeline_execution_description: self.pipeline_execution_description,
                pipeline_experiment_config: self.pipeline_experiment_config,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                created_by: self.created_by,
                last_modified_by: self.last_modified_by,
                parallelism_configuration: self.parallelism_configuration,
                pipeline_parameters: self.pipeline_parameters,
            }
        }
    }
}
impl PipelineExecution {
    /// Creates a new builder-style object to manufacture [`PipelineExecution`](crate::model::PipelineExecution)
    pub fn builder() -> crate::model::pipeline_execution::Builder {
        crate::model::pipeline_execution::Builder::default()
    }
}

/// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExperimentConfig {
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
}
impl PipelineExperimentConfig {
    /// <p>The name of the experiment.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
    /// <p>The name of the trial.</p>
    pub fn trial_name(&self) -> std::option::Option<&str> {
        self.trial_name.as_deref()
    }
}
impl std::fmt::Debug for PipelineExperimentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExperimentConfig");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}
/// See [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
pub mod pipeline_experiment_config {

    /// A builder for [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        /// <p>The name of the trial.</p>
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
        pub fn build(self) -> crate::model::PipelineExperimentConfig {
            crate::model::PipelineExperimentConfig {
                experiment_name: self.experiment_name,
                trial_name: self.trial_name,
            }
        }
    }
}
impl PipelineExperimentConfig {
    /// Creates a new builder-style object to manufacture [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
    pub fn builder() -> crate::model::pipeline_experiment_config::Builder {
        crate::model::pipeline_experiment_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PipelineExecutionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Executing,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PipelineExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Executing" => PipelineExecutionStatus::Executing,
            "Failed" => PipelineExecutionStatus::Failed,
            "Stopped" => PipelineExecutionStatus::Stopped,
            "Stopping" => PipelineExecutionStatus::Stopping,
            "Succeeded" => PipelineExecutionStatus::Succeeded,
            other => PipelineExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PipelineExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PipelineExecutionStatus::from(s))
    }
}
impl PipelineExecutionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PipelineExecutionStatus::Executing => "Executing",
            PipelineExecutionStatus::Failed => "Failed",
            PipelineExecutionStatus::Stopped => "Stopped",
            PipelineExecutionStatus::Stopping => "Stopping",
            PipelineExecutionStatus::Succeeded => "Succeeded",
            PipelineExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Executing", "Failed", "Stopped", "Stopping", "Succeeded"]
    }
}
impl AsRef<str> for PipelineExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A SageMaker Model Building Pipeline instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Pipeline {
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    pub pipeline_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline.</p>
    pub pipeline_status: std::option::Option<crate::model::PipelineStatus>,
    /// <p>The creation time of the pipeline.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the pipeline was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the pipeline was last run.</p>
    pub last_run_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The parallelism configuration applied to the pipeline.</p>
    pub parallelism_configuration: std::option::Option<crate::model::ParallelismConfiguration>,
    /// <p>A list of tags that apply to the pipeline.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Pipeline {
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    pub fn pipeline_arn(&self) -> std::option::Option<&str> {
        self.pipeline_arn.as_deref()
    }
    /// <p>The name of the pipeline.</p>
    pub fn pipeline_name(&self) -> std::option::Option<&str> {
        self.pipeline_name.as_deref()
    }
    /// <p>The display name of the pipeline.</p>
    pub fn pipeline_display_name(&self) -> std::option::Option<&str> {
        self.pipeline_display_name.as_deref()
    }
    /// <p>The description of the pipeline.</p>
    pub fn pipeline_description(&self) -> std::option::Option<&str> {
        self.pipeline_description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The status of the pipeline.</p>
    pub fn pipeline_status(&self) -> std::option::Option<&crate::model::PipelineStatus> {
        self.pipeline_status.as_ref()
    }
    /// <p>The creation time of the pipeline.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that the pipeline was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The time when the pipeline was last run.</p>
    pub fn last_run_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_run_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>The parallelism configuration applied to the pipeline.</p>
    pub fn parallelism_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ParallelismConfiguration> {
        self.parallelism_configuration.as_ref()
    }
    /// <p>A list of tags that apply to the pipeline.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for Pipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Pipeline");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("pipeline_status", &self.pipeline_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_run_time", &self.last_run_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("parallelism_configuration", &self.parallelism_configuration);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Pipeline`](crate::model::Pipeline)
pub mod pipeline {

    /// A builder for [`Pipeline`](crate::model::Pipeline)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_description: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_status: std::option::Option<crate::model::PipelineStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_run_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) parallelism_configuration:
            std::option::Option<crate::model::ParallelismConfiguration>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_name = Some(input.into());
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_name = input;
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn pipeline_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn set_pipeline_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_display_name = input;
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn pipeline_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_description = Some(input.into());
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn set_pipeline_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The status of the pipeline.</p>
        pub fn pipeline_status(mut self, input: crate::model::PipelineStatus) -> Self {
            self.pipeline_status = Some(input);
            self
        }
        /// <p>The status of the pipeline.</p>
        pub fn set_pipeline_status(
            mut self,
            input: std::option::Option<crate::model::PipelineStatus>,
        ) -> Self {
            self.pipeline_status = input;
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The time when the pipeline was last run.</p>
        pub fn last_run_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_run_time = Some(input);
            self
        }
        /// <p>The time when the pipeline was last run.</p>
        pub fn set_last_run_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_run_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The parallelism configuration applied to the pipeline.</p>
        pub fn parallelism_configuration(
            mut self,
            input: crate::model::ParallelismConfiguration,
        ) -> Self {
            self.parallelism_configuration = Some(input);
            self
        }
        /// <p>The parallelism configuration applied to the pipeline.</p>
        pub fn set_parallelism_configuration(
            mut self,
            input: std::option::Option<crate::model::ParallelismConfiguration>,
        ) -> Self {
            self.parallelism_configuration = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tags that apply to the pipeline.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of tags that apply to the pipeline.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Pipeline`](crate::model::Pipeline)
        pub fn build(self) -> crate::model::Pipeline {
            crate::model::Pipeline {
                pipeline_arn: self.pipeline_arn,
                pipeline_name: self.pipeline_name,
                pipeline_display_name: self.pipeline_display_name,
                pipeline_description: self.pipeline_description,
                role_arn: self.role_arn,
                pipeline_status: self.pipeline_status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                last_run_time: self.last_run_time,
                created_by: self.created_by,
                last_modified_by: self.last_modified_by,
                parallelism_configuration: self.parallelism_configuration,
                tags: self.tags,
            }
        }
    }
}
impl Pipeline {
    /// Creates a new builder-style object to manufacture [`Pipeline`](crate::model::Pipeline)
    pub fn builder() -> crate::model::pipeline::Builder {
        crate::model::pipeline::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PipelineStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PipelineStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => PipelineStatus::Active,
            other => PipelineStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PipelineStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PipelineStatus::from(s))
    }
}
impl PipelineStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PipelineStatus::Active => "Active",
            PipelineStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active"]
    }
}
impl AsRef<str> for PipelineStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A group of versioned models in the model registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageGroup {
    /// <p>The name of the model group.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub model_package_group_arn: std::option::Option<std::string::String>,
    /// <p>The description for the model group.</p>
    pub model_package_group_description: std::option::Option<std::string::String>,
    /// <p>The time that the model group was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>The status of the model group. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The model group is pending being created.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The model group is in the process of being created.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - The model group was successfully created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The model group failed.</p> </li>
    /// <li> <p> <code>DELETING</code> - The model group is in the process of being deleted.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p> </li>
    /// </ul>
    pub model_package_group_status: std::option::Option<crate::model::ModelPackageGroupStatus>,
    /// <p>A list of the tags associated with the model group. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ModelPackageGroup {
    /// <p>The name of the model group.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub fn model_package_group_arn(&self) -> std::option::Option<&str> {
        self.model_package_group_arn.as_deref()
    }
    /// <p>The description for the model group.</p>
    pub fn model_package_group_description(&self) -> std::option::Option<&str> {
        self.model_package_group_description.as_deref()
    }
    /// <p>The time that the model group was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>The status of the model group. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The model group is pending being created.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The model group is in the process of being created.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - The model group was successfully created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The model group failed.</p> </li>
    /// <li> <p> <code>DELETING</code> - The model group is in the process of being deleted.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p> </li>
    /// </ul>
    pub fn model_package_group_status(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackageGroupStatus> {
        self.model_package_group_status.as_ref()
    }
    /// <p>A list of the tags associated with the model group. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for ModelPackageGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageGroup");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field(
            "model_package_group_status",
            &self.model_package_group_status,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ModelPackageGroup`](crate::model::ModelPackageGroup)
pub mod model_package_group {

    /// A builder for [`ModelPackageGroup`](crate::model::ModelPackageGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_group_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) model_package_group_status:
            std::option::Option<crate::model::ModelPackageGroupStatus>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the model group.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The name of the model group.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn model_package_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn set_model_package_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_arn = input;
            self
        }
        /// <p>The description for the model group.</p>
        pub fn model_package_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_package_group_description = Some(input.into());
            self
        }
        /// <p>The description for the model group.</p>
        pub fn set_model_package_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_description = input;
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The status of the model group. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The model group is pending being created.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The model group is in the process of being created.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - The model group was successfully created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The model group failed.</p> </li>
        /// <li> <p> <code>DELETING</code> - The model group is in the process of being deleted.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p> </li>
        /// </ul>
        pub fn model_package_group_status(
            mut self,
            input: crate::model::ModelPackageGroupStatus,
        ) -> Self {
            self.model_package_group_status = Some(input);
            self
        }
        /// <p>The status of the model group. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The model group is pending being created.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The model group is in the process of being created.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - The model group was successfully created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The model group failed.</p> </li>
        /// <li> <p> <code>DELETING</code> - The model group is in the process of being deleted.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p> </li>
        /// </ul>
        pub fn set_model_package_group_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroupStatus>,
        ) -> Self {
            self.model_package_group_status = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of the tags associated with the model group. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of the tags associated with the model group. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageGroup`](crate::model::ModelPackageGroup)
        pub fn build(self) -> crate::model::ModelPackageGroup {
            crate::model::ModelPackageGroup {
                model_package_group_name: self.model_package_group_name,
                model_package_group_arn: self.model_package_group_arn,
                model_package_group_description: self.model_package_group_description,
                creation_time: self.creation_time,
                created_by: self.created_by,
                model_package_group_status: self.model_package_group_status,
                tags: self.tags,
            }
        }
    }
}
impl ModelPackageGroup {
    /// Creates a new builder-style object to manufacture [`ModelPackageGroup`](crate::model::ModelPackageGroup)
    pub fn builder() -> crate::model::model_package_group::Builder {
        crate::model::model_package_group::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageGroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ModelPackageGroupStatus::Completed,
            "DeleteFailed" => ModelPackageGroupStatus::DeleteFailed,
            "Deleting" => ModelPackageGroupStatus::Deleting,
            "Failed" => ModelPackageGroupStatus::Failed,
            "InProgress" => ModelPackageGroupStatus::InProgress,
            "Pending" => ModelPackageGroupStatus::Pending,
            other => ModelPackageGroupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageGroupStatus::from(s))
    }
}
impl ModelPackageGroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageGroupStatus::Completed => "Completed",
            ModelPackageGroupStatus::DeleteFailed => "DeleteFailed",
            ModelPackageGroupStatus::Deleting => "Deleting",
            ModelPackageGroupStatus::Failed => "Failed",
            ModelPackageGroupStatus::InProgress => "InProgress",
            ModelPackageGroupStatus::Pending => "Pending",
            ModelPackageGroupStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "DeleteFailed",
            "Deleting",
            "Failed",
            "InProgress",
            "Pending",
        ]
    }
}
impl AsRef<str> for ModelPackageGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A versioned model that can be deployed for SageMaker inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackage {
    /// <p>The name of the model.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>The model group to which the model belongs.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The version number of a versioned model.</p>
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>The description of the model package.</p>
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>The time that the model package was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Defines how to perform inference generation after a training job is run.</p>
    pub inference_specification: std::option::Option<crate::model::InferenceSpecification>,
    /// <p>A list of algorithms that were used to create a model package.</p>
    pub source_algorithm_specification:
        std::option::Option<crate::model::SourceAlgorithmSpecification>,
    /// <p>Specifies batch transform jobs that SageMaker runs to validate your model package.</p>
    pub validation_specification:
        std::option::Option<crate::model::ModelPackageValidationSpecification>,
    /// <p>The status of the model package. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The model package is pending being created.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The model package is in the process of being created.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - The model package was successfully created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The model package failed.</p> </li>
    /// <li> <p> <code>DELETING</code> - The model package is in the process of being deleted.</p> </li>
    /// </ul>
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>Specifies the validation and image scan statuses of the model package.</p>
    pub model_package_status_details: std::option::Option<crate::model::ModelPackageStatusDetails>,
    /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
    pub certify_for_marketplace: bool,
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
    /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
    /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
    /// </ul>
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>Metrics for the model.</p>
    pub model_metrics: std::option::Option<crate::model::ModelMetrics>,
    /// <p>The last time the model package was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>A description provided when the model approval is set.</p>
    pub approval_description: std::option::Option<std::string::String>,
    /// <p>The machine learning domain of your model package and its components. Common machine learning domains include computer vision and natural language processing.</p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The machine learning task your model package accomplishes. Common machine learning tasks include object detection and image classification.</p>
    pub task: std::option::Option<std::string::String>,
    /// <p>The Amazon Simple Storage Service path where the sample payload are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
    pub sample_payload_url: std::option::Option<std::string::String>,
    /// <p>An array of additional Inference Specification objects.</p>
    pub additional_inference_specifications: std::option::Option<
        std::vec::Vec<crate::model::AdditionalInferenceSpecificationDefinition>,
    >,
    /// <p>A list of the tags associated with the model package. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The metadata properties for the model package. </p>
    pub customer_metadata_properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Represents the drift check baselines that can be used when the model monitor is set using the model package.</p>
    pub drift_check_baselines: std::option::Option<crate::model::DriftCheckBaselines>,
}
impl ModelPackage {
    /// <p>The name of the model.</p>
    pub fn model_package_name(&self) -> std::option::Option<&str> {
        self.model_package_name.as_deref()
    }
    /// <p>The model group to which the model belongs.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The version number of a versioned model.</p>
    pub fn model_package_version(&self) -> std::option::Option<i32> {
        self.model_package_version
    }
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub fn model_package_arn(&self) -> std::option::Option<&str> {
        self.model_package_arn.as_deref()
    }
    /// <p>The description of the model package.</p>
    pub fn model_package_description(&self) -> std::option::Option<&str> {
        self.model_package_description.as_deref()
    }
    /// <p>The time that the model package was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Defines how to perform inference generation after a training job is run.</p>
    pub fn inference_specification(
        &self,
    ) -> std::option::Option<&crate::model::InferenceSpecification> {
        self.inference_specification.as_ref()
    }
    /// <p>A list of algorithms that were used to create a model package.</p>
    pub fn source_algorithm_specification(
        &self,
    ) -> std::option::Option<&crate::model::SourceAlgorithmSpecification> {
        self.source_algorithm_specification.as_ref()
    }
    /// <p>Specifies batch transform jobs that SageMaker runs to validate your model package.</p>
    pub fn validation_specification(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackageValidationSpecification> {
        self.validation_specification.as_ref()
    }
    /// <p>The status of the model package. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The model package is pending being created.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The model package is in the process of being created.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - The model package was successfully created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The model package failed.</p> </li>
    /// <li> <p> <code>DELETING</code> - The model package is in the process of being deleted.</p> </li>
    /// </ul>
    pub fn model_package_status(&self) -> std::option::Option<&crate::model::ModelPackageStatus> {
        self.model_package_status.as_ref()
    }
    /// <p>Specifies the validation and image scan statuses of the model package.</p>
    pub fn model_package_status_details(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackageStatusDetails> {
        self.model_package_status_details.as_ref()
    }
    /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
    pub fn certify_for_marketplace(&self) -> bool {
        self.certify_for_marketplace
    }
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
    /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
    /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
    /// </ul>
    pub fn model_approval_status(&self) -> std::option::Option<&crate::model::ModelApprovalStatus> {
        self.model_approval_status.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub fn metadata_properties(&self) -> std::option::Option<&crate::model::MetadataProperties> {
        self.metadata_properties.as_ref()
    }
    /// <p>Metrics for the model.</p>
    pub fn model_metrics(&self) -> std::option::Option<&crate::model::ModelMetrics> {
        self.model_metrics.as_ref()
    }
    /// <p>The last time the model package was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>A description provided when the model approval is set.</p>
    pub fn approval_description(&self) -> std::option::Option<&str> {
        self.approval_description.as_deref()
    }
    /// <p>The machine learning domain of your model package and its components. Common machine learning domains include computer vision and natural language processing.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The machine learning task your model package accomplishes. Common machine learning tasks include object detection and image classification.</p>
    pub fn task(&self) -> std::option::Option<&str> {
        self.task.as_deref()
    }
    /// <p>The Amazon Simple Storage Service path where the sample payload are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
    pub fn sample_payload_url(&self) -> std::option::Option<&str> {
        self.sample_payload_url.as_deref()
    }
    /// <p>An array of additional Inference Specification objects.</p>
    pub fn additional_inference_specifications(
        &self,
    ) -> std::option::Option<&[crate::model::AdditionalInferenceSpecificationDefinition]> {
        self.additional_inference_specifications.as_deref()
    }
    /// <p>A list of the tags associated with the model package. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The metadata properties for the model package. </p>
    pub fn customer_metadata_properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.customer_metadata_properties.as_ref()
    }
    /// <p>Represents the drift check baselines that can be used when the model monitor is set using the model package.</p>
    pub fn drift_check_baselines(&self) -> std::option::Option<&crate::model::DriftCheckBaselines> {
        self.drift_check_baselines.as_ref()
    }
}
impl std::fmt::Debug for ModelPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackage");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field(
            "source_algorithm_specification",
            &self.source_algorithm_specification,
        );
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field(
            "model_package_status_details",
            &self.model_package_status_details,
        );
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("created_by", &self.created_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("model_metrics", &self.model_metrics);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("approval_description", &self.approval_description);
        formatter.field("domain", &self.domain);
        formatter.field("task", &self.task);
        formatter.field("sample_payload_url", &self.sample_payload_url);
        formatter.field(
            "additional_inference_specifications",
            &self.additional_inference_specifications,
        );
        formatter.field("tags", &self.tags);
        formatter.field(
            "customer_metadata_properties",
            &self.customer_metadata_properties,
        );
        formatter.field("drift_check_baselines", &self.drift_check_baselines);
        formatter.finish()
    }
}
/// See [`ModelPackage`](crate::model::ModelPackage)
pub mod model_package {

    /// A builder for [`ModelPackage`](crate::model::ModelPackage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_version: std::option::Option<i32>,
        pub(crate) model_package_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) inference_specification:
            std::option::Option<crate::model::InferenceSpecification>,
        pub(crate) source_algorithm_specification:
            std::option::Option<crate::model::SourceAlgorithmSpecification>,
        pub(crate) validation_specification:
            std::option::Option<crate::model::ModelPackageValidationSpecification>,
        pub(crate) model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
        pub(crate) model_package_status_details:
            std::option::Option<crate::model::ModelPackageStatusDetails>,
        pub(crate) certify_for_marketplace: std::option::Option<bool>,
        pub(crate) model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) model_metrics: std::option::Option<crate::model::ModelMetrics>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) approval_description: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) task: std::option::Option<std::string::String>,
        pub(crate) sample_payload_url: std::option::Option<std::string::String>,
        pub(crate) additional_inference_specifications: std::option::Option<
            std::vec::Vec<crate::model::AdditionalInferenceSpecificationDefinition>,
        >,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) customer_metadata_properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) drift_check_baselines: std::option::Option<crate::model::DriftCheckBaselines>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>The model group to which the model belongs.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The model group to which the model belongs.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The version number of a versioned model.</p>
        pub fn model_package_version(mut self, input: i32) -> Self {
            self.model_package_version = Some(input);
            self
        }
        /// <p>The version number of a versioned model.</p>
        pub fn set_model_package_version(mut self, input: std::option::Option<i32>) -> Self {
            self.model_package_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn model_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn set_model_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_arn = input;
            self
        }
        /// <p>The description of the model package.</p>
        pub fn model_package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_description = Some(input.into());
            self
        }
        /// <p>The description of the model package.</p>
        pub fn set_model_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_description = input;
            self
        }
        /// <p>The time that the model package was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the model package was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Defines how to perform inference generation after a training job is run.</p>
        pub fn inference_specification(
            mut self,
            input: crate::model::InferenceSpecification,
        ) -> Self {
            self.inference_specification = Some(input);
            self
        }
        /// <p>Defines how to perform inference generation after a training job is run.</p>
        pub fn set_inference_specification(
            mut self,
            input: std::option::Option<crate::model::InferenceSpecification>,
        ) -> Self {
            self.inference_specification = input;
            self
        }
        /// <p>A list of algorithms that were used to create a model package.</p>
        pub fn source_algorithm_specification(
            mut self,
            input: crate::model::SourceAlgorithmSpecification,
        ) -> Self {
            self.source_algorithm_specification = Some(input);
            self
        }
        /// <p>A list of algorithms that were used to create a model package.</p>
        pub fn set_source_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::SourceAlgorithmSpecification>,
        ) -> Self {
            self.source_algorithm_specification = input;
            self
        }
        /// <p>Specifies batch transform jobs that SageMaker runs to validate your model package.</p>
        pub fn validation_specification(
            mut self,
            input: crate::model::ModelPackageValidationSpecification,
        ) -> Self {
            self.validation_specification = Some(input);
            self
        }
        /// <p>Specifies batch transform jobs that SageMaker runs to validate your model package.</p>
        pub fn set_validation_specification(
            mut self,
            input: std::option::Option<crate::model::ModelPackageValidationSpecification>,
        ) -> Self {
            self.validation_specification = input;
            self
        }
        /// <p>The status of the model package. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The model package is pending being created.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The model package is in the process of being created.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - The model package was successfully created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The model package failed.</p> </li>
        /// <li> <p> <code>DELETING</code> - The model package is in the process of being deleted.</p> </li>
        /// </ul>
        pub fn model_package_status(mut self, input: crate::model::ModelPackageStatus) -> Self {
            self.model_package_status = Some(input);
            self
        }
        /// <p>The status of the model package. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The model package is pending being created.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The model package is in the process of being created.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - The model package was successfully created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The model package failed.</p> </li>
        /// <li> <p> <code>DELETING</code> - The model package is in the process of being deleted.</p> </li>
        /// </ul>
        pub fn set_model_package_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatus>,
        ) -> Self {
            self.model_package_status = input;
            self
        }
        /// <p>Specifies the validation and image scan statuses of the model package.</p>
        pub fn model_package_status_details(
            mut self,
            input: crate::model::ModelPackageStatusDetails,
        ) -> Self {
            self.model_package_status_details = Some(input);
            self
        }
        /// <p>Specifies the validation and image scan statuses of the model package.</p>
        pub fn set_model_package_status_details(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatusDetails>,
        ) -> Self {
            self.model_package_status_details = input;
            self
        }
        /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
        pub fn certify_for_marketplace(mut self, input: bool) -> Self {
            self.certify_for_marketplace = Some(input);
            self
        }
        /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
        pub fn set_certify_for_marketplace(mut self, input: std::option::Option<bool>) -> Self {
            self.certify_for_marketplace = input;
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
        /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
        /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
        /// </ul>
        pub fn model_approval_status(mut self, input: crate::model::ModelApprovalStatus) -> Self {
            self.model_approval_status = Some(input);
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
        /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
        /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
        /// </ul>
        pub fn set_model_approval_status(
            mut self,
            input: std::option::Option<crate::model::ModelApprovalStatus>,
        ) -> Self {
            self.model_approval_status = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        /// <p>Metrics for the model.</p>
        pub fn model_metrics(mut self, input: crate::model::ModelMetrics) -> Self {
            self.model_metrics = Some(input);
            self
        }
        /// <p>Metrics for the model.</p>
        pub fn set_model_metrics(
            mut self,
            input: std::option::Option<crate::model::ModelMetrics>,
        ) -> Self {
            self.model_metrics = input;
            self
        }
        /// <p>The last time the model package was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time the model package was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>A description provided when the model approval is set.</p>
        pub fn approval_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.approval_description = Some(input.into());
            self
        }
        /// <p>A description provided when the model approval is set.</p>
        pub fn set_approval_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.approval_description = input;
            self
        }
        /// <p>The machine learning domain of your model package and its components. Common machine learning domains include computer vision and natural language processing.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The machine learning domain of your model package and its components. Common machine learning domains include computer vision and natural language processing.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The machine learning task your model package accomplishes. Common machine learning tasks include object detection and image classification.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.task = Some(input.into());
            self
        }
        /// <p>The machine learning task your model package accomplishes. Common machine learning tasks include object detection and image classification.</p>
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task = input;
            self
        }
        /// <p>The Amazon Simple Storage Service path where the sample payload are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
        pub fn sample_payload_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_payload_url = Some(input.into());
            self
        }
        /// <p>The Amazon Simple Storage Service path where the sample payload are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
        pub fn set_sample_payload_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sample_payload_url = input;
            self
        }
        /// Appends an item to `additional_inference_specifications`.
        ///
        /// To override the contents of this collection use [`set_additional_inference_specifications`](Self::set_additional_inference_specifications).
        ///
        /// <p>An array of additional Inference Specification objects.</p>
        pub fn additional_inference_specifications(
            mut self,
            input: crate::model::AdditionalInferenceSpecificationDefinition,
        ) -> Self {
            let mut v = self.additional_inference_specifications.unwrap_or_default();
            v.push(input);
            self.additional_inference_specifications = Some(v);
            self
        }
        /// <p>An array of additional Inference Specification objects.</p>
        pub fn set_additional_inference_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AdditionalInferenceSpecificationDefinition>,
            >,
        ) -> Self {
            self.additional_inference_specifications = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of the tags associated with the model package. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of the tags associated with the model package. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `customer_metadata_properties`.
        ///
        /// To override the contents of this collection use [`set_customer_metadata_properties`](Self::set_customer_metadata_properties).
        ///
        /// <p>The metadata properties for the model package. </p>
        pub fn customer_metadata_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.customer_metadata_properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.customer_metadata_properties = Some(hash_map);
            self
        }
        /// <p>The metadata properties for the model package. </p>
        pub fn set_customer_metadata_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.customer_metadata_properties = input;
            self
        }
        /// <p>Represents the drift check baselines that can be used when the model monitor is set using the model package.</p>
        pub fn drift_check_baselines(mut self, input: crate::model::DriftCheckBaselines) -> Self {
            self.drift_check_baselines = Some(input);
            self
        }
        /// <p>Represents the drift check baselines that can be used when the model monitor is set using the model package.</p>
        pub fn set_drift_check_baselines(
            mut self,
            input: std::option::Option<crate::model::DriftCheckBaselines>,
        ) -> Self {
            self.drift_check_baselines = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackage`](crate::model::ModelPackage)
        pub fn build(self) -> crate::model::ModelPackage {
            crate::model::ModelPackage {
                model_package_name: self.model_package_name,
                model_package_group_name: self.model_package_group_name,
                model_package_version: self.model_package_version,
                model_package_arn: self.model_package_arn,
                model_package_description: self.model_package_description,
                creation_time: self.creation_time,
                inference_specification: self.inference_specification,
                source_algorithm_specification: self.source_algorithm_specification,
                validation_specification: self.validation_specification,
                model_package_status: self.model_package_status,
                model_package_status_details: self.model_package_status_details,
                certify_for_marketplace: self.certify_for_marketplace.unwrap_or_default(),
                model_approval_status: self.model_approval_status,
                created_by: self.created_by,
                metadata_properties: self.metadata_properties,
                model_metrics: self.model_metrics,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                approval_description: self.approval_description,
                domain: self.domain,
                task: self.task,
                sample_payload_url: self.sample_payload_url,
                additional_inference_specifications: self.additional_inference_specifications,
                tags: self.tags,
                customer_metadata_properties: self.customer_metadata_properties,
                drift_check_baselines: self.drift_check_baselines,
            }
        }
    }
}
impl ModelPackage {
    /// Creates a new builder-style object to manufacture [`ModelPackage`](crate::model::ModelPackage)
    pub fn builder() -> crate::model::model_package::Builder {
        crate::model::model_package::Builder::default()
    }
}

/// <p>Represents the drift check baselines that can be used when the model monitor is set using the model package. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DriftCheckBaselines {
    /// <p>Represents the drift check bias baselines that can be used when the model monitor is set using the model package. </p>
    pub bias: std::option::Option<crate::model::DriftCheckBias>,
    /// <p>Represents the drift check explainability baselines that can be used when the model monitor is set using the model package. </p>
    pub explainability: std::option::Option<crate::model::DriftCheckExplainability>,
    /// <p>Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.</p>
    pub model_quality: std::option::Option<crate::model::DriftCheckModelQuality>,
    /// <p>Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.</p>
    pub model_data_quality: std::option::Option<crate::model::DriftCheckModelDataQuality>,
}
impl DriftCheckBaselines {
    /// <p>Represents the drift check bias baselines that can be used when the model monitor is set using the model package. </p>
    pub fn bias(&self) -> std::option::Option<&crate::model::DriftCheckBias> {
        self.bias.as_ref()
    }
    /// <p>Represents the drift check explainability baselines that can be used when the model monitor is set using the model package. </p>
    pub fn explainability(&self) -> std::option::Option<&crate::model::DriftCheckExplainability> {
        self.explainability.as_ref()
    }
    /// <p>Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.</p>
    pub fn model_quality(&self) -> std::option::Option<&crate::model::DriftCheckModelQuality> {
        self.model_quality.as_ref()
    }
    /// <p>Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.</p>
    pub fn model_data_quality(
        &self,
    ) -> std::option::Option<&crate::model::DriftCheckModelDataQuality> {
        self.model_data_quality.as_ref()
    }
}
impl std::fmt::Debug for DriftCheckBaselines {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DriftCheckBaselines");
        formatter.field("bias", &self.bias);
        formatter.field("explainability", &self.explainability);
        formatter.field("model_quality", &self.model_quality);
        formatter.field("model_data_quality", &self.model_data_quality);
        formatter.finish()
    }
}
/// See [`DriftCheckBaselines`](crate::model::DriftCheckBaselines)
pub mod drift_check_baselines {

    /// A builder for [`DriftCheckBaselines`](crate::model::DriftCheckBaselines)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bias: std::option::Option<crate::model::DriftCheckBias>,
        pub(crate) explainability: std::option::Option<crate::model::DriftCheckExplainability>,
        pub(crate) model_quality: std::option::Option<crate::model::DriftCheckModelQuality>,
        pub(crate) model_data_quality:
            std::option::Option<crate::model::DriftCheckModelDataQuality>,
    }
    impl Builder {
        /// <p>Represents the drift check bias baselines that can be used when the model monitor is set using the model package. </p>
        pub fn bias(mut self, input: crate::model::DriftCheckBias) -> Self {
            self.bias = Some(input);
            self
        }
        /// <p>Represents the drift check bias baselines that can be used when the model monitor is set using the model package. </p>
        pub fn set_bias(
            mut self,
            input: std::option::Option<crate::model::DriftCheckBias>,
        ) -> Self {
            self.bias = input;
            self
        }
        /// <p>Represents the drift check explainability baselines that can be used when the model monitor is set using the model package. </p>
        pub fn explainability(mut self, input: crate::model::DriftCheckExplainability) -> Self {
            self.explainability = Some(input);
            self
        }
        /// <p>Represents the drift check explainability baselines that can be used when the model monitor is set using the model package. </p>
        pub fn set_explainability(
            mut self,
            input: std::option::Option<crate::model::DriftCheckExplainability>,
        ) -> Self {
            self.explainability = input;
            self
        }
        /// <p>Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.</p>
        pub fn model_quality(mut self, input: crate::model::DriftCheckModelQuality) -> Self {
            self.model_quality = Some(input);
            self
        }
        /// <p>Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.</p>
        pub fn set_model_quality(
            mut self,
            input: std::option::Option<crate::model::DriftCheckModelQuality>,
        ) -> Self {
            self.model_quality = input;
            self
        }
        /// <p>Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.</p>
        pub fn model_data_quality(
            mut self,
            input: crate::model::DriftCheckModelDataQuality,
        ) -> Self {
            self.model_data_quality = Some(input);
            self
        }
        /// <p>Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.</p>
        pub fn set_model_data_quality(
            mut self,
            input: std::option::Option<crate::model::DriftCheckModelDataQuality>,
        ) -> Self {
            self.model_data_quality = input;
            self
        }
        /// Consumes the builder and constructs a [`DriftCheckBaselines`](crate::model::DriftCheckBaselines)
        pub fn build(self) -> crate::model::DriftCheckBaselines {
            crate::model::DriftCheckBaselines {
                bias: self.bias,
                explainability: self.explainability,
                model_quality: self.model_quality,
                model_data_quality: self.model_data_quality,
            }
        }
    }
}
impl DriftCheckBaselines {
    /// Creates a new builder-style object to manufacture [`DriftCheckBaselines`](crate::model::DriftCheckBaselines)
    pub fn builder() -> crate::model::drift_check_baselines::Builder {
        crate::model::drift_check_baselines::Builder::default()
    }
}

/// <p>Represents the drift check data quality baselines that can be used when the model monitor is set using the model package. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DriftCheckModelDataQuality {
    /// <p></p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p></p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl DriftCheckModelDataQuality {
    /// <p></p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.statistics.as_ref()
    }
    /// <p></p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.constraints.as_ref()
    }
}
impl std::fmt::Debug for DriftCheckModelDataQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DriftCheckModelDataQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`DriftCheckModelDataQuality`](crate::model::DriftCheckModelDataQuality)
pub mod drift_check_model_data_quality {

    /// A builder for [`DriftCheckModelDataQuality`](crate::model::DriftCheckModelDataQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p></p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p></p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p></p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p></p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`DriftCheckModelDataQuality`](crate::model::DriftCheckModelDataQuality)
        pub fn build(self) -> crate::model::DriftCheckModelDataQuality {
            crate::model::DriftCheckModelDataQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl DriftCheckModelDataQuality {
    /// Creates a new builder-style object to manufacture [`DriftCheckModelDataQuality`](crate::model::DriftCheckModelDataQuality)
    pub fn builder() -> crate::model::drift_check_model_data_quality::Builder {
        crate::model::drift_check_model_data_quality::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricsSource {
    /// <p></p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p></p>
    pub content_digest: std::option::Option<std::string::String>,
    /// <p></p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl MetricsSource {
    /// <p></p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p></p>
    pub fn content_digest(&self) -> std::option::Option<&str> {
        self.content_digest.as_deref()
    }
    /// <p></p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for MetricsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricsSource");
        formatter.field("content_type", &self.content_type);
        formatter.field("content_digest", &self.content_digest);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MetricsSource`](crate::model::MetricsSource)
pub mod metrics_source {

    /// A builder for [`MetricsSource`](crate::model::MetricsSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) content_digest: std::option::Option<std::string::String>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p></p>
        pub fn content_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_digest = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_content_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_digest = input;
            self
        }
        /// <p></p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricsSource`](crate::model::MetricsSource)
        pub fn build(self) -> crate::model::MetricsSource {
            crate::model::MetricsSource {
                content_type: self.content_type,
                content_digest: self.content_digest,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MetricsSource {
    /// Creates a new builder-style object to manufacture [`MetricsSource`](crate::model::MetricsSource)
    pub fn builder() -> crate::model::metrics_source::Builder {
        crate::model::metrics_source::Builder::default()
    }
}

/// <p>Represents the drift check model quality baselines that can be used when the model monitor is set using the model package. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DriftCheckModelQuality {
    /// <p></p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p></p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl DriftCheckModelQuality {
    /// <p></p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.statistics.as_ref()
    }
    /// <p></p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.constraints.as_ref()
    }
}
impl std::fmt::Debug for DriftCheckModelQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DriftCheckModelQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`DriftCheckModelQuality`](crate::model::DriftCheckModelQuality)
pub mod drift_check_model_quality {

    /// A builder for [`DriftCheckModelQuality`](crate::model::DriftCheckModelQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p></p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p></p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p></p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p></p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`DriftCheckModelQuality`](crate::model::DriftCheckModelQuality)
        pub fn build(self) -> crate::model::DriftCheckModelQuality {
            crate::model::DriftCheckModelQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl DriftCheckModelQuality {
    /// Creates a new builder-style object to manufacture [`DriftCheckModelQuality`](crate::model::DriftCheckModelQuality)
    pub fn builder() -> crate::model::drift_check_model_quality::Builder {
        crate::model::drift_check_model_quality::Builder::default()
    }
}

/// <p>Represents the drift check explainability baselines that can be used when the model monitor is set using the model package. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DriftCheckExplainability {
    /// <p></p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
    /// <p>The explainability config file for the model.</p>
    pub config_file: std::option::Option<crate::model::FileSource>,
}
impl DriftCheckExplainability {
    /// <p></p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.constraints.as_ref()
    }
    /// <p>The explainability config file for the model.</p>
    pub fn config_file(&self) -> std::option::Option<&crate::model::FileSource> {
        self.config_file.as_ref()
    }
}
impl std::fmt::Debug for DriftCheckExplainability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DriftCheckExplainability");
        formatter.field("constraints", &self.constraints);
        formatter.field("config_file", &self.config_file);
        formatter.finish()
    }
}
/// See [`DriftCheckExplainability`](crate::model::DriftCheckExplainability)
pub mod drift_check_explainability {

    /// A builder for [`DriftCheckExplainability`](crate::model::DriftCheckExplainability)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
        pub(crate) config_file: std::option::Option<crate::model::FileSource>,
    }
    impl Builder {
        /// <p></p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p></p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// <p>The explainability config file for the model.</p>
        pub fn config_file(mut self, input: crate::model::FileSource) -> Self {
            self.config_file = Some(input);
            self
        }
        /// <p>The explainability config file for the model.</p>
        pub fn set_config_file(
            mut self,
            input: std::option::Option<crate::model::FileSource>,
        ) -> Self {
            self.config_file = input;
            self
        }
        /// Consumes the builder and constructs a [`DriftCheckExplainability`](crate::model::DriftCheckExplainability)
        pub fn build(self) -> crate::model::DriftCheckExplainability {
            crate::model::DriftCheckExplainability {
                constraints: self.constraints,
                config_file: self.config_file,
            }
        }
    }
}
impl DriftCheckExplainability {
    /// Creates a new builder-style object to manufacture [`DriftCheckExplainability`](crate::model::DriftCheckExplainability)
    pub fn builder() -> crate::model::drift_check_explainability::Builder {
        crate::model::drift_check_explainability::Builder::default()
    }
}

/// <p>Contains details regarding the file source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSource {
    /// <p>The type of content stored in the file source.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The digest of the file source.</p>
    pub content_digest: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI for the file source.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl FileSource {
    /// <p>The type of content stored in the file source.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The digest of the file source.</p>
    pub fn content_digest(&self) -> std::option::Option<&str> {
        self.content_digest.as_deref()
    }
    /// <p>The Amazon S3 URI for the file source.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for FileSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSource");
        formatter.field("content_type", &self.content_type);
        formatter.field("content_digest", &self.content_digest);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`FileSource`](crate::model::FileSource)
pub mod file_source {

    /// A builder for [`FileSource`](crate::model::FileSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) content_digest: std::option::Option<std::string::String>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of content stored in the file source.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The type of content stored in the file source.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The digest of the file source.</p>
        pub fn content_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_digest = Some(input.into());
            self
        }
        /// <p>The digest of the file source.</p>
        pub fn set_content_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_digest = input;
            self
        }
        /// <p>The Amazon S3 URI for the file source.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI for the file source.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSource`](crate::model::FileSource)
        pub fn build(self) -> crate::model::FileSource {
            crate::model::FileSource {
                content_type: self.content_type,
                content_digest: self.content_digest,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl FileSource {
    /// Creates a new builder-style object to manufacture [`FileSource`](crate::model::FileSource)
    pub fn builder() -> crate::model::file_source::Builder {
        crate::model::file_source::Builder::default()
    }
}

/// <p>Represents the drift check bias baselines that can be used when the model monitor is set using the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DriftCheckBias {
    /// <p>The bias config file for a model.</p>
    pub config_file: std::option::Option<crate::model::FileSource>,
    /// <p></p>
    pub pre_training_constraints: std::option::Option<crate::model::MetricsSource>,
    /// <p></p>
    pub post_training_constraints: std::option::Option<crate::model::MetricsSource>,
}
impl DriftCheckBias {
    /// <p>The bias config file for a model.</p>
    pub fn config_file(&self) -> std::option::Option<&crate::model::FileSource> {
        self.config_file.as_ref()
    }
    /// <p></p>
    pub fn pre_training_constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.pre_training_constraints.as_ref()
    }
    /// <p></p>
    pub fn post_training_constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.post_training_constraints.as_ref()
    }
}
impl std::fmt::Debug for DriftCheckBias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DriftCheckBias");
        formatter.field("config_file", &self.config_file);
        formatter.field("pre_training_constraints", &self.pre_training_constraints);
        formatter.field("post_training_constraints", &self.post_training_constraints);
        formatter.finish()
    }
}
/// See [`DriftCheckBias`](crate::model::DriftCheckBias)
pub mod drift_check_bias {

    /// A builder for [`DriftCheckBias`](crate::model::DriftCheckBias)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_file: std::option::Option<crate::model::FileSource>,
        pub(crate) pre_training_constraints: std::option::Option<crate::model::MetricsSource>,
        pub(crate) post_training_constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>The bias config file for a model.</p>
        pub fn config_file(mut self, input: crate::model::FileSource) -> Self {
            self.config_file = Some(input);
            self
        }
        /// <p>The bias config file for a model.</p>
        pub fn set_config_file(
            mut self,
            input: std::option::Option<crate::model::FileSource>,
        ) -> Self {
            self.config_file = input;
            self
        }
        /// <p></p>
        pub fn pre_training_constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.pre_training_constraints = Some(input);
            self
        }
        /// <p></p>
        pub fn set_pre_training_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.pre_training_constraints = input;
            self
        }
        /// <p></p>
        pub fn post_training_constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.post_training_constraints = Some(input);
            self
        }
        /// <p></p>
        pub fn set_post_training_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.post_training_constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`DriftCheckBias`](crate::model::DriftCheckBias)
        pub fn build(self) -> crate::model::DriftCheckBias {
            crate::model::DriftCheckBias {
                config_file: self.config_file,
                pre_training_constraints: self.pre_training_constraints,
                post_training_constraints: self.post_training_constraints,
            }
        }
    }
}
impl DriftCheckBias {
    /// Creates a new builder-style object to manufacture [`DriftCheckBias`](crate::model::DriftCheckBias)
    pub fn builder() -> crate::model::drift_check_bias::Builder {
        crate::model::drift_check_bias::Builder::default()
    }
}

/// <p>Contains metrics captured from a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelMetrics {
    /// <p>Metrics that measure the quality of a model.</p>
    pub model_quality: std::option::Option<crate::model::ModelQuality>,
    /// <p>Metrics that measure the quality of the input data for a model.</p>
    pub model_data_quality: std::option::Option<crate::model::ModelDataQuality>,
    /// <p>Metrics that measure bais in a model.</p>
    pub bias: std::option::Option<crate::model::Bias>,
    /// <p>Metrics that help explain a model.</p>
    pub explainability: std::option::Option<crate::model::Explainability>,
}
impl ModelMetrics {
    /// <p>Metrics that measure the quality of a model.</p>
    pub fn model_quality(&self) -> std::option::Option<&crate::model::ModelQuality> {
        self.model_quality.as_ref()
    }
    /// <p>Metrics that measure the quality of the input data for a model.</p>
    pub fn model_data_quality(&self) -> std::option::Option<&crate::model::ModelDataQuality> {
        self.model_data_quality.as_ref()
    }
    /// <p>Metrics that measure bais in a model.</p>
    pub fn bias(&self) -> std::option::Option<&crate::model::Bias> {
        self.bias.as_ref()
    }
    /// <p>Metrics that help explain a model.</p>
    pub fn explainability(&self) -> std::option::Option<&crate::model::Explainability> {
        self.explainability.as_ref()
    }
}
impl std::fmt::Debug for ModelMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelMetrics");
        formatter.field("model_quality", &self.model_quality);
        formatter.field("model_data_quality", &self.model_data_quality);
        formatter.field("bias", &self.bias);
        formatter.field("explainability", &self.explainability);
        formatter.finish()
    }
}
/// See [`ModelMetrics`](crate::model::ModelMetrics)
pub mod model_metrics {

    /// A builder for [`ModelMetrics`](crate::model::ModelMetrics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_quality: std::option::Option<crate::model::ModelQuality>,
        pub(crate) model_data_quality: std::option::Option<crate::model::ModelDataQuality>,
        pub(crate) bias: std::option::Option<crate::model::Bias>,
        pub(crate) explainability: std::option::Option<crate::model::Explainability>,
    }
    impl Builder {
        /// <p>Metrics that measure the quality of a model.</p>
        pub fn model_quality(mut self, input: crate::model::ModelQuality) -> Self {
            self.model_quality = Some(input);
            self
        }
        /// <p>Metrics that measure the quality of a model.</p>
        pub fn set_model_quality(
            mut self,
            input: std::option::Option<crate::model::ModelQuality>,
        ) -> Self {
            self.model_quality = input;
            self
        }
        /// <p>Metrics that measure the quality of the input data for a model.</p>
        pub fn model_data_quality(mut self, input: crate::model::ModelDataQuality) -> Self {
            self.model_data_quality = Some(input);
            self
        }
        /// <p>Metrics that measure the quality of the input data for a model.</p>
        pub fn set_model_data_quality(
            mut self,
            input: std::option::Option<crate::model::ModelDataQuality>,
        ) -> Self {
            self.model_data_quality = input;
            self
        }
        /// <p>Metrics that measure bais in a model.</p>
        pub fn bias(mut self, input: crate::model::Bias) -> Self {
            self.bias = Some(input);
            self
        }
        /// <p>Metrics that measure bais in a model.</p>
        pub fn set_bias(mut self, input: std::option::Option<crate::model::Bias>) -> Self {
            self.bias = input;
            self
        }
        /// <p>Metrics that help explain a model.</p>
        pub fn explainability(mut self, input: crate::model::Explainability) -> Self {
            self.explainability = Some(input);
            self
        }
        /// <p>Metrics that help explain a model.</p>
        pub fn set_explainability(
            mut self,
            input: std::option::Option<crate::model::Explainability>,
        ) -> Self {
            self.explainability = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetrics`](crate::model::ModelMetrics)
        pub fn build(self) -> crate::model::ModelMetrics {
            crate::model::ModelMetrics {
                model_quality: self.model_quality,
                model_data_quality: self.model_data_quality,
                bias: self.bias,
                explainability: self.explainability,
            }
        }
    }
}
impl ModelMetrics {
    /// Creates a new builder-style object to manufacture [`ModelMetrics`](crate::model::ModelMetrics)
    pub fn builder() -> crate::model::model_metrics::Builder {
        crate::model::model_metrics::Builder::default()
    }
}

/// <p>Contains explainability metrics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Explainability {
    /// <p>The explainability report for a model.</p>
    pub report: std::option::Option<crate::model::MetricsSource>,
}
impl Explainability {
    /// <p>The explainability report for a model.</p>
    pub fn report(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.report.as_ref()
    }
}
impl std::fmt::Debug for Explainability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Explainability");
        formatter.field("report", &self.report);
        formatter.finish()
    }
}
/// See [`Explainability`](crate::model::Explainability)
pub mod explainability {

    /// A builder for [`Explainability`](crate::model::Explainability)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) report: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>The explainability report for a model.</p>
        pub fn report(mut self, input: crate::model::MetricsSource) -> Self {
            self.report = Some(input);
            self
        }
        /// <p>The explainability report for a model.</p>
        pub fn set_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.report = input;
            self
        }
        /// Consumes the builder and constructs a [`Explainability`](crate::model::Explainability)
        pub fn build(self) -> crate::model::Explainability {
            crate::model::Explainability {
                report: self.report,
            }
        }
    }
}
impl Explainability {
    /// Creates a new builder-style object to manufacture [`Explainability`](crate::model::Explainability)
    pub fn builder() -> crate::model::explainability::Builder {
        crate::model::explainability::Builder::default()
    }
}

/// <p>Contains bias metrics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Bias {
    /// <p>The bias report for a model</p>
    pub report: std::option::Option<crate::model::MetricsSource>,
    /// <p></p>
    pub pre_training_report: std::option::Option<crate::model::MetricsSource>,
    /// <p></p>
    pub post_training_report: std::option::Option<crate::model::MetricsSource>,
}
impl Bias {
    /// <p>The bias report for a model</p>
    pub fn report(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.report.as_ref()
    }
    /// <p></p>
    pub fn pre_training_report(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.pre_training_report.as_ref()
    }
    /// <p></p>
    pub fn post_training_report(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.post_training_report.as_ref()
    }
}
impl std::fmt::Debug for Bias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Bias");
        formatter.field("report", &self.report);
        formatter.field("pre_training_report", &self.pre_training_report);
        formatter.field("post_training_report", &self.post_training_report);
        formatter.finish()
    }
}
/// See [`Bias`](crate::model::Bias)
pub mod bias {

    /// A builder for [`Bias`](crate::model::Bias)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) report: std::option::Option<crate::model::MetricsSource>,
        pub(crate) pre_training_report: std::option::Option<crate::model::MetricsSource>,
        pub(crate) post_training_report: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>The bias report for a model</p>
        pub fn report(mut self, input: crate::model::MetricsSource) -> Self {
            self.report = Some(input);
            self
        }
        /// <p>The bias report for a model</p>
        pub fn set_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.report = input;
            self
        }
        /// <p></p>
        pub fn pre_training_report(mut self, input: crate::model::MetricsSource) -> Self {
            self.pre_training_report = Some(input);
            self
        }
        /// <p></p>
        pub fn set_pre_training_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.pre_training_report = input;
            self
        }
        /// <p></p>
        pub fn post_training_report(mut self, input: crate::model::MetricsSource) -> Self {
            self.post_training_report = Some(input);
            self
        }
        /// <p></p>
        pub fn set_post_training_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.post_training_report = input;
            self
        }
        /// Consumes the builder and constructs a [`Bias`](crate::model::Bias)
        pub fn build(self) -> crate::model::Bias {
            crate::model::Bias {
                report: self.report,
                pre_training_report: self.pre_training_report,
                post_training_report: self.post_training_report,
            }
        }
    }
}
impl Bias {
    /// Creates a new builder-style object to manufacture [`Bias`](crate::model::Bias)
    pub fn builder() -> crate::model::bias::Builder {
        crate::model::bias::Builder::default()
    }
}

/// <p>Data quality constraints and statistics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDataQuality {
    /// <p>Data quality statistics for a model.</p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p>Data quality constraints for a model.</p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl ModelDataQuality {
    /// <p>Data quality statistics for a model.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.statistics.as_ref()
    }
    /// <p>Data quality constraints for a model.</p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.constraints.as_ref()
    }
}
impl std::fmt::Debug for ModelDataQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDataQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`ModelDataQuality`](crate::model::ModelDataQuality)
pub mod model_data_quality {

    /// A builder for [`ModelDataQuality`](crate::model::ModelDataQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>Data quality statistics for a model.</p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>Data quality statistics for a model.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>Data quality constraints for a model.</p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p>Data quality constraints for a model.</p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDataQuality`](crate::model::ModelDataQuality)
        pub fn build(self) -> crate::model::ModelDataQuality {
            crate::model::ModelDataQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl ModelDataQuality {
    /// Creates a new builder-style object to manufacture [`ModelDataQuality`](crate::model::ModelDataQuality)
    pub fn builder() -> crate::model::model_data_quality::Builder {
        crate::model::model_data_quality::Builder::default()
    }
}

/// <p>Model quality statistics and constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQuality {
    /// <p>Model quality statistics.</p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p>Model quality constraints.</p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl ModelQuality {
    /// <p>Model quality statistics.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.statistics.as_ref()
    }
    /// <p>Model quality constraints.</p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::MetricsSource> {
        self.constraints.as_ref()
    }
}
impl std::fmt::Debug for ModelQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`ModelQuality`](crate::model::ModelQuality)
pub mod model_quality {

    /// A builder for [`ModelQuality`](crate::model::ModelQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>Model quality statistics.</p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>Model quality statistics.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>Model quality constraints.</p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p>Model quality constraints.</p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQuality`](crate::model::ModelQuality)
        pub fn build(self) -> crate::model::ModelQuality {
            crate::model::ModelQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl ModelQuality {
    /// Creates a new builder-style object to manufacture [`ModelQuality`](crate::model::ModelQuality)
    pub fn builder() -> crate::model::model_quality::Builder {
        crate::model::model_quality::Builder::default()
    }
}

/// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetadataProperties {
    /// <p>The commit ID.</p>
    pub commit_id: std::option::Option<std::string::String>,
    /// <p>The repository.</p>
    pub repository: std::option::Option<std::string::String>,
    /// <p>The entity this entity was generated by.</p>
    pub generated_by: std::option::Option<std::string::String>,
    /// <p>The project ID.</p>
    pub project_id: std::option::Option<std::string::String>,
}
impl MetadataProperties {
    /// <p>The commit ID.</p>
    pub fn commit_id(&self) -> std::option::Option<&str> {
        self.commit_id.as_deref()
    }
    /// <p>The repository.</p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>The entity this entity was generated by.</p>
    pub fn generated_by(&self) -> std::option::Option<&str> {
        self.generated_by.as_deref()
    }
    /// <p>The project ID.</p>
    pub fn project_id(&self) -> std::option::Option<&str> {
        self.project_id.as_deref()
    }
}
impl std::fmt::Debug for MetadataProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetadataProperties");
        formatter.field("commit_id", &self.commit_id);
        formatter.field("repository", &self.repository);
        formatter.field("generated_by", &self.generated_by);
        formatter.field("project_id", &self.project_id);
        formatter.finish()
    }
}
/// See [`MetadataProperties`](crate::model::MetadataProperties)
pub mod metadata_properties {

    /// A builder for [`MetadataProperties`](crate::model::MetadataProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) commit_id: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) generated_by: std::option::Option<std::string::String>,
        pub(crate) project_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The commit ID.</p>
        pub fn commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.commit_id = Some(input.into());
            self
        }
        /// <p>The commit ID.</p>
        pub fn set_commit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.commit_id = input;
            self
        }
        /// <p>The repository.</p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The repository.</p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The entity this entity was generated by.</p>
        pub fn generated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_by = Some(input.into());
            self
        }
        /// <p>The entity this entity was generated by.</p>
        pub fn set_generated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.generated_by = input;
            self
        }
        /// <p>The project ID.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The project ID.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MetadataProperties`](crate::model::MetadataProperties)
        pub fn build(self) -> crate::model::MetadataProperties {
            crate::model::MetadataProperties {
                commit_id: self.commit_id,
                repository: self.repository,
                generated_by: self.generated_by,
                project_id: self.project_id,
            }
        }
    }
}
impl MetadataProperties {
    /// Creates a new builder-style object to manufacture [`MetadataProperties`](crate::model::MetadataProperties)
    pub fn builder() -> crate::model::metadata_properties::Builder {
        crate::model::metadata_properties::Builder::default()
    }
}

/// <p>Specifies the validation and image scan statuses of the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageStatusDetails {
    /// <p>The validation status of the model package.</p>
    pub validation_statuses:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
    /// <p>The status of the scan of the Docker image container for the model package.</p>
    pub image_scan_statuses:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
}
impl ModelPackageStatusDetails {
    /// <p>The validation status of the model package.</p>
    pub fn validation_statuses(
        &self,
    ) -> std::option::Option<&[crate::model::ModelPackageStatusItem]> {
        self.validation_statuses.as_deref()
    }
    /// <p>The status of the scan of the Docker image container for the model package.</p>
    pub fn image_scan_statuses(
        &self,
    ) -> std::option::Option<&[crate::model::ModelPackageStatusItem]> {
        self.image_scan_statuses.as_deref()
    }
}
impl std::fmt::Debug for ModelPackageStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageStatusDetails");
        formatter.field("validation_statuses", &self.validation_statuses);
        formatter.field("image_scan_statuses", &self.image_scan_statuses);
        formatter.finish()
    }
}
/// See [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
pub mod model_package_status_details {

    /// A builder for [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_statuses:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        pub(crate) image_scan_statuses:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
    }
    impl Builder {
        /// Appends an item to `validation_statuses`.
        ///
        /// To override the contents of this collection use [`set_validation_statuses`](Self::set_validation_statuses).
        ///
        /// <p>The validation status of the model package.</p>
        pub fn validation_statuses(mut self, input: crate::model::ModelPackageStatusItem) -> Self {
            let mut v = self.validation_statuses.unwrap_or_default();
            v.push(input);
            self.validation_statuses = Some(v);
            self
        }
        /// <p>The validation status of the model package.</p>
        pub fn set_validation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        ) -> Self {
            self.validation_statuses = input;
            self
        }
        /// Appends an item to `image_scan_statuses`.
        ///
        /// To override the contents of this collection use [`set_image_scan_statuses`](Self::set_image_scan_statuses).
        ///
        /// <p>The status of the scan of the Docker image container for the model package.</p>
        pub fn image_scan_statuses(mut self, input: crate::model::ModelPackageStatusItem) -> Self {
            let mut v = self.image_scan_statuses.unwrap_or_default();
            v.push(input);
            self.image_scan_statuses = Some(v);
            self
        }
        /// <p>The status of the scan of the Docker image container for the model package.</p>
        pub fn set_image_scan_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        ) -> Self {
            self.image_scan_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
        pub fn build(self) -> crate::model::ModelPackageStatusDetails {
            crate::model::ModelPackageStatusDetails {
                validation_statuses: self.validation_statuses,
                image_scan_statuses: self.image_scan_statuses,
            }
        }
    }
}
impl ModelPackageStatusDetails {
    /// Creates a new builder-style object to manufacture [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
    pub fn builder() -> crate::model::model_package_status_details::Builder {
        crate::model::model_package_status_details::Builder::default()
    }
}

/// <p>Represents the overall status of a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageStatusItem {
    /// <p>The name of the model package for which the overall status is being reported.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status.</p>
    pub status: std::option::Option<crate::model::DetailedModelPackageStatus>,
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl ModelPackageStatusItem {
    /// <p>The name of the model package for which the overall status is being reported.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DetailedModelPackageStatus> {
        self.status.as_ref()
    }
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for ModelPackageStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageStatusItem");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
pub mod model_package_status_item {

    /// A builder for [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DetailedModelPackageStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the model package for which the overall status is being reported.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the model package for which the overall status is being reported.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current status.</p>
        pub fn status(mut self, input: crate::model::DetailedModelPackageStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DetailedModelPackageStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
        pub fn build(self) -> crate::model::ModelPackageStatusItem {
            crate::model::ModelPackageStatusItem {
                name: self.name,
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl ModelPackageStatusItem {
    /// Creates a new builder-style object to manufacture [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
    pub fn builder() -> crate::model::model_package_status_item::Builder {
        crate::model::model_package_status_item::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetailedModelPackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DetailedModelPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => DetailedModelPackageStatus::Completed,
            "Failed" => DetailedModelPackageStatus::Failed,
            "InProgress" => DetailedModelPackageStatus::InProgress,
            "NotStarted" => DetailedModelPackageStatus::NotStarted,
            other => DetailedModelPackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DetailedModelPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetailedModelPackageStatus::from(s))
    }
}
impl DetailedModelPackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DetailedModelPackageStatus::Completed => "Completed",
            DetailedModelPackageStatus::Failed => "Failed",
            DetailedModelPackageStatus::InProgress => "InProgress",
            DetailedModelPackageStatus::NotStarted => "NotStarted",
            DetailedModelPackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "NotStarted"]
    }
}
impl AsRef<str> for DetailedModelPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ModelPackageStatus::Completed,
            "Deleting" => ModelPackageStatus::Deleting,
            "Failed" => ModelPackageStatus::Failed,
            "InProgress" => ModelPackageStatus::InProgress,
            "Pending" => ModelPackageStatus::Pending,
            other => ModelPackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageStatus::from(s))
    }
}
impl ModelPackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageStatus::Completed => "Completed",
            ModelPackageStatus::Deleting => "Deleting",
            ModelPackageStatus::Failed => "Failed",
            ModelPackageStatus::InProgress => "InProgress",
            ModelPackageStatus::Pending => "Pending",
            ModelPackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Deleting", "Failed", "InProgress", "Pending"]
    }
}
impl AsRef<str> for ModelPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies batch transform jobs that SageMaker runs to validate your model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageValidationSpecification {
    /// <p>The IAM roles to be used for the validation of the model package.</p>
    pub validation_role: std::option::Option<std::string::String>,
    /// <p>An array of <code>ModelPackageValidationProfile</code> objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.</p>
    pub validation_profiles:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
}
impl ModelPackageValidationSpecification {
    /// <p>The IAM roles to be used for the validation of the model package.</p>
    pub fn validation_role(&self) -> std::option::Option<&str> {
        self.validation_role.as_deref()
    }
    /// <p>An array of <code>ModelPackageValidationProfile</code> objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.</p>
    pub fn validation_profiles(
        &self,
    ) -> std::option::Option<&[crate::model::ModelPackageValidationProfile]> {
        self.validation_profiles.as_deref()
    }
}
impl std::fmt::Debug for ModelPackageValidationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageValidationSpecification");
        formatter.field("validation_role", &self.validation_role);
        formatter.field("validation_profiles", &self.validation_profiles);
        formatter.finish()
    }
}
/// See [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
pub mod model_package_validation_specification {

    /// A builder for [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_role: std::option::Option<std::string::String>,
        pub(crate) validation_profiles:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
    }
    impl Builder {
        /// <p>The IAM roles to be used for the validation of the model package.</p>
        pub fn validation_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_role = Some(input.into());
            self
        }
        /// <p>The IAM roles to be used for the validation of the model package.</p>
        pub fn set_validation_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_role = input;
            self
        }
        /// Appends an item to `validation_profiles`.
        ///
        /// To override the contents of this collection use [`set_validation_profiles`](Self::set_validation_profiles).
        ///
        /// <p>An array of <code>ModelPackageValidationProfile</code> objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.</p>
        pub fn validation_profiles(
            mut self,
            input: crate::model::ModelPackageValidationProfile,
        ) -> Self {
            let mut v = self.validation_profiles.unwrap_or_default();
            v.push(input);
            self.validation_profiles = Some(v);
            self
        }
        /// <p>An array of <code>ModelPackageValidationProfile</code> objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.</p>
        pub fn set_validation_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
        ) -> Self {
            self.validation_profiles = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
        pub fn build(self) -> crate::model::ModelPackageValidationSpecification {
            crate::model::ModelPackageValidationSpecification {
                validation_role: self.validation_role,
                validation_profiles: self.validation_profiles,
            }
        }
    }
}
impl ModelPackageValidationSpecification {
    /// Creates a new builder-style object to manufacture [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
    pub fn builder() -> crate::model::model_package_validation_specification::Builder {
        crate::model::model_package_validation_specification::Builder::default()
    }
}

/// <p>Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.</p>
/// <p>The data provided in the validation profile is made available to your buyers on Amazon Web Services Marketplace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageValidationProfile {
    /// <p>The name of the profile for the model package.</p>
    pub profile_name: std::option::Option<std::string::String>,
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used for the validation of the model package.</p>
    pub transform_job_definition: std::option::Option<crate::model::TransformJobDefinition>,
}
impl ModelPackageValidationProfile {
    /// <p>The name of the profile for the model package.</p>
    pub fn profile_name(&self) -> std::option::Option<&str> {
        self.profile_name.as_deref()
    }
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used for the validation of the model package.</p>
    pub fn transform_job_definition(
        &self,
    ) -> std::option::Option<&crate::model::TransformJobDefinition> {
        self.transform_job_definition.as_ref()
    }
}
impl std::fmt::Debug for ModelPackageValidationProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageValidationProfile");
        formatter.field("profile_name", &self.profile_name);
        formatter.field("transform_job_definition", &self.transform_job_definition);
        formatter.finish()
    }
}
/// See [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
pub mod model_package_validation_profile {

    /// A builder for [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_definition:
            std::option::Option<crate::model::TransformJobDefinition>,
    }
    impl Builder {
        /// <p>The name of the profile for the model package.</p>
        pub fn profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_name = Some(input.into());
            self
        }
        /// <p>The name of the profile for the model package.</p>
        pub fn set_profile_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_name = input;
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used for the validation of the model package.</p>
        pub fn transform_job_definition(
            mut self,
            input: crate::model::TransformJobDefinition,
        ) -> Self {
            self.transform_job_definition = Some(input);
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used for the validation of the model package.</p>
        pub fn set_transform_job_definition(
            mut self,
            input: std::option::Option<crate::model::TransformJobDefinition>,
        ) -> Self {
            self.transform_job_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
        pub fn build(self) -> crate::model::ModelPackageValidationProfile {
            crate::model::ModelPackageValidationProfile {
                profile_name: self.profile_name,
                transform_job_definition: self.transform_job_definition,
            }
        }
    }
}
impl ModelPackageValidationProfile {
    /// Creates a new builder-style object to manufacture [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
    pub fn builder() -> crate::model::model_package_validation_profile::Builder {
        crate::model::model_package_validation_profile::Builder::default()
    }
}

/// <p>Defines the input needed to run a transform job using the inference specification specified in the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobDefinition {
    /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.</p>
    pub max_concurrent_transforms: std::option::Option<i32>,
    /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).</p>
    pub max_payload_in_mb: std::option::Option<i32>,
    /// <p>A string that determines the number of records included in a single mini-batch.</p>
    /// <p> <code>SingleRecord</code> means only one record is used per mini-batch. <code>MultiRecord</code> means a mini-batch is set to contain as many records that can fit within the <code>MaxPayloadInMB</code> limit.</p>
    pub batch_strategy: std::option::Option<crate::model::BatchStrategy>,
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A description of the input source and the way the transform job consumes it.</p>
    pub transform_input: std::option::Option<crate::model::TransformInput>,
    /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.</p>
    pub transform_output: std::option::Option<crate::model::TransformOutput>,
    /// <p>Identifies the ML compute instances for the transform job.</p>
    pub transform_resources: std::option::Option<crate::model::TransformResources>,
}
impl TransformJobDefinition {
    /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.</p>
    pub fn max_concurrent_transforms(&self) -> std::option::Option<i32> {
        self.max_concurrent_transforms
    }
    /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).</p>
    pub fn max_payload_in_mb(&self) -> std::option::Option<i32> {
        self.max_payload_in_mb
    }
    /// <p>A string that determines the number of records included in a single mini-batch.</p>
    /// <p> <code>SingleRecord</code> means only one record is used per mini-batch. <code>MultiRecord</code> means a mini-batch is set to contain as many records that can fit within the <code>MaxPayloadInMB</code> limit.</p>
    pub fn batch_strategy(&self) -> std::option::Option<&crate::model::BatchStrategy> {
        self.batch_strategy.as_ref()
    }
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>A description of the input source and the way the transform job consumes it.</p>
    pub fn transform_input(&self) -> std::option::Option<&crate::model::TransformInput> {
        self.transform_input.as_ref()
    }
    /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.</p>
    pub fn transform_output(&self) -> std::option::Option<&crate::model::TransformOutput> {
        self.transform_output.as_ref()
    }
    /// <p>Identifies the ML compute instances for the transform job.</p>
    pub fn transform_resources(&self) -> std::option::Option<&crate::model::TransformResources> {
        self.transform_resources.as_ref()
    }
}
impl std::fmt::Debug for TransformJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobDefinition");
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.finish()
    }
}
/// See [`TransformJobDefinition`](crate::model::TransformJobDefinition)
pub mod transform_job_definition {

    /// A builder for [`TransformJobDefinition`](crate::model::TransformJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_concurrent_transforms: std::option::Option<i32>,
        pub(crate) max_payload_in_mb: std::option::Option<i32>,
        pub(crate) batch_strategy: std::option::Option<crate::model::BatchStrategy>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transform_input: std::option::Option<crate::model::TransformInput>,
        pub(crate) transform_output: std::option::Option<crate::model::TransformOutput>,
        pub(crate) transform_resources: std::option::Option<crate::model::TransformResources>,
    }
    impl Builder {
        /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.</p>
        pub fn max_concurrent_transforms(mut self, input: i32) -> Self {
            self.max_concurrent_transforms = Some(input);
            self
        }
        /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.</p>
        pub fn set_max_concurrent_transforms(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_transforms = input;
            self
        }
        /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).</p>
        pub fn max_payload_in_mb(mut self, input: i32) -> Self {
            self.max_payload_in_mb = Some(input);
            self
        }
        /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).</p>
        pub fn set_max_payload_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.max_payload_in_mb = input;
            self
        }
        /// <p>A string that determines the number of records included in a single mini-batch.</p>
        /// <p> <code>SingleRecord</code> means only one record is used per mini-batch. <code>MultiRecord</code> means a mini-batch is set to contain as many records that can fit within the <code>MaxPayloadInMB</code> limit.</p>
        pub fn batch_strategy(mut self, input: crate::model::BatchStrategy) -> Self {
            self.batch_strategy = Some(input);
            self
        }
        /// <p>A string that determines the number of records included in a single mini-batch.</p>
        /// <p> <code>SingleRecord</code> means only one record is used per mini-batch. <code>MultiRecord</code> means a mini-batch is set to contain as many records that can fit within the <code>MaxPayloadInMB</code> limit.</p>
        pub fn set_batch_strategy(
            mut self,
            input: std::option::Option<crate::model::BatchStrategy>,
        ) -> Self {
            self.batch_strategy = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>A description of the input source and the way the transform job consumes it.</p>
        pub fn transform_input(mut self, input: crate::model::TransformInput) -> Self {
            self.transform_input = Some(input);
            self
        }
        /// <p>A description of the input source and the way the transform job consumes it.</p>
        pub fn set_transform_input(
            mut self,
            input: std::option::Option<crate::model::TransformInput>,
        ) -> Self {
            self.transform_input = input;
            self
        }
        /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.</p>
        pub fn transform_output(mut self, input: crate::model::TransformOutput) -> Self {
            self.transform_output = Some(input);
            self
        }
        /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.</p>
        pub fn set_transform_output(
            mut self,
            input: std::option::Option<crate::model::TransformOutput>,
        ) -> Self {
            self.transform_output = input;
            self
        }
        /// <p>Identifies the ML compute instances for the transform job.</p>
        pub fn transform_resources(mut self, input: crate::model::TransformResources) -> Self {
            self.transform_resources = Some(input);
            self
        }
        /// <p>Identifies the ML compute instances for the transform job.</p>
        pub fn set_transform_resources(
            mut self,
            input: std::option::Option<crate::model::TransformResources>,
        ) -> Self {
            self.transform_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobDefinition`](crate::model::TransformJobDefinition)
        pub fn build(self) -> crate::model::TransformJobDefinition {
            crate::model::TransformJobDefinition {
                max_concurrent_transforms: self.max_concurrent_transforms,
                max_payload_in_mb: self.max_payload_in_mb,
                batch_strategy: self.batch_strategy,
                environment: self.environment,
                transform_input: self.transform_input,
                transform_output: self.transform_output,
                transform_resources: self.transform_resources,
            }
        }
    }
}
impl TransformJobDefinition {
    /// Creates a new builder-style object to manufacture [`TransformJobDefinition`](crate::model::TransformJobDefinition)
    pub fn builder() -> crate::model::transform_job_definition::Builder {
        crate::model::transform_job_definition::Builder::default()
    }
}

/// <p>Describes the resources, including ML instance types and ML instance count, to use for transform job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformResources {
    /// <p>The ML compute instance type for the transform job. If you are using built-in algorithms to transform moderately sized datasets, we recommend using ml.m4.xlarge or <code>ml.m5.large</code>instance types.</p>
    pub instance_type: std::option::Option<crate::model::TransformInstanceType>,
    /// <p>The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is <code>1</code>.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.</p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    /// <p> The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl TransformResources {
    /// <p>The ML compute instance type for the transform job. If you are using built-in algorithms to transform moderately sized datasets, we recommend using ml.m4.xlarge or <code>ml.m5.large</code>instance types.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::TransformInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is <code>1</code>.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.</p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    /// <p> The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for TransformResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformResources");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`TransformResources`](crate::model::TransformResources)
pub mod transform_resources {

    /// A builder for [`TransformResources`](crate::model::TransformResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::TransformInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ML compute instance type for the transform job. If you are using built-in algorithms to transform moderately sized datasets, we recommend using ml.m4.xlarge or <code>ml.m5.large</code>instance types.</p>
        pub fn instance_type(mut self, input: crate::model::TransformInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The ML compute instance type for the transform job. If you are using built-in algorithms to transform moderately sized datasets, we recommend using ml.m4.xlarge or <code>ml.m5.large</code>instance types.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::TransformInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is <code>1</code>.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is <code>1</code>.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.</p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        /// <p> The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.</p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        /// <p> The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformResources`](crate::model::TransformResources)
        pub fn build(self) -> crate::model::TransformResources {
            crate::model::TransformResources {
                instance_type: self.instance_type,
                instance_count: self.instance_count,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl TransformResources {
    /// Creates a new builder-style object to manufacture [`TransformResources`](crate::model::TransformResources)
    pub fn builder() -> crate::model::transform_resources::Builder {
        crate::model::transform_resources::Builder::default()
    }
}

/// <p>Describes the results of a transform job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformOutput {
    /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    /// <p>For every S3 object used as input for the transform job, batch transform stores the transformed data with an .<code>out</code> suffix in a corresponding subfolder in the location in the output prefix. For example, for the input data stored at <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform stores the transformed data at <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>. Batch transform doesn't upload partially processed objects. For an input S3 object that contains multiple records, it creates an .<code>out</code> file only if the transform job succeeds on the entire file. When the input contains multiple S3 objects, the batch transform job processes the listed S3 objects and uploads only the output for successfully processed objects. If any object fails in the transform job batch transform marks the job as failed to prompt investigation.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.</p>
    pub accept: std::option::Option<std::string::String>,
    /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose a format that is most convenient to you. To concatenate the results in binary format, specify <code>None</code>. To add a newline character at the end of every transformed record, specify <code>Line</code>.</p>
    pub assemble_with: std::option::Option<crate::model::AssemblyType>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateModel.html">CreateModel</a> request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl TransformOutput {
    /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    /// <p>For every S3 object used as input for the transform job, batch transform stores the transformed data with an .<code>out</code> suffix in a corresponding subfolder in the location in the output prefix. For example, for the input data stored at <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform stores the transformed data at <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>. Batch transform doesn't upload partially processed objects. For an input S3 object that contains multiple records, it creates an .<code>out</code> file only if the transform job succeeds on the entire file. When the input contains multiple S3 objects, the batch transform job processes the listed S3 objects and uploads only the output for successfully processed objects. If any object fails in the transform job batch transform marks the job as failed to prompt investigation.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.</p>
    pub fn accept(&self) -> std::option::Option<&str> {
        self.accept.as_deref()
    }
    /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose a format that is most convenient to you. To concatenate the results in binary format, specify <code>None</code>. To add a newline character at the end of every transformed record, specify <code>Line</code>.</p>
    pub fn assemble_with(&self) -> std::option::Option<&crate::model::AssemblyType> {
        self.assemble_with.as_ref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateModel.html">CreateModel</a> request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for TransformOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformOutput");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("accept", &self.accept);
        formatter.field("assemble_with", &self.assemble_with);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`TransformOutput`](crate::model::TransformOutput)
pub mod transform_output {

    /// A builder for [`TransformOutput`](crate::model::TransformOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) accept: std::option::Option<std::string::String>,
        pub(crate) assemble_with: std::option::Option<crate::model::AssemblyType>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        /// <p>For every S3 object used as input for the transform job, batch transform stores the transformed data with an .<code>out</code> suffix in a corresponding subfolder in the location in the output prefix. For example, for the input data stored at <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform stores the transformed data at <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>. Batch transform doesn't upload partially processed objects. For an input S3 object that contains multiple records, it creates an .<code>out</code> file only if the transform job succeeds on the entire file. When the input contains multiple S3 objects, the batch transform job processes the listed S3 objects and uploads only the output for successfully processed objects. If any object fails in the transform job batch transform marks the job as failed to prompt investigation.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        /// <p>For every S3 object used as input for the transform job, batch transform stores the transformed data with an .<code>out</code> suffix in a corresponding subfolder in the location in the output prefix. For example, for the input data stored at <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform stores the transformed data at <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>. Batch transform doesn't upload partially processed objects. For an input S3 object that contains multiple records, it creates an .<code>out</code> file only if the transform job succeeds on the entire file. When the input contains multiple S3 objects, the batch transform job processes the listed S3 objects and uploads only the output for successfully processed objects. If any object fails in the transform job batch transform marks the job as failed to prompt investigation.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.</p>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept = Some(input.into());
            self
        }
        /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.</p>
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accept = input;
            self
        }
        /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose a format that is most convenient to you. To concatenate the results in binary format, specify <code>None</code>. To add a newline character at the end of every transformed record, specify <code>Line</code>.</p>
        pub fn assemble_with(mut self, input: crate::model::AssemblyType) -> Self {
            self.assemble_with = Some(input);
            self
        }
        /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose a format that is most convenient to you. To concatenate the results in binary format, specify <code>None</code>. To add a newline character at the end of every transformed record, specify <code>Line</code>.</p>
        pub fn set_assemble_with(
            mut self,
            input: std::option::Option<crate::model::AssemblyType>,
        ) -> Self {
            self.assemble_with = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateModel.html">CreateModel</a> request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateModel.html">CreateModel</a> request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformOutput`](crate::model::TransformOutput)
        pub fn build(self) -> crate::model::TransformOutput {
            crate::model::TransformOutput {
                s3_output_path: self.s3_output_path,
                accept: self.accept,
                assemble_with: self.assemble_with,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl TransformOutput {
    /// Creates a new builder-style object to manufacture [`TransformOutput`](crate::model::TransformOutput)
    pub fn builder() -> crate::model::transform_output::Builder {
        crate::model::transform_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssemblyType {
    #[allow(missing_docs)] // documentation missing in model
    Line,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssemblyType {
    fn from(s: &str) -> Self {
        match s {
            "Line" => AssemblyType::Line,
            "None" => AssemblyType::None,
            other => AssemblyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssemblyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssemblyType::from(s))
    }
}
impl AssemblyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssemblyType::Line => "Line",
            AssemblyType::None => "None",
            AssemblyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Line", "None"]
    }
}
impl AsRef<str> for AssemblyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the input source of a transform job and the way the transform job consumes it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformInput {
    /// <p>Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.</p>
    pub data_source: std::option::Option<crate::model::TransformDataSource>,
    /// <p>The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is <code>None</code>.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>The method to use to split the transform job's data files into smaller batches. Splitting is necessary when the total size of each object is too large to fit in a single request. You can also use data splitting to improve performance by processing multiple concurrent mini-batches. The default value for <code>SplitType</code> is <code>None</code>, which indicates that input data files are not split, and request payloads contain the entire contents of an input object. Set the value of this parameter to <code>Line</code> to split records on a newline character boundary. <code>SplitType</code> also supports a number of record-oriented binary data formats. Currently, the supported record formats are:</p>
    /// <ul>
    /// <li> <p>RecordIO</p> </li>
    /// <li> <p>TFRecord</p> </li>
    /// </ul>
    /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual records in each request.</p> <note>
    /// <p>Some data formats represent a record as a binary payload wrapped with extra padding bytes. When splitting is applied to a binary data format, padding is removed if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>. Padding is not removed if the value of <code>BatchStrategy</code> is set to <code>MultiRecord</code>.</p>
    /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using RecordIO</a> in the MXNet documentation. For more information about <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
    /// </note>
    pub split_type: std::option::Option<crate::model::SplitType>,
}
impl TransformInput {
    /// <p>Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::TransformDataSource> {
        self.data_source.as_ref()
    }
    /// <p>The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is <code>None</code>.</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>The method to use to split the transform job's data files into smaller batches. Splitting is necessary when the total size of each object is too large to fit in a single request. You can also use data splitting to improve performance by processing multiple concurrent mini-batches. The default value for <code>SplitType</code> is <code>None</code>, which indicates that input data files are not split, and request payloads contain the entire contents of an input object. Set the value of this parameter to <code>Line</code> to split records on a newline character boundary. <code>SplitType</code> also supports a number of record-oriented binary data formats. Currently, the supported record formats are:</p>
    /// <ul>
    /// <li> <p>RecordIO</p> </li>
    /// <li> <p>TFRecord</p> </li>
    /// </ul>
    /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual records in each request.</p> <note>
    /// <p>Some data formats represent a record as a binary payload wrapped with extra padding bytes. When splitting is applied to a binary data format, padding is removed if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>. Padding is not removed if the value of <code>BatchStrategy</code> is set to <code>MultiRecord</code>.</p>
    /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using RecordIO</a> in the MXNet documentation. For more information about <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
    /// </note>
    pub fn split_type(&self) -> std::option::Option<&crate::model::SplitType> {
        self.split_type.as_ref()
    }
}
impl std::fmt::Debug for TransformInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformInput");
        formatter.field("data_source", &self.data_source);
        formatter.field("content_type", &self.content_type);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("split_type", &self.split_type);
        formatter.finish()
    }
}
/// See [`TransformInput`](crate::model::TransformInput)
pub mod transform_input {

    /// A builder for [`TransformInput`](crate::model::TransformInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::TransformDataSource>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) split_type: std::option::Option<crate::model::SplitType>,
    }
    impl Builder {
        /// <p>Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.</p>
        pub fn data_source(mut self, input: crate::model::TransformDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::TransformDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is <code>None</code>.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is <code>None</code>.</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p>The method to use to split the transform job's data files into smaller batches. Splitting is necessary when the total size of each object is too large to fit in a single request. You can also use data splitting to improve performance by processing multiple concurrent mini-batches. The default value for <code>SplitType</code> is <code>None</code>, which indicates that input data files are not split, and request payloads contain the entire contents of an input object. Set the value of this parameter to <code>Line</code> to split records on a newline character boundary. <code>SplitType</code> also supports a number of record-oriented binary data formats. Currently, the supported record formats are:</p>
        /// <ul>
        /// <li> <p>RecordIO</p> </li>
        /// <li> <p>TFRecord</p> </li>
        /// </ul>
        /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual records in each request.</p> <note>
        /// <p>Some data formats represent a record as a binary payload wrapped with extra padding bytes. When splitting is applied to a binary data format, padding is removed if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>. Padding is not removed if the value of <code>BatchStrategy</code> is set to <code>MultiRecord</code>.</p>
        /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using RecordIO</a> in the MXNet documentation. For more information about <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
        /// </note>
        pub fn split_type(mut self, input: crate::model::SplitType) -> Self {
            self.split_type = Some(input);
            self
        }
        /// <p>The method to use to split the transform job's data files into smaller batches. Splitting is necessary when the total size of each object is too large to fit in a single request. You can also use data splitting to improve performance by processing multiple concurrent mini-batches. The default value for <code>SplitType</code> is <code>None</code>, which indicates that input data files are not split, and request payloads contain the entire contents of an input object. Set the value of this parameter to <code>Line</code> to split records on a newline character boundary. <code>SplitType</code> also supports a number of record-oriented binary data formats. Currently, the supported record formats are:</p>
        /// <ul>
        /// <li> <p>RecordIO</p> </li>
        /// <li> <p>TFRecord</p> </li>
        /// </ul>
        /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual records in each request.</p> <note>
        /// <p>Some data formats represent a record as a binary payload wrapped with extra padding bytes. When splitting is applied to a binary data format, padding is removed if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>. Padding is not removed if the value of <code>BatchStrategy</code> is set to <code>MultiRecord</code>.</p>
        /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using RecordIO</a> in the MXNet documentation. For more information about <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
        /// </note>
        pub fn set_split_type(
            mut self,
            input: std::option::Option<crate::model::SplitType>,
        ) -> Self {
            self.split_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformInput`](crate::model::TransformInput)
        pub fn build(self) -> crate::model::TransformInput {
            crate::model::TransformInput {
                data_source: self.data_source,
                content_type: self.content_type,
                compression_type: self.compression_type,
                split_type: self.split_type,
            }
        }
    }
}
impl TransformInput {
    /// Creates a new builder-style object to manufacture [`TransformInput`](crate::model::TransformInput)
    pub fn builder() -> crate::model::transform_input::Builder {
        crate::model::transform_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SplitType {
    #[allow(missing_docs)] // documentation missing in model
    Line,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Recordio,
    #[allow(missing_docs)] // documentation missing in model
    Tfrecord,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SplitType {
    fn from(s: &str) -> Self {
        match s {
            "Line" => SplitType::Line,
            "None" => SplitType::None,
            "RecordIO" => SplitType::Recordio,
            "TFRecord" => SplitType::Tfrecord,
            other => SplitType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SplitType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SplitType::from(s))
    }
}
impl SplitType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SplitType::Line => "Line",
            SplitType::None => "None",
            SplitType::Recordio => "RecordIO",
            SplitType::Tfrecord => "TFRecord",
            SplitType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Line", "None", "RecordIO", "TFRecord"]
    }
}
impl AsRef<str> for SplitType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CompressionType {
    fn from(s: &str) -> Self {
        match s {
            "Gzip" => CompressionType::Gzip,
            "None" => CompressionType::None,
            other => CompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CompressionType::from(s))
    }
}
impl CompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CompressionType::Gzip => "Gzip",
            CompressionType::None => "None",
            CompressionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Gzip", "None"]
    }
}
impl AsRef<str> for CompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the location of the channel data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformDataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub s3_data_source: std::option::Option<crate::model::TransformS3DataSource>,
}
impl TransformDataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub fn s3_data_source(&self) -> std::option::Option<&crate::model::TransformS3DataSource> {
        self.s3_data_source.as_ref()
    }
}
impl std::fmt::Debug for TransformDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.finish()
    }
}
/// See [`TransformDataSource`](crate::model::TransformDataSource)
pub mod transform_data_source {

    /// A builder for [`TransformDataSource`](crate::model::TransformDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::TransformS3DataSource>,
    }
    impl Builder {
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn s3_data_source(mut self, input: crate::model::TransformS3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::TransformS3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformDataSource`](crate::model::TransformDataSource)
        pub fn build(self) -> crate::model::TransformDataSource {
            crate::model::TransformDataSource {
                s3_data_source: self.s3_data_source,
            }
        }
    }
}
impl TransformDataSource {
    /// Creates a new builder-style object to manufacture [`TransformDataSource`](crate::model::TransformDataSource)
    pub fn builder() -> crate::model::transform_data_source::Builder {
        crate::model::transform_data_source::Builder::default()
    }
}

/// <p>Describes the S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformS3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform. </p>
    /// <p>The following values are compatible: <code>ManifestFile</code>, <code>S3Prefix</code> </p>
    /// <p>The following value is not compatible: <code>AugmentedManifestFile</code> </p>
    pub s3_data_type: std::option::Option<crate::model::S3DataType>,
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example:</p>
    /// <ul>
    /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code>. </p> </li>
    /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> The manifest is an S3 object which is a JSON file with the following format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code>"relative/path/to/custdata-1",</code> </p> <p> <code>"relative/path/custdata-2",</code> </p> <p> <code>...</code> </p> <p> <code>"relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> The preceding JSON matches the following <code>S3Uris</code>: </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p> The complete set of <code>S3Uris</code> in this manifest constitutes the input data for the channel for this datasource. The object that each <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.</p> </li>
    /// </ul>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl TransformS3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform. </p>
    /// <p>The following values are compatible: <code>ManifestFile</code>, <code>S3Prefix</code> </p>
    /// <p>The following value is not compatible: <code>AugmentedManifestFile</code> </p>
    pub fn s3_data_type(&self) -> std::option::Option<&crate::model::S3DataType> {
        self.s3_data_type.as_ref()
    }
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example:</p>
    /// <ul>
    /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code>. </p> </li>
    /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> The manifest is an S3 object which is a JSON file with the following format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code>"relative/path/to/custdata-1",</code> </p> <p> <code>"relative/path/custdata-2",</code> </p> <p> <code>...</code> </p> <p> <code>"relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> The preceding JSON matches the following <code>S3Uris</code>: </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p> The complete set of <code>S3Uris</code> in this manifest constitutes the input data for the channel for this datasource. The object that each <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.</p> </li>
    /// </ul>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for TransformS3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformS3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`TransformS3DataSource`](crate::model::TransformS3DataSource)
pub mod transform_s3_data_source {

    /// A builder for [`TransformS3DataSource`](crate::model::TransformS3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::S3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform. </p>
        /// <p>The following values are compatible: <code>ManifestFile</code>, <code>S3Prefix</code> </p>
        /// <p>The following value is not compatible: <code>AugmentedManifestFile</code> </p>
        pub fn s3_data_type(mut self, input: crate::model::S3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform. </p>
        /// <p>The following values are compatible: <code>ManifestFile</code>, <code>S3Prefix</code> </p>
        /// <p>The following value is not compatible: <code>AugmentedManifestFile</code> </p>
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::S3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example:</p>
        /// <ul>
        /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code>. </p> </li>
        /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> The manifest is an S3 object which is a JSON file with the following format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code>"relative/path/to/custdata-1",</code> </p> <p> <code>"relative/path/custdata-2",</code> </p> <p> <code>...</code> </p> <p> <code>"relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> The preceding JSON matches the following <code>S3Uris</code>: </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p> The complete set of <code>S3Uris</code> in this manifest constitutes the input data for the channel for this datasource. The object that each <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.</p> </li>
        /// </ul>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example:</p>
        /// <ul>
        /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code>. </p> </li>
        /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> The manifest is an S3 object which is a JSON file with the following format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code>"relative/path/to/custdata-1",</code> </p> <p> <code>"relative/path/custdata-2",</code> </p> <p> <code>...</code> </p> <p> <code>"relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> The preceding JSON matches the following <code>S3Uris</code>: </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p> The complete set of <code>S3Uris</code> in this manifest constitutes the input data for the channel for this datasource. The object that each <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.</p> </li>
        /// </ul>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformS3DataSource`](crate::model::TransformS3DataSource)
        pub fn build(self) -> crate::model::TransformS3DataSource {
            crate::model::TransformS3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl TransformS3DataSource {
    /// Creates a new builder-style object to manufacture [`TransformS3DataSource`](crate::model::TransformS3DataSource)
    pub fn builder() -> crate::model::transform_s3_data_source::Builder {
        crate::model::transform_s3_data_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3DataType {
    #[allow(missing_docs)] // documentation missing in model
    AugmentedManifestFile,
    #[allow(missing_docs)] // documentation missing in model
    ManifestFile,
    #[allow(missing_docs)] // documentation missing in model
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3DataType {
    fn from(s: &str) -> Self {
        match s {
            "AugmentedManifestFile" => S3DataType::AugmentedManifestFile,
            "ManifestFile" => S3DataType::ManifestFile,
            "S3Prefix" => S3DataType::S3Prefix,
            other => S3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3DataType::from(s))
    }
}
impl S3DataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3DataType::AugmentedManifestFile => "AugmentedManifestFile",
            S3DataType::ManifestFile => "ManifestFile",
            S3DataType::S3Prefix => "S3Prefix",
            S3DataType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AugmentedManifestFile", "ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for S3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchStrategy {
    #[allow(missing_docs)] // documentation missing in model
    MultiRecord,
    #[allow(missing_docs)] // documentation missing in model
    SingleRecord,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BatchStrategy {
    fn from(s: &str) -> Self {
        match s {
            "MultiRecord" => BatchStrategy::MultiRecord,
            "SingleRecord" => BatchStrategy::SingleRecord,
            other => BatchStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BatchStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchStrategy::from(s))
    }
}
impl BatchStrategy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchStrategy::MultiRecord => "MultiRecord",
            BatchStrategy::SingleRecord => "SingleRecord",
            BatchStrategy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["MultiRecord", "SingleRecord"]
    }
}
impl AsRef<str> for BatchStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of algorithms that were used to create a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAlgorithmSpecification {
    /// <p>A list of the algorithms that were used to create a model package.</p>
    pub source_algorithms: std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
}
impl SourceAlgorithmSpecification {
    /// <p>A list of the algorithms that were used to create a model package.</p>
    pub fn source_algorithms(&self) -> std::option::Option<&[crate::model::SourceAlgorithm]> {
        self.source_algorithms.as_deref()
    }
}
impl std::fmt::Debug for SourceAlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAlgorithmSpecification");
        formatter.field("source_algorithms", &self.source_algorithms);
        formatter.finish()
    }
}
/// See [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
pub mod source_algorithm_specification {

    /// A builder for [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_algorithms:
            std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
    }
    impl Builder {
        /// Appends an item to `source_algorithms`.
        ///
        /// To override the contents of this collection use [`set_source_algorithms`](Self::set_source_algorithms).
        ///
        /// <p>A list of the algorithms that were used to create a model package.</p>
        pub fn source_algorithms(mut self, input: crate::model::SourceAlgorithm) -> Self {
            let mut v = self.source_algorithms.unwrap_or_default();
            v.push(input);
            self.source_algorithms = Some(v);
            self
        }
        /// <p>A list of the algorithms that were used to create a model package.</p>
        pub fn set_source_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
        ) -> Self {
            self.source_algorithms = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
        pub fn build(self) -> crate::model::SourceAlgorithmSpecification {
            crate::model::SourceAlgorithmSpecification {
                source_algorithms: self.source_algorithms,
            }
        }
    }
}
impl SourceAlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
    pub fn builder() -> crate::model::source_algorithm_specification::Builder {
        crate::model::source_algorithm_specification::Builder::default()
    }
}

/// <p>Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAlgorithm {
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the algorithm.</p>
    /// </note>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
}
impl SourceAlgorithm {
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the algorithm.</p>
    /// </note>
    pub fn model_data_url(&self) -> std::option::Option<&str> {
        self.model_data_url.as_deref()
    }
    /// <p>The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&str> {
        self.algorithm_name.as_deref()
    }
}
impl std::fmt::Debug for SourceAlgorithm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAlgorithm");
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.finish()
    }
}
/// See [`SourceAlgorithm`](crate::model::SourceAlgorithm)
pub mod source_algorithm {

    /// A builder for [`SourceAlgorithm`](crate::model::SourceAlgorithm)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the algorithm.</p>
        /// </note>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single <code>gzip</code> compressed tar archive (<code>.tar.gz</code> suffix).</p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the algorithm.</p>
        /// </note>
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// <p>The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        /// <p>The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAlgorithm`](crate::model::SourceAlgorithm)
        pub fn build(self) -> crate::model::SourceAlgorithm {
            crate::model::SourceAlgorithm {
                model_data_url: self.model_data_url,
                algorithm_name: self.algorithm_name,
            }
        }
    }
}
impl SourceAlgorithm {
    /// Creates a new builder-style object to manufacture [`SourceAlgorithm`](crate::model::SourceAlgorithm)
    pub fn builder() -> crate::model::source_algorithm::Builder {
        crate::model::source_algorithm::Builder::default()
    }
}

/// <p>Defines how to perform inference generation after a training job is run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
    pub containers:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
    /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
    pub supported_transform_instance_types:
        std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
    /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
    pub supported_realtime_inference_instance_types:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
    /// <p>The supported MIME types for the input data.</p>
    pub supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The supported MIME types for the output data.</p>
    pub supported_response_mime_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl InferenceSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
    pub fn containers(
        &self,
    ) -> std::option::Option<&[crate::model::ModelPackageContainerDefinition]> {
        self.containers.as_deref()
    }
    /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
    pub fn supported_transform_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::TransformInstanceType]> {
        self.supported_transform_instance_types.as_deref()
    }
    /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
    pub fn supported_realtime_inference_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::ProductionVariantInstanceType]> {
        self.supported_realtime_inference_instance_types.as_deref()
    }
    /// <p>The supported MIME types for the input data.</p>
    pub fn supported_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_content_types.as_deref()
    }
    /// <p>The supported MIME types for the output data.</p>
    pub fn supported_response_mime_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_response_mime_types.as_deref()
    }
}
impl std::fmt::Debug for InferenceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceSpecification");
        formatter.field("containers", &self.containers);
        formatter.field(
            "supported_transform_instance_types",
            &self.supported_transform_instance_types,
        );
        formatter.field(
            "supported_realtime_inference_instance_types",
            &self.supported_realtime_inference_instance_types,
        );
        formatter.field("supported_content_types", &self.supported_content_types);
        formatter.field(
            "supported_response_mime_types",
            &self.supported_response_mime_types,
        );
        formatter.finish()
    }
}
/// See [`InferenceSpecification`](crate::model::InferenceSpecification)
pub mod inference_specification {

    /// A builder for [`InferenceSpecification`](crate::model::InferenceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) containers:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
        pub(crate) supported_transform_instance_types:
            std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        pub(crate) supported_realtime_inference_instance_types:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        pub(crate) supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supported_response_mime_types:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `containers`.
        ///
        /// To override the contents of this collection use [`set_containers`](Self::set_containers).
        ///
        /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
        pub fn containers(mut self, input: crate::model::ModelPackageContainerDefinition) -> Self {
            let mut v = self.containers.unwrap_or_default();
            v.push(input);
            self.containers = Some(v);
            self
        }
        /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
        pub fn set_containers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ModelPackageContainerDefinition>,
            >,
        ) -> Self {
            self.containers = input;
            self
        }
        /// Appends an item to `supported_transform_instance_types`.
        ///
        /// To override the contents of this collection use [`set_supported_transform_instance_types`](Self::set_supported_transform_instance_types).
        ///
        /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
        /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
        pub fn supported_transform_instance_types(
            mut self,
            input: crate::model::TransformInstanceType,
        ) -> Self {
            let mut v = self.supported_transform_instance_types.unwrap_or_default();
            v.push(input);
            self.supported_transform_instance_types = Some(v);
            self
        }
        /// <p>A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.</p>
        /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
        pub fn set_supported_transform_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        ) -> Self {
            self.supported_transform_instance_types = input;
            self
        }
        /// Appends an item to `supported_realtime_inference_instance_types`.
        ///
        /// To override the contents of this collection use [`set_supported_realtime_inference_instance_types`](Self::set_supported_realtime_inference_instance_types).
        ///
        /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
        /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
        pub fn supported_realtime_inference_instance_types(
            mut self,
            input: crate::model::ProductionVariantInstanceType,
        ) -> Self {
            let mut v = self
                .supported_realtime_inference_instance_types
                .unwrap_or_default();
            v.push(input);
            self.supported_realtime_inference_instance_types = Some(v);
            self
        }
        /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
        /// <p>This parameter is required for unversioned models, and optional for versioned models.</p>
        pub fn set_supported_realtime_inference_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        ) -> Self {
            self.supported_realtime_inference_instance_types = input;
            self
        }
        /// Appends an item to `supported_content_types`.
        ///
        /// To override the contents of this collection use [`set_supported_content_types`](Self::set_supported_content_types).
        ///
        /// <p>The supported MIME types for the input data.</p>
        pub fn supported_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supported_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_content_types = Some(v);
            self
        }
        /// <p>The supported MIME types for the input data.</p>
        pub fn set_supported_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_content_types = input;
            self
        }
        /// Appends an item to `supported_response_mime_types`.
        ///
        /// To override the contents of this collection use [`set_supported_response_mime_types`](Self::set_supported_response_mime_types).
        ///
        /// <p>The supported MIME types for the output data.</p>
        pub fn supported_response_mime_types(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.supported_response_mime_types.unwrap_or_default();
            v.push(input.into());
            self.supported_response_mime_types = Some(v);
            self
        }
        /// <p>The supported MIME types for the output data.</p>
        pub fn set_supported_response_mime_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_response_mime_types = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceSpecification`](crate::model::InferenceSpecification)
        pub fn build(self) -> crate::model::InferenceSpecification {
            crate::model::InferenceSpecification {
                containers: self.containers,
                supported_transform_instance_types: self.supported_transform_instance_types,
                supported_realtime_inference_instance_types: self
                    .supported_realtime_inference_instance_types,
                supported_content_types: self.supported_content_types,
                supported_response_mime_types: self.supported_response_mime_types,
            }
        }
    }
}
impl InferenceSpecification {
    /// Creates a new builder-style object to manufacture [`InferenceSpecification`](crate::model::InferenceSpecification)
    pub fn builder() -> crate::model::inference_specification::Builder {
        crate::model::inference_specification::Builder::default()
    }
}

/// <p>A hosted endpoint for real-time inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Endpoint {
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>The endpoint configuration associated with the endpoint.</p>
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>A list of the production variants hosted on the endpoint. Each production variant is a model.</p>
    pub production_variants:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
    /// <p>The currently active data capture configuration used by your Endpoint.</p>
    pub data_capture_config: std::option::Option<crate::model::DataCaptureConfigSummary>,
    /// <p>The status of the endpoint.</p>
    pub endpoint_status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>If the endpoint failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the endpoint was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the endpoint was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of monitoring schedules for the endpoint. For information about model monitoring, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
    pub monitoring_schedules: std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
    /// <p>A list of the tags associated with the endpoint. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Endpoint {
    /// <p>The name of the endpoint.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
    /// <p>The endpoint configuration associated with the endpoint.</p>
    pub fn endpoint_config_name(&self) -> std::option::Option<&str> {
        self.endpoint_config_name.as_deref()
    }
    /// <p>A list of the production variants hosted on the endpoint. Each production variant is a model.</p>
    pub fn production_variants(
        &self,
    ) -> std::option::Option<&[crate::model::ProductionVariantSummary]> {
        self.production_variants.as_deref()
    }
    /// <p>The currently active data capture configuration used by your Endpoint.</p>
    pub fn data_capture_config(
        &self,
    ) -> std::option::Option<&crate::model::DataCaptureConfigSummary> {
        self.data_capture_config.as_ref()
    }
    /// <p>The status of the endpoint.</p>
    pub fn endpoint_status(&self) -> std::option::Option<&crate::model::EndpointStatus> {
        self.endpoint_status.as_ref()
    }
    /// <p>If the endpoint failed, the reason it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The time that the endpoint was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the endpoint was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>A list of monitoring schedules for the endpoint. For information about model monitoring, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
    pub fn monitoring_schedules(&self) -> std::option::Option<&[crate::model::MonitoringSchedule]> {
        self.monitoring_schedules.as_deref()
    }
    /// <p>A list of the tags associated with the endpoint. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Endpoint");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("data_capture_config", &self.data_capture_config);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("monitoring_schedules", &self.monitoring_schedules);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Endpoint`](crate::model::Endpoint)
pub mod endpoint {

    /// A builder for [`Endpoint`](crate::model::Endpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
        pub(crate) endpoint_config_name: std::option::Option<std::string::String>,
        pub(crate) production_variants:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
        pub(crate) data_capture_config: std::option::Option<crate::model::DataCaptureConfigSummary>,
        pub(crate) endpoint_status: std::option::Option<crate::model::EndpointStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) monitoring_schedules:
            std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// <p>The endpoint configuration associated with the endpoint.</p>
        pub fn endpoint_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_name = Some(input.into());
            self
        }
        /// <p>The endpoint configuration associated with the endpoint.</p>
        pub fn set_endpoint_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_name = input;
            self
        }
        /// Appends an item to `production_variants`.
        ///
        /// To override the contents of this collection use [`set_production_variants`](Self::set_production_variants).
        ///
        /// <p>A list of the production variants hosted on the endpoint. Each production variant is a model.</p>
        pub fn production_variants(
            mut self,
            input: crate::model::ProductionVariantSummary,
        ) -> Self {
            let mut v = self.production_variants.unwrap_or_default();
            v.push(input);
            self.production_variants = Some(v);
            self
        }
        /// <p>A list of the production variants hosted on the endpoint. Each production variant is a model.</p>
        pub fn set_production_variants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
        ) -> Self {
            self.production_variants = input;
            self
        }
        /// <p>The currently active data capture configuration used by your Endpoint.</p>
        pub fn data_capture_config(
            mut self,
            input: crate::model::DataCaptureConfigSummary,
        ) -> Self {
            self.data_capture_config = Some(input);
            self
        }
        /// <p>The currently active data capture configuration used by your Endpoint.</p>
        pub fn set_data_capture_config(
            mut self,
            input: std::option::Option<crate::model::DataCaptureConfigSummary>,
        ) -> Self {
            self.data_capture_config = input;
            self
        }
        /// <p>The status of the endpoint.</p>
        pub fn endpoint_status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.endpoint_status = Some(input);
            self
        }
        /// <p>The status of the endpoint.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>If the endpoint failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the endpoint failed, the reason it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the endpoint was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time the endpoint was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `monitoring_schedules`.
        ///
        /// To override the contents of this collection use [`set_monitoring_schedules`](Self::set_monitoring_schedules).
        ///
        /// <p>A list of monitoring schedules for the endpoint. For information about model monitoring, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
        pub fn monitoring_schedules(mut self, input: crate::model::MonitoringSchedule) -> Self {
            let mut v = self.monitoring_schedules.unwrap_or_default();
            v.push(input);
            self.monitoring_schedules = Some(v);
            self
        }
        /// <p>A list of monitoring schedules for the endpoint. For information about model monitoring, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
        pub fn set_monitoring_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
        ) -> Self {
            self.monitoring_schedules = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of the tags associated with the endpoint. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of the tags associated with the endpoint. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint)
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                endpoint_name: self.endpoint_name,
                endpoint_arn: self.endpoint_arn,
                endpoint_config_name: self.endpoint_config_name,
                production_variants: self.production_variants,
                data_capture_config: self.data_capture_config,
                endpoint_status: self.endpoint_status,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedules: self.monitoring_schedules,
                tags: self.tags,
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint)
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>A schedule for a model monitoring job. For information about model monitor, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringSchedule {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The schedule is pending being created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The schedule failed.</p> </li>
    /// <li> <p> <code>SCHEDULED</code> - The schedule was successfully created.</p> </li>
    /// <li> <p> <code>STOPPED</code> - The schedule was stopped.</p> </li>
    /// </ul>
    pub monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
    /// <p>If the monitoring schedule failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the monitoring schedule was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the monitoring schedule was changed.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
    pub monitoring_schedule_config: std::option::Option<crate::model::MonitoringScheduleConfig>,
    /// <p>The endpoint that hosts the model being monitored.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Summary of information about the last monitoring job to run.</p>
    pub last_monitoring_execution_summary:
        std::option::Option<crate::model::MonitoringExecutionSummary>,
    /// <p>A list of the tags associated with the monitoring schedlue. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl MonitoringSchedule {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub fn monitoring_schedule_arn(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_arn.as_deref()
    }
    /// <p>The name of the monitoring schedule.</p>
    pub fn monitoring_schedule_name(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_name.as_deref()
    }
    /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - The schedule is pending being created.</p> </li>
    /// <li> <p> <code>FAILED</code> - The schedule failed.</p> </li>
    /// <li> <p> <code>SCHEDULED</code> - The schedule was successfully created.</p> </li>
    /// <li> <p> <code>STOPPED</code> - The schedule was stopped.</p> </li>
    /// </ul>
    pub fn monitoring_schedule_status(&self) -> std::option::Option<&crate::model::ScheduleStatus> {
        self.monitoring_schedule_status.as_ref()
    }
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub fn monitoring_type(&self) -> std::option::Option<&crate::model::MonitoringType> {
        self.monitoring_type.as_ref()
    }
    /// <p>If the monitoring schedule failed, the reason it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The time that the monitoring schedule was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the monitoring schedule was changed.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
    pub fn monitoring_schedule_config(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringScheduleConfig> {
        self.monitoring_schedule_config.as_ref()
    }
    /// <p>The endpoint that hosts the model being monitored.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>Summary of information about the last monitoring job to run.</p>
    pub fn last_monitoring_execution_summary(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringExecutionSummary> {
        self.last_monitoring_execution_summary.as_ref()
    }
    /// <p>A list of the tags associated with the monitoring schedlue. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for MonitoringSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringSchedule");
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field(
            "monitoring_schedule_status",
            &self.monitoring_schedule_status,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_schedule_config",
            &self.monitoring_schedule_config,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "last_monitoring_execution_summary",
            &self.last_monitoring_execution_summary,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`MonitoringSchedule`](crate::model::MonitoringSchedule)
pub mod monitoring_schedule {

    /// A builder for [`MonitoringSchedule`](crate::model::MonitoringSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) monitoring_schedule_config:
            std::option::Option<crate::model::MonitoringScheduleConfig>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) last_monitoring_execution_summary:
            std::option::Option<crate::model::MonitoringExecutionSummary>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The schedule is pending being created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The schedule failed.</p> </li>
        /// <li> <p> <code>SCHEDULED</code> - The schedule was successfully created.</p> </li>
        /// <li> <p> <code>STOPPED</code> - The schedule was stopped.</p> </li>
        /// </ul>
        pub fn monitoring_schedule_status(mut self, input: crate::model::ScheduleStatus) -> Self {
            self.monitoring_schedule_status = Some(input);
            self
        }
        /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - The schedule is pending being created.</p> </li>
        /// <li> <p> <code>FAILED</code> - The schedule failed.</p> </li>
        /// <li> <p> <code>SCHEDULED</code> - The schedule was successfully created.</p> </li>
        /// <li> <p> <code>STOPPED</code> - The schedule was stopped.</p> </li>
        /// </ul>
        pub fn set_monitoring_schedule_status(
            mut self,
            input: std::option::Option<crate::model::ScheduleStatus>,
        ) -> Self {
            self.monitoring_schedule_status = input;
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// <p>If the monitoring schedule failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the monitoring schedule failed, the reason it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the monitoring schedule was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the monitoring schedule was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the monitoring schedule was changed.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time the monitoring schedule was changed.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
        pub fn monitoring_schedule_config(
            mut self,
            input: crate::model::MonitoringScheduleConfig,
        ) -> Self {
            self.monitoring_schedule_config = Some(input);
            self
        }
        /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
        pub fn set_monitoring_schedule_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringScheduleConfig>,
        ) -> Self {
            self.monitoring_schedule_config = input;
            self
        }
        /// <p>The endpoint that hosts the model being monitored.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The endpoint that hosts the model being monitored.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Summary of information about the last monitoring job to run.</p>
        pub fn last_monitoring_execution_summary(
            mut self,
            input: crate::model::MonitoringExecutionSummary,
        ) -> Self {
            self.last_monitoring_execution_summary = Some(input);
            self
        }
        /// <p>Summary of information about the last monitoring job to run.</p>
        pub fn set_last_monitoring_execution_summary(
            mut self,
            input: std::option::Option<crate::model::MonitoringExecutionSummary>,
        ) -> Self {
            self.last_monitoring_execution_summary = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of the tags associated with the monitoring schedlue. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of the tags associated with the monitoring schedlue. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringSchedule`](crate::model::MonitoringSchedule)
        pub fn build(self) -> crate::model::MonitoringSchedule {
            crate::model::MonitoringSchedule {
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                monitoring_schedule_name: self.monitoring_schedule_name,
                monitoring_schedule_status: self.monitoring_schedule_status,
                monitoring_type: self.monitoring_type,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedule_config: self.monitoring_schedule_config,
                endpoint_name: self.endpoint_name,
                last_monitoring_execution_summary: self.last_monitoring_execution_summary,
                tags: self.tags,
            }
        }
    }
}
impl MonitoringSchedule {
    /// Creates a new builder-style object to manufacture [`MonitoringSchedule`](crate::model::MonitoringSchedule)
    pub fn builder() -> crate::model::monitoring_schedule::Builder {
        crate::model::monitoring_schedule::Builder::default()
    }
}

/// <p>Summary of information about the last monitoring job to run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringExecutionSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The time the monitoring job was scheduled.</p>
    pub scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the monitoring job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the monitoring job.</p>
    pub monitoring_execution_status: std::option::Option<crate::model::ExecutionStatus>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the endpoint used to run the monitoring job.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Contains the reason a monitoring job failed, if it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring job.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl MonitoringExecutionSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub fn monitoring_schedule_name(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_name.as_deref()
    }
    /// <p>The time the monitoring job was scheduled.</p>
    pub fn scheduled_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_time.as_ref()
    }
    /// <p>The time at which the monitoring job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the monitoring job.</p>
    pub fn monitoring_execution_status(
        &self,
    ) -> std::option::Option<&crate::model::ExecutionStatus> {
        self.monitoring_execution_status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub fn processing_job_arn(&self) -> std::option::Option<&str> {
        self.processing_job_arn.as_deref()
    }
    /// <p>The name of the endpoint used to run the monitoring job.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>Contains the reason a monitoring job failed, if it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The name of the monitoring job.</p>
    pub fn monitoring_job_definition_name(&self) -> std::option::Option<&str> {
        self.monitoring_job_definition_name.as_deref()
    }
    /// <p>The type of the monitoring job.</p>
    pub fn monitoring_type(&self) -> std::option::Option<&crate::model::MonitoringType> {
        self.monitoring_type.as_ref()
    }
}
impl std::fmt::Debug for MonitoringExecutionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringExecutionSummary");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field("scheduled_time", &self.scheduled_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_execution_status",
            &self.monitoring_execution_status,
        );
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
pub mod monitoring_execution_summary {

    /// A builder for [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) monitoring_execution_status: std::option::Option<crate::model::ExecutionStatus>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The time the monitoring job was scheduled.</p>
        pub fn scheduled_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        /// <p>The time the monitoring job was scheduled.</p>
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        /// <p>The time at which the monitoring job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the monitoring job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the monitoring job.</p>
        pub fn monitoring_execution_status(mut self, input: crate::model::ExecutionStatus) -> Self {
            self.monitoring_execution_status = Some(input);
            self
        }
        /// <p>The status of the monitoring job.</p>
        pub fn set_monitoring_execution_status(
            mut self,
            input: std::option::Option<crate::model::ExecutionStatus>,
        ) -> Self {
            self.monitoring_execution_status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The name of the endpoint used to run the monitoring job.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint used to run the monitoring job.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Contains the reason a monitoring job failed, if it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>Contains the reason a monitoring job failed, if it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The name of the monitoring job.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring job.</p>
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        /// <p>The type of the monitoring job.</p>
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
        pub fn build(self) -> crate::model::MonitoringExecutionSummary {
            crate::model::MonitoringExecutionSummary {
                monitoring_schedule_name: self.monitoring_schedule_name,
                scheduled_time: self.scheduled_time,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_execution_status: self.monitoring_execution_status,
                processing_job_arn: self.processing_job_arn,
                endpoint_name: self.endpoint_name,
                failure_reason: self.failure_reason,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringExecutionSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
    pub fn builder() -> crate::model::monitoring_execution_summary::Builder {
        crate::model::monitoring_execution_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithViolations,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ExecutionStatus::Completed,
            "CompletedWithViolations" => ExecutionStatus::CompletedWithViolations,
            "Failed" => ExecutionStatus::Failed,
            "InProgress" => ExecutionStatus::InProgress,
            "Pending" => ExecutionStatus::Pending,
            "Stopped" => ExecutionStatus::Stopped,
            "Stopping" => ExecutionStatus::Stopping,
            other => ExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExecutionStatus::from(s))
    }
}
impl ExecutionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExecutionStatus::Completed => "Completed",
            ExecutionStatus::CompletedWithViolations => "CompletedWithViolations",
            ExecutionStatus::Failed => "Failed",
            ExecutionStatus::InProgress => "InProgress",
            ExecutionStatus::Pending => "Pending",
            ExecutionStatus::Stopped => "Stopped",
            ExecutionStatus::Stopping => "Stopping",
            ExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "CompletedWithViolations",
            "Failed",
            "InProgress",
            "Pending",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for ExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduleStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ScheduleStatus::Failed,
            "Pending" => ScheduleStatus::Pending,
            "Scheduled" => ScheduleStatus::Scheduled,
            "Stopped" => ScheduleStatus::Stopped,
            other => ScheduleStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleStatus::from(s))
    }
}
impl ScheduleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleStatus::Failed => "Failed",
            ScheduleStatus::Pending => "Pending",
            ScheduleStatus::Scheduled => "Scheduled",
            ScheduleStatus::Stopped => "Stopped",
            ScheduleStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Failed", "Pending", "Scheduled", "Stopped"]
    }
}
impl AsRef<str> for ScheduleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointStatus {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    OutOfService,
    #[allow(missing_docs)] // documentation missing in model
    RollingBack,
    #[allow(missing_docs)] // documentation missing in model
    SystemUpdating,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "Creating" => EndpointStatus::Creating,
            "Deleting" => EndpointStatus::Deleting,
            "Failed" => EndpointStatus::Failed,
            "InService" => EndpointStatus::InService,
            "OutOfService" => EndpointStatus::OutOfService,
            "RollingBack" => EndpointStatus::RollingBack,
            "SystemUpdating" => EndpointStatus::SystemUpdating,
            "Updating" => EndpointStatus::Updating,
            other => EndpointStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointStatus::from(s))
    }
}
impl EndpointStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointStatus::Creating => "Creating",
            EndpointStatus::Deleting => "Deleting",
            EndpointStatus::Failed => "Failed",
            EndpointStatus::InService => "InService",
            EndpointStatus::OutOfService => "OutOfService",
            EndpointStatus::RollingBack => "RollingBack",
            EndpointStatus::SystemUpdating => "SystemUpdating",
            EndpointStatus::Updating => "Updating",
            EndpointStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Creating",
            "Deleting",
            "Failed",
            "InService",
            "OutOfService",
            "RollingBack",
            "SystemUpdating",
            "Updating",
        ]
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The currently active data capture configuration used by your Endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCaptureConfigSummary {
    /// <p>Whether data capture is enabled or disabled.</p>
    pub enable_capture: bool,
    /// <p>Whether data capture is currently functional.</p>
    pub capture_status: std::option::Option<crate::model::CaptureStatus>,
    /// <p>The percentage of requests being captured by your Endpoint.</p>
    pub current_sampling_percentage: std::option::Option<i32>,
    /// <p>The Amazon S3 location being used to capture the data.</p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p>The KMS key being used to encrypt the data in Amazon S3.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl DataCaptureConfigSummary {
    /// <p>Whether data capture is enabled or disabled.</p>
    pub fn enable_capture(&self) -> bool {
        self.enable_capture
    }
    /// <p>Whether data capture is currently functional.</p>
    pub fn capture_status(&self) -> std::option::Option<&crate::model::CaptureStatus> {
        self.capture_status.as_ref()
    }
    /// <p>The percentage of requests being captured by your Endpoint.</p>
    pub fn current_sampling_percentage(&self) -> std::option::Option<i32> {
        self.current_sampling_percentage
    }
    /// <p>The Amazon S3 location being used to capture the data.</p>
    pub fn destination_s3_uri(&self) -> std::option::Option<&str> {
        self.destination_s3_uri.as_deref()
    }
    /// <p>The KMS key being used to encrypt the data in Amazon S3.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for DataCaptureConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCaptureConfigSummary");
        formatter.field("enable_capture", &self.enable_capture);
        formatter.field("capture_status", &self.capture_status);
        formatter.field(
            "current_sampling_percentage",
            &self.current_sampling_percentage,
        );
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
pub mod data_capture_config_summary {

    /// A builder for [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_capture: std::option::Option<bool>,
        pub(crate) capture_status: std::option::Option<crate::model::CaptureStatus>,
        pub(crate) current_sampling_percentage: std::option::Option<i32>,
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether data capture is enabled or disabled.</p>
        pub fn enable_capture(mut self, input: bool) -> Self {
            self.enable_capture = Some(input);
            self
        }
        /// <p>Whether data capture is enabled or disabled.</p>
        pub fn set_enable_capture(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_capture = input;
            self
        }
        /// <p>Whether data capture is currently functional.</p>
        pub fn capture_status(mut self, input: crate::model::CaptureStatus) -> Self {
            self.capture_status = Some(input);
            self
        }
        /// <p>Whether data capture is currently functional.</p>
        pub fn set_capture_status(
            mut self,
            input: std::option::Option<crate::model::CaptureStatus>,
        ) -> Self {
            self.capture_status = input;
            self
        }
        /// <p>The percentage of requests being captured by your Endpoint.</p>
        pub fn current_sampling_percentage(mut self, input: i32) -> Self {
            self.current_sampling_percentage = Some(input);
            self
        }
        /// <p>The percentage of requests being captured by your Endpoint.</p>
        pub fn set_current_sampling_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.current_sampling_percentage = input;
            self
        }
        /// <p>The Amazon S3 location being used to capture the data.</p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location being used to capture the data.</p>
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p>The KMS key being used to encrypt the data in Amazon S3.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key being used to encrypt the data in Amazon S3.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
        pub fn build(self) -> crate::model::DataCaptureConfigSummary {
            crate::model::DataCaptureConfigSummary {
                enable_capture: self.enable_capture.unwrap_or_default(),
                capture_status: self.capture_status,
                current_sampling_percentage: self.current_sampling_percentage,
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl DataCaptureConfigSummary {
    /// Creates a new builder-style object to manufacture [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
    pub fn builder() -> crate::model::data_capture_config_summary::Builder {
        crate::model::data_capture_config_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CaptureStatus {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CaptureStatus {
    fn from(s: &str) -> Self {
        match s {
            "Started" => CaptureStatus::Started,
            "Stopped" => CaptureStatus::Stopped,
            other => CaptureStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CaptureStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CaptureStatus::from(s))
    }
}
impl CaptureStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CaptureStatus::Started => "Started",
            CaptureStatus::Stopped => "Stopped",
            CaptureStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Started", "Stopped"]
    }
}
impl AsRef<str> for CaptureStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes weight and capacities for a production variant associated with an endpoint. If you sent a request to the <code>UpdateEndpointWeightsAndCapacities</code> API and the endpoint status is <code>Updating</code>, you get different desired and current values. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantSummary {
    /// <p>The name of the variant.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
    pub deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
    /// <p>The weight associated with the variant.</p>
    pub current_weight: std::option::Option<f32>,
    /// <p>The requested weight, as specified in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub desired_weight: std::option::Option<f32>,
    /// <p>The number of instances associated with the variant.</p>
    pub current_instance_count: std::option::Option<i32>,
    /// <p>The number of instances requested in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub desired_instance_count: std::option::Option<i32>,
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    pub variant_status: std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
    /// <p>The serverless configuration for the endpoint.</p>
    pub current_serverless_config:
        std::option::Option<crate::model::ProductionVariantServerlessConfig>,
    /// <p>The serverless configuration requested for the endpoint update.</p>
    pub desired_serverless_config:
        std::option::Option<crate::model::ProductionVariantServerlessConfig>,
}
impl ProductionVariantSummary {
    /// <p>The name of the variant.</p>
    pub fn variant_name(&self) -> std::option::Option<&str> {
        self.variant_name.as_deref()
    }
    /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
    pub fn deployed_images(&self) -> std::option::Option<&[crate::model::DeployedImage]> {
        self.deployed_images.as_deref()
    }
    /// <p>The weight associated with the variant.</p>
    pub fn current_weight(&self) -> std::option::Option<f32> {
        self.current_weight
    }
    /// <p>The requested weight, as specified in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub fn desired_weight(&self) -> std::option::Option<f32> {
        self.desired_weight
    }
    /// <p>The number of instances associated with the variant.</p>
    pub fn current_instance_count(&self) -> std::option::Option<i32> {
        self.current_instance_count
    }
    /// <p>The number of instances requested in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub fn desired_instance_count(&self) -> std::option::Option<i32> {
        self.desired_instance_count
    }
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    pub fn variant_status(&self) -> std::option::Option<&[crate::model::ProductionVariantStatus]> {
        self.variant_status.as_deref()
    }
    /// <p>The serverless configuration for the endpoint.</p>
    pub fn current_serverless_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantServerlessConfig> {
        self.current_serverless_config.as_ref()
    }
    /// <p>The serverless configuration requested for the endpoint update.</p>
    pub fn desired_serverless_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantServerlessConfig> {
        self.desired_serverless_config.as_ref()
    }
}
impl std::fmt::Debug for ProductionVariantSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantSummary");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("deployed_images", &self.deployed_images);
        formatter.field("current_weight", &self.current_weight);
        formatter.field("desired_weight", &self.desired_weight);
        formatter.field("current_instance_count", &self.current_instance_count);
        formatter.field("desired_instance_count", &self.desired_instance_count);
        formatter.field("variant_status", &self.variant_status);
        formatter.field("current_serverless_config", &self.current_serverless_config);
        formatter.field("desired_serverless_config", &self.desired_serverless_config);
        formatter.finish()
    }
}
/// See [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
pub mod production_variant_summary {

    /// A builder for [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        pub(crate) current_weight: std::option::Option<f32>,
        pub(crate) desired_weight: std::option::Option<f32>,
        pub(crate) current_instance_count: std::option::Option<i32>,
        pub(crate) desired_instance_count: std::option::Option<i32>,
        pub(crate) variant_status:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
        pub(crate) current_serverless_config:
            std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        pub(crate) desired_serverless_config:
            std::option::Option<crate::model::ProductionVariantServerlessConfig>,
    }
    impl Builder {
        /// <p>The name of the variant.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        /// <p>The name of the variant.</p>
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// Appends an item to `deployed_images`.
        ///
        /// To override the contents of this collection use [`set_deployed_images`](Self::set_deployed_images).
        ///
        /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
        pub fn deployed_images(mut self, input: crate::model::DeployedImage) -> Self {
            let mut v = self.deployed_images.unwrap_or_default();
            v.push(input);
            self.deployed_images = Some(v);
            self
        }
        /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
        pub fn set_deployed_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        ) -> Self {
            self.deployed_images = input;
            self
        }
        /// <p>The weight associated with the variant.</p>
        pub fn current_weight(mut self, input: f32) -> Self {
            self.current_weight = Some(input);
            self
        }
        /// <p>The weight associated with the variant.</p>
        pub fn set_current_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.current_weight = input;
            self
        }
        /// <p>The requested weight, as specified in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn desired_weight(mut self, input: f32) -> Self {
            self.desired_weight = Some(input);
            self
        }
        /// <p>The requested weight, as specified in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn set_desired_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.desired_weight = input;
            self
        }
        /// <p>The number of instances associated with the variant.</p>
        pub fn current_instance_count(mut self, input: i32) -> Self {
            self.current_instance_count = Some(input);
            self
        }
        /// <p>The number of instances associated with the variant.</p>
        pub fn set_current_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.current_instance_count = input;
            self
        }
        /// <p>The number of instances requested in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn desired_instance_count(mut self, input: i32) -> Self {
            self.desired_instance_count = Some(input);
            self
        }
        /// <p>The number of instances requested in the <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn set_desired_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_instance_count = input;
            self
        }
        /// Appends an item to `variant_status`.
        ///
        /// To override the contents of this collection use [`set_variant_status`](Self::set_variant_status).
        ///
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        pub fn variant_status(mut self, input: crate::model::ProductionVariantStatus) -> Self {
            let mut v = self.variant_status.unwrap_or_default();
            v.push(input);
            self.variant_status = Some(v);
            self
        }
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        pub fn set_variant_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
        ) -> Self {
            self.variant_status = input;
            self
        }
        /// <p>The serverless configuration for the endpoint.</p>
        pub fn current_serverless_config(
            mut self,
            input: crate::model::ProductionVariantServerlessConfig,
        ) -> Self {
            self.current_serverless_config = Some(input);
            self
        }
        /// <p>The serverless configuration for the endpoint.</p>
        pub fn set_current_serverless_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        ) -> Self {
            self.current_serverless_config = input;
            self
        }
        /// <p>The serverless configuration requested for the endpoint update.</p>
        pub fn desired_serverless_config(
            mut self,
            input: crate::model::ProductionVariantServerlessConfig,
        ) -> Self {
            self.desired_serverless_config = Some(input);
            self
        }
        /// <p>The serverless configuration requested for the endpoint update.</p>
        pub fn set_desired_serverless_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        ) -> Self {
            self.desired_serverless_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
        pub fn build(self) -> crate::model::ProductionVariantSummary {
            crate::model::ProductionVariantSummary {
                variant_name: self.variant_name,
                deployed_images: self.deployed_images,
                current_weight: self.current_weight,
                desired_weight: self.desired_weight,
                current_instance_count: self.current_instance_count,
                desired_instance_count: self.desired_instance_count,
                variant_status: self.variant_status,
                current_serverless_config: self.current_serverless_config,
                desired_serverless_config: self.desired_serverless_config,
            }
        }
    }
}
impl ProductionVariantSummary {
    /// Creates a new builder-style object to manufacture [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
    pub fn builder() -> crate::model::production_variant_summary::Builder {
        crate::model::production_variant_summary::Builder::default()
    }
}

/// <p>Specifies the serverless configuration for an endpoint variant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantServerlessConfig {
    /// <p>The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.</p>
    pub memory_size_in_mb: std::option::Option<i32>,
    /// <p>The maximum number of concurrent invocations your serverless endpoint can process.</p>
    pub max_concurrency: std::option::Option<i32>,
}
impl ProductionVariantServerlessConfig {
    /// <p>The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.</p>
    pub fn memory_size_in_mb(&self) -> std::option::Option<i32> {
        self.memory_size_in_mb
    }
    /// <p>The maximum number of concurrent invocations your serverless endpoint can process.</p>
    pub fn max_concurrency(&self) -> std::option::Option<i32> {
        self.max_concurrency
    }
}
impl std::fmt::Debug for ProductionVariantServerlessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantServerlessConfig");
        formatter.field("memory_size_in_mb", &self.memory_size_in_mb);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.finish()
    }
}
/// See [`ProductionVariantServerlessConfig`](crate::model::ProductionVariantServerlessConfig)
pub mod production_variant_serverless_config {

    /// A builder for [`ProductionVariantServerlessConfig`](crate::model::ProductionVariantServerlessConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) memory_size_in_mb: std::option::Option<i32>,
        pub(crate) max_concurrency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.</p>
        pub fn memory_size_in_mb(mut self, input: i32) -> Self {
            self.memory_size_in_mb = Some(input);
            self
        }
        /// <p>The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.</p>
        pub fn set_memory_size_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_size_in_mb = input;
            self
        }
        /// <p>The maximum number of concurrent invocations your serverless endpoint can process.</p>
        pub fn max_concurrency(mut self, input: i32) -> Self {
            self.max_concurrency = Some(input);
            self
        }
        /// <p>The maximum number of concurrent invocations your serverless endpoint can process.</p>
        pub fn set_max_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrency = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantServerlessConfig`](crate::model::ProductionVariantServerlessConfig)
        pub fn build(self) -> crate::model::ProductionVariantServerlessConfig {
            crate::model::ProductionVariantServerlessConfig {
                memory_size_in_mb: self.memory_size_in_mb,
                max_concurrency: self.max_concurrency,
            }
        }
    }
}
impl ProductionVariantServerlessConfig {
    /// Creates a new builder-style object to manufacture [`ProductionVariantServerlessConfig`](crate::model::ProductionVariantServerlessConfig)
    pub fn builder() -> crate::model::production_variant_serverless_config::Builder {
        crate::model::production_variant_serverless_config::Builder::default()
    }
}

/// <p>Describes the status of the production variant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantStatus {
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    /// <ul>
    /// <li> <p> <code>Creating</code>: Creating inference resources for the production variant.</p> </li>
    /// <li> <p> <code>Deleting</code>: Terminating inference resources for the production variant.</p> </li>
    /// <li> <p> <code>Updating</code>: Updating capacity for the production variant.</p> </li>
    /// <li> <p> <code>ActivatingTraffic</code>: Turning on traffic for the production variant.</p> </li>
    /// <li> <p> <code>Baking</code>: Waiting period to monitor the CloudWatch alarms in the automatic rollback configuration.</p> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::VariantStatus>,
    /// <p>A message that describes the status of the production variant.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The start time of the current status change.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ProductionVariantStatus {
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    /// <ul>
    /// <li> <p> <code>Creating</code>: Creating inference resources for the production variant.</p> </li>
    /// <li> <p> <code>Deleting</code>: Terminating inference resources for the production variant.</p> </li>
    /// <li> <p> <code>Updating</code>: Updating capacity for the production variant.</p> </li>
    /// <li> <p> <code>ActivatingTraffic</code>: Turning on traffic for the production variant.</p> </li>
    /// <li> <p> <code>Baking</code>: Waiting period to monitor the CloudWatch alarms in the automatic rollback configuration.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::VariantStatus> {
        self.status.as_ref()
    }
    /// <p>A message that describes the status of the production variant.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The start time of the current status change.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl std::fmt::Debug for ProductionVariantStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantStatus");
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`ProductionVariantStatus`](crate::model::ProductionVariantStatus)
pub mod production_variant_status {

    /// A builder for [`ProductionVariantStatus`](crate::model::ProductionVariantStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::VariantStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        /// <ul>
        /// <li> <p> <code>Creating</code>: Creating inference resources for the production variant.</p> </li>
        /// <li> <p> <code>Deleting</code>: Terminating inference resources for the production variant.</p> </li>
        /// <li> <p> <code>Updating</code>: Updating capacity for the production variant.</p> </li>
        /// <li> <p> <code>ActivatingTraffic</code>: Turning on traffic for the production variant.</p> </li>
        /// <li> <p> <code>Baking</code>: Waiting period to monitor the CloudWatch alarms in the automatic rollback configuration.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::VariantStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        /// <ul>
        /// <li> <p> <code>Creating</code>: Creating inference resources for the production variant.</p> </li>
        /// <li> <p> <code>Deleting</code>: Terminating inference resources for the production variant.</p> </li>
        /// <li> <p> <code>Updating</code>: Updating capacity for the production variant.</p> </li>
        /// <li> <p> <code>ActivatingTraffic</code>: Turning on traffic for the production variant.</p> </li>
        /// <li> <p> <code>Baking</code>: Waiting period to monitor the CloudWatch alarms in the automatic rollback configuration.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VariantStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A message that describes the status of the production variant.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>A message that describes the status of the production variant.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The start time of the current status change.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the current status change.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantStatus`](crate::model::ProductionVariantStatus)
        pub fn build(self) -> crate::model::ProductionVariantStatus {
            crate::model::ProductionVariantStatus {
                status: self.status,
                status_message: self.status_message,
                start_time: self.start_time,
            }
        }
    }
}
impl ProductionVariantStatus {
    /// Creates a new builder-style object to manufacture [`ProductionVariantStatus`](crate::model::ProductionVariantStatus)
    pub fn builder() -> crate::model::production_variant_status::Builder {
        crate::model::production_variant_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VariantStatus {
    #[allow(missing_docs)] // documentation missing in model
    ActivatingTraffic,
    #[allow(missing_docs)] // documentation missing in model
    Baking,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VariantStatus {
    fn from(s: &str) -> Self {
        match s {
            "ActivatingTraffic" => VariantStatus::ActivatingTraffic,
            "Baking" => VariantStatus::Baking,
            "Creating" => VariantStatus::Creating,
            "Deleting" => VariantStatus::Deleting,
            "Updating" => VariantStatus::Updating,
            other => VariantStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VariantStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VariantStatus::from(s))
    }
}
impl VariantStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VariantStatus::ActivatingTraffic => "ActivatingTraffic",
            VariantStatus::Baking => "Baking",
            VariantStatus::Creating => "Creating",
            VariantStatus::Deleting => "Deleting",
            VariantStatus::Updating => "Updating",
            VariantStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ActivatingTraffic",
            "Baking",
            "Creating",
            "Deleting",
            "Updating",
        ]
    }
}
impl AsRef<str> for VariantStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Gets the Amazon EC2 Container Registry path of the docker image of the model that is hosted in this <code>ProductionVariant</code>.</p>
/// <p>If you used the <code>registry/repository[:tag]</code> form to specify the image path of the primary container when you created the model hosted in this <code>ProductionVariant</code>, the path resolves to a path of the form <code>registry/repository[@digest]</code>. A digest is a hash value that identifies a specific version of an image. For information about Amazon ECR paths, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html">Pulling an Image</a> in the <i>Amazon ECR User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeployedImage {
    /// <p>The image path you specified when you created the model.</p>
    pub specified_image: std::option::Option<std::string::String>,
    /// <p>The specific digest path of the image hosted in this <code>ProductionVariant</code>.</p>
    pub resolved_image: std::option::Option<std::string::String>,
    /// <p>The date and time when the image path for the model resolved to the <code>ResolvedImage</code> </p>
    pub resolution_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeployedImage {
    /// <p>The image path you specified when you created the model.</p>
    pub fn specified_image(&self) -> std::option::Option<&str> {
        self.specified_image.as_deref()
    }
    /// <p>The specific digest path of the image hosted in this <code>ProductionVariant</code>.</p>
    pub fn resolved_image(&self) -> std::option::Option<&str> {
        self.resolved_image.as_deref()
    }
    /// <p>The date and time when the image path for the model resolved to the <code>ResolvedImage</code> </p>
    pub fn resolution_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resolution_time.as_ref()
    }
}
impl std::fmt::Debug for DeployedImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeployedImage");
        formatter.field("specified_image", &self.specified_image);
        formatter.field("resolved_image", &self.resolved_image);
        formatter.field("resolution_time", &self.resolution_time);
        formatter.finish()
    }
}
/// See [`DeployedImage`](crate::model::DeployedImage)
pub mod deployed_image {

    /// A builder for [`DeployedImage`](crate::model::DeployedImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) specified_image: std::option::Option<std::string::String>,
        pub(crate) resolved_image: std::option::Option<std::string::String>,
        pub(crate) resolution_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The image path you specified when you created the model.</p>
        pub fn specified_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.specified_image = Some(input.into());
            self
        }
        /// <p>The image path you specified when you created the model.</p>
        pub fn set_specified_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.specified_image = input;
            self
        }
        /// <p>The specific digest path of the image hosted in this <code>ProductionVariant</code>.</p>
        pub fn resolved_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_image = Some(input.into());
            self
        }
        /// <p>The specific digest path of the image hosted in this <code>ProductionVariant</code>.</p>
        pub fn set_resolved_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_image = input;
            self
        }
        /// <p>The date and time when the image path for the model resolved to the <code>ResolvedImage</code> </p>
        pub fn resolution_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resolution_time = Some(input);
            self
        }
        /// <p>The date and time when the image path for the model resolved to the <code>ResolvedImage</code> </p>
        pub fn set_resolution_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resolution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployedImage`](crate::model::DeployedImage)
        pub fn build(self) -> crate::model::DeployedImage {
            crate::model::DeployedImage {
                specified_image: self.specified_image,
                resolved_image: self.resolved_image,
                resolution_time: self.resolution_time,
            }
        }
    }
}
impl DeployedImage {
    /// Creates a new builder-style object to manufacture [`DeployedImage`](crate::model::DeployedImage)
    pub fn builder() -> crate::model::deployed_image::Builder {
        crate::model::deployed_image::Builder::default()
    }
}

/// <p>The properties of a trial component as returned by the <code>Search</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponent {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
    pub source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>The status of the trial component.</p>
    pub status: std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the component ended.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who created the trial component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the component was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The hyperparameters of the component.</p>
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    >,
    /// <p>The input artifacts of the component.</p>
    pub input_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The output artifacts of the component.</p>
    pub output_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The metrics for the component.</p>
    pub metrics: std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>Details of the source of the component.</p>
    pub source_detail: std::option::Option<crate::model::TrialComponentSourceDetail>,
    /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
    pub lineage_group_arn: std::option::Option<std::string::String>,
    /// <p>The list of tags that are associated with the component. You can use <code>Search</code> API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of the parents of the component. A parent is a trial the component is associated with and the experiment the trial is part of. A component might not have any parents.</p>
    pub parents: std::option::Option<std::vec::Vec<crate::model::Parent>>,
}
impl TrialComponent {
    /// <p>The name of the trial component.</p>
    pub fn trial_component_name(&self) -> std::option::Option<&str> {
        self.trial_component_name.as_deref()
    }
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub fn trial_component_arn(&self) -> std::option::Option<&str> {
        self.trial_component_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::TrialComponentSource> {
        self.source.as_ref()
    }
    /// <p>The status of the trial component.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TrialComponentStatus> {
        self.status.as_ref()
    }
    /// <p>When the component started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>When the component ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>When the component was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Who created the trial component.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>When the component was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>The hyperparameters of the component.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    > {
        self.parameters.as_ref()
    }
    /// <p>The input artifacts of the component.</p>
    pub fn input_artifacts(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    > {
        self.input_artifacts.as_ref()
    }
    /// <p>The output artifacts of the component.</p>
    pub fn output_artifacts(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    > {
        self.output_artifacts.as_ref()
    }
    /// <p>The metrics for the component.</p>
    pub fn metrics(&self) -> std::option::Option<&[crate::model::TrialComponentMetricSummary]> {
        self.metrics.as_deref()
    }
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub fn metadata_properties(&self) -> std::option::Option<&crate::model::MetadataProperties> {
        self.metadata_properties.as_ref()
    }
    /// <p>Details of the source of the component.</p>
    pub fn source_detail(&self) -> std::option::Option<&crate::model::TrialComponentSourceDetail> {
        self.source_detail.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
    pub fn lineage_group_arn(&self) -> std::option::Option<&str> {
        self.lineage_group_arn.as_deref()
    }
    /// <p>The list of tags that are associated with the component. You can use <code>Search</code> API to search on the tags.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of the parents of the component. A parent is a trial the component is associated with and the experiment the trial is part of. A component might not have any parents.</p>
    pub fn parents(&self) -> std::option::Option<&[crate::model::Parent]> {
        self.parents.as_deref()
    }
}
impl std::fmt::Debug for TrialComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponent");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("source", &self.source);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("parameters", &self.parameters);
        formatter.field("input_artifacts", &self.input_artifacts);
        formatter.field("output_artifacts", &self.output_artifacts);
        formatter.field("metrics", &self.metrics);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("source_detail", &self.source_detail);
        formatter.field("lineage_group_arn", &self.lineage_group_arn);
        formatter.field("tags", &self.tags);
        formatter.field("parents", &self.parents);
        formatter.finish()
    }
}
/// See [`TrialComponent`](crate::model::TrialComponent)
pub mod trial_component {

    /// A builder for [`TrialComponent`](crate::model::TrialComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) status: std::option::Option<crate::model::TrialComponentStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::TrialComponentParameterValue,
            >,
        >,
        pub(crate) input_artifacts: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
        >,
        pub(crate) output_artifacts: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
        >,
        pub(crate) metrics:
            std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) source_detail: std::option::Option<crate::model::TrialComponentSourceDetail>,
        pub(crate) lineage_group_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) parents: std::option::Option<std::vec::Vec<crate::model::Parent>>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        /// <p>The name of the trial component.</p>
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
        pub fn source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The status of the trial component.</p>
        pub fn status(mut self, input: crate::model::TrialComponentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the trial component.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the component started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>When the component started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the component ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>When the component ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the component was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Who created the trial component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Who created the trial component.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The hyperparameters of the component.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::TrialComponentParameterValue,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.parameters = Some(hash_map);
            self
        }
        /// <p>The hyperparameters of the component.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentParameterValue,
                >,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Adds a key-value pair to `input_artifacts`.
        ///
        /// To override the contents of this collection use [`set_input_artifacts`](Self::set_input_artifacts).
        ///
        /// <p>The input artifacts of the component.</p>
        pub fn input_artifacts(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::TrialComponentArtifact,
        ) -> Self {
            let mut hash_map = self.input_artifacts.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.input_artifacts = Some(hash_map);
            self
        }
        /// <p>The input artifacts of the component.</p>
        pub fn set_input_artifacts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentArtifact,
                >,
            >,
        ) -> Self {
            self.input_artifacts = input;
            self
        }
        /// Adds a key-value pair to `output_artifacts`.
        ///
        /// To override the contents of this collection use [`set_output_artifacts`](Self::set_output_artifacts).
        ///
        /// <p>The output artifacts of the component.</p>
        pub fn output_artifacts(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::TrialComponentArtifact,
        ) -> Self {
            let mut hash_map = self.output_artifacts.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.output_artifacts = Some(hash_map);
            self
        }
        /// <p>The output artifacts of the component.</p>
        pub fn set_output_artifacts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentArtifact,
                >,
            >,
        ) -> Self {
            self.output_artifacts = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>The metrics for the component.</p>
        pub fn metrics(mut self, input: crate::model::TrialComponentMetricSummary) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input);
            self.metrics = Some(v);
            self
        }
        /// <p>The metrics for the component.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        /// <p>Details of the source of the component.</p>
        pub fn source_detail(mut self, input: crate::model::TrialComponentSourceDetail) -> Self {
            self.source_detail = Some(input);
            self
        }
        /// <p>Details of the source of the component.</p>
        pub fn set_source_detail(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSourceDetail>,
        ) -> Self {
            self.source_detail = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
        pub fn lineage_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lineage_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
        pub fn set_lineage_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lineage_group_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags that are associated with the component. You can use <code>Search</code> API to search on the tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags that are associated with the component. You can use <code>Search</code> API to search on the tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `parents`.
        ///
        /// To override the contents of this collection use [`set_parents`](Self::set_parents).
        ///
        /// <p>An array of the parents of the component. A parent is a trial the component is associated with and the experiment the trial is part of. A component might not have any parents.</p>
        pub fn parents(mut self, input: crate::model::Parent) -> Self {
            let mut v = self.parents.unwrap_or_default();
            v.push(input);
            self.parents = Some(v);
            self
        }
        /// <p>An array of the parents of the component. A parent is a trial the component is associated with and the experiment the trial is part of. A component might not have any parents.</p>
        pub fn set_parents(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Parent>>,
        ) -> Self {
            self.parents = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponent`](crate::model::TrialComponent)
        pub fn build(self) -> crate::model::TrialComponent {
            crate::model::TrialComponent {
                trial_component_name: self.trial_component_name,
                display_name: self.display_name,
                trial_component_arn: self.trial_component_arn,
                source: self.source,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                parameters: self.parameters,
                input_artifacts: self.input_artifacts,
                output_artifacts: self.output_artifacts,
                metrics: self.metrics,
                metadata_properties: self.metadata_properties,
                source_detail: self.source_detail,
                lineage_group_arn: self.lineage_group_arn,
                tags: self.tags,
                parents: self.parents,
            }
        }
    }
}
impl TrialComponent {
    /// Creates a new builder-style object to manufacture [`TrialComponent`](crate::model::TrialComponent)
    pub fn builder() -> crate::model::trial_component::Builder {
        crate::model::trial_component::Builder::default()
    }
}

/// <p>The trial that a trial component is associated with and the experiment the trial is part of. A component might not be associated with a trial. A component can be associated with multiple trials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parent {
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
}
impl Parent {
    /// <p>The name of the trial.</p>
    pub fn trial_name(&self) -> std::option::Option<&str> {
        self.trial_name.as_deref()
    }
    /// <p>The name of the experiment.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
}
impl std::fmt::Debug for Parent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parent");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.finish()
    }
}
/// See [`Parent`](crate::model::Parent)
pub mod parent {

    /// A builder for [`Parent`](crate::model::Parent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        /// <p>The name of the trial.</p>
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Parent`](crate::model::Parent)
        pub fn build(self) -> crate::model::Parent {
            crate::model::Parent {
                trial_name: self.trial_name,
                experiment_name: self.experiment_name,
            }
        }
    }
}
impl Parent {
    /// Creates a new builder-style object to manufacture [`Parent`](crate::model::Parent)
    pub fn builder() -> crate::model::parent::Builder {
        crate::model::parent::Builder::default()
    }
}

/// <p>Detailed information about the source of a trial component. Either <code>ProcessingJob</code> or <code>TrainingJob</code> is returned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSourceDetail {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>Information about a training job that's the source of a trial component.</p>
    pub training_job: std::option::Option<crate::model::TrainingJob>,
    /// <p>Information about a processing job that's the source of a trial component.</p>
    pub processing_job: std::option::Option<crate::model::ProcessingJob>,
    /// <p>Information about a transform job that's the source of a trial component.</p>
    pub transform_job: std::option::Option<crate::model::TransformJob>,
}
impl TrialComponentSourceDetail {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>Information about a training job that's the source of a trial component.</p>
    pub fn training_job(&self) -> std::option::Option<&crate::model::TrainingJob> {
        self.training_job.as_ref()
    }
    /// <p>Information about a processing job that's the source of a trial component.</p>
    pub fn processing_job(&self) -> std::option::Option<&crate::model::ProcessingJob> {
        self.processing_job.as_ref()
    }
    /// <p>Information about a transform job that's the source of a trial component.</p>
    pub fn transform_job(&self) -> std::option::Option<&crate::model::TransformJob> {
        self.transform_job.as_ref()
    }
}
impl std::fmt::Debug for TrialComponentSourceDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSourceDetail");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("training_job", &self.training_job);
        formatter.field("processing_job", &self.processing_job);
        formatter.field("transform_job", &self.transform_job);
        formatter.finish()
    }
}
/// See [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
pub mod trial_component_source_detail {

    /// A builder for [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) training_job: std::option::Option<crate::model::TrainingJob>,
        pub(crate) processing_job: std::option::Option<crate::model::ProcessingJob>,
        pub(crate) transform_job: std::option::Option<crate::model::TransformJob>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>Information about a training job that's the source of a trial component.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJob) -> Self {
            self.training_job = Some(input);
            self
        }
        /// <p>Information about a training job that's the source of a trial component.</p>
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJob>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>Information about a processing job that's the source of a trial component.</p>
        pub fn processing_job(mut self, input: crate::model::ProcessingJob) -> Self {
            self.processing_job = Some(input);
            self
        }
        /// <p>Information about a processing job that's the source of a trial component.</p>
        pub fn set_processing_job(
            mut self,
            input: std::option::Option<crate::model::ProcessingJob>,
        ) -> Self {
            self.processing_job = input;
            self
        }
        /// <p>Information about a transform job that's the source of a trial component.</p>
        pub fn transform_job(mut self, input: crate::model::TransformJob) -> Self {
            self.transform_job = Some(input);
            self
        }
        /// <p>Information about a transform job that's the source of a trial component.</p>
        pub fn set_transform_job(
            mut self,
            input: std::option::Option<crate::model::TransformJob>,
        ) -> Self {
            self.transform_job = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
        pub fn build(self) -> crate::model::TrialComponentSourceDetail {
            crate::model::TrialComponentSourceDetail {
                source_arn: self.source_arn,
                training_job: self.training_job,
                processing_job: self.processing_job,
                transform_job: self.transform_job,
            }
        }
    }
}
impl TrialComponentSourceDetail {
    /// Creates a new builder-style object to manufacture [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
    pub fn builder() -> crate::model::trial_component_source_detail::Builder {
        crate::model::trial_component_source_detail::Builder::default()
    }
}

/// <p>A batch transform job. For information about SageMaker batch transform, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform.html">Use Batch Transform</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJob {
    /// <p>The name of the transform job.</p>
    pub transform_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub transform_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the transform job.</p>
    /// <p>Transform job statuses are:</p>
    /// <ul>
    /// <li> <p> <code>InProgress</code> - The job is in progress.</p> </li>
    /// <li> <p> <code>Completed</code> - The job has completed.</p> </li>
    /// <li> <p> <code>Failed</code> - The transform job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTransformJob</code> call.</p> </li>
    /// <li> <p> <code>Stopping</code> - The transform job is stopping.</p> </li>
    /// <li> <p> <code>Stopped</code> - The transform job has stopped.</p> </li>
    /// </ul>
    pub transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
    /// <p>If the transform job failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The name of the model associated with the transform job.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms, you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
    pub max_concurrent_transforms: std::option::Option<i32>,
    /// <p>Configures the timeout and maximum number of retries for processing a transform job invocation.</p>
    pub model_client_config: std::option::Option<crate::model::ModelClientConfig>,
    /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in algorithms do not support HTTP chunked encoding.</p>
    pub max_payload_in_mb: std::option::Option<i32>,
    /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.</p>
    pub batch_strategy: std::option::Option<crate::model::BatchStrategy>,
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Describes the input source of a transform job and the way the transform job consumes it.</p>
    pub transform_input: std::option::Option<crate::model::TransformInput>,
    /// <p>Describes the results of a transform job.</p>
    pub transform_output: std::option::Option<crate::model::TransformOutput>,
    /// <p>Describes the resources, including ML instance types and ML instance count, to use for transform job.</p>
    pub transform_resources: std::option::Option<crate::model::TransformResources>,
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of <code>TransformEndTime</code>.</p>
    pub transform_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are billed for the time interval between this time and the value of <code>TransformStartTime</code>.</p>
    pub transform_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the labeling job that created the transform job.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction Results with their Corresponding Input Records</a>.</p>
    pub data_processing: std::option::Option<crate::model::DataProcessing>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>A list of tags associated with the transform job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TransformJob {
    /// <p>The name of the transform job.</p>
    pub fn transform_job_name(&self) -> std::option::Option<&str> {
        self.transform_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub fn transform_job_arn(&self) -> std::option::Option<&str> {
        self.transform_job_arn.as_deref()
    }
    /// <p>The status of the transform job.</p>
    /// <p>Transform job statuses are:</p>
    /// <ul>
    /// <li> <p> <code>InProgress</code> - The job is in progress.</p> </li>
    /// <li> <p> <code>Completed</code> - The job has completed.</p> </li>
    /// <li> <p> <code>Failed</code> - The transform job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTransformJob</code> call.</p> </li>
    /// <li> <p> <code>Stopping</code> - The transform job is stopping.</p> </li>
    /// <li> <p> <code>Stopped</code> - The transform job has stopped.</p> </li>
    /// </ul>
    pub fn transform_job_status(&self) -> std::option::Option<&crate::model::TransformJobStatus> {
        self.transform_job_status.as_ref()
    }
    /// <p>If the transform job failed, the reason it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The name of the model associated with the transform job.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms, you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
    pub fn max_concurrent_transforms(&self) -> std::option::Option<i32> {
        self.max_concurrent_transforms
    }
    /// <p>Configures the timeout and maximum number of retries for processing a transform job invocation.</p>
    pub fn model_client_config(&self) -> std::option::Option<&crate::model::ModelClientConfig> {
        self.model_client_config.as_ref()
    }
    /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in algorithms do not support HTTP chunked encoding.</p>
    pub fn max_payload_in_mb(&self) -> std::option::Option<i32> {
        self.max_payload_in_mb
    }
    /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.</p>
    pub fn batch_strategy(&self) -> std::option::Option<&crate::model::BatchStrategy> {
        self.batch_strategy.as_ref()
    }
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>Describes the input source of a transform job and the way the transform job consumes it.</p>
    pub fn transform_input(&self) -> std::option::Option<&crate::model::TransformInput> {
        self.transform_input.as_ref()
    }
    /// <p>Describes the results of a transform job.</p>
    pub fn transform_output(&self) -> std::option::Option<&crate::model::TransformOutput> {
        self.transform_output.as_ref()
    }
    /// <p>Describes the resources, including ML instance types and ML instance count, to use for transform job.</p>
    pub fn transform_resources(&self) -> std::option::Option<&crate::model::TransformResources> {
        self.transform_resources.as_ref()
    }
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of <code>TransformEndTime</code>.</p>
    pub fn transform_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.transform_start_time.as_ref()
    }
    /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are billed for the time interval between this time and the value of <code>TransformStartTime</code>.</p>
    pub fn transform_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.transform_end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the labeling job that created the transform job.</p>
    pub fn labeling_job_arn(&self) -> std::option::Option<&str> {
        self.labeling_job_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
    pub fn auto_ml_job_arn(&self) -> std::option::Option<&str> {
        self.auto_ml_job_arn.as_deref()
    }
    /// <p>The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction Results with their Corresponding Input Records</a>.</p>
    pub fn data_processing(&self) -> std::option::Option<&crate::model::DataProcessing> {
        self.data_processing.as_ref()
    }
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub fn experiment_config(&self) -> std::option::Option<&crate::model::ExperimentConfig> {
        self.experiment_config.as_ref()
    }
    /// <p>A list of tags associated with the transform job.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TransformJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJob");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.field("transform_job_status", &self.transform_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("model_name", &self.model_name);
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("model_client_config", &self.model_client_config);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("transform_start_time", &self.transform_start_time);
        formatter.field("transform_end_time", &self.transform_end_time);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("data_processing", &self.data_processing);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransformJob`](crate::model::TransformJob)
pub mod transform_job {

    /// A builder for [`TransformJob`](crate::model::TransformJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_job_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_arn: std::option::Option<std::string::String>,
        pub(crate) transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) max_concurrent_transforms: std::option::Option<i32>,
        pub(crate) model_client_config: std::option::Option<crate::model::ModelClientConfig>,
        pub(crate) max_payload_in_mb: std::option::Option<i32>,
        pub(crate) batch_strategy: std::option::Option<crate::model::BatchStrategy>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transform_input: std::option::Option<crate::model::TransformInput>,
        pub(crate) transform_output: std::option::Option<crate::model::TransformOutput>,
        pub(crate) transform_resources: std::option::Option<crate::model::TransformResources>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) transform_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) transform_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) data_processing: std::option::Option<crate::model::DataProcessing>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the transform job.</p>
        pub fn transform_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_name = Some(input.into());
            self
        }
        /// <p>The name of the transform job.</p>
        pub fn set_transform_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn transform_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn set_transform_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_arn = input;
            self
        }
        /// <p>The status of the transform job.</p>
        /// <p>Transform job statuses are:</p>
        /// <ul>
        /// <li> <p> <code>InProgress</code> - The job is in progress.</p> </li>
        /// <li> <p> <code>Completed</code> - The job has completed.</p> </li>
        /// <li> <p> <code>Failed</code> - The transform job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTransformJob</code> call.</p> </li>
        /// <li> <p> <code>Stopping</code> - The transform job is stopping.</p> </li>
        /// <li> <p> <code>Stopped</code> - The transform job has stopped.</p> </li>
        /// </ul>
        pub fn transform_job_status(mut self, input: crate::model::TransformJobStatus) -> Self {
            self.transform_job_status = Some(input);
            self
        }
        /// <p>The status of the transform job.</p>
        /// <p>Transform job statuses are:</p>
        /// <ul>
        /// <li> <p> <code>InProgress</code> - The job is in progress.</p> </li>
        /// <li> <p> <code>Completed</code> - The job has completed.</p> </li>
        /// <li> <p> <code>Failed</code> - The transform job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTransformJob</code> call.</p> </li>
        /// <li> <p> <code>Stopping</code> - The transform job is stopping.</p> </li>
        /// <li> <p> <code>Stopped</code> - The transform job has stopped.</p> </li>
        /// </ul>
        pub fn set_transform_job_status(
            mut self,
            input: std::option::Option<crate::model::TransformJobStatus>,
        ) -> Self {
            self.transform_job_status = input;
            self
        }
        /// <p>If the transform job failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the transform job failed, the reason it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The name of the model associated with the transform job.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model associated with the transform job.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms, you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
        pub fn max_concurrent_transforms(mut self, input: i32) -> Self {
            self.max_concurrent_transforms = Some(input);
            self
        }
        /// <p>The maximum number of parallel requests that can be sent to each instance in a transform job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms, you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
        pub fn set_max_concurrent_transforms(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_transforms = input;
            self
        }
        /// <p>Configures the timeout and maximum number of retries for processing a transform job invocation.</p>
        pub fn model_client_config(mut self, input: crate::model::ModelClientConfig) -> Self {
            self.model_client_config = Some(input);
            self
        }
        /// <p>Configures the timeout and maximum number of retries for processing a transform job invocation.</p>
        pub fn set_model_client_config(
            mut self,
            input: std::option::Option<crate::model::ModelClientConfig>,
        ) -> Self {
            self.model_client_config = input;
            self
        }
        /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in algorithms do not support HTTP chunked encoding.</p>
        pub fn max_payload_in_mb(mut self, input: i32) -> Self {
            self.max_payload_in_mb = Some(input);
            self
        }
        /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in algorithms do not support HTTP chunked encoding.</p>
        pub fn set_max_payload_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.max_payload_in_mb = input;
            self
        }
        /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.</p>
        pub fn batch_strategy(mut self, input: crate::model::BatchStrategy) -> Self {
            self.batch_strategy = Some(input);
            self
        }
        /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.</p>
        pub fn set_batch_strategy(
            mut self,
            input: std::option::Option<crate::model::BatchStrategy>,
        ) -> Self {
            self.batch_strategy = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Describes the input source of a transform job and the way the transform job consumes it.</p>
        pub fn transform_input(mut self, input: crate::model::TransformInput) -> Self {
            self.transform_input = Some(input);
            self
        }
        /// <p>Describes the input source of a transform job and the way the transform job consumes it.</p>
        pub fn set_transform_input(
            mut self,
            input: std::option::Option<crate::model::TransformInput>,
        ) -> Self {
            self.transform_input = input;
            self
        }
        /// <p>Describes the results of a transform job.</p>
        pub fn transform_output(mut self, input: crate::model::TransformOutput) -> Self {
            self.transform_output = Some(input);
            self
        }
        /// <p>Describes the results of a transform job.</p>
        pub fn set_transform_output(
            mut self,
            input: std::option::Option<crate::model::TransformOutput>,
        ) -> Self {
            self.transform_output = input;
            self
        }
        /// <p>Describes the resources, including ML instance types and ML instance count, to use for transform job.</p>
        pub fn transform_resources(mut self, input: crate::model::TransformResources) -> Self {
            self.transform_resources = Some(input);
            self
        }
        /// <p>Describes the resources, including ML instance types and ML instance count, to use for transform job.</p>
        pub fn set_transform_resources(
            mut self,
            input: std::option::Option<crate::model::TransformResources>,
        ) -> Self {
            self.transform_resources = input;
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of <code>TransformEndTime</code>.</p>
        pub fn transform_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.transform_start_time = Some(input);
            self
        }
        /// <p>Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of <code>TransformEndTime</code>.</p>
        pub fn set_transform_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.transform_start_time = input;
            self
        }
        /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are billed for the time interval between this time and the value of <code>TransformStartTime</code>.</p>
        pub fn transform_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.transform_end_time = Some(input);
            self
        }
        /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are billed for the time interval between this time and the value of <code>TransformStartTime</code>.</p>
        pub fn set_transform_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.transform_end_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the labeling job that created the transform job.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the labeling job that created the transform job.</p>
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction Results with their Corresponding Input Records</a>.</p>
        pub fn data_processing(mut self, input: crate::model::DataProcessing) -> Self {
            self.data_processing = Some(input);
            self
        }
        /// <p>The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction Results with their Corresponding Input Records</a>.</p>
        pub fn set_data_processing(
            mut self,
            input: std::option::Option<crate::model::DataProcessing>,
        ) -> Self {
            self.data_processing = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tags associated with the transform job.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>A list of tags associated with the transform job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJob`](crate::model::TransformJob)
        pub fn build(self) -> crate::model::TransformJob {
            crate::model::TransformJob {
                transform_job_name: self.transform_job_name,
                transform_job_arn: self.transform_job_arn,
                transform_job_status: self.transform_job_status,
                failure_reason: self.failure_reason,
                model_name: self.model_name,
                max_concurrent_transforms: self.max_concurrent_transforms,
                model_client_config: self.model_client_config,
                max_payload_in_mb: self.max_payload_in_mb,
                batch_strategy: self.batch_strategy,
                environment: self.environment,
                transform_input: self.transform_input,
                transform_output: self.transform_output,
                transform_resources: self.transform_resources,
                creation_time: self.creation_time,
                transform_start_time: self.transform_start_time,
                transform_end_time: self.transform_end_time,
                labeling_job_arn: self.labeling_job_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                data_processing: self.data_processing,
                experiment_config: self.experiment_config,
                tags: self.tags,
            }
        }
    }
}
impl TransformJob {
    /// Creates a new builder-style object to manufacture [`TransformJob`](crate::model::TransformJob)
    pub fn builder() -> crate::model::transform_job::Builder {
        crate::model::transform_job::Builder::default()
    }
}

/// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
/// <ul>
/// <li> <p> <code>CreateProcessingJob</code> </p> </li>
/// <li> <p> <code>CreateTrainingJob</code> </p> </li>
/// <li> <p> <code>CreateTransformJob</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentConfig {
    /// <p>The name of an existing experiment to associate the trial component with.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of an existing trial to associate the trial component with. If not specified, a new trial is created.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The display name for the trial component. If this key isn't specified, the display name is the trial component name.</p>
    pub trial_component_display_name: std::option::Option<std::string::String>,
}
impl ExperimentConfig {
    /// <p>The name of an existing experiment to associate the trial component with.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
    /// <p>The name of an existing trial to associate the trial component with. If not specified, a new trial is created.</p>
    pub fn trial_name(&self) -> std::option::Option<&str> {
        self.trial_name.as_deref()
    }
    /// <p>The display name for the trial component. If this key isn't specified, the display name is the trial component name.</p>
    pub fn trial_component_display_name(&self) -> std::option::Option<&str> {
        self.trial_component_display_name.as_deref()
    }
}
impl std::fmt::Debug for ExperimentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentConfig");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.field(
            "trial_component_display_name",
            &self.trial_component_display_name,
        );
        formatter.finish()
    }
}
/// See [`ExperimentConfig`](crate::model::ExperimentConfig)
pub mod experiment_config {

    /// A builder for [`ExperimentConfig`](crate::model::ExperimentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing experiment to associate the trial component with.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of an existing experiment to associate the trial component with.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of an existing trial to associate the trial component with. If not specified, a new trial is created.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        /// <p>The name of an existing trial to associate the trial component with. If not specified, a new trial is created.</p>
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The display name for the trial component. If this key isn't specified, the display name is the trial component name.</p>
        pub fn trial_component_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.trial_component_display_name = Some(input.into());
            self
        }
        /// <p>The display name for the trial component. If this key isn't specified, the display name is the trial component name.</p>
        pub fn set_trial_component_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentConfig`](crate::model::ExperimentConfig)
        pub fn build(self) -> crate::model::ExperimentConfig {
            crate::model::ExperimentConfig {
                experiment_name: self.experiment_name,
                trial_name: self.trial_name,
                trial_component_display_name: self.trial_component_display_name,
            }
        }
    }
}
impl ExperimentConfig {
    /// Creates a new builder-style object to manufacture [`ExperimentConfig`](crate::model::ExperimentConfig)
    pub fn builder() -> crate::model::experiment_config::Builder {
        crate::model::experiment_config::Builder::default()
    }
}

/// <p>The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction Results with their Corresponding Input Records</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataProcessing {
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an ID column, from the input. If you want SageMaker to pass the entire input dataset to the algorithm, accept the default value <code>$</code>.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code> </p>
    pub input_filter: std::option::Option<std::string::String>,
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save in the output file for a batch transform job. If you want SageMaker to store the entire input dataset in the output file, leave the default value, <code>$</code>. If you specify indexes that aren't within the dimension size of the joined dataset, you get an error.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>, <code>"$['id','SageMakerOutput']"</code> </p>
    pub output_filter: std::option::Option<std::string::String>,
    /// <p>Specifies the source of the data to join with the transformed data. The valid values are <code>None</code> and <code>Input</code>. The default value is <code>None</code>, which specifies not to join the input with the transformed data. If you want the batch transform job to join the original input data with the transformed data, set <code>JoinSource</code> to <code>Input</code>. You can specify <code>OutputFilter</code> as an additional filter to select a portion of the joined dataset and store it in the output file.</p>
    /// <p>For JSON or JSONLines objects, such as a JSON array, SageMaker adds the transformed data to the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined result for JSON must be a key-value pair object. If the input is not a key-value pair object, SageMaker creates a new JSON file. In the new JSON file, and the input data is stored under the <code>SageMakerInput</code> key and the results are stored in <code>SageMakerOutput</code>.</p>
    /// <p>For CSV data, SageMaker takes each row as a JSON array and joins the transformed data with the input by appending each transformed row to the end of the input. The joined data has the original input data followed by the transformed data and the output is a CSV file.</p>
    /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
    pub join_source: std::option::Option<crate::model::JoinSource>,
}
impl DataProcessing {
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an ID column, from the input. If you want SageMaker to pass the entire input dataset to the algorithm, accept the default value <code>$</code>.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code> </p>
    pub fn input_filter(&self) -> std::option::Option<&str> {
        self.input_filter.as_deref()
    }
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save in the output file for a batch transform job. If you want SageMaker to store the entire input dataset in the output file, leave the default value, <code>$</code>. If you specify indexes that aren't within the dimension size of the joined dataset, you get an error.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>, <code>"$['id','SageMakerOutput']"</code> </p>
    pub fn output_filter(&self) -> std::option::Option<&str> {
        self.output_filter.as_deref()
    }
    /// <p>Specifies the source of the data to join with the transformed data. The valid values are <code>None</code> and <code>Input</code>. The default value is <code>None</code>, which specifies not to join the input with the transformed data. If you want the batch transform job to join the original input data with the transformed data, set <code>JoinSource</code> to <code>Input</code>. You can specify <code>OutputFilter</code> as an additional filter to select a portion of the joined dataset and store it in the output file.</p>
    /// <p>For JSON or JSONLines objects, such as a JSON array, SageMaker adds the transformed data to the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined result for JSON must be a key-value pair object. If the input is not a key-value pair object, SageMaker creates a new JSON file. In the new JSON file, and the input data is stored under the <code>SageMakerInput</code> key and the results are stored in <code>SageMakerOutput</code>.</p>
    /// <p>For CSV data, SageMaker takes each row as a JSON array and joins the transformed data with the input by appending each transformed row to the end of the input. The joined data has the original input data followed by the transformed data and the output is a CSV file.</p>
    /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
    pub fn join_source(&self) -> std::option::Option<&crate::model::JoinSource> {
        self.join_source.as_ref()
    }
}
impl std::fmt::Debug for DataProcessing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataProcessing");
        formatter.field("input_filter", &self.input_filter);
        formatter.field("output_filter", &self.output_filter);
        formatter.field("join_source", &self.join_source);
        formatter.finish()
    }
}
/// See [`DataProcessing`](crate::model::DataProcessing)
pub mod data_processing {

    /// A builder for [`DataProcessing`](crate::model::DataProcessing)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_filter: std::option::Option<std::string::String>,
        pub(crate) output_filter: std::option::Option<std::string::String>,
        pub(crate) join_source: std::option::Option<crate::model::JoinSource>,
    }
    impl Builder {
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an ID column, from the input. If you want SageMaker to pass the entire input dataset to the algorithm, accept the default value <code>$</code>.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code> </p>
        pub fn input_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_filter = Some(input.into());
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an ID column, from the input. If you want SageMaker to pass the entire input dataset to the algorithm, accept the default value <code>$</code>.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code> </p>
        pub fn set_input_filter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_filter = input;
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save in the output file for a batch transform job. If you want SageMaker to store the entire input dataset in the output file, leave the default value, <code>$</code>. If you specify indexes that aren't within the dimension size of the joined dataset, you get an error.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>, <code>"$['id','SageMakerOutput']"</code> </p>
        pub fn output_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_filter = Some(input.into());
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save in the output file for a batch transform job. If you want SageMaker to store the entire input dataset in the output file, leave the default value, <code>$</code>. If you specify indexes that aren't within the dimension size of the joined dataset, you get an error.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>, <code>"$['id','SageMakerOutput']"</code> </p>
        pub fn set_output_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_filter = input;
            self
        }
        /// <p>Specifies the source of the data to join with the transformed data. The valid values are <code>None</code> and <code>Input</code>. The default value is <code>None</code>, which specifies not to join the input with the transformed data. If you want the batch transform job to join the original input data with the transformed data, set <code>JoinSource</code> to <code>Input</code>. You can specify <code>OutputFilter</code> as an additional filter to select a portion of the joined dataset and store it in the output file.</p>
        /// <p>For JSON or JSONLines objects, such as a JSON array, SageMaker adds the transformed data to the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined result for JSON must be a key-value pair object. If the input is not a key-value pair object, SageMaker creates a new JSON file. In the new JSON file, and the input data is stored under the <code>SageMakerInput</code> key and the results are stored in <code>SageMakerOutput</code>.</p>
        /// <p>For CSV data, SageMaker takes each row as a JSON array and joins the transformed data with the input by appending each transformed row to the end of the input. The joined data has the original input data followed by the transformed data and the output is a CSV file.</p>
        /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
        pub fn join_source(mut self, input: crate::model::JoinSource) -> Self {
            self.join_source = Some(input);
            self
        }
        /// <p>Specifies the source of the data to join with the transformed data. The valid values are <code>None</code> and <code>Input</code>. The default value is <code>None</code>, which specifies not to join the input with the transformed data. If you want the batch transform job to join the original input data with the transformed data, set <code>JoinSource</code> to <code>Input</code>. You can specify <code>OutputFilter</code> as an additional filter to select a portion of the joined dataset and store it in the output file.</p>
        /// <p>For JSON or JSONLines objects, such as a JSON array, SageMaker adds the transformed data to the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined result for JSON must be a key-value pair object. If the input is not a key-value pair object, SageMaker creates a new JSON file. In the new JSON file, and the input data is stored under the <code>SageMakerInput</code> key and the results are stored in <code>SageMakerOutput</code>.</p>
        /// <p>For CSV data, SageMaker takes each row as a JSON array and joins the transformed data with the input by appending each transformed row to the end of the input. The joined data has the original input data followed by the transformed data and the output is a CSV file.</p>
        /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
        pub fn set_join_source(
            mut self,
            input: std::option::Option<crate::model::JoinSource>,
        ) -> Self {
            self.join_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataProcessing`](crate::model::DataProcessing)
        pub fn build(self) -> crate::model::DataProcessing {
            crate::model::DataProcessing {
                input_filter: self.input_filter,
                output_filter: self.output_filter,
                join_source: self.join_source,
            }
        }
    }
}
impl DataProcessing {
    /// Creates a new builder-style object to manufacture [`DataProcessing`](crate::model::DataProcessing)
    pub fn builder() -> crate::model::data_processing::Builder {
        crate::model::data_processing::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JoinSource {
    #[allow(missing_docs)] // documentation missing in model
    Input,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for JoinSource {
    fn from(s: &str) -> Self {
        match s {
            "Input" => JoinSource::Input,
            "None" => JoinSource::None,
            other => JoinSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for JoinSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JoinSource::from(s))
    }
}
impl JoinSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JoinSource::Input => "Input",
            JoinSource::None => "None",
            JoinSource::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Input", "None"]
    }
}
impl AsRef<str> for JoinSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configures the timeout and maximum number of retries for processing a transform job invocation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelClientConfig {
    /// <p>The timeout value in seconds for an invocation request. The default value is 600.</p>
    pub invocations_timeout_in_seconds: std::option::Option<i32>,
    /// <p>The maximum number of retries when invocation requests are failing. The default value is 3.</p>
    pub invocations_max_retries: std::option::Option<i32>,
}
impl ModelClientConfig {
    /// <p>The timeout value in seconds for an invocation request. The default value is 600.</p>
    pub fn invocations_timeout_in_seconds(&self) -> std::option::Option<i32> {
        self.invocations_timeout_in_seconds
    }
    /// <p>The maximum number of retries when invocation requests are failing. The default value is 3.</p>
    pub fn invocations_max_retries(&self) -> std::option::Option<i32> {
        self.invocations_max_retries
    }
}
impl std::fmt::Debug for ModelClientConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelClientConfig");
        formatter.field(
            "invocations_timeout_in_seconds",
            &self.invocations_timeout_in_seconds,
        );
        formatter.field("invocations_max_retries", &self.invocations_max_retries);
        formatter.finish()
    }
}
/// See [`ModelClientConfig`](crate::model::ModelClientConfig)
pub mod model_client_config {

    /// A builder for [`ModelClientConfig`](crate::model::ModelClientConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invocations_timeout_in_seconds: std::option::Option<i32>,
        pub(crate) invocations_max_retries: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The timeout value in seconds for an invocation request. The default value is 600.</p>
        pub fn invocations_timeout_in_seconds(mut self, input: i32) -> Self {
            self.invocations_timeout_in_seconds = Some(input);
            self
        }
        /// <p>The timeout value in seconds for an invocation request. The default value is 600.</p>
        pub fn set_invocations_timeout_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.invocations_timeout_in_seconds = input;
            self
        }
        /// <p>The maximum number of retries when invocation requests are failing. The default value is 3.</p>
        pub fn invocations_max_retries(mut self, input: i32) -> Self {
            self.invocations_max_retries = Some(input);
            self
        }
        /// <p>The maximum number of retries when invocation requests are failing. The default value is 3.</p>
        pub fn set_invocations_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.invocations_max_retries = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelClientConfig`](crate::model::ModelClientConfig)
        pub fn build(self) -> crate::model::ModelClientConfig {
            crate::model::ModelClientConfig {
                invocations_timeout_in_seconds: self.invocations_timeout_in_seconds,
                invocations_max_retries: self.invocations_max_retries,
            }
        }
    }
}
impl ModelClientConfig {
    /// Creates a new builder-style object to manufacture [`ModelClientConfig`](crate::model::ModelClientConfig)
    pub fn builder() -> crate::model::model_client_config::Builder {
        crate::model::model_client_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransformJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TransformJobStatus::Completed,
            "Failed" => TransformJobStatus::Failed,
            "InProgress" => TransformJobStatus::InProgress,
            "Stopped" => TransformJobStatus::Stopped,
            "Stopping" => TransformJobStatus::Stopping,
            other => TransformJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransformJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformJobStatus::from(s))
    }
}
impl TransformJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformJobStatus::Completed => "Completed",
            TransformJobStatus::Failed => "Failed",
            TransformJobStatus::InProgress => "InProgress",
            TransformJobStatus::Stopped => "Stopped",
            TransformJobStatus::Stopping => "Stopping",
            TransformJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TransformJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An Amazon SageMaker processing job that is used to analyze data and evaluate models. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/processing-job.html">Process Data and Evaluate Models</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJob {
    /// <p>List of input configurations for the processing job.</p>
    pub processing_inputs: std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
    /// <p>Configuration for uploading output from the processing container.</p>
    pub processing_output_config: std::option::Option<crate::model::ProcessingOutputConfig>,
    /// <p>The name of the processing job.</p>
    pub processing_job_name: std::option::Option<std::string::String>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.</p>
    pub processing_resources: std::option::Option<crate::model::ProcessingResources>,
    /// <p>Configures conditions under which the processing job should be stopped, such as how long the processing job has been running. After the condition is met, the processing job is stopped.</p>
    pub stopping_condition: std::option::Option<crate::model::ProcessingStoppingCondition>,
    /// <p>Configuration to run a processing job in a specified container image.</p>
    pub app_specification: std::option::Option<crate::model::AppSpecification>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.</p>
    pub network_config: std::option::Option<crate::model::NetworkConfig>,
    /// <p>The ARN of the role used to create the processing job.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>The ARN of the processing job.</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the processing job.</p>
    pub processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>A string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
    pub exit_message: std::option::Option<std::string::String>,
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the processing job ended.</p>
    pub processing_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the processing job started.</p>
    pub processing_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the processing job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the processing job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing job.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the training job associated with this processing job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ProcessingJob {
    /// <p>List of input configurations for the processing job.</p>
    pub fn processing_inputs(&self) -> std::option::Option<&[crate::model::ProcessingInput]> {
        self.processing_inputs.as_deref()
    }
    /// <p>Configuration for uploading output from the processing container.</p>
    pub fn processing_output_config(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingOutputConfig> {
        self.processing_output_config.as_ref()
    }
    /// <p>The name of the processing job.</p>
    pub fn processing_job_name(&self) -> std::option::Option<&str> {
        self.processing_job_name.as_deref()
    }
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.</p>
    pub fn processing_resources(&self) -> std::option::Option<&crate::model::ProcessingResources> {
        self.processing_resources.as_ref()
    }
    /// <p>Configures conditions under which the processing job should be stopped, such as how long the processing job has been running. After the condition is met, the processing job is stopped.</p>
    pub fn stopping_condition(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingStoppingCondition> {
        self.stopping_condition.as_ref()
    }
    /// <p>Configuration to run a processing job in a specified container image.</p>
    pub fn app_specification(&self) -> std::option::Option<&crate::model::AppSpecification> {
        self.app_specification.as_ref()
    }
    /// <p>Sets the environment variables in the Docker container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.</p>
    pub fn network_config(&self) -> std::option::Option<&crate::model::NetworkConfig> {
        self.network_config.as_ref()
    }
    /// <p>The ARN of the role used to create the processing job.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub fn experiment_config(&self) -> std::option::Option<&crate::model::ExperimentConfig> {
        self.experiment_config.as_ref()
    }
    /// <p>The ARN of the processing job.</p>
    pub fn processing_job_arn(&self) -> std::option::Option<&str> {
        self.processing_job_arn.as_deref()
    }
    /// <p>The status of the processing job.</p>
    pub fn processing_job_status(&self) -> std::option::Option<&crate::model::ProcessingJobStatus> {
        self.processing_job_status.as_ref()
    }
    /// <p>A string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
    pub fn exit_message(&self) -> std::option::Option<&str> {
        self.exit_message.as_deref()
    }
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The time that the processing job ended.</p>
    pub fn processing_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.processing_end_time.as_ref()
    }
    /// <p>The time that the processing job started.</p>
    pub fn processing_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.processing_start_time.as_ref()
    }
    /// <p>The time the processing job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The time the processing job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing job.</p>
    pub fn monitoring_schedule_arn(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
    pub fn auto_ml_job_arn(&self) -> std::option::Option<&str> {
        self.auto_ml_job_arn.as_deref()
    }
    /// <p>The ARN of the training job associated with this processing job.</p>
    pub fn training_job_arn(&self) -> std::option::Option<&str> {
        self.training_job_arn.as_deref()
    }
    /// <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for ProcessingJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJob");
        formatter.field("processing_inputs", &self.processing_inputs);
        formatter.field("processing_output_config", &self.processing_output_config);
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_resources", &self.processing_resources);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("app_specification", &self.app_specification);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("processing_job_status", &self.processing_job_status);
        formatter.field("exit_message", &self.exit_message);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("processing_end_time", &self.processing_end_time);
        formatter.field("processing_start_time", &self.processing_start_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ProcessingJob`](crate::model::ProcessingJob)
pub mod processing_job {

    /// A builder for [`ProcessingJob`](crate::model::ProcessingJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) processing_inputs:
            std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
        pub(crate) processing_output_config:
            std::option::Option<crate::model::ProcessingOutputConfig>,
        pub(crate) processing_job_name: std::option::Option<std::string::String>,
        pub(crate) processing_resources: std::option::Option<crate::model::ProcessingResources>,
        pub(crate) stopping_condition:
            std::option::Option<crate::model::ProcessingStoppingCondition>,
        pub(crate) app_specification: std::option::Option<crate::model::AppSpecification>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) network_config: std::option::Option<crate::model::NetworkConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
        pub(crate) exit_message: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) processing_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) processing_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// Appends an item to `processing_inputs`.
        ///
        /// To override the contents of this collection use [`set_processing_inputs`](Self::set_processing_inputs).
        ///
        /// <p>List of input configurations for the processing job.</p>
        pub fn processing_inputs(mut self, input: crate::model::ProcessingInput) -> Self {
            let mut v = self.processing_inputs.unwrap_or_default();
            v.push(input);
            self.processing_inputs = Some(v);
            self
        }
        /// <p>List of input configurations for the processing job.</p>
        pub fn set_processing_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
        ) -> Self {
            self.processing_inputs = input;
            self
        }
        /// <p>Configuration for uploading output from the processing container.</p>
        pub fn processing_output_config(
            mut self,
            input: crate::model::ProcessingOutputConfig,
        ) -> Self {
            self.processing_output_config = Some(input);
            self
        }
        /// <p>Configuration for uploading output from the processing container.</p>
        pub fn set_processing_output_config(
            mut self,
            input: std::option::Option<crate::model::ProcessingOutputConfig>,
        ) -> Self {
            self.processing_output_config = input;
            self
        }
        /// <p>The name of the processing job.</p>
        pub fn processing_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_name = Some(input.into());
            self
        }
        /// <p>The name of the processing job.</p>
        pub fn set_processing_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_name = input;
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.</p>
        pub fn processing_resources(mut self, input: crate::model::ProcessingResources) -> Self {
            self.processing_resources = Some(input);
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.</p>
        pub fn set_processing_resources(
            mut self,
            input: std::option::Option<crate::model::ProcessingResources>,
        ) -> Self {
            self.processing_resources = input;
            self
        }
        /// <p>Configures conditions under which the processing job should be stopped, such as how long the processing job has been running. After the condition is met, the processing job is stopped.</p>
        pub fn stopping_condition(
            mut self,
            input: crate::model::ProcessingStoppingCondition,
        ) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        /// <p>Configures conditions under which the processing job should be stopped, such as how long the processing job has been running. After the condition is met, the processing job is stopped.</p>
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::ProcessingStoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>Configuration to run a processing job in a specified container image.</p>
        pub fn app_specification(mut self, input: crate::model::AppSpecification) -> Self {
            self.app_specification = Some(input);
            self
        }
        /// <p>Configuration to run a processing job in a specified container image.</p>
        pub fn set_app_specification(
            mut self,
            input: std::option::Option<crate::model::AppSpecification>,
        ) -> Self {
            self.app_specification = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.</p>
        pub fn network_config(mut self, input: crate::model::NetworkConfig) -> Self {
            self.network_config = Some(input);
            self
        }
        /// <p>Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.</p>
        pub fn set_network_config(
            mut self,
            input: std::option::Option<crate::model::NetworkConfig>,
        ) -> Self {
            self.network_config = input;
            self
        }
        /// <p>The ARN of the role used to create the processing job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role used to create the processing job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        /// <p>The ARN of the processing job.</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the processing job.</p>
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn processing_job_status(mut self, input: crate::model::ProcessingJobStatus) -> Self {
            self.processing_job_status = Some(input);
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn set_processing_job_status(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStatus>,
        ) -> Self {
            self.processing_job_status = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
        pub fn exit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.exit_message = Some(input.into());
            self
        }
        /// <p>A string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
        pub fn set_exit_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.exit_message = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the processing job ended.</p>
        pub fn processing_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.processing_end_time = Some(input);
            self
        }
        /// <p>The time that the processing job ended.</p>
        pub fn set_processing_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.processing_end_time = input;
            self
        }
        /// <p>The time that the processing job started.</p>
        pub fn processing_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.processing_start_time = Some(input);
            self
        }
        /// <p>The time that the processing job started.</p>
        pub fn set_processing_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.processing_start_time = input;
            self
        }
        /// <p>The time the processing job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time the processing job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The time the processing job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the processing job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing job.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing job.</p>
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The ARN of the training job associated with this processing job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the training job associated with this processing job.</p>
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJob`](crate::model::ProcessingJob)
        pub fn build(self) -> crate::model::ProcessingJob {
            crate::model::ProcessingJob {
                processing_inputs: self.processing_inputs,
                processing_output_config: self.processing_output_config,
                processing_job_name: self.processing_job_name,
                processing_resources: self.processing_resources,
                stopping_condition: self.stopping_condition,
                app_specification: self.app_specification,
                environment: self.environment,
                network_config: self.network_config,
                role_arn: self.role_arn,
                experiment_config: self.experiment_config,
                processing_job_arn: self.processing_job_arn,
                processing_job_status: self.processing_job_status,
                exit_message: self.exit_message,
                failure_reason: self.failure_reason,
                processing_end_time: self.processing_end_time,
                processing_start_time: self.processing_start_time,
                last_modified_time: self.last_modified_time,
                creation_time: self.creation_time,
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                training_job_arn: self.training_job_arn,
                tags: self.tags,
            }
        }
    }
}
impl ProcessingJob {
    /// Creates a new builder-style object to manufacture [`ProcessingJob`](crate::model::ProcessingJob)
    pub fn builder() -> crate::model::processing_job::Builder {
        crate::model::processing_job::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ProcessingJobStatus::Completed,
            "Failed" => ProcessingJobStatus::Failed,
            "InProgress" => ProcessingJobStatus::InProgress,
            "Stopped" => ProcessingJobStatus::Stopped,
            "Stopping" => ProcessingJobStatus::Stopping,
            other => ProcessingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingJobStatus::from(s))
    }
}
impl ProcessingJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingJobStatus::Completed => "Completed",
            ProcessingJobStatus::Failed => "Failed",
            ProcessingJobStatus::InProgress => "InProgress",
            ProcessingJobStatus::Stopped => "Stopped",
            ProcessingJobStatus::Stopping => "Stopping",
            ProcessingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for ProcessingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration to run a processing job in a specified container image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppSpecification {
    /// <p>The container image to be run by the processing job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The entrypoint for a container used to run a processing job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The arguments for a container used to run a processing job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AppSpecification {
    /// <p>The container image to be run by the processing job.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The entrypoint for a container used to run a processing job.</p>
    pub fn container_entrypoint(&self) -> std::option::Option<&[std::string::String]> {
        self.container_entrypoint.as_deref()
    }
    /// <p>The arguments for a container used to run a processing job.</p>
    pub fn container_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.container_arguments.as_deref()
    }
}
impl std::fmt::Debug for AppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.finish()
    }
}
/// See [`AppSpecification`](crate::model::AppSpecification)
pub mod app_specification {

    /// A builder for [`AppSpecification`](crate::model::AppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The container image to be run by the processing job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The container image to be run by the processing job.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Appends an item to `container_entrypoint`.
        ///
        /// To override the contents of this collection use [`set_container_entrypoint`](Self::set_container_entrypoint).
        ///
        /// <p>The entrypoint for a container used to run a processing job.</p>
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        /// <p>The entrypoint for a container used to run a processing job.</p>
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        /// Appends an item to `container_arguments`.
        ///
        /// To override the contents of this collection use [`set_container_arguments`](Self::set_container_arguments).
        ///
        /// <p>The arguments for a container used to run a processing job.</p>
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        /// <p>The arguments for a container used to run a processing job.</p>
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// Consumes the builder and constructs a [`AppSpecification`](crate::model::AppSpecification)
        pub fn build(self) -> crate::model::AppSpecification {
            crate::model::AppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
            }
        }
    }
}
impl AppSpecification {
    /// Creates a new builder-style object to manufacture [`AppSpecification`](crate::model::AppSpecification)
    pub fn builder() -> crate::model::app_specification::Builder {
        crate::model::app_specification::Builder::default()
    }
}

/// <p>Configures conditions under which the processing job should be stopped, such as how long the processing job has been running. After the condition is met, the processing job is stopped.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingStoppingCondition {
    /// <p>Specifies the maximum runtime in seconds.</p>
    pub max_runtime_in_seconds: i32,
}
impl ProcessingStoppingCondition {
    /// <p>Specifies the maximum runtime in seconds.</p>
    pub fn max_runtime_in_seconds(&self) -> i32 {
        self.max_runtime_in_seconds
    }
}
impl std::fmt::Debug for ProcessingStoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingStoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.finish()
    }
}
/// See [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
pub mod processing_stopping_condition {

    /// A builder for [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies the maximum runtime in seconds.</p>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        /// <p>Specifies the maximum runtime in seconds.</p>
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
        pub fn build(self) -> crate::model::ProcessingStoppingCondition {
            crate::model::ProcessingStoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
            }
        }
    }
}
impl ProcessingStoppingCondition {
    /// Creates a new builder-style object to manufacture [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
    pub fn builder() -> crate::model::processing_stopping_condition::Builder {
        crate::model::processing_stopping_condition::Builder::default()
    }
}

/// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingResources {
    /// <p>The configuration for the resources in a cluster used to run the processing job.</p>
    pub cluster_config: std::option::Option<crate::model::ProcessingClusterConfig>,
}
impl ProcessingResources {
    /// <p>The configuration for the resources in a cluster used to run the processing job.</p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::ProcessingClusterConfig> {
        self.cluster_config.as_ref()
    }
}
impl std::fmt::Debug for ProcessingResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingResources");
        formatter.field("cluster_config", &self.cluster_config);
        formatter.finish()
    }
}
/// See [`ProcessingResources`](crate::model::ProcessingResources)
pub mod processing_resources {

    /// A builder for [`ProcessingResources`](crate::model::ProcessingResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_config: std::option::Option<crate::model::ProcessingClusterConfig>,
    }
    impl Builder {
        /// <p>The configuration for the resources in a cluster used to run the processing job.</p>
        pub fn cluster_config(mut self, input: crate::model::ProcessingClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>The configuration for the resources in a cluster used to run the processing job.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ProcessingClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingResources`](crate::model::ProcessingResources)
        pub fn build(self) -> crate::model::ProcessingResources {
            crate::model::ProcessingResources {
                cluster_config: self.cluster_config,
            }
        }
    }
}
impl ProcessingResources {
    /// Creates a new builder-style object to manufacture [`ProcessingResources`](crate::model::ProcessingResources)
    pub fn builder() -> crate::model::processing_resources::Builder {
        crate::model::processing_resources::Builder::default()
    }
}

/// <p>Configuration for the cluster used to run a processing job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingClusterConfig {
    /// <p>The number of ML compute instances to use in the processing job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type for the processing job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must specify sufficient ML storage for your scenario.</p> <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_size_in_gb: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the processing job. </p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl ProcessingClusterConfig {
    /// <p>The number of ML compute instances to use in the processing job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>The ML compute instance type for the processing job.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::ProcessingInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must specify sufficient ML storage for your scenario.</p> <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub fn volume_size_in_gb(&self) -> std::option::Option<i32> {
        self.volume_size_in_gb
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the processing job. </p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for ProcessingClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingClusterConfig");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
pub mod processing_cluster_config {

    /// A builder for [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of ML compute instances to use in the processing job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of ML compute instances to use in the processing job. For distributed processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must specify sufficient ML storage for your scenario.</p> <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must specify sufficient ML storage for your scenario.</p> <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the processing job. </p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the processing job. </p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
        pub fn build(self) -> crate::model::ProcessingClusterConfig {
            crate::model::ProcessingClusterConfig {
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl ProcessingClusterConfig {
    /// Creates a new builder-style object to manufacture [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
    pub fn builder() -> crate::model::processing_cluster_config::Builder {
        crate::model::processing_cluster_config::Builder::default()
    }
}

/// <p>Configuration for uploading output from the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingOutputConfig {
    /// <p>An array of outputs configuring the data to upload from the processing container.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all outputs.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl ProcessingOutputConfig {
    /// <p>An array of outputs configuring the data to upload from the processing container.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::ProcessingOutput]> {
        self.outputs.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all outputs.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for ProcessingOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingOutputConfig");
        formatter.field("outputs", &self.outputs);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
pub mod processing_output_config {

    /// A builder for [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>An array of outputs configuring the data to upload from the processing container.</p>
        pub fn outputs(mut self, input: crate::model::ProcessingOutput) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>An array of outputs configuring the data to upload from the processing container.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all outputs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all outputs.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
        pub fn build(self) -> crate::model::ProcessingOutputConfig {
            crate::model::ProcessingOutputConfig {
                outputs: self.outputs,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl ProcessingOutputConfig {
    /// Creates a new builder-style object to manufacture [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
    pub fn builder() -> crate::model::processing_output_config::Builder {
        crate::model::processing_output_config::Builder::default()
    }
}

/// <p>Describes the results of a processing job. The processing output must specify exactly one of either <code>S3Output</code> or <code>FeatureStoreOutput</code> types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingOutput {
    /// <p>The name for the processing job output.</p>
    pub output_name: std::option::Option<std::string::String>,
    /// <p>Configuration for processing job outputs in Amazon S3.</p>
    pub s3_output: std::option::Option<crate::model::ProcessingS3Output>,
    /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output type is only supported when <code>AppManaged</code> is specified. </p>
    pub feature_store_output: std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
    /// <p>When <code>True</code>, output operations such as data upload are managed natively by the processing job application. When <code>False</code> (default), output operations are managed by Amazon SageMaker.</p>
    pub app_managed: bool,
}
impl ProcessingOutput {
    /// <p>The name for the processing job output.</p>
    pub fn output_name(&self) -> std::option::Option<&str> {
        self.output_name.as_deref()
    }
    /// <p>Configuration for processing job outputs in Amazon S3.</p>
    pub fn s3_output(&self) -> std::option::Option<&crate::model::ProcessingS3Output> {
        self.s3_output.as_ref()
    }
    /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output type is only supported when <code>AppManaged</code> is specified. </p>
    pub fn feature_store_output(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingFeatureStoreOutput> {
        self.feature_store_output.as_ref()
    }
    /// <p>When <code>True</code>, output operations such as data upload are managed natively by the processing job application. When <code>False</code> (default), output operations are managed by Amazon SageMaker.</p>
    pub fn app_managed(&self) -> bool {
        self.app_managed
    }
}
impl std::fmt::Debug for ProcessingOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingOutput");
        formatter.field("output_name", &self.output_name);
        formatter.field("s3_output", &self.s3_output);
        formatter.field("feature_store_output", &self.feature_store_output);
        formatter.field("app_managed", &self.app_managed);
        formatter.finish()
    }
}
/// See [`ProcessingOutput`](crate::model::ProcessingOutput)
pub mod processing_output {

    /// A builder for [`ProcessingOutput`](crate::model::ProcessingOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_name: std::option::Option<std::string::String>,
        pub(crate) s3_output: std::option::Option<crate::model::ProcessingS3Output>,
        pub(crate) feature_store_output:
            std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
        pub(crate) app_managed: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name for the processing job output.</p>
        pub fn output_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_name = Some(input.into());
            self
        }
        /// <p>The name for the processing job output.</p>
        pub fn set_output_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_name = input;
            self
        }
        /// <p>Configuration for processing job outputs in Amazon S3.</p>
        pub fn s3_output(mut self, input: crate::model::ProcessingS3Output) -> Self {
            self.s3_output = Some(input);
            self
        }
        /// <p>Configuration for processing job outputs in Amazon S3.</p>
        pub fn set_s3_output(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3Output>,
        ) -> Self {
            self.s3_output = input;
            self
        }
        /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output type is only supported when <code>AppManaged</code> is specified. </p>
        pub fn feature_store_output(
            mut self,
            input: crate::model::ProcessingFeatureStoreOutput,
        ) -> Self {
            self.feature_store_output = Some(input);
            self
        }
        /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output type is only supported when <code>AppManaged</code> is specified. </p>
        pub fn set_feature_store_output(
            mut self,
            input: std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
        ) -> Self {
            self.feature_store_output = input;
            self
        }
        /// <p>When <code>True</code>, output operations such as data upload are managed natively by the processing job application. When <code>False</code> (default), output operations are managed by Amazon SageMaker.</p>
        pub fn app_managed(mut self, input: bool) -> Self {
            self.app_managed = Some(input);
            self
        }
        /// <p>When <code>True</code>, output operations such as data upload are managed natively by the processing job application. When <code>False</code> (default), output operations are managed by Amazon SageMaker.</p>
        pub fn set_app_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.app_managed = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingOutput`](crate::model::ProcessingOutput)
        pub fn build(self) -> crate::model::ProcessingOutput {
            crate::model::ProcessingOutput {
                output_name: self.output_name,
                s3_output: self.s3_output,
                feature_store_output: self.feature_store_output,
                app_managed: self.app_managed.unwrap_or_default(),
            }
        }
    }
}
impl ProcessingOutput {
    /// Creates a new builder-style object to manufacture [`ProcessingOutput`](crate::model::ProcessingOutput)
    pub fn builder() -> crate::model::processing_output::Builder {
        crate::model::processing_output::Builder::default()
    }
}

/// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingFeatureStoreOutput {
    /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your processing script is responsible for putting records into your Feature Store.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
}
impl ProcessingFeatureStoreOutput {
    /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your processing script is responsible for putting records into your Feature Store.</p>
    pub fn feature_group_name(&self) -> std::option::Option<&str> {
        self.feature_group_name.as_deref()
    }
}
impl std::fmt::Debug for ProcessingFeatureStoreOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingFeatureStoreOutput");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.finish()
    }
}
/// See [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
pub mod processing_feature_store_output {

    /// A builder for [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your processing script is responsible for putting records into your Feature Store.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your processing script is responsible for putting records into your Feature Store.</p>
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
        pub fn build(self) -> crate::model::ProcessingFeatureStoreOutput {
            crate::model::ProcessingFeatureStoreOutput {
                feature_group_name: self.feature_group_name,
            }
        }
    }
}
impl ProcessingFeatureStoreOutput {
    /// Creates a new builder-style object to manufacture [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
    pub fn builder() -> crate::model::processing_feature_store_output::Builder {
        crate::model::processing_feature_store_output::Builder::default()
    }
}

/// <p>Configuration for uploading output data to Amazon S3 from the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingS3Output {
    /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of a processing job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3. <code>LocalPath</code> is an absolute path to a directory containing output files. This directory will be created by the platform and exist when your container's entrypoint is invoked.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether to upload the results of the processing job continuously or after the job completes.</p>
    pub s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
}
impl ProcessingS3Output {
    /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of a processing job.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3. <code>LocalPath</code> is an absolute path to a directory containing output files. This directory will be created by the platform and exist when your container's entrypoint is invoked.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Whether to upload the results of the processing job continuously or after the job completes.</p>
    pub fn s3_upload_mode(&self) -> std::option::Option<&crate::model::ProcessingS3UploadMode> {
        self.s3_upload_mode.as_ref()
    }
}
impl std::fmt::Debug for ProcessingS3Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingS3Output");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_upload_mode", &self.s3_upload_mode);
        formatter.finish()
    }
}
/// See [`ProcessingS3Output`](crate::model::ProcessingS3Output)
pub mod processing_s3_output {

    /// A builder for [`ProcessingS3Output`](crate::model::ProcessingS3Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
    }
    impl Builder {
        /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of a processing job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of a processing job.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3. <code>LocalPath</code> is an absolute path to a directory containing output files. This directory will be created by the platform and exist when your container's entrypoint is invoked.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3. <code>LocalPath</code> is an absolute path to a directory containing output files. This directory will be created by the platform and exist when your container's entrypoint is invoked.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether to upload the results of the processing job continuously or after the job completes.</p>
        pub fn s3_upload_mode(mut self, input: crate::model::ProcessingS3UploadMode) -> Self {
            self.s3_upload_mode = Some(input);
            self
        }
        /// <p>Whether to upload the results of the processing job continuously or after the job completes.</p>
        pub fn set_s3_upload_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3UploadMode>,
        ) -> Self {
            self.s3_upload_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingS3Output`](crate::model::ProcessingS3Output)
        pub fn build(self) -> crate::model::ProcessingS3Output {
            crate::model::ProcessingS3Output {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_upload_mode: self.s3_upload_mode,
            }
        }
    }
}
impl ProcessingS3Output {
    /// Creates a new builder-style object to manufacture [`ProcessingS3Output`](crate::model::ProcessingS3Output)
    pub fn builder() -> crate::model::processing_s3_output::Builder {
        crate::model::processing_s3_output::Builder::default()
    }
}

/// <p>The inputs for a processing job. The processing input must specify exactly one of either <code>S3Input</code> or <code>DatasetDefinition</code> types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingInput {
    /// <p>The name for the processing job input.</p>
    pub input_name: std::option::Option<std::string::String>,
    /// <p>When <code>True</code>, input operations such as data download are managed natively by the processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
    pub app_managed: bool,
    /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
    pub s3_input: std::option::Option<crate::model::ProcessingS3Input>,
    /// <p>Configuration for a Dataset Definition input. </p>
    pub dataset_definition: std::option::Option<crate::model::DatasetDefinition>,
}
impl ProcessingInput {
    /// <p>The name for the processing job input.</p>
    pub fn input_name(&self) -> std::option::Option<&str> {
        self.input_name.as_deref()
    }
    /// <p>When <code>True</code>, input operations such as data download are managed natively by the processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
    pub fn app_managed(&self) -> bool {
        self.app_managed
    }
    /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
    pub fn s3_input(&self) -> std::option::Option<&crate::model::ProcessingS3Input> {
        self.s3_input.as_ref()
    }
    /// <p>Configuration for a Dataset Definition input. </p>
    pub fn dataset_definition(&self) -> std::option::Option<&crate::model::DatasetDefinition> {
        self.dataset_definition.as_ref()
    }
}
impl std::fmt::Debug for ProcessingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingInput");
        formatter.field("input_name", &self.input_name);
        formatter.field("app_managed", &self.app_managed);
        formatter.field("s3_input", &self.s3_input);
        formatter.field("dataset_definition", &self.dataset_definition);
        formatter.finish()
    }
}
/// See [`ProcessingInput`](crate::model::ProcessingInput)
pub mod processing_input {

    /// A builder for [`ProcessingInput`](crate::model::ProcessingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_name: std::option::Option<std::string::String>,
        pub(crate) app_managed: std::option::Option<bool>,
        pub(crate) s3_input: std::option::Option<crate::model::ProcessingS3Input>,
        pub(crate) dataset_definition: std::option::Option<crate::model::DatasetDefinition>,
    }
    impl Builder {
        /// <p>The name for the processing job input.</p>
        pub fn input_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_name = Some(input.into());
            self
        }
        /// <p>The name for the processing job input.</p>
        pub fn set_input_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_name = input;
            self
        }
        /// <p>When <code>True</code>, input operations such as data download are managed natively by the processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
        pub fn app_managed(mut self, input: bool) -> Self {
            self.app_managed = Some(input);
            self
        }
        /// <p>When <code>True</code>, input operations such as data download are managed natively by the processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
        pub fn set_app_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.app_managed = input;
            self
        }
        /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
        pub fn s3_input(mut self, input: crate::model::ProcessingS3Input) -> Self {
            self.s3_input = Some(input);
            self
        }
        /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
        pub fn set_s3_input(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3Input>,
        ) -> Self {
            self.s3_input = input;
            self
        }
        /// <p>Configuration for a Dataset Definition input. </p>
        pub fn dataset_definition(mut self, input: crate::model::DatasetDefinition) -> Self {
            self.dataset_definition = Some(input);
            self
        }
        /// <p>Configuration for a Dataset Definition input. </p>
        pub fn set_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::DatasetDefinition>,
        ) -> Self {
            self.dataset_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingInput`](crate::model::ProcessingInput)
        pub fn build(self) -> crate::model::ProcessingInput {
            crate::model::ProcessingInput {
                input_name: self.input_name,
                app_managed: self.app_managed.unwrap_or_default(),
                s3_input: self.s3_input,
                dataset_definition: self.dataset_definition,
            }
        }
    }
}
impl ProcessingInput {
    /// Creates a new builder-style object to manufacture [`ProcessingInput`](crate::model::ProcessingInput)
    pub fn builder() -> crate::model::processing_input::Builder {
        crate::model::processing_input::Builder::default()
    }
}

/// <p>Configuration for Dataset Definition inputs. The Dataset Definition input must specify exactly one of either <code>AthenaDatasetDefinition</code> or <code>RedshiftDatasetDefinition</code> types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DatasetDefinition {
    /// <p>Configuration for Athena Dataset Definition input.</p>
    pub athena_dataset_definition: std::option::Option<crate::model::AthenaDatasetDefinition>,
    /// <p>Configuration for Redshift Dataset Definition input.</p>
    pub redshift_dataset_definition: std::option::Option<crate::model::RedshiftDatasetDefinition>,
    /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether the generated dataset is <code>FullyReplicated</code> or <code>ShardedByS3Key</code> (default).</p>
    pub data_distribution_type: std::option::Option<crate::model::DataDistributionType>,
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub input_mode: std::option::Option<crate::model::InputMode>,
}
impl DatasetDefinition {
    /// <p>Configuration for Athena Dataset Definition input.</p>
    pub fn athena_dataset_definition(
        &self,
    ) -> std::option::Option<&crate::model::AthenaDatasetDefinition> {
        self.athena_dataset_definition.as_ref()
    }
    /// <p>Configuration for Redshift Dataset Definition input.</p>
    pub fn redshift_dataset_definition(
        &self,
    ) -> std::option::Option<&crate::model::RedshiftDatasetDefinition> {
        self.redshift_dataset_definition.as_ref()
    }
    /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Whether the generated dataset is <code>FullyReplicated</code> or <code>ShardedByS3Key</code> (default).</p>
    pub fn data_distribution_type(
        &self,
    ) -> std::option::Option<&crate::model::DataDistributionType> {
        self.data_distribution_type.as_ref()
    }
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub fn input_mode(&self) -> std::option::Option<&crate::model::InputMode> {
        self.input_mode.as_ref()
    }
}
impl std::fmt::Debug for DatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DatasetDefinition");
        formatter.field("athena_dataset_definition", &self.athena_dataset_definition);
        formatter.field(
            "redshift_dataset_definition",
            &self.redshift_dataset_definition,
        );
        formatter.field("local_path", &self.local_path);
        formatter.field("data_distribution_type", &self.data_distribution_type);
        formatter.field("input_mode", &self.input_mode);
        formatter.finish()
    }
}
/// See [`DatasetDefinition`](crate::model::DatasetDefinition)
pub mod dataset_definition {

    /// A builder for [`DatasetDefinition`](crate::model::DatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) athena_dataset_definition:
            std::option::Option<crate::model::AthenaDatasetDefinition>,
        pub(crate) redshift_dataset_definition:
            std::option::Option<crate::model::RedshiftDatasetDefinition>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) data_distribution_type: std::option::Option<crate::model::DataDistributionType>,
        pub(crate) input_mode: std::option::Option<crate::model::InputMode>,
    }
    impl Builder {
        /// <p>Configuration for Athena Dataset Definition input.</p>
        pub fn athena_dataset_definition(
            mut self,
            input: crate::model::AthenaDatasetDefinition,
        ) -> Self {
            self.athena_dataset_definition = Some(input);
            self
        }
        /// <p>Configuration for Athena Dataset Definition input.</p>
        pub fn set_athena_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::AthenaDatasetDefinition>,
        ) -> Self {
            self.athena_dataset_definition = input;
            self
        }
        /// <p>Configuration for Redshift Dataset Definition input.</p>
        pub fn redshift_dataset_definition(
            mut self,
            input: crate::model::RedshiftDatasetDefinition,
        ) -> Self {
            self.redshift_dataset_definition = Some(input);
            self
        }
        /// <p>Configuration for Redshift Dataset Definition input.</p>
        pub fn set_redshift_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::RedshiftDatasetDefinition>,
        ) -> Self {
            self.redshift_dataset_definition = input;
            self
        }
        /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether the generated dataset is <code>FullyReplicated</code> or <code>ShardedByS3Key</code> (default).</p>
        pub fn data_distribution_type(mut self, input: crate::model::DataDistributionType) -> Self {
            self.data_distribution_type = Some(input);
            self
        }
        /// <p>Whether the generated dataset is <code>FullyReplicated</code> or <code>ShardedByS3Key</code> (default).</p>
        pub fn set_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::DataDistributionType>,
        ) -> Self {
            self.data_distribution_type = input;
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
        pub fn input_mode(mut self, input: crate::model::InputMode) -> Self {
            self.input_mode = Some(input);
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
        pub fn set_input_mode(
            mut self,
            input: std::option::Option<crate::model::InputMode>,
        ) -> Self {
            self.input_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetDefinition`](crate::model::DatasetDefinition)
        pub fn build(self) -> crate::model::DatasetDefinition {
            crate::model::DatasetDefinition {
                athena_dataset_definition: self.athena_dataset_definition,
                redshift_dataset_definition: self.redshift_dataset_definition,
                local_path: self.local_path,
                data_distribution_type: self.data_distribution_type,
                input_mode: self.input_mode,
            }
        }
    }
}
impl DatasetDefinition {
    /// Creates a new builder-style object to manufacture [`DatasetDefinition`](crate::model::DatasetDefinition)
    pub fn builder() -> crate::model::dataset_definition::Builder {
        crate::model::dataset_definition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InputMode {
    #[allow(missing_docs)] // documentation missing in model
    File,
    #[allow(missing_docs)] // documentation missing in model
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InputMode {
    fn from(s: &str) -> Self {
        match s {
            "File" => InputMode::File,
            "Pipe" => InputMode::Pipe,
            other => InputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InputMode::from(s))
    }
}
impl InputMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InputMode::File => "File",
            InputMode::Pipe => "Pipe",
            InputMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["File", "Pipe"]
    }
}
impl AsRef<str> for InputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataDistributionType {
    #[allow(missing_docs)] // documentation missing in model
    Fullyreplicated,
    #[allow(missing_docs)] // documentation missing in model
    Shardedbys3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataDistributionType {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => DataDistributionType::Fullyreplicated,
            "ShardedByS3Key" => DataDistributionType::Shardedbys3Key,
            other => DataDistributionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataDistributionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataDistributionType::from(s))
    }
}
impl DataDistributionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataDistributionType::Fullyreplicated => "FullyReplicated",
            DataDistributionType::Shardedbys3Key => "ShardedByS3Key",
            DataDistributionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for DataDistributionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for Redshift Dataset Definition input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedshiftDatasetDefinition {
    /// <p>The Redshift cluster Identifier.</p>
    pub cluster_id: std::option::Option<std::string::String>,
    /// <p>The name of the Redshift database used in Redshift query execution.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The database user name used in Redshift query execution.</p>
    pub db_user: std::option::Option<std::string::String>,
    /// <p>The SQL query statements to be executed.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
    pub cluster_role_arn: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
    pub output_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a Redshift execution.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The data storage format for Redshift query results.</p>
    pub output_format: std::option::Option<crate::model::RedshiftResultFormat>,
    /// <p>The compression used for Redshift query results.</p>
    pub output_compression: std::option::Option<crate::model::RedshiftResultCompressionType>,
}
impl RedshiftDatasetDefinition {
    /// <p>The Redshift cluster Identifier.</p>
    pub fn cluster_id(&self) -> std::option::Option<&str> {
        self.cluster_id.as_deref()
    }
    /// <p>The name of the Redshift database used in Redshift query execution.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The database user name used in Redshift query execution.</p>
    pub fn db_user(&self) -> std::option::Option<&str> {
        self.db_user.as_deref()
    }
    /// <p>The SQL query statements to be executed.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
    pub fn cluster_role_arn(&self) -> std::option::Option<&str> {
        self.cluster_role_arn.as_deref()
    }
    /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
    pub fn output_s3_uri(&self) -> std::option::Option<&str> {
        self.output_s3_uri.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a Redshift execution.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The data storage format for Redshift query results.</p>
    pub fn output_format(&self) -> std::option::Option<&crate::model::RedshiftResultFormat> {
        self.output_format.as_ref()
    }
    /// <p>The compression used for Redshift query results.</p>
    pub fn output_compression(
        &self,
    ) -> std::option::Option<&crate::model::RedshiftResultCompressionType> {
        self.output_compression.as_ref()
    }
}
impl std::fmt::Debug for RedshiftDatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedshiftDatasetDefinition");
        formatter.field("cluster_id", &self.cluster_id);
        formatter.field("database", &self.database);
        formatter.field("db_user", &self.db_user);
        formatter.field("query_string", &self.query_string);
        formatter.field("cluster_role_arn", &self.cluster_role_arn);
        formatter.field("output_s3_uri", &self.output_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("output_format", &self.output_format);
        formatter.field("output_compression", &self.output_compression);
        formatter.finish()
    }
}
/// See [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
pub mod redshift_dataset_definition {

    /// A builder for [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_id: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) db_user: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) cluster_role_arn: std::option::Option<std::string::String>,
        pub(crate) output_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<crate::model::RedshiftResultFormat>,
        pub(crate) output_compression:
            std::option::Option<crate::model::RedshiftResultCompressionType>,
    }
    impl Builder {
        /// <p>The Redshift cluster Identifier.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_id = Some(input.into());
            self
        }
        /// <p>The Redshift cluster Identifier.</p>
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_id = input;
            self
        }
        /// <p>The name of the Redshift database used in Redshift query execution.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the Redshift database used in Redshift query execution.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The database user name used in Redshift query execution.</p>
        pub fn db_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_user = Some(input.into());
            self
        }
        /// <p>The database user name used in Redshift query execution.</p>
        pub fn set_db_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_user = input;
            self
        }
        /// <p>The SQL query statements to be executed.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The SQL query statements to be executed.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
        pub fn cluster_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
        pub fn set_cluster_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_role_arn = input;
            self
        }
        /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
        pub fn output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_uri = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
        pub fn set_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a Redshift execution.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a Redshift execution.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The data storage format for Redshift query results.</p>
        pub fn output_format(mut self, input: crate::model::RedshiftResultFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        /// <p>The data storage format for Redshift query results.</p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::RedshiftResultFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p>The compression used for Redshift query results.</p>
        pub fn output_compression(
            mut self,
            input: crate::model::RedshiftResultCompressionType,
        ) -> Self {
            self.output_compression = Some(input);
            self
        }
        /// <p>The compression used for Redshift query results.</p>
        pub fn set_output_compression(
            mut self,
            input: std::option::Option<crate::model::RedshiftResultCompressionType>,
        ) -> Self {
            self.output_compression = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
        pub fn build(self) -> crate::model::RedshiftDatasetDefinition {
            crate::model::RedshiftDatasetDefinition {
                cluster_id: self.cluster_id,
                database: self.database,
                db_user: self.db_user,
                query_string: self.query_string,
                cluster_role_arn: self.cluster_role_arn,
                output_s3_uri: self.output_s3_uri,
                kms_key_id: self.kms_key_id,
                output_format: self.output_format,
                output_compression: self.output_compression,
            }
        }
    }
}
impl RedshiftDatasetDefinition {
    /// Creates a new builder-style object to manufacture [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
    pub fn builder() -> crate::model::redshift_dataset_definition::Builder {
        crate::model::redshift_dataset_definition::Builder::default()
    }
}

/// <p>The compression used for Redshift query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedshiftResultCompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Bzip2,
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Snappy,
    #[allow(missing_docs)] // documentation missing in model
    Zstd,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedshiftResultCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "BZIP2" => RedshiftResultCompressionType::Bzip2,
            "GZIP" => RedshiftResultCompressionType::Gzip,
            "None" => RedshiftResultCompressionType::None,
            "SNAPPY" => RedshiftResultCompressionType::Snappy,
            "ZSTD" => RedshiftResultCompressionType::Zstd,
            other => RedshiftResultCompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedshiftResultCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedshiftResultCompressionType::from(s))
    }
}
impl RedshiftResultCompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RedshiftResultCompressionType::Bzip2 => "BZIP2",
            RedshiftResultCompressionType::Gzip => "GZIP",
            RedshiftResultCompressionType::None => "None",
            RedshiftResultCompressionType::Snappy => "SNAPPY",
            RedshiftResultCompressionType::Zstd => "ZSTD",
            RedshiftResultCompressionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["BZIP2", "GZIP", "None", "SNAPPY", "ZSTD"]
    }
}
impl AsRef<str> for RedshiftResultCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data storage format for Redshift query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedshiftResultFormat {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Parquet,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedshiftResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => RedshiftResultFormat::Csv,
            "PARQUET" => RedshiftResultFormat::Parquet,
            other => RedshiftResultFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedshiftResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedshiftResultFormat::from(s))
    }
}
impl RedshiftResultFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RedshiftResultFormat::Csv => "CSV",
            RedshiftResultFormat::Parquet => "PARQUET",
            RedshiftResultFormat::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CSV", "PARQUET"]
    }
}
impl AsRef<str> for RedshiftResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for Athena Dataset Definition input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AthenaDatasetDefinition {
    /// <p>The name of the data catalog used in Athena query execution.</p>
    pub catalog: std::option::Option<std::string::String>,
    /// <p>The name of the database used in the Athena query execution.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The SQL query statements, to be executed.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup in which the Athena query is being started.</p>
    pub work_group: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where Athena query results are stored.</p>
    pub output_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from an Athena query execution.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The data storage format for Athena query results.</p>
    pub output_format: std::option::Option<crate::model::AthenaResultFormat>,
    /// <p>The compression used for Athena query results.</p>
    pub output_compression: std::option::Option<crate::model::AthenaResultCompressionType>,
}
impl AthenaDatasetDefinition {
    /// <p>The name of the data catalog used in Athena query execution.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
    /// <p>The name of the database used in the Athena query execution.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The SQL query statements, to be executed.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The name of the workgroup in which the Athena query is being started.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>The location in Amazon S3 where Athena query results are stored.</p>
    pub fn output_s3_uri(&self) -> std::option::Option<&str> {
        self.output_s3_uri.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from an Athena query execution.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The data storage format for Athena query results.</p>
    pub fn output_format(&self) -> std::option::Option<&crate::model::AthenaResultFormat> {
        self.output_format.as_ref()
    }
    /// <p>The compression used for Athena query results.</p>
    pub fn output_compression(
        &self,
    ) -> std::option::Option<&crate::model::AthenaResultCompressionType> {
        self.output_compression.as_ref()
    }
}
impl std::fmt::Debug for AthenaDatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AthenaDatasetDefinition");
        formatter.field("catalog", &self.catalog);
        formatter.field("database", &self.database);
        formatter.field("query_string", &self.query_string);
        formatter.field("work_group", &self.work_group);
        formatter.field("output_s3_uri", &self.output_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("output_format", &self.output_format);
        formatter.field("output_compression", &self.output_compression);
        formatter.finish()
    }
}
/// See [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
pub mod athena_dataset_definition {

    /// A builder for [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) output_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<crate::model::AthenaResultFormat>,
        pub(crate) output_compression:
            std::option::Option<crate::model::AthenaResultCompressionType>,
    }
    impl Builder {
        /// <p>The name of the data catalog used in Athena query execution.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>The name of the data catalog used in Athena query execution.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The name of the database used in the Athena query execution.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database used in the Athena query execution.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The SQL query statements, to be executed.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The SQL query statements, to be executed.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The name of the workgroup in which the Athena query is being started.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the workgroup in which the Athena query is being started.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>The location in Amazon S3 where Athena query results are stored.</p>
        pub fn output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_uri = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where Athena query results are stored.</p>
        pub fn set_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from an Athena query execution.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from an Athena query execution.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The data storage format for Athena query results.</p>
        pub fn output_format(mut self, input: crate::model::AthenaResultFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        /// <p>The data storage format for Athena query results.</p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::AthenaResultFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p>The compression used for Athena query results.</p>
        pub fn output_compression(
            mut self,
            input: crate::model::AthenaResultCompressionType,
        ) -> Self {
            self.output_compression = Some(input);
            self
        }
        /// <p>The compression used for Athena query results.</p>
        pub fn set_output_compression(
            mut self,
            input: std::option::Option<crate::model::AthenaResultCompressionType>,
        ) -> Self {
            self.output_compression = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
        pub fn build(self) -> crate::model::AthenaDatasetDefinition {
            crate::model::AthenaDatasetDefinition {
                catalog: self.catalog,
                database: self.database,
                query_string: self.query_string,
                work_group: self.work_group,
                output_s3_uri: self.output_s3_uri,
                kms_key_id: self.kms_key_id,
                output_format: self.output_format,
                output_compression: self.output_compression,
            }
        }
    }
}
impl AthenaDatasetDefinition {
    /// Creates a new builder-style object to manufacture [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
    pub fn builder() -> crate::model::athena_dataset_definition::Builder {
        crate::model::athena_dataset_definition::Builder::default()
    }
}

/// <p>The compression used for Athena query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AthenaResultCompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    Snappy,
    #[allow(missing_docs)] // documentation missing in model
    Zlib,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AthenaResultCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "GZIP" => AthenaResultCompressionType::Gzip,
            "SNAPPY" => AthenaResultCompressionType::Snappy,
            "ZLIB" => AthenaResultCompressionType::Zlib,
            other => AthenaResultCompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AthenaResultCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AthenaResultCompressionType::from(s))
    }
}
impl AthenaResultCompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AthenaResultCompressionType::Gzip => "GZIP",
            AthenaResultCompressionType::Snappy => "SNAPPY",
            AthenaResultCompressionType::Zlib => "ZLIB",
            AthenaResultCompressionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["GZIP", "SNAPPY", "ZLIB"]
    }
}
impl AsRef<str> for AthenaResultCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data storage format for Athena query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AthenaResultFormat {
    #[allow(missing_docs)] // documentation missing in model
    Avro,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Orc,
    #[allow(missing_docs)] // documentation missing in model
    Parquet,
    #[allow(missing_docs)] // documentation missing in model
    Textfile,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AthenaResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "AVRO" => AthenaResultFormat::Avro,
            "JSON" => AthenaResultFormat::Json,
            "ORC" => AthenaResultFormat::Orc,
            "PARQUET" => AthenaResultFormat::Parquet,
            "TEXTFILE" => AthenaResultFormat::Textfile,
            other => AthenaResultFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AthenaResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AthenaResultFormat::from(s))
    }
}
impl AthenaResultFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AthenaResultFormat::Avro => "AVRO",
            AthenaResultFormat::Json => "JSON",
            AthenaResultFormat::Orc => "ORC",
            AthenaResultFormat::Parquet => "PARQUET",
            AthenaResultFormat::Textfile => "TEXTFILE",
            AthenaResultFormat::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AVRO", "JSON", "ORC", "PARQUET", "TEXTFILE"]
    }
}
impl AsRef<str> for AthenaResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingS3Input {
    /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path in your container where you want Amazon SageMaker to write input data to. <code>LocalPath</code> is an absolute path to the input data and must begin with <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for the processing job.</p>
    pub s3_data_type: std::option::Option<crate::model::ProcessingS3DataType>,
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data from the input source onto the local ML storage volume before starting your processing container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your processing container into named pipes without using the ML storage volume.</p>
    pub s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
    /// <p>Whether to distribute the data from Amazon S3 to all processing instances with <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key, downloading one shard of data to each processing instance.</p>
    pub s3_data_distribution_type:
        std::option::Option<crate::model::ProcessingS3DataDistributionType>,
    /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your container without using the EBS volume.</p>
    pub s3_compression_type: std::option::Option<crate::model::ProcessingS3CompressionType>,
}
impl ProcessingS3Input {
    /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The local path in your container where you want Amazon SageMaker to write input data to. <code>LocalPath</code> is an absolute path to the input data and must begin with <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for the processing job.</p>
    pub fn s3_data_type(&self) -> std::option::Option<&crate::model::ProcessingS3DataType> {
        self.s3_data_type.as_ref()
    }
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data from the input source onto the local ML storage volume before starting your processing container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your processing container into named pipes without using the ML storage volume.</p>
    pub fn s3_input_mode(&self) -> std::option::Option<&crate::model::ProcessingS3InputMode> {
        self.s3_input_mode.as_ref()
    }
    /// <p>Whether to distribute the data from Amazon S3 to all processing instances with <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key, downloading one shard of data to each processing instance.</p>
    pub fn s3_data_distribution_type(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingS3DataDistributionType> {
        self.s3_data_distribution_type.as_ref()
    }
    /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your container without using the EBS volume.</p>
    pub fn s3_compression_type(
        &self,
    ) -> std::option::Option<&crate::model::ProcessingS3CompressionType> {
        self.s3_compression_type.as_ref()
    }
}
impl std::fmt::Debug for ProcessingS3Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingS3Input");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_input_mode", &self.s3_input_mode);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("s3_compression_type", &self.s3_compression_type);
        formatter.finish()
    }
}
/// See [`ProcessingS3Input`](crate::model::ProcessingS3Input)
pub mod processing_s3_input {

    /// A builder for [`ProcessingS3Input`](crate::model::ProcessingS3Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_data_type: std::option::Option<crate::model::ProcessingS3DataType>,
        pub(crate) s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
        pub(crate) s3_data_distribution_type:
            std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        pub(crate) s3_compression_type:
            std::option::Option<crate::model::ProcessingS3CompressionType>,
    }
    impl Builder {
        /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path in your container where you want Amazon SageMaker to write input data to. <code>LocalPath</code> is an absolute path to the input data and must begin with <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>The local path in your container where you want Amazon SageMaker to write input data to. <code>LocalPath</code> is an absolute path to the input data and must begin with <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for the processing job.</p>
        pub fn s3_data_type(mut self, input: crate::model::ProcessingS3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for the processing job.</p>
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data from the input source onto the local ML storage volume before starting your processing container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your processing container into named pipes without using the ML storage volume.</p>
        pub fn s3_input_mode(mut self, input: crate::model::ProcessingS3InputMode) -> Self {
            self.s3_input_mode = Some(input);
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data from the input source onto the local ML storage volume before starting your processing container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your processing container into named pipes without using the ML storage volume.</p>
        pub fn set_s3_input_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3InputMode>,
        ) -> Self {
            self.s3_input_mode = input;
            self
        }
        /// <p>Whether to distribute the data from Amazon S3 to all processing instances with <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key, downloading one shard of data to each processing instance.</p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::ProcessingS3DataDistributionType,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        /// <p>Whether to distribute the data from Amazon S3 to all processing instances with <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key, downloading one shard of data to each processing instance.</p>
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your container without using the EBS volume.</p>
        pub fn s3_compression_type(
            mut self,
            input: crate::model::ProcessingS3CompressionType,
        ) -> Self {
            self.s3_compression_type = Some(input);
            self
        }
        /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your container without using the EBS volume.</p>
        pub fn set_s3_compression_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3CompressionType>,
        ) -> Self {
            self.s3_compression_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingS3Input`](crate::model::ProcessingS3Input)
        pub fn build(self) -> crate::model::ProcessingS3Input {
            crate::model::ProcessingS3Input {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_data_type: self.s3_data_type,
                s3_input_mode: self.s3_input_mode,
                s3_data_distribution_type: self.s3_data_distribution_type,
                s3_compression_type: self.s3_compression_type,
            }
        }
    }
}
impl ProcessingS3Input {
    /// Creates a new builder-style object to manufacture [`ProcessingS3Input`](crate::model::ProcessingS3Input)
    pub fn builder() -> crate::model::processing_s3_input::Builder {
        crate::model::processing_s3_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3CompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3CompressionType {
    fn from(s: &str) -> Self {
        match s {
            "Gzip" => ProcessingS3CompressionType::Gzip,
            "None" => ProcessingS3CompressionType::None,
            other => ProcessingS3CompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3CompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3CompressionType::from(s))
    }
}
impl ProcessingS3CompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3CompressionType::Gzip => "Gzip",
            ProcessingS3CompressionType::None => "None",
            ProcessingS3CompressionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Gzip", "None"]
    }
}
impl AsRef<str> for ProcessingS3CompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3DataType {
    #[allow(missing_docs)] // documentation missing in model
    ManifestFile,
    #[allow(missing_docs)] // documentation missing in model
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3DataType {
    fn from(s: &str) -> Self {
        match s {
            "ManifestFile" => ProcessingS3DataType::ManifestFile,
            "S3Prefix" => ProcessingS3DataType::S3Prefix,
            other => ProcessingS3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3DataType::from(s))
    }
}
impl ProcessingS3DataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3DataType::ManifestFile => "ManifestFile",
            ProcessingS3DataType::S3Prefix => "S3Prefix",
            ProcessingS3DataType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for ProcessingS3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJob {
    /// <p>The name of the training job.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.</p>
    pub tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>Information about the Amazon S3 location that is configured for storing model artifacts.</p>
    pub model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
    /// <p>The status of the training job.</p>
    /// <p>Training job statuses are:</p>
    /// <ul>
    /// <li> <p> <code>InProgress</code> - The training is in progress.</p> </li>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// <li> <p> <code>Failed</code> - The training job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTrainingJobResponse</code> call.</p> </li>
    /// <li> <p> <code>Stopping</code> - The training job is stopping.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// <p>For more detailed information, see <code>SecondaryStatus</code>. </p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    /// <p> Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see <code>StatusMessage</code> under <code>SecondaryStatusTransition</code>.</p>
    /// <p>SageMaker provides primary statuses and secondary statuses that apply to each of them:</p>
    /// <dl>
    /// <dt>
    /// InProgress
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
    /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
    /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
    /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Completed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Failed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopped
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopping
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl> <important>
    /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
    /// </important>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
    /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
    /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
    /// </ul>
    pub secondary_status: std::option::Option<crate::model::SecondaryStatus>,
    /// <p>If the training job failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Algorithm-specific parameters.</p>
    pub hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
    pub algorithm_specification: std::option::Option<crate::model::AlgorithmSpecification>,
    /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An array of <code>Channel</code> objects that describes each data input channel.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>Resources, including ML compute instances and ML storage volumes, that are configured for model training.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>A <code>VpcConfig</code> object that specifies the VPC that this training job has access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost. </p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>A timestamp that indicates when the training job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of <code>TrainingEndTime</code>. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.</p>
    pub training_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
    pub training_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that indicates when the status of the training job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A history of all of the secondary statuses that the training job has transitioned through.</p>
    pub secondary_status_transitions:
        std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
    /// <p>A list of final metric values that are set when the training job completes. Used only if the training job was configured to use metrics.</p>
    pub final_metric_data_list: std::option::Option<std::vec::Vec<crate::model::MetricData>>,
    /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.</p>
    pub enable_network_isolation: bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
    pub enable_managed_spot_training: bool,
    /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
    pub checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
    /// <p>The training time in seconds.</p>
    pub training_time_in_seconds: std::option::Option<i32>,
    /// <p>The billable time in seconds.</p>
    pub billable_time_in_seconds: std::option::Option<i32>,
    /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths. To learn more about how to configure the <code>DebugHookConfig</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
    pub debug_hook_config: std::option::Option<crate::model::DebugHookConfig>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>Information about the debug rule configuration.</p>
    pub debug_rule_configurations:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
    /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
    pub tensor_board_output_config: std::option::Option<crate::model::TensorBoardOutputConfig>,
    /// <p>Information about the evaluation status of the rules for the training job.</p>
    pub debug_rule_evaluation_statuses:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
    /// <p>The environment variables to set in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
    pub retry_strategy: std::option::Option<crate::model::RetryStrategy>,
    /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TrainingJob {
    /// <p>The name of the training job.</p>
    pub fn training_job_name(&self) -> std::option::Option<&str> {
        self.training_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub fn training_job_arn(&self) -> std::option::Option<&str> {
        self.training_job_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.</p>
    pub fn tuning_job_arn(&self) -> std::option::Option<&str> {
        self.tuning_job_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
    pub fn labeling_job_arn(&self) -> std::option::Option<&str> {
        self.labeling_job_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub fn auto_ml_job_arn(&self) -> std::option::Option<&str> {
        self.auto_ml_job_arn.as_deref()
    }
    /// <p>Information about the Amazon S3 location that is configured for storing model artifacts.</p>
    pub fn model_artifacts(&self) -> std::option::Option<&crate::model::ModelArtifacts> {
        self.model_artifacts.as_ref()
    }
    /// <p>The status of the training job.</p>
    /// <p>Training job statuses are:</p>
    /// <ul>
    /// <li> <p> <code>InProgress</code> - The training is in progress.</p> </li>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// <li> <p> <code>Failed</code> - The training job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTrainingJobResponse</code> call.</p> </li>
    /// <li> <p> <code>Stopping</code> - The training job is stopping.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// <p>For more detailed information, see <code>SecondaryStatus</code>. </p>
    pub fn training_job_status(&self) -> std::option::Option<&crate::model::TrainingJobStatus> {
        self.training_job_status.as_ref()
    }
    /// <p> Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see <code>StatusMessage</code> under <code>SecondaryStatusTransition</code>.</p>
    /// <p>SageMaker provides primary statuses and secondary statuses that apply to each of them:</p>
    /// <dl>
    /// <dt>
    /// InProgress
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
    /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
    /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
    /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Completed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Failed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopped
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopping
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl> <important>
    /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
    /// </important>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
    /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
    /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
    /// </ul>
    pub fn secondary_status(&self) -> std::option::Option<&crate::model::SecondaryStatus> {
        self.secondary_status.as_ref()
    }
    /// <p>If the training job failed, the reason it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Algorithm-specific parameters.</p>
    pub fn hyper_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.hyper_parameters.as_ref()
    }
    /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
    pub fn algorithm_specification(
        &self,
    ) -> std::option::Option<&crate::model::AlgorithmSpecification> {
        self.algorithm_specification.as_ref()
    }
    /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>An array of <code>Channel</code> objects that describes each data input channel.</p>
    pub fn input_data_config(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.input_data_config.as_deref()
    }
    /// <p>The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>Resources, including ML compute instances and ML storage volumes, that are configured for model training.</p>
    pub fn resource_config(&self) -> std::option::Option<&crate::model::ResourceConfig> {
        self.resource_config.as_ref()
    }
    /// <p>A <code>VpcConfig</code> object that specifies the VPC that this training job has access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost. </p>
    pub fn stopping_condition(&self) -> std::option::Option<&crate::model::StoppingCondition> {
        self.stopping_condition.as_ref()
    }
    /// <p>A timestamp that indicates when the training job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of <code>TrainingEndTime</code>. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.</p>
    pub fn training_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_start_time.as_ref()
    }
    /// <p>Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
    pub fn training_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_end_time.as_ref()
    }
    /// <p>A timestamp that indicates when the status of the training job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>A history of all of the secondary statuses that the training job has transitioned through.</p>
    pub fn secondary_status_transitions(
        &self,
    ) -> std::option::Option<&[crate::model::SecondaryStatusTransition]> {
        self.secondary_status_transitions.as_deref()
    }
    /// <p>A list of final metric values that are set when the training job completes. Used only if the training job was configured to use metrics.</p>
    pub fn final_metric_data_list(&self) -> std::option::Option<&[crate::model::MetricData]> {
        self.final_metric_data_list.as_deref()
    }
    /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.</p>
    pub fn enable_network_isolation(&self) -> bool {
        self.enable_network_isolation
    }
    /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
    pub fn enable_inter_container_traffic_encryption(&self) -> bool {
        self.enable_inter_container_traffic_encryption
    }
    /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
    pub fn enable_managed_spot_training(&self) -> bool {
        self.enable_managed_spot_training
    }
    /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
    pub fn checkpoint_config(&self) -> std::option::Option<&crate::model::CheckpointConfig> {
        self.checkpoint_config.as_ref()
    }
    /// <p>The training time in seconds.</p>
    pub fn training_time_in_seconds(&self) -> std::option::Option<i32> {
        self.training_time_in_seconds
    }
    /// <p>The billable time in seconds.</p>
    pub fn billable_time_in_seconds(&self) -> std::option::Option<i32> {
        self.billable_time_in_seconds
    }
    /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths. To learn more about how to configure the <code>DebugHookConfig</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
    pub fn debug_hook_config(&self) -> std::option::Option<&crate::model::DebugHookConfig> {
        self.debug_hook_config.as_ref()
    }
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
    /// <ul>
    /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
    /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
    /// <li> <p> <code>CreateTransformJob</code> </p> </li>
    /// </ul>
    pub fn experiment_config(&self) -> std::option::Option<&crate::model::ExperimentConfig> {
        self.experiment_config.as_ref()
    }
    /// <p>Information about the debug rule configuration.</p>
    pub fn debug_rule_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::DebugRuleConfiguration]> {
        self.debug_rule_configurations.as_deref()
    }
    /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
    pub fn tensor_board_output_config(
        &self,
    ) -> std::option::Option<&crate::model::TensorBoardOutputConfig> {
        self.tensor_board_output_config.as_ref()
    }
    /// <p>Information about the evaluation status of the rules for the training job.</p>
    pub fn debug_rule_evaluation_statuses(
        &self,
    ) -> std::option::Option<&[crate::model::DebugRuleEvaluationStatus]> {
        self.debug_rule_evaluation_statuses.as_deref()
    }
    /// <p>The environment variables to set in the Docker container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
    pub fn retry_strategy(&self) -> std::option::Option<&crate::model::RetryStrategy> {
        self.retry_strategy.as_ref()
    }
    /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TrainingJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJob");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tuning_job_arn", &self.tuning_job_arn);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("model_artifacts", &self.model_artifacts);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.field("secondary_status", &self.secondary_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "secondary_status_transitions",
            &self.secondary_status_transitions,
        );
        formatter.field("final_metric_data_list", &self.final_metric_data_list);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("training_time_in_seconds", &self.training_time_in_seconds);
        formatter.field("billable_time_in_seconds", &self.billable_time_in_seconds);
        formatter.field("debug_hook_config", &self.debug_hook_config);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("debug_rule_configurations", &self.debug_rule_configurations);
        formatter.field(
            "tensor_board_output_config",
            &self.tensor_board_output_config,
        );
        formatter.field(
            "debug_rule_evaluation_statuses",
            &self.debug_rule_evaluation_statuses,
        );
        formatter.field("environment", &self.environment);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrainingJob`](crate::model::TrainingJob)
pub mod training_job {

    /// A builder for [`TrainingJob`](crate::model::TrainingJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tuning_job_arn: std::option::Option<std::string::String>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
        pub(crate) secondary_status: std::option::Option<crate::model::SecondaryStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) algorithm_specification:
            std::option::Option<crate::model::AlgorithmSpecification>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) secondary_status_transitions:
            std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
        pub(crate) final_metric_data_list:
            std::option::Option<std::vec::Vec<crate::model::MetricData>>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_managed_spot_training: std::option::Option<bool>,
        pub(crate) checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
        pub(crate) training_time_in_seconds: std::option::Option<i32>,
        pub(crate) billable_time_in_seconds: std::option::Option<i32>,
        pub(crate) debug_hook_config: std::option::Option<crate::model::DebugHookConfig>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) debug_rule_configurations:
            std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
        pub(crate) tensor_board_output_config:
            std::option::Option<crate::model::TensorBoardOutputConfig>,
        pub(crate) debug_rule_evaluation_statuses:
            std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) retry_strategy: std::option::Option<crate::model::RetryStrategy>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the training job.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        /// <p>The name of the training job.</p>
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.</p>
        pub fn tuning_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.</p>
        pub fn set_tuning_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the job.</p>
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>Information about the Amazon S3 location that is configured for storing model artifacts.</p>
        pub fn model_artifacts(mut self, input: crate::model::ModelArtifacts) -> Self {
            self.model_artifacts = Some(input);
            self
        }
        /// <p>Information about the Amazon S3 location that is configured for storing model artifacts.</p>
        pub fn set_model_artifacts(
            mut self,
            input: std::option::Option<crate::model::ModelArtifacts>,
        ) -> Self {
            self.model_artifacts = input;
            self
        }
        /// <p>The status of the training job.</p>
        /// <p>Training job statuses are:</p>
        /// <ul>
        /// <li> <p> <code>InProgress</code> - The training is in progress.</p> </li>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// <li> <p> <code>Failed</code> - The training job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTrainingJobResponse</code> call.</p> </li>
        /// <li> <p> <code>Stopping</code> - The training job is stopping.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// <p>For more detailed information, see <code>SecondaryStatus</code>. </p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        /// <p>The status of the training job.</p>
        /// <p>Training job statuses are:</p>
        /// <ul>
        /// <li> <p> <code>InProgress</code> - The training is in progress.</p> </li>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// <li> <p> <code>Failed</code> - The training job has failed. To see the reason for the failure, see the <code>FailureReason</code> field in the response to a <code>DescribeTrainingJobResponse</code> call.</p> </li>
        /// <li> <p> <code>Stopping</code> - The training job is stopping.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// <p>For more detailed information, see <code>SecondaryStatus</code>. </p>
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        /// <p> Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see <code>StatusMessage</code> under <code>SecondaryStatusTransition</code>.</p>
        /// <p>SageMaker provides primary statuses and secondary statuses that apply to each of them:</p>
        /// <dl>
        /// <dt>
        /// InProgress
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
        /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
        /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
        /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Completed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Failed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopped
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopping
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl> <important>
        /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
        /// </important>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
        /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
        /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
        /// </ul>
        pub fn secondary_status(mut self, input: crate::model::SecondaryStatus) -> Self {
            self.secondary_status = Some(input);
            self
        }
        /// <p> Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see <code>StatusMessage</code> under <code>SecondaryStatusTransition</code>.</p>
        /// <p>SageMaker provides primary statuses and secondary statuses that apply to each of them:</p>
        /// <dl>
        /// <dt>
        /// InProgress
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
        /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
        /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
        /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Completed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Failed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopped
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopping
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl> <important>
        /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
        /// </important>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
        /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
        /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
        /// </ul>
        pub fn set_secondary_status(
            mut self,
            input: std::option::Option<crate::model::SecondaryStatus>,
        ) -> Self {
            self.secondary_status = input;
            self
        }
        /// <p>If the training job failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the training job failed, the reason it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Adds a key-value pair to `hyper_parameters`.
        ///
        /// To override the contents of this collection use [`set_hyper_parameters`](Self::set_hyper_parameters).
        ///
        /// <p>Algorithm-specific parameters.</p>
        pub fn hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hyper_parameters = Some(hash_map);
            self
        }
        /// <p>Algorithm-specific parameters.</p>
        pub fn set_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hyper_parameters = input;
            self
        }
        /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
        pub fn algorithm_specification(
            mut self,
            input: crate::model::AlgorithmSpecification,
        ) -> Self {
            self.algorithm_specification = Some(input);
            self
        }
        /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
        pub fn set_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::AlgorithmSpecification>,
        ) -> Self {
            self.algorithm_specification = input;
            self
        }
        /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Appends an item to `input_data_config`.
        ///
        /// To override the contents of this collection use [`set_input_data_config`](Self::set_input_data_config).
        ///
        /// <p>An array of <code>Channel</code> objects that describes each data input channel.</p>
        pub fn input_data_config(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input);
            self.input_data_config = Some(v);
            self
        }
        /// <p>An array of <code>Channel</code> objects that describes each data input channel.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>Resources, including ML compute instances and ML storage volumes, that are configured for model training.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        /// <p>Resources, including ML compute instances and ML storage volumes, that are configured for model training.</p>
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>A <code>VpcConfig</code> object that specifies the VPC that this training job has access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>A <code>VpcConfig</code> object that specifies the VPC that this training job has access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost. </p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost. </p>
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>A timestamp that indicates when the training job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that indicates when the training job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of <code>TrainingEndTime</code>. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.</p>
        pub fn training_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_start_time = Some(input);
            self
        }
        /// <p>Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of <code>TrainingEndTime</code>. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.</p>
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
        pub fn training_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_end_time = Some(input);
            self
        }
        /// <p>Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>A timestamp that indicates when the status of the training job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that indicates when the status of the training job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `secondary_status_transitions`.
        ///
        /// To override the contents of this collection use [`set_secondary_status_transitions`](Self::set_secondary_status_transitions).
        ///
        /// <p>A history of all of the secondary statuses that the training job has transitioned through.</p>
        pub fn secondary_status_transitions(
            mut self,
            input: crate::model::SecondaryStatusTransition,
        ) -> Self {
            let mut v = self.secondary_status_transitions.unwrap_or_default();
            v.push(input);
            self.secondary_status_transitions = Some(v);
            self
        }
        /// <p>A history of all of the secondary statuses that the training job has transitioned through.</p>
        pub fn set_secondary_status_transitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
        ) -> Self {
            self.secondary_status_transitions = input;
            self
        }
        /// Appends an item to `final_metric_data_list`.
        ///
        /// To override the contents of this collection use [`set_final_metric_data_list`](Self::set_final_metric_data_list).
        ///
        /// <p>A list of final metric values that are set when the training job completes. Used only if the training job was configured to use metrics.</p>
        pub fn final_metric_data_list(mut self, input: crate::model::MetricData) -> Self {
            let mut v = self.final_metric_data_list.unwrap_or_default();
            v.push(input);
            self.final_metric_data_list = Some(v);
            self
        }
        /// <p>A list of final metric values that are set when the training job completes. Used only if the training job was configured to use metrics.</p>
        pub fn set_final_metric_data_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricData>>,
        ) -> Self {
            self.final_metric_data_list = input;
            self
        }
        /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.</p>
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
        pub fn enable_managed_spot_training(mut self, input: bool) -> Self {
            self.enable_managed_spot_training = Some(input);
            self
        }
        /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
        pub fn set_enable_managed_spot_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_managed_spot_training = input;
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
        pub fn checkpoint_config(mut self, input: crate::model::CheckpointConfig) -> Self {
            self.checkpoint_config = Some(input);
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
        pub fn set_checkpoint_config(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfig>,
        ) -> Self {
            self.checkpoint_config = input;
            self
        }
        /// <p>The training time in seconds.</p>
        pub fn training_time_in_seconds(mut self, input: i32) -> Self {
            self.training_time_in_seconds = Some(input);
            self
        }
        /// <p>The training time in seconds.</p>
        pub fn set_training_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.training_time_in_seconds = input;
            self
        }
        /// <p>The billable time in seconds.</p>
        pub fn billable_time_in_seconds(mut self, input: i32) -> Self {
            self.billable_time_in_seconds = Some(input);
            self
        }
        /// <p>The billable time in seconds.</p>
        pub fn set_billable_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.billable_time_in_seconds = input;
            self
        }
        /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths. To learn more about how to configure the <code>DebugHookConfig</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
        pub fn debug_hook_config(mut self, input: crate::model::DebugHookConfig) -> Self {
            self.debug_hook_config = Some(input);
            self
        }
        /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths. To learn more about how to configure the <code>DebugHookConfig</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
        pub fn set_debug_hook_config(
            mut self,
            input: std::option::Option<crate::model::DebugHookConfig>,
        ) -> Self {
            self.debug_hook_config = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when you call the following APIs:</p>
        /// <ul>
        /// <li> <p> <code>CreateProcessingJob</code> </p> </li>
        /// <li> <p> <code>CreateTrainingJob</code> </p> </li>
        /// <li> <p> <code>CreateTransformJob</code> </p> </li>
        /// </ul>
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        /// Appends an item to `debug_rule_configurations`.
        ///
        /// To override the contents of this collection use [`set_debug_rule_configurations`](Self::set_debug_rule_configurations).
        ///
        /// <p>Information about the debug rule configuration.</p>
        pub fn debug_rule_configurations(
            mut self,
            input: crate::model::DebugRuleConfiguration,
        ) -> Self {
            let mut v = self.debug_rule_configurations.unwrap_or_default();
            v.push(input);
            self.debug_rule_configurations = Some(v);
            self
        }
        /// <p>Information about the debug rule configuration.</p>
        pub fn set_debug_rule_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
        ) -> Self {
            self.debug_rule_configurations = input;
            self
        }
        /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
        pub fn tensor_board_output_config(
            mut self,
            input: crate::model::TensorBoardOutputConfig,
        ) -> Self {
            self.tensor_board_output_config = Some(input);
            self
        }
        /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
        pub fn set_tensor_board_output_config(
            mut self,
            input: std::option::Option<crate::model::TensorBoardOutputConfig>,
        ) -> Self {
            self.tensor_board_output_config = input;
            self
        }
        /// Appends an item to `debug_rule_evaluation_statuses`.
        ///
        /// To override the contents of this collection use [`set_debug_rule_evaluation_statuses`](Self::set_debug_rule_evaluation_statuses).
        ///
        /// <p>Information about the evaluation status of the rules for the training job.</p>
        pub fn debug_rule_evaluation_statuses(
            mut self,
            input: crate::model::DebugRuleEvaluationStatus,
        ) -> Self {
            let mut v = self.debug_rule_evaluation_statuses.unwrap_or_default();
            v.push(input);
            self.debug_rule_evaluation_statuses = Some(v);
            self
        }
        /// <p>Information about the evaluation status of the rules for the training job.</p>
        pub fn set_debug_rule_evaluation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
        ) -> Self {
            self.debug_rule_evaluation_statuses = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the Docker container.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the Docker container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
        pub fn retry_strategy(mut self, input: crate::model::RetryStrategy) -> Self {
            self.retry_strategy = Some(input);
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
        pub fn set_retry_strategy(
            mut self,
            input: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.retry_strategy = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJob`](crate::model::TrainingJob)
        pub fn build(self) -> crate::model::TrainingJob {
            crate::model::TrainingJob {
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                tuning_job_arn: self.tuning_job_arn,
                labeling_job_arn: self.labeling_job_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                model_artifacts: self.model_artifacts,
                training_job_status: self.training_job_status,
                secondary_status: self.secondary_status,
                failure_reason: self.failure_reason,
                hyper_parameters: self.hyper_parameters,
                algorithm_specification: self.algorithm_specification,
                role_arn: self.role_arn,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                vpc_config: self.vpc_config,
                stopping_condition: self.stopping_condition,
                creation_time: self.creation_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                last_modified_time: self.last_modified_time,
                secondary_status_transitions: self.secondary_status_transitions,
                final_metric_data_list: self.final_metric_data_list,
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_managed_spot_training: self.enable_managed_spot_training.unwrap_or_default(),
                checkpoint_config: self.checkpoint_config,
                training_time_in_seconds: self.training_time_in_seconds,
                billable_time_in_seconds: self.billable_time_in_seconds,
                debug_hook_config: self.debug_hook_config,
                experiment_config: self.experiment_config,
                debug_rule_configurations: self.debug_rule_configurations,
                tensor_board_output_config: self.tensor_board_output_config,
                debug_rule_evaluation_statuses: self.debug_rule_evaluation_statuses,
                environment: self.environment,
                retry_strategy: self.retry_strategy,
                tags: self.tags,
            }
        }
    }
}
impl TrainingJob {
    /// Creates a new builder-style object to manufacture [`TrainingJob`](crate::model::TrainingJob)
    pub fn builder() -> crate::model::training_job::Builder {
        crate::model::training_job::Builder::default()
    }
}

/// <p>The retry strategy to use when a training job fails due to an <code>InternalServerError</code>. <code>RetryStrategy</code> is specified as part of the <code>CreateTrainingJob</code> and <code>CreateHyperParameterTuningJob</code> requests. You can add the <code>StoppingCondition</code> parameter to the request to limit the training time for the complete job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RetryStrategy {
    /// <p>The number of times to retry the job. When the job is retried, it's <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
    pub maximum_retry_attempts: i32,
}
impl RetryStrategy {
    /// <p>The number of times to retry the job. When the job is retried, it's <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
    pub fn maximum_retry_attempts(&self) -> i32 {
        self.maximum_retry_attempts
    }
}
impl std::fmt::Debug for RetryStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RetryStrategy");
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.finish()
    }
}
/// See [`RetryStrategy`](crate::model::RetryStrategy)
pub mod retry_strategy {

    /// A builder for [`RetryStrategy`](crate::model::RetryStrategy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_retry_attempts: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of times to retry the job. When the job is retried, it's <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
        pub fn maximum_retry_attempts(mut self, input: i32) -> Self {
            self.maximum_retry_attempts = Some(input);
            self
        }
        /// <p>The number of times to retry the job. When the job is retried, it's <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
        pub fn set_maximum_retry_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_retry_attempts = input;
            self
        }
        /// Consumes the builder and constructs a [`RetryStrategy`](crate::model::RetryStrategy)
        pub fn build(self) -> crate::model::RetryStrategy {
            crate::model::RetryStrategy {
                maximum_retry_attempts: self.maximum_retry_attempts.unwrap_or_default(),
            }
        }
    }
}
impl RetryStrategy {
    /// Creates a new builder-style object to manufacture [`RetryStrategy`](crate::model::RetryStrategy)
    pub fn builder() -> crate::model::retry_strategy::Builder {
        crate::model::retry_strategy::Builder::default()
    }
}

/// <p>Information about the status of the rule evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub rule_evaluation_job_arn: std::option::Option<std::string::String>,
    /// <p>Status of the rule evaluation.</p>
    pub rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
    /// <p>Details from the rule evaluation.</p>
    pub status_details: std::option::Option<std::string::String>,
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DebugRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub fn rule_configuration_name(&self) -> std::option::Option<&str> {
        self.rule_configuration_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub fn rule_evaluation_job_arn(&self) -> std::option::Option<&str> {
        self.rule_evaluation_job_arn.as_deref()
    }
    /// <p>Status of the rule evaluation.</p>
    pub fn rule_evaluation_status(
        &self,
    ) -> std::option::Option<&crate::model::RuleEvaluationStatus> {
        self.rule_evaluation_status.as_ref()
    }
    /// <p>Details from the rule evaluation.</p>
    pub fn status_details(&self) -> std::option::Option<&str> {
        self.status_details.as_deref()
    }
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for DebugRuleEvaluationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugRuleEvaluationStatus");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("rule_evaluation_job_arn", &self.rule_evaluation_job_arn);
        formatter.field("rule_evaluation_status", &self.rule_evaluation_status);
        formatter.field("status_details", &self.status_details);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
pub mod debug_rule_evaluation_status {

    /// A builder for [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_job_arn: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the rule configuration.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the rule configuration.</p>
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn rule_evaluation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluation_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn set_rule_evaluation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluation_job_arn = input;
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn rule_evaluation_status(mut self, input: crate::model::RuleEvaluationStatus) -> Self {
            self.rule_evaluation_status = Some(input);
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn set_rule_evaluation_status(
            mut self,
            input: std::option::Option<crate::model::RuleEvaluationStatus>,
        ) -> Self {
            self.rule_evaluation_status = input;
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
        pub fn build(self) -> crate::model::DebugRuleEvaluationStatus {
            crate::model::DebugRuleEvaluationStatus {
                rule_configuration_name: self.rule_configuration_name,
                rule_evaluation_job_arn: self.rule_evaluation_job_arn,
                rule_evaluation_status: self.rule_evaluation_status,
                status_details: self.status_details,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl DebugRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
    pub fn builder() -> crate::model::debug_rule_evaluation_status::Builder {
        crate::model::debug_rule_evaluation_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuleEvaluationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    IssuesFound,
    #[allow(missing_docs)] // documentation missing in model
    NoIssuesFound,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RuleEvaluationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Error" => RuleEvaluationStatus::Error,
            "InProgress" => RuleEvaluationStatus::InProgress,
            "IssuesFound" => RuleEvaluationStatus::IssuesFound,
            "NoIssuesFound" => RuleEvaluationStatus::NoIssuesFound,
            "Stopped" => RuleEvaluationStatus::Stopped,
            "Stopping" => RuleEvaluationStatus::Stopping,
            other => RuleEvaluationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RuleEvaluationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuleEvaluationStatus::from(s))
    }
}
impl RuleEvaluationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RuleEvaluationStatus::Error => "Error",
            RuleEvaluationStatus::InProgress => "InProgress",
            RuleEvaluationStatus::IssuesFound => "IssuesFound",
            RuleEvaluationStatus::NoIssuesFound => "NoIssuesFound",
            RuleEvaluationStatus::Stopped => "Stopped",
            RuleEvaluationStatus::Stopping => "Stopping",
            RuleEvaluationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Error",
            "InProgress",
            "IssuesFound",
            "NoIssuesFound",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for RuleEvaluationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TensorBoardOutputConfig {
    /// <p>Path to local storage location for tensorBoard output. Defaults to <code>/opt/ml/output/tensorboard</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl TensorBoardOutputConfig {
    /// <p>Path to local storage location for tensorBoard output. Defaults to <code>/opt/ml/output/tensorboard</code>.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
}
impl std::fmt::Debug for TensorBoardOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TensorBoardOutputConfig");
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
pub mod tensor_board_output_config {

    /// A builder for [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Path to local storage location for tensorBoard output. Defaults to <code>/opt/ml/output/tensorboard</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>Path to local storage location for tensorBoard output. Defaults to <code>/opt/ml/output/tensorboard</code>.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
        pub fn build(self) -> crate::model::TensorBoardOutputConfig {
            crate::model::TensorBoardOutputConfig {
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl TensorBoardOutputConfig {
    /// Creates a new builder-style object to manufacture [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
    pub fn builder() -> crate::model::tensor_board_output_config::Builder {
        crate::model::tensor_board_output_config::Builder::default()
    }
}

/// <p>Configuration information for SageMaker Debugger rules for debugging. To learn more about how to configure the <code>DebugRuleConfiguration</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub rule_evaluator_image: std::option::Option<std::string::String>,
    /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub volume_size_in_gb: i32,
    /// <p>Runtime configuration for rule container.</p>
    pub rule_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DebugRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
    pub fn rule_configuration_name(&self) -> std::option::Option<&str> {
        self.rule_configuration_name.as_deref()
    }
    /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub fn rule_evaluator_image(&self) -> std::option::Option<&str> {
        self.rule_evaluator_image.as_deref()
    }
    /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::ProcessingInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub fn volume_size_in_gb(&self) -> i32 {
        self.volume_size_in_gb
    }
    /// <p>Runtime configuration for rule container.</p>
    pub fn rule_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.rule_parameters.as_ref()
    }
}
impl std::fmt::Debug for DebugRuleConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugRuleConfiguration");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("rule_evaluator_image", &self.rule_evaluator_image);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("rule_parameters", &self.rule_parameters);
        formatter.finish()
    }
}
/// See [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
pub mod debug_rule_configuration {

    /// A builder for [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) rule_evaluator_image: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) rule_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn rule_evaluator_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluator_image = Some(input.into());
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn set_rule_evaluator_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluator_image = input;
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// Adds a key-value pair to `rule_parameters`.
        ///
        /// To override the contents of this collection use [`set_rule_parameters`](Self::set_rule_parameters).
        ///
        /// <p>Runtime configuration for rule container.</p>
        pub fn rule_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.rule_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.rule_parameters = Some(hash_map);
            self
        }
        /// <p>Runtime configuration for rule container.</p>
        pub fn set_rule_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.rule_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
        pub fn build(self) -> crate::model::DebugRuleConfiguration {
            crate::model::DebugRuleConfiguration {
                rule_configuration_name: self.rule_configuration_name,
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                rule_evaluator_image: self.rule_evaluator_image,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                rule_parameters: self.rule_parameters,
            }
        }
    }
}
impl DebugRuleConfiguration {
    /// Creates a new builder-style object to manufacture [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
    pub fn builder() -> crate::model::debug_rule_configuration::Builder {
        crate::model::debug_rule_configuration::Builder::default()
    }
}

/// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths. To learn more about how to configure the <code>DebugHookConfig</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugHookConfig {
    /// <p>Path to local storage location for metrics and tensors. Defaults to <code>/opt/ml/output/tensors/</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>Configuration information for the Debugger hook parameters.</p>
    pub hook_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Configuration information for Debugger tensor collections. To learn more about how to configure the <code>CollectionConfiguration</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub collection_configurations:
        std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
}
impl DebugHookConfig {
    /// <p>Path to local storage location for metrics and tensors. Defaults to <code>/opt/ml/output/tensors/</code>.</p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
    /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>Configuration information for the Debugger hook parameters.</p>
    pub fn hook_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.hook_parameters.as_ref()
    }
    /// <p>Configuration information for Debugger tensor collections. To learn more about how to configure the <code>CollectionConfiguration</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub fn collection_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::CollectionConfiguration]> {
        self.collection_configurations.as_deref()
    }
}
impl std::fmt::Debug for DebugHookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugHookConfig");
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("hook_parameters", &self.hook_parameters);
        formatter.field("collection_configurations", &self.collection_configurations);
        formatter.finish()
    }
}
/// See [`DebugHookConfig`](crate::model::DebugHookConfig)
pub mod debug_hook_config {

    /// A builder for [`DebugHookConfig`](crate::model::DebugHookConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) hook_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) collection_configurations:
            std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
    }
    impl Builder {
        /// <p>Path to local storage location for metrics and tensors. Defaults to <code>/opt/ml/output/tensors/</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>Path to local storage location for metrics and tensors. Defaults to <code>/opt/ml/output/tensors/</code>.</p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Adds a key-value pair to `hook_parameters`.
        ///
        /// To override the contents of this collection use [`set_hook_parameters`](Self::set_hook_parameters).
        ///
        /// <p>Configuration information for the Debugger hook parameters.</p>
        pub fn hook_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hook_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hook_parameters = Some(hash_map);
            self
        }
        /// <p>Configuration information for the Debugger hook parameters.</p>
        pub fn set_hook_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hook_parameters = input;
            self
        }
        /// Appends an item to `collection_configurations`.
        ///
        /// To override the contents of this collection use [`set_collection_configurations`](Self::set_collection_configurations).
        ///
        /// <p>Configuration information for Debugger tensor collections. To learn more about how to configure the <code>CollectionConfiguration</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn collection_configurations(
            mut self,
            input: crate::model::CollectionConfiguration,
        ) -> Self {
            let mut v = self.collection_configurations.unwrap_or_default();
            v.push(input);
            self.collection_configurations = Some(v);
            self
        }
        /// <p>Configuration information for Debugger tensor collections. To learn more about how to configure the <code>CollectionConfiguration</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn set_collection_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
        ) -> Self {
            self.collection_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugHookConfig`](crate::model::DebugHookConfig)
        pub fn build(self) -> crate::model::DebugHookConfig {
            crate::model::DebugHookConfig {
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                hook_parameters: self.hook_parameters,
                collection_configurations: self.collection_configurations,
            }
        }
    }
}
impl DebugHookConfig {
    /// Creates a new builder-style object to manufacture [`DebugHookConfig`](crate::model::DebugHookConfig)
    pub fn builder() -> crate::model::debug_hook_config::Builder {
        crate::model::debug_hook_config::Builder::default()
    }
}

/// <p>Configuration information for the Debugger output tensor collections.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CollectionConfiguration {
    /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
    pub collection_name: std::option::Option<std::string::String>,
    /// <p>Parameter values for the tensor collection. The allowed parameters are <code>"name"</code>, <code>"include_regex"</code>, <code>"reduction_config"</code>, <code>"save_config"</code>, <code>"tensor_names"</code>, and <code>"save_histogram"</code>.</p>
    pub collection_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CollectionConfiguration {
    /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
    pub fn collection_name(&self) -> std::option::Option<&str> {
        self.collection_name.as_deref()
    }
    /// <p>Parameter values for the tensor collection. The allowed parameters are <code>"name"</code>, <code>"include_regex"</code>, <code>"reduction_config"</code>, <code>"save_config"</code>, <code>"tensor_names"</code>, and <code>"save_histogram"</code>.</p>
    pub fn collection_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.collection_parameters.as_ref()
    }
}
impl std::fmt::Debug for CollectionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CollectionConfiguration");
        formatter.field("collection_name", &self.collection_name);
        formatter.field("collection_parameters", &self.collection_parameters);
        formatter.finish()
    }
}
/// See [`CollectionConfiguration`](crate::model::CollectionConfiguration)
pub mod collection_configuration {

    /// A builder for [`CollectionConfiguration`](crate::model::CollectionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_name: std::option::Option<std::string::String>,
        pub(crate) collection_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_name = Some(input.into());
            self
        }
        /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_name = input;
            self
        }
        /// Adds a key-value pair to `collection_parameters`.
        ///
        /// To override the contents of this collection use [`set_collection_parameters`](Self::set_collection_parameters).
        ///
        /// <p>Parameter values for the tensor collection. The allowed parameters are <code>"name"</code>, <code>"include_regex"</code>, <code>"reduction_config"</code>, <code>"save_config"</code>, <code>"tensor_names"</code>, and <code>"save_histogram"</code>.</p>
        pub fn collection_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.collection_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.collection_parameters = Some(hash_map);
            self
        }
        /// <p>Parameter values for the tensor collection. The allowed parameters are <code>"name"</code>, <code>"include_regex"</code>, <code>"reduction_config"</code>, <code>"save_config"</code>, <code>"tensor_names"</code>, and <code>"save_histogram"</code>.</p>
        pub fn set_collection_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.collection_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CollectionConfiguration`](crate::model::CollectionConfiguration)
        pub fn build(self) -> crate::model::CollectionConfiguration {
            crate::model::CollectionConfiguration {
                collection_name: self.collection_name,
                collection_parameters: self.collection_parameters,
            }
        }
    }
}
impl CollectionConfiguration {
    /// Creates a new builder-style object to manufacture [`CollectionConfiguration`](crate::model::CollectionConfiguration)
    pub fn builder() -> crate::model::collection_configuration::Builder {
        crate::model::collection_configuration::Builder::default()
    }
}

/// <p>Contains information about the output location for managed spot training checkpoint data. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckpointConfig {
    /// <p>Identifies the S3 path where you want SageMaker to store checkpoints. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>(Optional) The local directory where checkpoints are written. The default directory is <code>/opt/ml/checkpoints/</code>. </p>
    pub local_path: std::option::Option<std::string::String>,
}
impl CheckpointConfig {
    /// <p>Identifies the S3 path where you want SageMaker to store checkpoints. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>(Optional) The local directory where checkpoints are written. The default directory is <code>/opt/ml/checkpoints/</code>. </p>
    pub fn local_path(&self) -> std::option::Option<&str> {
        self.local_path.as_deref()
    }
}
impl std::fmt::Debug for CheckpointConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckpointConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.finish()
    }
}
/// See [`CheckpointConfig`](crate::model::CheckpointConfig)
pub mod checkpoint_config {

    /// A builder for [`CheckpointConfig`](crate::model::CheckpointConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the S3 path where you want SageMaker to store checkpoints. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>Identifies the S3 path where you want SageMaker to store checkpoints. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>(Optional) The local directory where checkpoints are written. The default directory is <code>/opt/ml/checkpoints/</code>. </p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        /// <p>(Optional) The local directory where checkpoints are written. The default directory is <code>/opt/ml/checkpoints/</code>. </p>
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckpointConfig`](crate::model::CheckpointConfig)
        pub fn build(self) -> crate::model::CheckpointConfig {
            crate::model::CheckpointConfig {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
            }
        }
    }
}
impl CheckpointConfig {
    /// Creates a new builder-style object to manufacture [`CheckpointConfig`](crate::model::CheckpointConfig)
    pub fn builder() -> crate::model::checkpoint_config::Builder {
        crate::model::checkpoint_config::Builder::default()
    }
}

/// <p>The name, value, and date and time of a metric that was emitted to Amazon CloudWatch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricData {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The value of the metric.</p>
    pub value: f32,
    /// <p>The date and time that the algorithm emitted the metric.</p>
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl MetricData {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> f32 {
        self.value
    }
    /// <p>The date and time that the algorithm emitted the metric.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
}
impl std::fmt::Debug for MetricData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricData");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`MetricData`](crate::model::MetricData)
pub mod metric_data {

    /// A builder for [`MetricData`](crate::model::MetricData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f32>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// <p>The date and time that the algorithm emitted the metric.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The date and time that the algorithm emitted the metric.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricData`](crate::model::MetricData)
        pub fn build(self) -> crate::model::MetricData {
            crate::model::MetricData {
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
                timestamp: self.timestamp,
            }
        }
    }
}
impl MetricData {
    /// Creates a new builder-style object to manufacture [`MetricData`](crate::model::MetricData)
    pub fn builder() -> crate::model::metric_data::Builder {
        crate::model::metric_data::Builder::default()
    }
}

/// <p>An array element of <code>DescribeTrainingJobResponse$SecondaryStatusTransitions</code>. It provides additional details about a status that the training job has transitioned through. A training job can be in one of several states, for example, starting, downloading, training, or uploading. Within each state, there are a number of intermediate states. For example, within the starting state, SageMaker could be starting the training job or launching the ML instances. These transitional states are referred to as the job's secondary status. </p>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecondaryStatusTransition {
    /// <p>Contains a secondary status information from a training job.</p>
    /// <p>Status might be one of the following secondary statuses:</p>
    /// <dl>
    /// <dt>
    /// InProgress
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
    /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
    /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
    /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Completed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Failed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopped
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopping
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
    /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
    /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::SecondaryStatus>,
    /// <p>A timestamp that shows when the training job transitioned to the current secondary status state.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A detailed description of the progress within a secondary status. </p>
    /// <p>SageMaker provides secondary statuses and status messages that apply to each of them:</p>
    /// <dl>
    /// <dt>
    /// Starting
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p>Starting the training job.</p> </li>
    /// <li> <p>Launching requested ML instances.</p> </li>
    /// <li> <p>Insufficient capacity error from EC2 while launching instances, retrying!</p> </li>
    /// <li> <p>Launched instance was unhealthy, replacing it!</p> </li>
    /// <li> <p>Preparing the instances for training.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Training
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p>Downloading the training image.</p> </li>
    /// <li> <p>Training image download completed. Training in progress.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl> <important>
    /// <p>Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.</p>
    /// </important>
    /// <p>To have an overview of your training job's progress, view <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <code>DescribeTrainingJob</code>, and <code>StatusMessage</code> together. For example, at the start of a training job, you might see the following:</p>
    /// <ul>
    /// <li> <p> <code>TrainingJobStatus</code> - InProgress</p> </li>
    /// <li> <p> <code>SecondaryStatus</code> - Training</p> </li>
    /// <li> <p> <code>StatusMessage</code> - Downloading the training image</p> </li>
    /// </ul>
    pub status_message: std::option::Option<std::string::String>,
}
impl SecondaryStatusTransition {
    /// <p>Contains a secondary status information from a training job.</p>
    /// <p>Status might be one of the following secondary statuses:</p>
    /// <dl>
    /// <dt>
    /// InProgress
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
    /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
    /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
    /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Completed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Failed
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopped
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
    /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Stopping
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
    /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
    /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::SecondaryStatus> {
        self.status.as_ref()
    }
    /// <p>A timestamp that shows when the training job transitioned to the current secondary status state.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>A detailed description of the progress within a secondary status. </p>
    /// <p>SageMaker provides secondary statuses and status messages that apply to each of them:</p>
    /// <dl>
    /// <dt>
    /// Starting
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p>Starting the training job.</p> </li>
    /// <li> <p>Launching requested ML instances.</p> </li>
    /// <li> <p>Insufficient capacity error from EC2 while launching instances, retrying!</p> </li>
    /// <li> <p>Launched instance was unhealthy, replacing it!</p> </li>
    /// <li> <p>Preparing the instances for training.</p> </li>
    /// </ul>
    /// </dd>
    /// <dt>
    /// Training
    /// </dt>
    /// <dd>
    /// <ul>
    /// <li> <p>Downloading the training image.</p> </li>
    /// <li> <p>Training image download completed. Training in progress.</p> </li>
    /// </ul>
    /// </dd>
    /// </dl> <important>
    /// <p>Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.</p>
    /// </important>
    /// <p>To have an overview of your training job's progress, view <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <code>DescribeTrainingJob</code>, and <code>StatusMessage</code> together. For example, at the start of a training job, you might see the following:</p>
    /// <ul>
    /// <li> <p> <code>TrainingJobStatus</code> - InProgress</p> </li>
    /// <li> <p> <code>SecondaryStatus</code> - Training</p> </li>
    /// <li> <p> <code>StatusMessage</code> - Downloading the training image</p> </li>
    /// </ul>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl std::fmt::Debug for SecondaryStatusTransition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecondaryStatusTransition");
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
pub mod secondary_status_transition {

    /// A builder for [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::SecondaryStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Contains a secondary status information from a training job.</p>
        /// <p>Status might be one of the following secondary statuses:</p>
        /// <dl>
        /// <dt>
        /// InProgress
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
        /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
        /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
        /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Completed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Failed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopped
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopping
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
        /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
        /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::SecondaryStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Contains a secondary status information from a training job.</p>
        /// <p>Status might be one of the following secondary statuses:</p>
        /// <dl>
        /// <dt>
        /// InProgress
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Starting</code> - Starting the training job.</p> </li>
        /// <li> <p> <code>Downloading</code> - An optional stage for algorithms that support <code>File</code> training input mode. It indicates that data is being downloaded to the ML storage volumes.</p> </li>
        /// <li> <p> <code>Training</code> - Training is in progress.</p> </li>
        /// <li> <p> <code>Uploading</code> - Training is complete and the model artifacts are being uploaded to the S3 location.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Completed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Completed</code> - The training job has completed.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Failed
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Failed</code> - The training job has failed. The reason for the failure is returned in the <code>FailureReason</code> field of <code>DescribeTrainingJobResponse</code>.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopped
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>MaxRuntimeExceeded</code> - The job stopped because it exceeded the maximum allowed runtime.</p> </li>
        /// <li> <p> <code>Stopped</code> - The training job has stopped.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Stopping
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p> <code>Stopping</code> - Stopping the training job.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li> <p> <code>LaunchingMLInstances</code> </p> </li>
        /// <li> <p> <code>PreparingTrainingStack</code> </p> </li>
        /// <li> <p> <code>DownloadingTrainingImage</code> </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SecondaryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp that shows when the training job transitioned to the current secondary status state.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the training job transitioned to the current secondary status state.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A detailed description of the progress within a secondary status. </p>
        /// <p>SageMaker provides secondary statuses and status messages that apply to each of them:</p>
        /// <dl>
        /// <dt>
        /// Starting
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p>Starting the training job.</p> </li>
        /// <li> <p>Launching requested ML instances.</p> </li>
        /// <li> <p>Insufficient capacity error from EC2 while launching instances, retrying!</p> </li>
        /// <li> <p>Launched instance was unhealthy, replacing it!</p> </li>
        /// <li> <p>Preparing the instances for training.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Training
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p>Downloading the training image.</p> </li>
        /// <li> <p>Training image download completed. Training in progress.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl> <important>
        /// <p>Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.</p>
        /// </important>
        /// <p>To have an overview of your training job's progress, view <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <code>DescribeTrainingJob</code>, and <code>StatusMessage</code> together. For example, at the start of a training job, you might see the following:</p>
        /// <ul>
        /// <li> <p> <code>TrainingJobStatus</code> - InProgress</p> </li>
        /// <li> <p> <code>SecondaryStatus</code> - Training</p> </li>
        /// <li> <p> <code>StatusMessage</code> - Downloading the training image</p> </li>
        /// </ul>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>A detailed description of the progress within a secondary status. </p>
        /// <p>SageMaker provides secondary statuses and status messages that apply to each of them:</p>
        /// <dl>
        /// <dt>
        /// Starting
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p>Starting the training job.</p> </li>
        /// <li> <p>Launching requested ML instances.</p> </li>
        /// <li> <p>Insufficient capacity error from EC2 while launching instances, retrying!</p> </li>
        /// <li> <p>Launched instance was unhealthy, replacing it!</p> </li>
        /// <li> <p>Preparing the instances for training.</p> </li>
        /// </ul>
        /// </dd>
        /// <dt>
        /// Training
        /// </dt>
        /// <dd>
        /// <ul>
        /// <li> <p>Downloading the training image.</p> </li>
        /// <li> <p>Training image download completed. Training in progress.</p> </li>
        /// </ul>
        /// </dd>
        /// </dl> <important>
        /// <p>Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.</p>
        /// </important>
        /// <p>To have an overview of your training job's progress, view <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <code>DescribeTrainingJob</code>, and <code>StatusMessage</code> together. For example, at the start of a training job, you might see the following:</p>
        /// <ul>
        /// <li> <p> <code>TrainingJobStatus</code> - InProgress</p> </li>
        /// <li> <p> <code>SecondaryStatus</code> - Training</p> </li>
        /// <li> <p> <code>StatusMessage</code> - Downloading the training image</p> </li>
        /// </ul>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
        pub fn build(self) -> crate::model::SecondaryStatusTransition {
            crate::model::SecondaryStatusTransition {
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                status_message: self.status_message,
            }
        }
    }
}
impl SecondaryStatusTransition {
    /// Creates a new builder-style object to manufacture [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
    pub fn builder() -> crate::model::secondary_status_transition::Builder {
        crate::model::secondary_status_transition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SecondaryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Downloading,
    #[allow(missing_docs)] // documentation missing in model
    DownloadingTrainingImage,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Interrupted,
    #[allow(missing_docs)] // documentation missing in model
    LaunchingMlInstances,
    #[allow(missing_docs)] // documentation missing in model
    MaxRuntimeExceeded,
    #[allow(missing_docs)] // documentation missing in model
    MaxWaitTimeExceeded,
    #[allow(missing_docs)] // documentation missing in model
    PreparingTrainingStack,
    #[allow(missing_docs)] // documentation missing in model
    Restarting,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Training,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    #[allow(missing_docs)] // documentation missing in model
    Uploading,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SecondaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => SecondaryStatus::Completed,
            "Downloading" => SecondaryStatus::Downloading,
            "DownloadingTrainingImage" => SecondaryStatus::DownloadingTrainingImage,
            "Failed" => SecondaryStatus::Failed,
            "Interrupted" => SecondaryStatus::Interrupted,
            "LaunchingMLInstances" => SecondaryStatus::LaunchingMlInstances,
            "MaxRuntimeExceeded" => SecondaryStatus::MaxRuntimeExceeded,
            "MaxWaitTimeExceeded" => SecondaryStatus::MaxWaitTimeExceeded,
            "PreparingTrainingStack" => SecondaryStatus::PreparingTrainingStack,
            "Restarting" => SecondaryStatus::Restarting,
            "Starting" => SecondaryStatus::Starting,
            "Stopped" => SecondaryStatus::Stopped,
            "Stopping" => SecondaryStatus::Stopping,
            "Training" => SecondaryStatus::Training,
            "Updating" => SecondaryStatus::Updating,
            "Uploading" => SecondaryStatus::Uploading,
            other => SecondaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SecondaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SecondaryStatus::from(s))
    }
}
impl SecondaryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SecondaryStatus::Completed => "Completed",
            SecondaryStatus::Downloading => "Downloading",
            SecondaryStatus::DownloadingTrainingImage => "DownloadingTrainingImage",
            SecondaryStatus::Failed => "Failed",
            SecondaryStatus::Interrupted => "Interrupted",
            SecondaryStatus::LaunchingMlInstances => "LaunchingMLInstances",
            SecondaryStatus::MaxRuntimeExceeded => "MaxRuntimeExceeded",
            SecondaryStatus::MaxWaitTimeExceeded => "MaxWaitTimeExceeded",
            SecondaryStatus::PreparingTrainingStack => "PreparingTrainingStack",
            SecondaryStatus::Restarting => "Restarting",
            SecondaryStatus::Starting => "Starting",
            SecondaryStatus::Stopped => "Stopped",
            SecondaryStatus::Stopping => "Stopping",
            SecondaryStatus::Training => "Training",
            SecondaryStatus::Updating => "Updating",
            SecondaryStatus::Uploading => "Uploading",
            SecondaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Downloading",
            "DownloadingTrainingImage",
            "Failed",
            "Interrupted",
            "LaunchingMLInstances",
            "MaxRuntimeExceeded",
            "MaxWaitTimeExceeded",
            "PreparingTrainingStack",
            "Restarting",
            "Starting",
            "Stopped",
            "Stopping",
            "Training",
            "Updating",
            "Uploading",
        ]
    }
}
impl AsRef<str> for SecondaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a limit to how long a model training job or model compilation job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training or compilation job. Use this API to cap model training costs.</p>
/// <p>To stop a training job, SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost. </p>
/// <p>The training algorithms provided by SageMaker automatically save the intermediate results of a model training job when possible. This attempt to save artifacts is only a best effort case as model might not be in a state from which it can be saved. For example, if training has just started, the model might not be ready to save. When saved, this intermediate data is a valid model artifact. You can use it to create a model with <code>CreateModel</code>.</p> <note>
/// <p>The Neural Topic Model (NTM) currently does not support saving intermediate model artifacts. When training NTMs, make sure that the maximum runtime is sufficient for the training job to complete.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StoppingCondition {
    /// <p>The maximum length of time, in seconds, that a training or compilation job can run.</p>
    /// <p>For compilation jobs, if the job does not complete during this time, a <code>TimeOut</code> error is generated. We recommend starting with 900 seconds and increasing as necessary based on your model.</p>
    /// <p>For all other jobs, if the job does not complete during this time, SageMaker ends the job. When <code>RetryStrategy</code> is specified in the job request, <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt. The default value is 1 day. The maximum value is 28 days.</p>
    pub max_runtime_in_seconds: i32,
    /// <p>The maximum length of time, in seconds, that a managed Spot training job has to complete. It is the amount of time spent waiting for Spot capacity plus the amount of time the job can run. It must be equal to or greater than <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time, SageMaker ends the job.</p>
    /// <p>When <code>RetryStrategy</code> is specified in the job request, <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt.</p>
    pub max_wait_time_in_seconds: std::option::Option<i32>,
}
impl StoppingCondition {
    /// <p>The maximum length of time, in seconds, that a training or compilation job can run.</p>
    /// <p>For compilation jobs, if the job does not complete during this time, a <code>TimeOut</code> error is generated. We recommend starting with 900 seconds and increasing as necessary based on your model.</p>
    /// <p>For all other jobs, if the job does not complete during this time, SageMaker ends the job. When <code>RetryStrategy</code> is specified in the job request, <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt. The default value is 1 day. The maximum value is 28 days.</p>
    pub fn max_runtime_in_seconds(&self) -> i32 {
        self.max_runtime_in_seconds
    }
    /// <p>The maximum length of time, in seconds, that a managed Spot training job has to complete. It is the amount of time spent waiting for Spot capacity plus the amount of time the job can run. It must be equal to or greater than <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time, SageMaker ends the job.</p>
    /// <p>When <code>RetryStrategy</code> is specified in the job request, <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt.</p>
    pub fn max_wait_time_in_seconds(&self) -> std::option::Option<i32> {
        self.max_wait_time_in_seconds
    }
}
impl std::fmt::Debug for StoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.field("max_wait_time_in_seconds", &self.max_wait_time_in_seconds);
        formatter.finish()
    }
}
/// See [`StoppingCondition`](crate::model::StoppingCondition)
pub mod stopping_condition {

    /// A builder for [`StoppingCondition`](crate::model::StoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
        pub(crate) max_wait_time_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum length of time, in seconds, that a training or compilation job can run.</p>
        /// <p>For compilation jobs, if the job does not complete during this time, a <code>TimeOut</code> error is generated. We recommend starting with 900 seconds and increasing as necessary based on your model.</p>
        /// <p>For all other jobs, if the job does not complete during this time, SageMaker ends the job. When <code>RetryStrategy</code> is specified in the job request, <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt. The default value is 1 day. The maximum value is 28 days.</p>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        /// <p>The maximum length of time, in seconds, that a training or compilation job can run.</p>
        /// <p>For compilation jobs, if the job does not complete during this time, a <code>TimeOut</code> error is generated. We recommend starting with 900 seconds and increasing as necessary based on your model.</p>
        /// <p>For all other jobs, if the job does not complete during this time, SageMaker ends the job. When <code>RetryStrategy</code> is specified in the job request, <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt. The default value is 1 day. The maximum value is 28 days.</p>
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// <p>The maximum length of time, in seconds, that a managed Spot training job has to complete. It is the amount of time spent waiting for Spot capacity plus the amount of time the job can run. It must be equal to or greater than <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time, SageMaker ends the job.</p>
        /// <p>When <code>RetryStrategy</code> is specified in the job request, <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt.</p>
        pub fn max_wait_time_in_seconds(mut self, input: i32) -> Self {
            self.max_wait_time_in_seconds = Some(input);
            self
        }
        /// <p>The maximum length of time, in seconds, that a managed Spot training job has to complete. It is the amount of time spent waiting for Spot capacity plus the amount of time the job can run. It must be equal to or greater than <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time, SageMaker ends the job.</p>
        /// <p>When <code>RetryStrategy</code> is specified in the job request, <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts in total, not each individual attempt.</p>
        pub fn set_max_wait_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_wait_time_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`StoppingCondition`](crate::model::StoppingCondition)
        pub fn build(self) -> crate::model::StoppingCondition {
            crate::model::StoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
                max_wait_time_in_seconds: self.max_wait_time_in_seconds,
            }
        }
    }
}
impl StoppingCondition {
    /// Creates a new builder-style object to manufacture [`StoppingCondition`](crate::model::StoppingCondition)
    pub fn builder() -> crate::model::stopping_condition::Builder {
        crate::model::stopping_condition::Builder::default()
    }
}

/// <p>Describes the resources, including ML compute instances and ML storage volumes, to use for model training. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConfig {
    /// <p>The ML compute instance type. </p>
    pub instance_type: std::option::Option<crate::model::TrainingInstanceType>,
    /// <p>The number of ML compute instances to use. For distributed training, provide a value greater than 1. </p>
    pub instance_count: i32,
    /// <p>The size of the ML storage volume that you want to provision. </p>
    /// <p>ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. </p>
    /// <p>You must specify sufficient ML storage for your scenario. </p> <note>
    /// <p> SageMaker supports only the General Purpose SSD (gp2) ML storage volume type. </p>
    /// </note> <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for training, SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_size_in_gb: i32,
    /// <p>The Amazon Web Services KMS key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.</p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl ResourceConfig {
    /// <p>The ML compute instance type. </p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::TrainingInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The number of ML compute instances to use. For distributed training, provide a value greater than 1. </p>
    pub fn instance_count(&self) -> i32 {
        self.instance_count
    }
    /// <p>The size of the ML storage volume that you want to provision. </p>
    /// <p>ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. </p>
    /// <p>You must specify sufficient ML storage for your scenario. </p> <note>
    /// <p> SageMaker supports only the General Purpose SSD (gp2) ML storage volume type. </p>
    /// </note> <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for training, SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub fn volume_size_in_gb(&self) -> i32 {
        self.volume_size_in_gb
    }
    /// <p>The Amazon Web Services KMS key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.</p> <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
    /// </note>
    /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for ResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConfig");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`ResourceConfig`](crate::model::ResourceConfig)
pub mod resource_config {

    /// A builder for [`ResourceConfig`](crate::model::ResourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::TrainingInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ML compute instance type. </p>
        pub fn instance_type(mut self, input: crate::model::TrainingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The ML compute instance type. </p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::TrainingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of ML compute instances to use. For distributed training, provide a value greater than 1. </p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of ML compute instances to use. For distributed training, provide a value greater than 1. </p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The size of the ML storage volume that you want to provision. </p>
        /// <p>ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. </p>
        /// <p>You must specify sufficient ML storage for your scenario. </p> <note>
        /// <p> SageMaker supports only the General Purpose SSD (gp2) ML storage volume type. </p>
        /// </note> <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for training, SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        /// <p>The size of the ML storage volume that you want to provision. </p>
        /// <p>ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. </p>
        /// <p>You must specify sufficient ML storage for your scenario. </p> <note>
        /// <p> SageMaker supports only the General Purpose SSD (gp2) ML storage volume type. </p>
        /// </note> <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for training, SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a <code>VolumeSizeInGB</code> greater than the total size of the local instance storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services KMS key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.</p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services KMS key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.</p> <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a <code>VolumeKmsKeyId</code> when using an instance type with local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD Instance Store Volumes</a>.</p>
        /// </note>
        /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConfig`](crate::model::ResourceConfig)
        pub fn build(self) -> crate::model::ResourceConfig {
            crate::model::ResourceConfig {
                instance_type: self.instance_type,
                instance_count: self.instance_count.unwrap_or_default(),
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl ResourceConfig {
    /// Creates a new builder-style object to manufacture [`ResourceConfig`](crate::model::ResourceConfig)
    pub fn builder() -> crate::model::resource_config::Builder {
        crate::model::resource_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    MlC42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC48Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC518Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC59Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5N18Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5N2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5N4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5N9Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlC5NXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn12Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn16Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn8Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG4DnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG516Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG548Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG58Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlG5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM410Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM416Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM42Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM44Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM4Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM512Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM524Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM52Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM54Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Large,
    #[allow(missing_docs)] // documentation missing in model
    MlM5Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP216Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP28Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP2Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP316Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP32Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP38Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP3Dn24Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlP4D24Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => TrainingInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => TrainingInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => TrainingInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => TrainingInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => TrainingInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => TrainingInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => TrainingInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => TrainingInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => TrainingInstanceType::MlC5Xlarge,
            "ml.c5n.18xlarge" => TrainingInstanceType::MlC5N18Xlarge,
            "ml.c5n.2xlarge" => TrainingInstanceType::MlC5N2Xlarge,
            "ml.c5n.4xlarge" => TrainingInstanceType::MlC5N4Xlarge,
            "ml.c5n.9xlarge" => TrainingInstanceType::MlC5N9Xlarge,
            "ml.c5n.xlarge" => TrainingInstanceType::MlC5NXlarge,
            "ml.g4dn.12xlarge" => TrainingInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => TrainingInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => TrainingInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => TrainingInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => TrainingInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => TrainingInstanceType::MlG4DnXlarge,
            "ml.g5.12xlarge" => TrainingInstanceType::MlG512Xlarge,
            "ml.g5.16xlarge" => TrainingInstanceType::MlG516Xlarge,
            "ml.g5.24xlarge" => TrainingInstanceType::MlG524Xlarge,
            "ml.g5.2xlarge" => TrainingInstanceType::MlG52Xlarge,
            "ml.g5.48xlarge" => TrainingInstanceType::MlG548Xlarge,
            "ml.g5.4xlarge" => TrainingInstanceType::MlG54Xlarge,
            "ml.g5.8xlarge" => TrainingInstanceType::MlG58Xlarge,
            "ml.g5.xlarge" => TrainingInstanceType::MlG5Xlarge,
            "ml.m4.10xlarge" => TrainingInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => TrainingInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => TrainingInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => TrainingInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => TrainingInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => TrainingInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => TrainingInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => TrainingInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => TrainingInstanceType::MlM54Xlarge,
            "ml.m5.large" => TrainingInstanceType::MlM5Large,
            "ml.m5.xlarge" => TrainingInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => TrainingInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => TrainingInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => TrainingInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => TrainingInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => TrainingInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => TrainingInstanceType::MlP38Xlarge,
            "ml.p3dn.24xlarge" => TrainingInstanceType::MlP3Dn24Xlarge,
            "ml.p4d.24xlarge" => TrainingInstanceType::MlP4D24Xlarge,
            other => TrainingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingInstanceType::from(s))
    }
}
impl TrainingInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            TrainingInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            TrainingInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            TrainingInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            TrainingInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            TrainingInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            TrainingInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            TrainingInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            TrainingInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            TrainingInstanceType::MlC5N18Xlarge => "ml.c5n.18xlarge",
            TrainingInstanceType::MlC5N2Xlarge => "ml.c5n.2xlarge",
            TrainingInstanceType::MlC5N4Xlarge => "ml.c5n.4xlarge",
            TrainingInstanceType::MlC5N9Xlarge => "ml.c5n.9xlarge",
            TrainingInstanceType::MlC5NXlarge => "ml.c5n.xlarge",
            TrainingInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            TrainingInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            TrainingInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            TrainingInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            TrainingInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            TrainingInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            TrainingInstanceType::MlG512Xlarge => "ml.g5.12xlarge",
            TrainingInstanceType::MlG516Xlarge => "ml.g5.16xlarge",
            TrainingInstanceType::MlG524Xlarge => "ml.g5.24xlarge",
            TrainingInstanceType::MlG52Xlarge => "ml.g5.2xlarge",
            TrainingInstanceType::MlG548Xlarge => "ml.g5.48xlarge",
            TrainingInstanceType::MlG54Xlarge => "ml.g5.4xlarge",
            TrainingInstanceType::MlG58Xlarge => "ml.g5.8xlarge",
            TrainingInstanceType::MlG5Xlarge => "ml.g5.xlarge",
            TrainingInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            TrainingInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            TrainingInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            TrainingInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            TrainingInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            TrainingInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            TrainingInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            TrainingInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            TrainingInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            TrainingInstanceType::MlM5Large => "ml.m5.large",
            TrainingInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            TrainingInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            TrainingInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            TrainingInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            TrainingInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            TrainingInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            TrainingInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            TrainingInstanceType::MlP3Dn24Xlarge => "ml.p3dn.24xlarge",
            TrainingInstanceType::MlP4D24Xlarge => "ml.p4d.24xlarge",
            TrainingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.c5n.18xlarge",
            "ml.c5n.2xlarge",
            "ml.c5n.4xlarge",
            "ml.c5n.9xlarge",
            "ml.c5n.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.g5.12xlarge",
            "ml.g5.16xlarge",
            "ml.g5.24xlarge",
            "ml.g5.2xlarge",
            "ml.g5.48xlarge",
            "ml.g5.4xlarge",
            "ml.g5.8xlarge",
            "ml.g5.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.p3dn.24xlarge",
            "ml.p4d.24xlarge",
        ]
    }
}
impl AsRef<str> for TrainingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about how to store model training results (model artifacts).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputDataConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or <code>CreateHyperParameterTuningJob</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Identifies the S3 path where you want SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>. </p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl OutputDataConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or <code>CreateHyperParameterTuningJob</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Identifies the S3 path where you want SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>. </p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
}
impl std::fmt::Debug for OutputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputDataConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`OutputDataConfig`](crate::model::OutputDataConfig)
pub mod output_data_config {

    /// A builder for [`OutputDataConfig`](crate::model::OutputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or <code>CreateHyperParameterTuningJob</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or <code>CreateHyperParameterTuningJob</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Identifies the S3 path where you want SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>. </p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Identifies the S3 path where you want SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>. </p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputDataConfig`](crate::model::OutputDataConfig)
        pub fn build(self) -> crate::model::OutputDataConfig {
            crate::model::OutputDataConfig {
                kms_key_id: self.kms_key_id,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl OutputDataConfig {
    /// Creates a new builder-style object to manufacture [`OutputDataConfig`](crate::model::OutputDataConfig)
    pub fn builder() -> crate::model::output_data_config::Builder {
        crate::model::output_data_config::Builder::default()
    }
}

/// <p>A channel is a named input source that training algorithms can consume. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Channel {
    /// <p>The name of the channel. </p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The location of the channel data.</p>
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The MIME type of the data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>If training data is compressed, the compression type. The default value is <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In File mode, leave this field unset or set it to None.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p></p>
    /// <p>Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create a Dataset Using RecordIO</a>. </p>
    /// <p>In File mode, leave this field unset or set it to None.</p>
    pub record_wrapper_type: std::option::Option<crate::model::RecordWrapper>,
    /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't set a value for <code>InputMode</code>, SageMaker uses the value set for <code>TrainingInputMode</code>. Use this parameter to override the <code>TrainingInputMode</code> setting in a <code>AlgorithmSpecification</code> request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use <code>File</code> input mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input mode.</p>
    /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
    pub input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>A configuration for a shuffle option for input data in a channel. If you use <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object references in the <code>ManifestFile</code> is shuffled. If you use <code>AugmentedManifestFile</code>, the order of the JSON lines in the <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined using the <code>Seed</code> value.</p>
    /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.</p>
    pub shuffle_config: std::option::Option<crate::model::ShuffleConfig>,
}
impl Channel {
    /// <p>The name of the channel. </p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The location of the channel data.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>The MIME type of the data.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>If training data is compressed, the compression type. The default value is <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In File mode, leave this field unset or set it to None.</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p></p>
    /// <p>Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create a Dataset Using RecordIO</a>. </p>
    /// <p>In File mode, leave this field unset or set it to None.</p>
    pub fn record_wrapper_type(&self) -> std::option::Option<&crate::model::RecordWrapper> {
        self.record_wrapper_type.as_ref()
    }
    /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't set a value for <code>InputMode</code>, SageMaker uses the value set for <code>TrainingInputMode</code>. Use this parameter to override the <code>TrainingInputMode</code> setting in a <code>AlgorithmSpecification</code> request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use <code>File</code> input mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input mode.</p>
    /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
    pub fn input_mode(&self) -> std::option::Option<&crate::model::TrainingInputMode> {
        self.input_mode.as_ref()
    }
    /// <p>A configuration for a shuffle option for input data in a channel. If you use <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object references in the <code>ManifestFile</code> is shuffled. If you use <code>AugmentedManifestFile</code>, the order of the JSON lines in the <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined using the <code>Seed</code> value.</p>
    /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.</p>
    pub fn shuffle_config(&self) -> std::option::Option<&crate::model::ShuffleConfig> {
        self.shuffle_config.as_ref()
    }
}
impl std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Channel");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("data_source", &self.data_source);
        formatter.field("content_type", &self.content_type);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("record_wrapper_type", &self.record_wrapper_type);
        formatter.field("input_mode", &self.input_mode);
        formatter.field("shuffle_config", &self.shuffle_config);
        formatter.finish()
    }
}
/// See [`Channel`](crate::model::Channel)
pub mod channel {

    /// A builder for [`Channel`](crate::model::Channel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) record_wrapper_type: std::option::Option<crate::model::RecordWrapper>,
        pub(crate) input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) shuffle_config: std::option::Option<crate::model::ShuffleConfig>,
    }
    impl Builder {
        /// <p>The name of the channel. </p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel. </p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The location of the channel data.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The location of the channel data.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The MIME type of the data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The MIME type of the data.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>If training data is compressed, the compression type. The default value is <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In File mode, leave this field unset or set it to None.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>If training data is compressed, the compression type. The default value is <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In File mode, leave this field unset or set it to None.</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p></p>
        /// <p>Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create a Dataset Using RecordIO</a>. </p>
        /// <p>In File mode, leave this field unset or set it to None.</p>
        pub fn record_wrapper_type(mut self, input: crate::model::RecordWrapper) -> Self {
            self.record_wrapper_type = Some(input);
            self
        }
        /// <p></p>
        /// <p>Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create a Dataset Using RecordIO</a>. </p>
        /// <p>In File mode, leave this field unset or set it to None.</p>
        pub fn set_record_wrapper_type(
            mut self,
            input: std::option::Option<crate::model::RecordWrapper>,
        ) -> Self {
            self.record_wrapper_type = input;
            self
        }
        /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't set a value for <code>InputMode</code>, SageMaker uses the value set for <code>TrainingInputMode</code>. Use this parameter to override the <code>TrainingInputMode</code> setting in a <code>AlgorithmSpecification</code> request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use <code>File</code> input mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input mode.</p>
        /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
        pub fn input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.input_mode = Some(input);
            self
        }
        /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't set a value for <code>InputMode</code>, SageMaker uses the value set for <code>TrainingInputMode</code>. Use this parameter to override the <code>TrainingInputMode</code> setting in a <code>AlgorithmSpecification</code> request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use <code>File</code> input mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input mode.</p>
        /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
        pub fn set_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.input_mode = input;
            self
        }
        /// <p>A configuration for a shuffle option for input data in a channel. If you use <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object references in the <code>ManifestFile</code> is shuffled. If you use <code>AugmentedManifestFile</code>, the order of the JSON lines in the <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined using the <code>Seed</code> value.</p>
        /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.</p>
        pub fn shuffle_config(mut self, input: crate::model::ShuffleConfig) -> Self {
            self.shuffle_config = Some(input);
            self
        }
        /// <p>A configuration for a shuffle option for input data in a channel. If you use <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object references in the <code>ManifestFile</code> is shuffled. If you use <code>AugmentedManifestFile</code>, the order of the JSON lines in the <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined using the <code>Seed</code> value.</p>
        /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.</p>
        pub fn set_shuffle_config(
            mut self,
            input: std::option::Option<crate::model::ShuffleConfig>,
        ) -> Self {
            self.shuffle_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Channel`](crate::model::Channel)
        pub fn build(self) -> crate::model::Channel {
            crate::model::Channel {
                channel_name: self.channel_name,
                data_source: self.data_source,
                content_type: self.content_type,
                compression_type: self.compression_type,
                record_wrapper_type: self.record_wrapper_type,
                input_mode: self.input_mode,
                shuffle_config: self.shuffle_config,
            }
        }
    }
}
impl Channel {
    /// Creates a new builder-style object to manufacture [`Channel`](crate::model::Channel)
    pub fn builder() -> crate::model::channel::Builder {
        crate::model::channel::Builder::default()
    }
}

/// <p>A configuration for a shuffle option for input data in a channel. If you use <code>S3Prefix</code> for <code>S3DataType</code>, the results of the S3 key prefix matches are shuffled. If you use <code>ManifestFile</code>, the order of the S3 object references in the <code>ManifestFile</code> is shuffled. If you use <code>AugmentedManifestFile</code>, the order of the JSON lines in the <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined using the <code>Seed</code> value.</p>
/// <p>For Pipe input mode, when <code>ShuffleConfig</code> is specified shuffling is done at the start of every epoch. With large datasets, this ensures that the order of the training data is different for each epoch, and it helps reduce bias and possible overfitting. In a multi-node training job when <code>ShuffleConfig</code> is combined with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ShuffleConfig {
    /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
    pub seed: i64,
}
impl ShuffleConfig {
    /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
    pub fn seed(&self) -> i64 {
        self.seed
    }
}
impl std::fmt::Debug for ShuffleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ShuffleConfig");
        formatter.field("seed", &self.seed);
        formatter.finish()
    }
}
/// See [`ShuffleConfig`](crate::model::ShuffleConfig)
pub mod shuffle_config {

    /// A builder for [`ShuffleConfig`](crate::model::ShuffleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) seed: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
        pub fn seed(mut self, input: i64) -> Self {
            self.seed = Some(input);
            self
        }
        /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
        pub fn set_seed(mut self, input: std::option::Option<i64>) -> Self {
            self.seed = input;
            self
        }
        /// Consumes the builder and constructs a [`ShuffleConfig`](crate::model::ShuffleConfig)
        pub fn build(self) -> crate::model::ShuffleConfig {
            crate::model::ShuffleConfig {
                seed: self.seed.unwrap_or_default(),
            }
        }
    }
}
impl ShuffleConfig {
    /// Creates a new builder-style object to manufacture [`ShuffleConfig`](crate::model::ShuffleConfig)
    pub fn builder() -> crate::model::shuffle_config::Builder {
        crate::model::shuffle_config::Builder::default()
    }
}

/// <p>The training input mode that the algorithm supports. For more information about input modes, see
/// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
///
/// <p>
/// <b>Pipe mode</b>
/// </p>
/// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly
/// from Amazon S3 to the container.</p>
///
/// <p>
/// <b>File mode</b>
/// </p>
/// <p>If an algorithm supports <code>File</code> mode, SageMaker
/// downloads the training data from S3 to the provisioned ML storage volume, and mounts the
/// directory to the Docker volume for the training container.</p>
/// <p>You must provision the ML storage volume with sufficient capacity
/// to accommodate the data downloaded from S3. In addition to the training data, the ML
/// storage volume also stores the output model. The algorithm container uses the ML storage
/// volume to also store intermediate information, if any.</p>
/// <p>For distributed algorithms, training data is distributed uniformly.
/// Your training duration is predictable if the input data objects sizes are
/// approximately the same. SageMaker does not split the files any further for model training.
/// If the object sizes are skewed, training won't be optimal as the data distribution is also
/// skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in
/// training.</p>
///
/// <p>
/// <b>FastFile mode</b>
/// </p>
/// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly
/// from S3 to the container with no code changes, and provides file system access to
/// the data. Users can author their training script to interact with these files as if
/// they were stored on disk.</p>
/// <p>
/// <code>FastFile</code> mode works best when the data is read sequentially.
/// Augmented manifest files aren't supported.
/// The startup time is lower when there are fewer files in the S3 bucket provided.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingInputMode {
    #[allow(missing_docs)] // documentation missing in model
    Fastfile,
    #[allow(missing_docs)] // documentation missing in model
    File,
    #[allow(missing_docs)] // documentation missing in model
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingInputMode {
    fn from(s: &str) -> Self {
        match s {
            "FastFile" => TrainingInputMode::Fastfile,
            "File" => TrainingInputMode::File,
            "Pipe" => TrainingInputMode::Pipe,
            other => TrainingInputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingInputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingInputMode::from(s))
    }
}
impl TrainingInputMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingInputMode::Fastfile => "FastFile",
            TrainingInputMode::File => "File",
            TrainingInputMode::Pipe => "Pipe",
            TrainingInputMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FastFile", "File", "Pipe"]
    }
}
impl AsRef<str> for TrainingInputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordWrapper {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Recordio,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecordWrapper {
    fn from(s: &str) -> Self {
        match s {
            "None" => RecordWrapper::None,
            "RecordIO" => RecordWrapper::Recordio,
            other => RecordWrapper::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecordWrapper {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordWrapper::from(s))
    }
}
impl RecordWrapper {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecordWrapper::None => "None",
            RecordWrapper::Recordio => "RecordIO",
            RecordWrapper::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["None", "RecordIO"]
    }
}
impl AsRef<str> for RecordWrapper {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the location of the channel data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub s3_data_source: std::option::Option<crate::model::S3DataSource>,
    /// <p>The file system that is associated with a channel.</p>
    pub file_system_data_source: std::option::Option<crate::model::FileSystemDataSource>,
}
impl DataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub fn s3_data_source(&self) -> std::option::Option<&crate::model::S3DataSource> {
        self.s3_data_source.as_ref()
    }
    /// <p>The file system that is associated with a channel.</p>
    pub fn file_system_data_source(
        &self,
    ) -> std::option::Option<&crate::model::FileSystemDataSource> {
        self.file_system_data_source.as_ref()
    }
}
impl std::fmt::Debug for DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.field("file_system_data_source", &self.file_system_data_source);
        formatter.finish()
    }
}
/// See [`DataSource`](crate::model::DataSource)
pub mod data_source {

    /// A builder for [`DataSource`](crate::model::DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::S3DataSource>,
        pub(crate) file_system_data_source: std::option::Option<crate::model::FileSystemDataSource>,
    }
    impl Builder {
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn s3_data_source(mut self, input: crate::model::S3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::S3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// <p>The file system that is associated with a channel.</p>
        pub fn file_system_data_source(
            mut self,
            input: crate::model::FileSystemDataSource,
        ) -> Self {
            self.file_system_data_source = Some(input);
            self
        }
        /// <p>The file system that is associated with a channel.</p>
        pub fn set_file_system_data_source(
            mut self,
            input: std::option::Option<crate::model::FileSystemDataSource>,
        ) -> Self {
            self.file_system_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource)
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                s3_data_source: self.s3_data_source,
                file_system_data_source: self.file_system_data_source,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource)
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>Specifies a file system data source for a channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemDataSource {
    /// <p>The file system id.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The access mode of the mount of the directory associated with the channel. A directory can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write) mode.</p>
    pub file_system_access_mode: std::option::Option<crate::model::FileSystemAccessMode>,
    /// <p>The file system type. </p>
    pub file_system_type: std::option::Option<crate::model::FileSystemType>,
    /// <p>The full path to the directory to associate with the channel.</p>
    pub directory_path: std::option::Option<std::string::String>,
}
impl FileSystemDataSource {
    /// <p>The file system id.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The access mode of the mount of the directory associated with the channel. A directory can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write) mode.</p>
    pub fn file_system_access_mode(
        &self,
    ) -> std::option::Option<&crate::model::FileSystemAccessMode> {
        self.file_system_access_mode.as_ref()
    }
    /// <p>The file system type. </p>
    pub fn file_system_type(&self) -> std::option::Option<&crate::model::FileSystemType> {
        self.file_system_type.as_ref()
    }
    /// <p>The full path to the directory to associate with the channel.</p>
    pub fn directory_path(&self) -> std::option::Option<&str> {
        self.directory_path.as_deref()
    }
}
impl std::fmt::Debug for FileSystemDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemDataSource");
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("file_system_access_mode", &self.file_system_access_mode);
        formatter.field("file_system_type", &self.file_system_type);
        formatter.field("directory_path", &self.directory_path);
        formatter.finish()
    }
}
/// See [`FileSystemDataSource`](crate::model::FileSystemDataSource)
pub mod file_system_data_source {

    /// A builder for [`FileSystemDataSource`](crate::model::FileSystemDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) file_system_access_mode: std::option::Option<crate::model::FileSystemAccessMode>,
        pub(crate) file_system_type: std::option::Option<crate::model::FileSystemType>,
        pub(crate) directory_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file system id.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The file system id.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The access mode of the mount of the directory associated with the channel. A directory can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write) mode.</p>
        pub fn file_system_access_mode(
            mut self,
            input: crate::model::FileSystemAccessMode,
        ) -> Self {
            self.file_system_access_mode = Some(input);
            self
        }
        /// <p>The access mode of the mount of the directory associated with the channel. A directory can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write) mode.</p>
        pub fn set_file_system_access_mode(
            mut self,
            input: std::option::Option<crate::model::FileSystemAccessMode>,
        ) -> Self {
            self.file_system_access_mode = input;
            self
        }
        /// <p>The file system type. </p>
        pub fn file_system_type(mut self, input: crate::model::FileSystemType) -> Self {
            self.file_system_type = Some(input);
            self
        }
        /// <p>The file system type. </p>
        pub fn set_file_system_type(
            mut self,
            input: std::option::Option<crate::model::FileSystemType>,
        ) -> Self {
            self.file_system_type = input;
            self
        }
        /// <p>The full path to the directory to associate with the channel.</p>
        pub fn directory_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_path = Some(input.into());
            self
        }
        /// <p>The full path to the directory to associate with the channel.</p>
        pub fn set_directory_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemDataSource`](crate::model::FileSystemDataSource)
        pub fn build(self) -> crate::model::FileSystemDataSource {
            crate::model::FileSystemDataSource {
                file_system_id: self.file_system_id,
                file_system_access_mode: self.file_system_access_mode,
                file_system_type: self.file_system_type,
                directory_path: self.directory_path,
            }
        }
    }
}
impl FileSystemDataSource {
    /// Creates a new builder-style object to manufacture [`FileSystemDataSource`](crate::model::FileSystemDataSource)
    pub fn builder() -> crate::model::file_system_data_source::Builder {
        crate::model::file_system_data_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemType {
    #[allow(missing_docs)] // documentation missing in model
    Efs,
    #[allow(missing_docs)] // documentation missing in model
    Fsxlustre,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemType {
    fn from(s: &str) -> Self {
        match s {
            "EFS" => FileSystemType::Efs,
            "FSxLustre" => FileSystemType::Fsxlustre,
            other => FileSystemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemType::from(s))
    }
}
impl FileSystemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemType::Efs => "EFS",
            FileSystemType::Fsxlustre => "FSxLustre",
            FileSystemType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EFS", "FSxLustre"]
    }
}
impl AsRef<str> for FileSystemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemAccessMode {
    #[allow(missing_docs)] // documentation missing in model
    Ro,
    #[allow(missing_docs)] // documentation missing in model
    Rw,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemAccessMode {
    fn from(s: &str) -> Self {
        match s {
            "ro" => FileSystemAccessMode::Ro,
            "rw" => FileSystemAccessMode::Rw,
            other => FileSystemAccessMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemAccessMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemAccessMode::from(s))
    }
}
impl FileSystemAccessMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemAccessMode::Ro => "ro",
            FileSystemAccessMode::Rw => "rw",
            FileSystemAccessMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ro", "rw"]
    }
}
impl AsRef<str> for FileSystemAccessMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. SageMaker uses all objects that match the specified key name prefix for model training. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want SageMaker to use for model training. </p>
    /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. <code>AugmentedManifestFile</code> can only be used if the Channel's input mode is <code>Pipe</code>.</p>
    pub s3_data_type: std::option::Option<crate::model::S3DataType>,
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example: </p>
    /// <ul>
    /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code> </p> </li>
    /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> A manifest is an S3 object which is a JSON file consisting of an array of elements. The first element is a prefix which is followed by one or more suffixes. SageMaker appends the suffix elements to the prefix to get a full set of <code>S3Uri</code>. Note that the prefix must be a valid non-empty <code>S3Uri</code> that precludes users from specifying a manifest whose individual <code>S3Uri</code> is sourced from different S3 buckets.</p> <p> The following code example shows a valid manifest format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code> "relative/path/to/custdata-1",</code> </p> <p> <code> "relative/path/custdata-2",</code> </p> <p> <code> ...</code> </p> <p> <code> "relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> This JSON is equivalent to the following <code>S3Uri</code> list:</p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p>The complete set of <code>S3Uri</code> in this manifest is the input data for the channel for this data source. The object that each <code>S3Uri</code> points to must be readable by the IAM role that SageMaker uses to perform tasks on your behalf. </p> </li>
    /// </ul>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>If you want SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify <code>FullyReplicated</code>. </p>
    /// <p>If you want SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify <code>ShardedByS3Key</code>. If there are <i>n</i> ML compute instances launched for a training job, each instance gets approximately 1/<i>n</i> of the number of S3 objects. In this case, model training on each machine uses only the subset of training data. </p>
    /// <p>Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipe modes. Keep this in mind when developing algorithms. </p>
    /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>), this copies 1/<i>n</i> of the number of objects. </p>
    pub s3_data_distribution_type: std::option::Option<crate::model::S3DataDistribution>,
    /// <p>A list of one or more attribute names to use that are found in a specified augmented manifest file.</p>
    pub attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl S3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. SageMaker uses all objects that match the specified key name prefix for model training. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want SageMaker to use for model training. </p>
    /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. <code>AugmentedManifestFile</code> can only be used if the Channel's input mode is <code>Pipe</code>.</p>
    pub fn s3_data_type(&self) -> std::option::Option<&crate::model::S3DataType> {
        self.s3_data_type.as_ref()
    }
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example: </p>
    /// <ul>
    /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code> </p> </li>
    /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> A manifest is an S3 object which is a JSON file consisting of an array of elements. The first element is a prefix which is followed by one or more suffixes. SageMaker appends the suffix elements to the prefix to get a full set of <code>S3Uri</code>. Note that the prefix must be a valid non-empty <code>S3Uri</code> that precludes users from specifying a manifest whose individual <code>S3Uri</code> is sourced from different S3 buckets.</p> <p> The following code example shows a valid manifest format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code> "relative/path/to/custdata-1",</code> </p> <p> <code> "relative/path/custdata-2",</code> </p> <p> <code> ...</code> </p> <p> <code> "relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> This JSON is equivalent to the following <code>S3Uri</code> list:</p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p>The complete set of <code>S3Uri</code> in this manifest is the input data for the channel for this data source. The object that each <code>S3Uri</code> points to must be readable by the IAM role that SageMaker uses to perform tasks on your behalf. </p> </li>
    /// </ul>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>If you want SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify <code>FullyReplicated</code>. </p>
    /// <p>If you want SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify <code>ShardedByS3Key</code>. If there are <i>n</i> ML compute instances launched for a training job, each instance gets approximately 1/<i>n</i> of the number of S3 objects. In this case, model training on each machine uses only the subset of training data. </p>
    /// <p>Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipe modes. Keep this in mind when developing algorithms. </p>
    /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>), this copies 1/<i>n</i> of the number of objects. </p>
    pub fn s3_data_distribution_type(
        &self,
    ) -> std::option::Option<&crate::model::S3DataDistribution> {
        self.s3_data_distribution_type.as_ref()
    }
    /// <p>A list of one or more attribute names to use that are found in a specified augmented manifest file.</p>
    pub fn attribute_names(&self) -> std::option::Option<&[std::string::String]> {
        self.attribute_names.as_deref()
    }
}
impl std::fmt::Debug for S3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("attribute_names", &self.attribute_names);
        formatter.finish()
    }
}
/// See [`S3DataSource`](crate::model::S3DataSource)
pub mod s3_data_source {

    /// A builder for [`S3DataSource`](crate::model::S3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::S3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) s3_data_distribution_type: std::option::Option<crate::model::S3DataDistribution>,
        pub(crate) attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. SageMaker uses all objects that match the specified key name prefix for model training. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want SageMaker to use for model training. </p>
        /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. <code>AugmentedManifestFile</code> can only be used if the Channel's input mode is <code>Pipe</code>.</p>
        pub fn s3_data_type(mut self, input: crate::model::S3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix. SageMaker uses all objects that match the specified key name prefix for model training. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that is a manifest file containing a list of object keys that you want SageMaker to use for model training. </p>
        /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. <code>AugmentedManifestFile</code> can only be used if the Channel's input mode is <code>Pipe</code>.</p>
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::S3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example: </p>
        /// <ul>
        /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code> </p> </li>
        /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> A manifest is an S3 object which is a JSON file consisting of an array of elements. The first element is a prefix which is followed by one or more suffixes. SageMaker appends the suffix elements to the prefix to get a full set of <code>S3Uri</code>. Note that the prefix must be a valid non-empty <code>S3Uri</code> that precludes users from specifying a manifest whose individual <code>S3Uri</code> is sourced from different S3 buckets.</p> <p> The following code example shows a valid manifest format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code> "relative/path/to/custdata-1",</code> </p> <p> <code> "relative/path/custdata-2",</code> </p> <p> <code> ...</code> </p> <p> <code> "relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> This JSON is equivalent to the following <code>S3Uri</code> list:</p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p>The complete set of <code>S3Uri</code> in this manifest is the input data for the channel for this data source. The object that each <code>S3Uri</code> points to must be readable by the IAM role that SageMaker uses to perform tasks on your behalf. </p> </li>
        /// </ul>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a key name prefix or a manifest. For example: </p>
        /// <ul>
        /// <li> <p> A key name prefix might look like this: <code>s3://bucketname/exampleprefix</code> </p> </li>
        /// <li> <p> A manifest might look like this: <code>s3://bucketname/example.manifest</code> </p> <p> A manifest is an S3 object which is a JSON file consisting of an array of elements. The first element is a prefix which is followed by one or more suffixes. SageMaker appends the suffix elements to the prefix to get a full set of <code>S3Uri</code>. Note that the prefix must be a valid non-empty <code>S3Uri</code> that precludes users from specifying a manifest whose individual <code>S3Uri</code> is sourced from different S3 buckets.</p> <p> The following code example shows a valid manifest format: </p> <p> <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code> </p> <p> <code> "relative/path/to/custdata-1",</code> </p> <p> <code> "relative/path/custdata-2",</code> </p> <p> <code> ...</code> </p> <p> <code> "relative/path/custdata-N"</code> </p> <p> <code>]</code> </p> <p> This JSON is equivalent to the following <code>S3Uri</code> list:</p> <p> <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code> </p> <p> <code>...</code> </p> <p> <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code> </p> <p>The complete set of <code>S3Uri</code> in this manifest is the input data for the channel for this data source. The object that each <code>S3Uri</code> points to must be readable by the IAM role that SageMaker uses to perform tasks on your behalf. </p> </li>
        /// </ul>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>If you want SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify <code>FullyReplicated</code>. </p>
        /// <p>If you want SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify <code>ShardedByS3Key</code>. If there are <i>n</i> ML compute instances launched for a training job, each instance gets approximately 1/<i>n</i> of the number of S3 objects. In this case, model training on each machine uses only the subset of training data. </p>
        /// <p>Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipe modes. Keep this in mind when developing algorithms. </p>
        /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>), this copies 1/<i>n</i> of the number of objects. </p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::S3DataDistribution,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        /// <p>If you want SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify <code>FullyReplicated</code>. </p>
        /// <p>If you want SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify <code>ShardedByS3Key</code>. If there are <i>n</i> ML compute instances launched for a training job, each instance gets approximately 1/<i>n</i> of the number of S3 objects. In this case, model training on each machine uses only the subset of training data. </p>
        /// <p>Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipe modes. Keep this in mind when developing algorithms. </p>
        /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>), this copies 1/<i>n</i> of the number of objects. </p>
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::S3DataDistribution>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        /// Appends an item to `attribute_names`.
        ///
        /// To override the contents of this collection use [`set_attribute_names`](Self::set_attribute_names).
        ///
        /// <p>A list of one or more attribute names to use that are found in a specified augmented manifest file.</p>
        pub fn attribute_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.attribute_names.unwrap_or_default();
            v.push(input.into());
            self.attribute_names = Some(v);
            self
        }
        /// <p>A list of one or more attribute names to use that are found in a specified augmented manifest file.</p>
        pub fn set_attribute_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attribute_names = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DataSource`](crate::model::S3DataSource)
        pub fn build(self) -> crate::model::S3DataSource {
            crate::model::S3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
                s3_data_distribution_type: self.s3_data_distribution_type,
                attribute_names: self.attribute_names,
            }
        }
    }
}
impl S3DataSource {
    /// Creates a new builder-style object to manufacture [`S3DataSource`](crate::model::S3DataSource)
    pub fn builder() -> crate::model::s3_data_source::Builder {
        crate::model::s3_data_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3DataDistribution {
    #[allow(missing_docs)] // documentation missing in model
    FullyReplicated,
    #[allow(missing_docs)] // documentation missing in model
    ShardedByS3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3DataDistribution {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => S3DataDistribution::FullyReplicated,
            "ShardedByS3Key" => S3DataDistribution::ShardedByS3Key,
            other => S3DataDistribution::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3DataDistribution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3DataDistribution::from(s))
    }
}
impl S3DataDistribution {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3DataDistribution::FullyReplicated => "FullyReplicated",
            S3DataDistribution::ShardedByS3Key => "ShardedByS3Key",
            S3DataDistribution::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for S3DataDistribution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the training algorithm to use in a <code>CreateTrainingJob</code> request.</p>
/// <p>For more information about algorithms provided by SageMaker, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. For information about using your own algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmSpecification {
    /// <p>The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for SageMaker built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Docker Registry Paths and Example Code</a> in the <i>Amazon SageMaker developer guide</i>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information about using your custom training container, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p> <note>
    /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
    /// <p>For more information, see the note in the <code>AlgorithmName</code> parameter description.</p>
    /// </note>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on Amazon Web Services Marketplace.</p> <note>
    /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
    /// <p>Note that the <code>AlgorithmName</code> parameter is mutually exclusive with the <code>TrainingImage</code> parameter. If you specify a value for the <code>AlgorithmName</code> parameter, you can't specify a value for <code>TrainingImage</code>, and vice versa.</p>
    /// <p>If you specify values for both parameters, the training job might break; if you don't specify any value for both parameters, the training job might raise a <code>null</code> error.</p>
    /// </note>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. SageMaker publishes each metric to Amazon CloudWatch.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    /// <p>To generate and save time-series metrics during training, set to <code>true</code>. The default is <code>false</code> and time-series metrics aren't generated except in the following cases:</p>
    /// <ul>
    /// <li> <p>You use one of the SageMaker built-in algorithms</p> </li>
    /// <li> <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt SageMaker Docker Images</a>:</p>
    /// <ul>
    /// <li> <p>Tensorflow (version &gt;= 1.15)</p> </li>
    /// <li> <p>MXNet (version &gt;= 1.6)</p> </li>
    /// <li> <p>PyTorch (version &gt;= 1.3)</p> </li>
    /// </ul> </li>
    /// <li> <p>You specify at least one <code>MetricDefinition</code> </p> </li>
    /// </ul>
    pub enable_sage_maker_metrics_time_series: bool,
}
impl AlgorithmSpecification {
    /// <p>The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for SageMaker built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Docker Registry Paths and Example Code</a> in the <i>Amazon SageMaker developer guide</i>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information about using your custom training container, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p> <note>
    /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
    /// <p>For more information, see the note in the <code>AlgorithmName</code> parameter description.</p>
    /// </note>
    pub fn training_image(&self) -> std::option::Option<&str> {
        self.training_image.as_deref()
    }
    /// <p>The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on Amazon Web Services Marketplace.</p> <note>
    /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
    /// <p>Note that the <code>AlgorithmName</code> parameter is mutually exclusive with the <code>TrainingImage</code> parameter. If you specify a value for the <code>AlgorithmName</code> parameter, you can't specify a value for <code>TrainingImage</code>, and vice versa.</p>
    /// <p>If you specify values for both parameters, the training job might break; if you don't specify any value for both parameters, the training job might raise a <code>null</code> error.</p>
    /// </note>
    pub fn algorithm_name(&self) -> std::option::Option<&str> {
        self.algorithm_name.as_deref()
    }
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub fn training_input_mode(&self) -> std::option::Option<&crate::model::TrainingInputMode> {
        self.training_input_mode.as_ref()
    }
    /// <p>A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. SageMaker publishes each metric to Amazon CloudWatch.</p>
    pub fn metric_definitions(&self) -> std::option::Option<&[crate::model::MetricDefinition]> {
        self.metric_definitions.as_deref()
    }
    /// <p>To generate and save time-series metrics during training, set to <code>true</code>. The default is <code>false</code> and time-series metrics aren't generated except in the following cases:</p>
    /// <ul>
    /// <li> <p>You use one of the SageMaker built-in algorithms</p> </li>
    /// <li> <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt SageMaker Docker Images</a>:</p>
    /// <ul>
    /// <li> <p>Tensorflow (version &gt;= 1.15)</p> </li>
    /// <li> <p>MXNet (version &gt;= 1.6)</p> </li>
    /// <li> <p>PyTorch (version &gt;= 1.3)</p> </li>
    /// </ul> </li>
    /// <li> <p>You specify at least one <code>MetricDefinition</code> </p> </li>
    /// </ul>
    pub fn enable_sage_maker_metrics_time_series(&self) -> bool {
        self.enable_sage_maker_metrics_time_series
    }
}
impl std::fmt::Debug for AlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.field(
            "enable_sage_maker_metrics_time_series",
            &self.enable_sage_maker_metrics_time_series,
        );
        formatter.finish()
    }
}
/// See [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
pub mod algorithm_specification {

    /// A builder for [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        pub(crate) enable_sage_maker_metrics_time_series: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for SageMaker built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Docker Registry Paths and Example Code</a> in the <i>Amazon SageMaker developer guide</i>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information about using your custom training container, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p> <note>
        /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
        /// <p>For more information, see the note in the <code>AlgorithmName</code> parameter description.</p>
        /// </note>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        /// <p>The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for SageMaker built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Docker Registry Paths and Example Code</a> in the <i>Amazon SageMaker developer guide</i>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information about using your custom training container, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p> <note>
        /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
        /// <p>For more information, see the note in the <code>AlgorithmName</code> parameter description.</p>
        /// </note>
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on Amazon Web Services Marketplace.</p> <note>
        /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
        /// <p>Note that the <code>AlgorithmName</code> parameter is mutually exclusive with the <code>TrainingImage</code> parameter. If you specify a value for the <code>AlgorithmName</code> parameter, you can't specify a value for <code>TrainingImage</code>, and vice versa.</p>
        /// <p>If you specify values for both parameters, the training job might break; if you don't specify any value for both parameters, the training job might raise a <code>null</code> error.</p>
        /// </note>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        /// <p>The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on Amazon Web Services Marketplace.</p> <note>
        /// <p>You must specify either the algorithm name to the <code>AlgorithmName</code> parameter or the image URI of the algorithm container to the <code>TrainingImage</code> parameter.</p>
        /// <p>Note that the <code>AlgorithmName</code> parameter is mutually exclusive with the <code>TrainingImage</code> parameter. If you specify a value for the <code>AlgorithmName</code> parameter, you can't specify a value for <code>TrainingImage</code>, and vice versa.</p>
        /// <p>If you specify values for both parameters, the training job might break; if you don't specify any value for both parameters, the training job might raise a <code>null</code> error.</p>
        /// </note>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        /// Appends an item to `metric_definitions`.
        ///
        /// To override the contents of this collection use [`set_metric_definitions`](Self::set_metric_definitions).
        ///
        /// <p>A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. SageMaker publishes each metric to Amazon CloudWatch.</p>
        pub fn metric_definitions(mut self, input: crate::model::MetricDefinition) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input);
            self.metric_definitions = Some(v);
            self
        }
        /// <p>A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. SageMaker publishes each metric to Amazon CloudWatch.</p>
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        /// <p>To generate and save time-series metrics during training, set to <code>true</code>. The default is <code>false</code> and time-series metrics aren't generated except in the following cases:</p>
        /// <ul>
        /// <li> <p>You use one of the SageMaker built-in algorithms</p> </li>
        /// <li> <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt SageMaker Docker Images</a>:</p>
        /// <ul>
        /// <li> <p>Tensorflow (version &gt;= 1.15)</p> </li>
        /// <li> <p>MXNet (version &gt;= 1.6)</p> </li>
        /// <li> <p>PyTorch (version &gt;= 1.3)</p> </li>
        /// </ul> </li>
        /// <li> <p>You specify at least one <code>MetricDefinition</code> </p> </li>
        /// </ul>
        pub fn enable_sage_maker_metrics_time_series(mut self, input: bool) -> Self {
            self.enable_sage_maker_metrics_time_series = Some(input);
            self
        }
        /// <p>To generate and save time-series metrics during training, set to <code>true</code>. The default is <code>false</code> and time-series metrics aren't generated except in the following cases:</p>
        /// <ul>
        /// <li> <p>You use one of the SageMaker built-in algorithms</p> </li>
        /// <li> <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt SageMaker Docker Images</a>:</p>
        /// <ul>
        /// <li> <p>Tensorflow (version &gt;= 1.15)</p> </li>
        /// <li> <p>MXNet (version &gt;= 1.6)</p> </li>
        /// <li> <p>PyTorch (version &gt;= 1.3)</p> </li>
        /// </ul> </li>
        /// <li> <p>You specify at least one <code>MetricDefinition</code> </p> </li>
        /// </ul>
        pub fn set_enable_sage_maker_metrics_time_series(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_sage_maker_metrics_time_series = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
        pub fn build(self) -> crate::model::AlgorithmSpecification {
            crate::model::AlgorithmSpecification {
                training_image: self.training_image,
                algorithm_name: self.algorithm_name,
                training_input_mode: self.training_input_mode,
                metric_definitions: self.metric_definitions,
                enable_sage_maker_metrics_time_series: self
                    .enable_sage_maker_metrics_time_series
                    .unwrap_or_default(),
            }
        }
    }
}
impl AlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
    pub fn builder() -> crate::model::algorithm_specification::Builder {
        crate::model::algorithm_specification::Builder::default()
    }
}

/// <p>Specifies a metric that the training algorithm writes to <code>stderr</code> or <code>stdout</code>. SageMakerhyperparameter tuning captures all defined metrics. You specify one metric that a hyperparameter tuning job uses as its objective metric to choose the best training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDefinition {
    /// <p>The name of the metric.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining Objective Metrics</a>.</p>
    pub regex: std::option::Option<std::string::String>,
}
impl MetricDefinition {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining Objective Metrics</a>.</p>
    pub fn regex(&self) -> std::option::Option<&str> {
        self.regex.as_deref()
    }
}
impl std::fmt::Debug for MetricDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDefinition");
        formatter.field("name", &self.name);
        formatter.field("regex", &self.regex);
        formatter.finish()
    }
}
/// See [`MetricDefinition`](crate::model::MetricDefinition)
pub mod metric_definition {

    /// A builder for [`MetricDefinition`](crate::model::MetricDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) regex: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining Objective Metrics</a>.</p>
        pub fn regex(mut self, input: impl Into<std::string::String>) -> Self {
            self.regex = Some(input.into());
            self
        }
        /// <p>A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining Objective Metrics</a>.</p>
        pub fn set_regex(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.regex = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDefinition`](crate::model::MetricDefinition)
        pub fn build(self) -> crate::model::MetricDefinition {
            crate::model::MetricDefinition {
                name: self.name,
                regex: self.regex,
            }
        }
    }
}
impl MetricDefinition {
    /// Creates a new builder-style object to manufacture [`MetricDefinition`](crate::model::MetricDefinition)
    pub fn builder() -> crate::model::metric_definition::Builder {
        crate::model::metric_definition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TrainingJobStatus::Completed,
            "Failed" => TrainingJobStatus::Failed,
            "InProgress" => TrainingJobStatus::InProgress,
            "Stopped" => TrainingJobStatus::Stopped,
            "Stopping" => TrainingJobStatus::Stopping,
            other => TrainingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobStatus::from(s))
    }
}
impl TrainingJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobStatus::Completed => "Completed",
            TrainingJobStatus::Failed => "Failed",
            TrainingJobStatus::InProgress => "InProgress",
            TrainingJobStatus::Stopped => "Stopped",
            TrainingJobStatus::Stopping => "Stopping",
            TrainingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TrainingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the location that is configured for storing model artifacts. </p>
/// <p>Model artifacts are the output that results from training a model, and typically consist of trained parameters, a model definition that describes how to compute inferences, and other metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelArtifacts {
    /// <p>The path of the S3 object that contains the model artifacts. For example, <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
    pub s3_model_artifacts: std::option::Option<std::string::String>,
}
impl ModelArtifacts {
    /// <p>The path of the S3 object that contains the model artifacts. For example, <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
    pub fn s3_model_artifacts(&self) -> std::option::Option<&str> {
        self.s3_model_artifacts.as_deref()
    }
}
impl std::fmt::Debug for ModelArtifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelArtifacts");
        formatter.field("s3_model_artifacts", &self.s3_model_artifacts);
        formatter.finish()
    }
}
/// See [`ModelArtifacts`](crate::model::ModelArtifacts)
pub mod model_artifacts {

    /// A builder for [`ModelArtifacts`](crate::model::ModelArtifacts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_model_artifacts: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path of the S3 object that contains the model artifacts. For example, <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
        pub fn s3_model_artifacts(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_model_artifacts = Some(input.into());
            self
        }
        /// <p>The path of the S3 object that contains the model artifacts. For example, <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
        pub fn set_s3_model_artifacts(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_model_artifacts = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelArtifacts`](crate::model::ModelArtifacts)
        pub fn build(self) -> crate::model::ModelArtifacts {
            crate::model::ModelArtifacts {
                s3_model_artifacts: self.s3_model_artifacts,
            }
        }
    }
}
impl ModelArtifacts {
    /// Creates a new builder-style object to manufacture [`ModelArtifacts`](crate::model::ModelArtifacts)
    pub fn builder() -> crate::model::model_artifacts::Builder {
        crate::model::model_artifacts::Builder::default()
    }
}

/// <p>A summary of the metrics of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentMetricSummary {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>When the metric was last updated.</p>
    pub time_stamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum value of the metric.</p>
    pub max: std::option::Option<f64>,
    /// <p>The minimum value of the metric.</p>
    pub min: std::option::Option<f64>,
    /// <p>The most recent value of the metric.</p>
    pub last: std::option::Option<f64>,
    /// <p>The number of samples used to generate the metric.</p>
    pub count: std::option::Option<i32>,
    /// <p>The average value of the metric.</p>
    pub avg: std::option::Option<f64>,
    /// <p>The standard deviation of the metric.</p>
    pub std_dev: std::option::Option<f64>,
}
impl TrialComponentMetricSummary {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>When the metric was last updated.</p>
    pub fn time_stamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.time_stamp.as_ref()
    }
    /// <p>The maximum value of the metric.</p>
    pub fn max(&self) -> std::option::Option<f64> {
        self.max
    }
    /// <p>The minimum value of the metric.</p>
    pub fn min(&self) -> std::option::Option<f64> {
        self.min
    }
    /// <p>The most recent value of the metric.</p>
    pub fn last(&self) -> std::option::Option<f64> {
        self.last
    }
    /// <p>The number of samples used to generate the metric.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
    /// <p>The average value of the metric.</p>
    pub fn avg(&self) -> std::option::Option<f64> {
        self.avg
    }
    /// <p>The standard deviation of the metric.</p>
    pub fn std_dev(&self) -> std::option::Option<f64> {
        self.std_dev
    }
}
impl std::fmt::Debug for TrialComponentMetricSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentMetricSummary");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("source_arn", &self.source_arn);
        formatter.field("time_stamp", &self.time_stamp);
        formatter.field("max", &self.max);
        formatter.field("min", &self.min);
        formatter.field("last", &self.last);
        formatter.field("count", &self.count);
        formatter.field("avg", &self.avg);
        formatter.field("std_dev", &self.std_dev);
        formatter.finish()
    }
}
/// See [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
pub mod trial_component_metric_summary {

    /// A builder for [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) time_stamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) max: std::option::Option<f64>,
        pub(crate) min: std::option::Option<f64>,
        pub(crate) last: std::option::Option<f64>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) avg: std::option::Option<f64>,
        pub(crate) std_dev: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>When the metric was last updated.</p>
        pub fn time_stamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.time_stamp = Some(input);
            self
        }
        /// <p>When the metric was last updated.</p>
        pub fn set_time_stamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.time_stamp = input;
            self
        }
        /// <p>The maximum value of the metric.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The maximum value of the metric.</p>
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// <p>The minimum value of the metric.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The minimum value of the metric.</p>
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The most recent value of the metric.</p>
        pub fn last(mut self, input: f64) -> Self {
            self.last = Some(input);
            self
        }
        /// <p>The most recent value of the metric.</p>
        pub fn set_last(mut self, input: std::option::Option<f64>) -> Self {
            self.last = input;
            self
        }
        /// <p>The number of samples used to generate the metric.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of samples used to generate the metric.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The average value of the metric.</p>
        pub fn avg(mut self, input: f64) -> Self {
            self.avg = Some(input);
            self
        }
        /// <p>The average value of the metric.</p>
        pub fn set_avg(mut self, input: std::option::Option<f64>) -> Self {
            self.avg = input;
            self
        }
        /// <p>The standard deviation of the metric.</p>
        pub fn std_dev(mut self, input: f64) -> Self {
            self.std_dev = Some(input);
            self
        }
        /// <p>The standard deviation of the metric.</p>
        pub fn set_std_dev(mut self, input: std::option::Option<f64>) -> Self {
            self.std_dev = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
        pub fn build(self) -> crate::model::TrialComponentMetricSummary {
            crate::model::TrialComponentMetricSummary {
                metric_name: self.metric_name,
                source_arn: self.source_arn,
                time_stamp: self.time_stamp,
                max: self.max,
                min: self.min,
                last: self.last,
                count: self.count,
                avg: self.avg,
                std_dev: self.std_dev,
            }
        }
    }
}
impl TrialComponentMetricSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
    pub fn builder() -> crate::model::trial_component_metric_summary::Builder {
        crate::model::trial_component_metric_summary::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSource {
    /// <p>The source ARN.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source job type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl TrialComponentSource {
    /// <p>The source ARN.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The source job type.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
}
impl std::fmt::Debug for TrialComponentSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`TrialComponentSource`](crate::model::TrialComponentSource)
pub mod trial_component_source {

    /// A builder for [`TrialComponentSource`](crate::model::TrialComponentSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source ARN.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The source ARN.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source job type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source job type.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSource`](crate::model::TrialComponentSource)
        pub fn build(self) -> crate::model::TrialComponentSource {
            crate::model::TrialComponentSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl TrialComponentSource {
    /// Creates a new builder-style object to manufacture [`TrialComponentSource`](crate::model::TrialComponentSource)
    pub fn builder() -> crate::model::trial_component_source::Builder {
        crate::model::trial_component_source::Builder::default()
    }
}

/// <p>The properties of a trial as returned by the <code>Search</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Trial {
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub trial_arn: std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment the trial is part of.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The source of the trial.</p>
    pub source: std::option::Option<crate::model::TrialSource>,
    /// <p>When the trial was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who created the trial.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Who last modified the trial.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>The list of tags that are associated with the trial. You can use <code>Search</code> API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A list of the components associated with the trial. For each component, a summary of the component's properties is included.</p>
    pub trial_component_summaries:
        std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
}
impl Trial {
    /// <p>The name of the trial.</p>
    pub fn trial_name(&self) -> std::option::Option<&str> {
        self.trial_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub fn trial_arn(&self) -> std::option::Option<&str> {
        self.trial_arn.as_deref()
    }
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The name of the experiment the trial is part of.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
    /// <p>The source of the trial.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::TrialSource> {
        self.source.as_ref()
    }
    /// <p>When the trial was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Who created the trial.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>Who last modified the trial.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub fn metadata_properties(&self) -> std::option::Option<&crate::model::MetadataProperties> {
        self.metadata_properties.as_ref()
    }
    /// <p>The list of tags that are associated with the trial. You can use <code>Search</code> API to search on the tags.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>A list of the components associated with the trial. For each component, a summary of the component's properties is included.</p>
    pub fn trial_component_summaries(
        &self,
    ) -> std::option::Option<&[crate::model::TrialComponentSimpleSummary]> {
        self.trial_component_summaries.as_deref()
    }
}
impl std::fmt::Debug for Trial {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Trial");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("trial_arn", &self.trial_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("source", &self.source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.field("trial_component_summaries", &self.trial_component_summaries);
        formatter.finish()
    }
}
/// See [`Trial`](crate::model::Trial)
pub mod trial {

    /// A builder for [`Trial`](crate::model::Trial)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) trial_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::TrialSource>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) trial_component_summaries:
            std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
    }
    impl Builder {
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        /// <p>The name of the trial.</p>
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn trial_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn set_trial_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_arn = input;
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The name of the experiment the trial is part of.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment the trial is part of.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The source of the trial.</p>
        pub fn source(mut self, input: crate::model::TrialSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the trial.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::TrialSource>) -> Self {
            self.source = input;
            self
        }
        /// <p>When the trial was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the trial was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Who created the trial.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Who created the trial.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Who last modified the trial.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Who last modified the trial.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags that are associated with the trial. You can use <code>Search</code> API to search on the tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags that are associated with the trial. You can use <code>Search</code> API to search on the tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `trial_component_summaries`.
        ///
        /// To override the contents of this collection use [`set_trial_component_summaries`](Self::set_trial_component_summaries).
        ///
        /// <p>A list of the components associated with the trial. For each component, a summary of the component's properties is included.</p>
        pub fn trial_component_summaries(
            mut self,
            input: crate::model::TrialComponentSimpleSummary,
        ) -> Self {
            let mut v = self.trial_component_summaries.unwrap_or_default();
            v.push(input);
            self.trial_component_summaries = Some(v);
            self
        }
        /// <p>A list of the components associated with the trial. For each component, a summary of the component's properties is included.</p>
        pub fn set_trial_component_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
        ) -> Self {
            self.trial_component_summaries = input;
            self
        }
        /// Consumes the builder and constructs a [`Trial`](crate::model::Trial)
        pub fn build(self) -> crate::model::Trial {
            crate::model::Trial {
                trial_name: self.trial_name,
                trial_arn: self.trial_arn,
                display_name: self.display_name,
                experiment_name: self.experiment_name,
                source: self.source,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                metadata_properties: self.metadata_properties,
                tags: self.tags,
                trial_component_summaries: self.trial_component_summaries,
            }
        }
    }
}
impl Trial {
    /// Creates a new builder-style object to manufacture [`Trial`](crate::model::Trial)
    pub fn builder() -> crate::model::trial::Builder {
        crate::model::trial::Builder::default()
    }
}

/// <p>A short summary of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSimpleSummary {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
}
impl TrialComponentSimpleSummary {
    /// <p>The name of the trial component.</p>
    pub fn trial_component_name(&self) -> std::option::Option<&str> {
        self.trial_component_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub fn trial_component_arn(&self) -> std::option::Option<&str> {
        self.trial_component_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub fn trial_component_source(
        &self,
    ) -> std::option::Option<&crate::model::TrialComponentSource> {
        self.trial_component_source.as_ref()
    }
    /// <p>When the component was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
}
impl std::fmt::Debug for TrialComponentSimpleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSimpleSummary");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("trial_component_source", &self.trial_component_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.finish()
    }
}
/// See [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
pub mod trial_component_simple_summary {

    /// A builder for [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        /// <p>The name of the trial component.</p>
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn trial_component_source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.trial_component_source = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn set_trial_component_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.trial_component_source = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the component was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
        pub fn build(self) -> crate::model::TrialComponentSimpleSummary {
            crate::model::TrialComponentSimpleSummary {
                trial_component_name: self.trial_component_name,
                trial_component_arn: self.trial_component_arn,
                trial_component_source: self.trial_component_source,
                creation_time: self.creation_time,
                created_by: self.created_by,
            }
        }
    }
}
impl TrialComponentSimpleSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
    pub fn builder() -> crate::model::trial_component_simple_summary::Builder {
        crate::model::trial_component_simple_summary::Builder::default()
    }
}

/// <p>The source of the trial.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source job type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl TrialSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The source job type.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
}
impl std::fmt::Debug for TrialSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`TrialSource`](crate::model::TrialSource)
pub mod trial_source {

    /// A builder for [`TrialSource`](crate::model::TrialSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source job type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source job type.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialSource`](crate::model::TrialSource)
        pub fn build(self) -> crate::model::TrialSource {
            crate::model::TrialSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl TrialSource {
    /// Creates a new builder-style object to manufacture [`TrialSource`](crate::model::TrialSource)
    pub fn builder() -> crate::model::trial_source::Builder {
        crate::model::trial_source::Builder::default()
    }
}

/// <p>The properties of an experiment as returned by the <code>Search</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Experiment {
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub experiment_arn: std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the experiment.</p>
    pub source: std::option::Option<crate::model::ExperimentSource>,
    /// <p>The description of the experiment.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>When the experiment was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who created the experiment.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the experiment was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The list of tags that are associated with the experiment. You can use <code>Search</code> API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Experiment {
    /// <p>The name of the experiment.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub fn experiment_arn(&self) -> std::option::Option<&str> {
        self.experiment_arn.as_deref()
    }
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The source of the experiment.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::ExperimentSource> {
        self.source.as_ref()
    }
    /// <p>The description of the experiment.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>When the experiment was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Who created the experiment.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>When the experiment was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
    /// <p>The list of tags that are associated with the experiment. You can use <code>Search</code> API to search on the tags.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for Experiment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Experiment");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("source", &self.source);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Experiment`](crate::model::Experiment)
pub mod experiment {

    /// A builder for [`Experiment`](crate::model::Experiment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) experiment_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ExperimentSource>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn experiment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn set_experiment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_arn = input;
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn source(mut self, input: crate::model::ExperimentSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ExperimentSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The description of the experiment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the experiment.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Who created the experiment.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Who created the experiment.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags that are associated with the experiment. You can use <code>Search</code> API to search on the tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags that are associated with the experiment. You can use <code>Search</code> API to search on the tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Experiment`](crate::model::Experiment)
        pub fn build(self) -> crate::model::Experiment {
            crate::model::Experiment {
                experiment_name: self.experiment_name,
                experiment_arn: self.experiment_arn,
                display_name: self.display_name,
                source: self.source,
                description: self.description,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                tags: self.tags,
            }
        }
    }
}
impl Experiment {
    /// Creates a new builder-style object to manufacture [`Experiment`](crate::model::Experiment)
    pub fn builder() -> crate::model::experiment::Builder {
        crate::model::experiment::Builder::default()
    }
}

/// <p>The source of the experiment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl ExperimentSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The source type.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
}
impl std::fmt::Debug for ExperimentSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`ExperimentSource`](crate::model::ExperimentSource)
pub mod experiment_source {

    /// A builder for [`ExperimentSource`](crate::model::ExperimentSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentSource`](crate::model::ExperimentSource)
        pub fn build(self) -> crate::model::ExperimentSource {
            crate::model::ExperimentSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl ExperimentSource {
    /// Creates a new builder-style object to manufacture [`ExperimentSource`](crate::model::ExperimentSource)
    pub fn builder() -> crate::model::experiment_source::Builder {
        crate::model::experiment_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SearchSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SearchSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => SearchSortOrder::Ascending,
            "Descending" => SearchSortOrder::Descending,
            other => SearchSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SearchSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SearchSortOrder::from(s))
    }
}
impl SearchSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SearchSortOrder::Ascending => "Ascending",
            SearchSortOrder::Descending => "Descending",
            SearchSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for SearchSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A multi-expression that searches for the specified resource or resources in a search. All resource objects that satisfy the expression's condition are included in the search results. You must specify at least one subexpression, filter, or nested filter. A <code>SearchExpression</code> can contain up to twenty elements.</p>
/// <p>A <code>SearchExpression</code> contains the following components:</p>
/// <ul>
/// <li> <p>A list of <code>Filter</code> objects. Each filter defines a simple Boolean expression comprised of a resource property name, Boolean operator, and value.</p> </li>
/// <li> <p>A list of <code>NestedFilter</code> objects. Each nested filter defines a list of Boolean expressions using a list of resource properties. A nested filter is satisfied if a single object in the list satisfies all Boolean expressions.</p> </li>
/// <li> <p>A list of <code>SearchExpression</code> objects. A search expression object can be nested in a list of search expression objects.</p> </li>
/// <li> <p>A Boolean operator: <code>And</code> or <code>Or</code>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchExpression {
    /// <p>A list of filter objects.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>A list of nested filter objects.</p>
    pub nested_filters: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
    /// <p>A list of search expression objects.</p>
    pub sub_expressions: std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
    /// <p>A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify <code>And</code>. If only a single conditional statement needs to be true for the entire search expression to be true, specify <code>Or</code>. The default value is <code>And</code>.</p>
    pub operator: std::option::Option<crate::model::BooleanOperator>,
}
impl SearchExpression {
    /// <p>A list of filter objects.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>A list of nested filter objects.</p>
    pub fn nested_filters(&self) -> std::option::Option<&[crate::model::NestedFilters]> {
        self.nested_filters.as_deref()
    }
    /// <p>A list of search expression objects.</p>
    pub fn sub_expressions(&self) -> std::option::Option<&[crate::model::SearchExpression]> {
        self.sub_expressions.as_deref()
    }
    /// <p>A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify <code>And</code>. If only a single conditional statement needs to be true for the entire search expression to be true, specify <code>Or</code>. The default value is <code>And</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::BooleanOperator> {
        self.operator.as_ref()
    }
}
impl std::fmt::Debug for SearchExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchExpression");
        formatter.field("filters", &self.filters);
        formatter.field("nested_filters", &self.nested_filters);
        formatter.field("sub_expressions", &self.sub_expressions);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`SearchExpression`](crate::model::SearchExpression)
pub mod search_expression {

    /// A builder for [`SearchExpression`](crate::model::SearchExpression)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) nested_filters: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
        pub(crate) sub_expressions:
            std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
        pub(crate) operator: std::option::Option<crate::model::BooleanOperator>,
    }
    impl Builder {
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>A list of filter objects.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>A list of filter objects.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Appends an item to `nested_filters`.
        ///
        /// To override the contents of this collection use [`set_nested_filters`](Self::set_nested_filters).
        ///
        /// <p>A list of nested filter objects.</p>
        pub fn nested_filters(mut self, input: crate::model::NestedFilters) -> Self {
            let mut v = self.nested_filters.unwrap_or_default();
            v.push(input);
            self.nested_filters = Some(v);
            self
        }
        /// <p>A list of nested filter objects.</p>
        pub fn set_nested_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
        ) -> Self {
            self.nested_filters = input;
            self
        }
        /// Appends an item to `sub_expressions`.
        ///
        /// To override the contents of this collection use [`set_sub_expressions`](Self::set_sub_expressions).
        ///
        /// <p>A list of search expression objects.</p>
        pub fn sub_expressions(mut self, input: crate::model::SearchExpression) -> Self {
            let mut v = self.sub_expressions.unwrap_or_default();
            v.push(input);
            self.sub_expressions = Some(v);
            self
        }
        /// <p>A list of search expression objects.</p>
        pub fn set_sub_expressions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
        ) -> Self {
            self.sub_expressions = input;
            self
        }
        /// <p>A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify <code>And</code>. If only a single conditional statement needs to be true for the entire search expression to be true, specify <code>Or</code>. The default value is <code>And</code>.</p>
        pub fn operator(mut self, input: crate::model::BooleanOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify <code>And</code>. If only a single conditional statement needs to be true for the entire search expression to be true, specify <code>Or</code>. The default value is <code>And</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::BooleanOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchExpression`](crate::model::SearchExpression)
        pub fn build(self) -> crate::model::SearchExpression {
            crate::model::SearchExpression {
                filters: self.filters,
                nested_filters: self.nested_filters,
                sub_expressions: self.sub_expressions,
                operator: self.operator,
            }
        }
    }
}
impl SearchExpression {
    /// Creates a new builder-style object to manufacture [`SearchExpression`](crate::model::SearchExpression)
    pub fn builder() -> crate::model::search_expression::Builder {
        crate::model::search_expression::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BooleanOperator {
    #[allow(missing_docs)] // documentation missing in model
    And,
    #[allow(missing_docs)] // documentation missing in model
    Or,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BooleanOperator {
    fn from(s: &str) -> Self {
        match s {
            "And" => BooleanOperator::And,
            "Or" => BooleanOperator::Or,
            other => BooleanOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BooleanOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BooleanOperator::from(s))
    }
}
impl BooleanOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BooleanOperator::And => "And",
            BooleanOperator::Or => "Or",
            BooleanOperator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["And", "Or"]
    }
}
impl AsRef<str> for BooleanOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of nested <code>Filter</code> objects. A resource must satisfy the conditions of all filters to be included in the results returned from the <code>Search</code> API.</p>
/// <p>For example, to filter on a training job's <code>InputDataConfig</code> property with a specific channel name and <code>S3Uri</code> prefix, define the following filters:</p>
/// <ul>
/// <li> <p> <code>'{Name:"InputDataConfig.ChannelName", "Operator":"Equals", "Value":"train"}',</code> </p> </li>
/// <li> <p> <code>'{Name:"InputDataConfig.DataSource.S3DataSource.S3Uri", "Operator":"Contains", "Value":"mybucket/catdata"}'</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NestedFilters {
    /// <p>The name of the property to use in the nested filters. The value must match a listed property name, such as <code>InputDataConfig</code>.</p>
    pub nested_property_name: std::option::Option<std::string::String>,
    /// <p>A list of filters. Each filter acts on a property. Filters must contain at least one <code>Filters</code> value. For example, a <code>NestedFilters</code> call might include a filter on the <code>PropertyName</code> parameter of the <code>InputDataConfig</code> property: <code>InputDataConfig.DataSource.S3DataSource.S3Uri</code>.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
}
impl NestedFilters {
    /// <p>The name of the property to use in the nested filters. The value must match a listed property name, such as <code>InputDataConfig</code>.</p>
    pub fn nested_property_name(&self) -> std::option::Option<&str> {
        self.nested_property_name.as_deref()
    }
    /// <p>A list of filters. Each filter acts on a property. Filters must contain at least one <code>Filters</code> value. For example, a <code>NestedFilters</code> call might include a filter on the <code>PropertyName</code> parameter of the <code>InputDataConfig</code> property: <code>InputDataConfig.DataSource.S3DataSource.S3Uri</code>.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
}
impl std::fmt::Debug for NestedFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NestedFilters");
        formatter.field("nested_property_name", &self.nested_property_name);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}
/// See [`NestedFilters`](crate::model::NestedFilters)
pub mod nested_filters {

    /// A builder for [`NestedFilters`](crate::model::NestedFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) nested_property_name: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    }
    impl Builder {
        /// <p>The name of the property to use in the nested filters. The value must match a listed property name, such as <code>InputDataConfig</code>.</p>
        pub fn nested_property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.nested_property_name = Some(input.into());
            self
        }
        /// <p>The name of the property to use in the nested filters. The value must match a listed property name, such as <code>InputDataConfig</code>.</p>
        pub fn set_nested_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nested_property_name = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>A list of filters. Each filter acts on a property. Filters must contain at least one <code>Filters</code> value. For example, a <code>NestedFilters</code> call might include a filter on the <code>PropertyName</code> parameter of the <code>InputDataConfig</code> property: <code>InputDataConfig.DataSource.S3DataSource.S3Uri</code>.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>A list of filters. Each filter acts on a property. Filters must contain at least one <code>Filters</code> value. For example, a <code>NestedFilters</code> call might include a filter on the <code>PropertyName</code> parameter of the <code>InputDataConfig</code> property: <code>InputDataConfig.DataSource.S3DataSource.S3Uri</code>.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`NestedFilters`](crate::model::NestedFilters)
        pub fn build(self) -> crate::model::NestedFilters {
            crate::model::NestedFilters {
                nested_property_name: self.nested_property_name,
                filters: self.filters,
            }
        }
    }
}
impl NestedFilters {
    /// Creates a new builder-style object to manufacture [`NestedFilters`](crate::model::NestedFilters)
    pub fn builder() -> crate::model::nested_filters::Builder {
        crate::model::nested_filters::Builder::default()
    }
}

/// <p>A conditional statement for a search expression that includes a resource property, a Boolean operator, and a value. Resources that match the statement are returned in the results from the <code>Search</code> API.</p>
/// <p>If you specify a <code>Value</code>, but not an <code>Operator</code>, Amazon SageMaker uses the equals operator.</p>
/// <p>In search, there are several property types:</p>
/// <dl>
/// <dt>
/// Metrics
/// </dt>
/// <dd>
/// <p>To define a metric filter, enter a value using the form <code>"Metrics.
/// <name>
/// "
/// </name></code>, where <code>
/// <name></name></code> is a metric name. For example, the following filter searches for training jobs with an <code>"accuracy"</code> metric greater than <code>"0.9"</code>:</p>
/// <p> <code>{</code> </p>
/// <p> <code>"Name": "Metrics.accuracy",</code> </p>
/// <p> <code>"Operator": "GreaterThan",</code> </p>
/// <p> <code>"Value": "0.9"</code> </p>
/// <p> <code>}</code> </p>
/// </dd>
/// <dt>
/// HyperParameters
/// </dt>
/// <dd>
/// <p>To define a hyperparameter filter, enter a value with the form <code>"HyperParameters.
/// <name>
/// "
/// </name></code>. Decimal hyperparameter values are treated as a decimal in a comparison if the specified <code>Value</code> is also a decimal value. If the specified <code>Value</code> is an integer, the decimal hyperparameter values are treated as integers. For example, the following filter is satisfied by training jobs with a <code>"learning_rate"</code> hyperparameter that is less than <code>"0.5"</code>:</p>
/// <p> <code> {</code> </p>
/// <p> <code> "Name": "HyperParameters.learning_rate",</code> </p>
/// <p> <code> "Operator": "LessThan",</code> </p>
/// <p> <code> "Value": "0.5"</code> </p>
/// <p> <code> }</code> </p>
/// </dd>
/// <dt>
/// Tags
/// </dt>
/// <dd>
/// <p>To define a tag filter, enter a value with the form <code>Tags.
/// <key></key></code>.</p>
/// </dd>
/// </dl>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>A resource property name. For example, <code>TrainingJobName</code>. For valid property names, see <code>SearchRecord</code>. You must specify a valid property for the resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:</p>
    /// <dl>
    /// <dt>
    /// Equals
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
    /// </dd>
    /// <dt>
    /// NotEquals
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
    /// </dd>
    /// <dt>
    /// Exists
    /// </dt>
    /// <dd>
    /// <p>The <code>Name</code> property exists.</p>
    /// </dd>
    /// <dt>
    /// NotExists
    /// </dt>
    /// <dd>
    /// <p>The <code>Name</code> property does not exist.</p>
    /// </dd>
    /// <dt>
    /// GreaterThan
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// GreaterThanOrEqualTo
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// LessThan
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// LessThanOrEqualTo
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// In
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is one of the comma delimited strings in <code>Value</code>. Only supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// Contains
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> contains the string <code>Value</code>. Only supported for text properties.</p>
    /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator multiple times when the value of <code>Name</code> is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Experiment.DisplayName</code> </p> </li>
    /// <li> <p> <code>Experiment.ExperimentName</code> </p> </li>
    /// <li> <p> <code>Experiment.Tags</code> </p> </li>
    /// <li> <p> <code>Trial.DisplayName</code> </p> </li>
    /// <li> <p> <code>Trial.TrialName</code> </p> </li>
    /// <li> <p> <code>Trial.Tags</code> </p> </li>
    /// <li> <p> <code>TrialComponent.DisplayName</code> </p> </li>
    /// <li> <p> <code>TrialComponent.TrialComponentName</code> </p> </li>
    /// <li> <p> <code>TrialComponent.Tags</code> </p> </li>
    /// <li> <p> <code>TrialComponent.InputArtifacts</code> </p> </li>
    /// <li> <p> <code>TrialComponent.OutputArtifacts</code> </p> </li>
    /// </ul>
    /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator for all other values of <code>Name</code>. In these cases, if you include multiple <code>Contains</code> operators in the <code>SearchExpression</code>, the result is the following error message: "<code>'CONTAINS' operator usage limit of 1 exceeded.</code>"</p>
    /// </dd>
    /// </dl>
    pub operator: std::option::Option<crate::model::Operator>,
    /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which resources satisfy the filter's condition. For numerical properties, <code>Value</code> must be an integer or floating-point decimal. For timestamp properties, <code>Value</code> must be an ISO 8601 date-time string of the following format: <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Filter {
    /// <p>A resource property name. For example, <code>TrainingJobName</code>. For valid property names, see <code>SearchRecord</code>. You must specify a valid property for the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:</p>
    /// <dl>
    /// <dt>
    /// Equals
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
    /// </dd>
    /// <dt>
    /// NotEquals
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
    /// </dd>
    /// <dt>
    /// Exists
    /// </dt>
    /// <dd>
    /// <p>The <code>Name</code> property exists.</p>
    /// </dd>
    /// <dt>
    /// NotExists
    /// </dt>
    /// <dd>
    /// <p>The <code>Name</code> property does not exist.</p>
    /// </dd>
    /// <dt>
    /// GreaterThan
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// GreaterThanOrEqualTo
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// LessThan
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// LessThanOrEqualTo
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>. Not supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// In
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is one of the comma delimited strings in <code>Value</code>. Only supported for text properties.</p>
    /// </dd>
    /// <dt>
    /// Contains
    /// </dt>
    /// <dd>
    /// <p>The value of <code>Name</code> contains the string <code>Value</code>. Only supported for text properties.</p>
    /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator multiple times when the value of <code>Name</code> is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Experiment.DisplayName</code> </p> </li>
    /// <li> <p> <code>Experiment.ExperimentName</code> </p> </li>
    /// <li> <p> <code>Experiment.Tags</code> </p> </li>
    /// <li> <p> <code>Trial.DisplayName</code> </p> </li>
    /// <li> <p> <code>Trial.TrialName</code> </p> </li>
    /// <li> <p> <code>Trial.Tags</code> </p> </li>
    /// <li> <p> <code>TrialComponent.DisplayName</code> </p> </li>
    /// <li> <p> <code>TrialComponent.TrialComponentName</code> </p> </li>
    /// <li> <p> <code>TrialComponent.Tags</code> </p> </li>
    /// <li> <p> <code>TrialComponent.InputArtifacts</code> </p> </li>
    /// <li> <p> <code>TrialComponent.OutputArtifacts</code> </p> </li>
    /// </ul>
    /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator for all other values of <code>Name</code>. In these cases, if you include multiple <code>Contains</code> operators in the <code>SearchExpression</code>, the result is the following error message: "<code>'CONTAINS' operator usage limit of 1 exceeded.</code>"</p>
    /// </dd>
    /// </dl>
    pub fn operator(&self) -> std::option::Option<&crate::model::Operator> {
        self.operator.as_ref()
    }
    /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which resources satisfy the filter's condition. For numerical properties, <code>Value</code> must be an integer or floating-point decimal. For timestamp properties, <code>Value</code> must be an ISO 8601 date-time string of the following format: <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("operator", &self.operator);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A resource property name. For example, <code>TrainingJobName</code>. For valid property names, see <code>SearchRecord</code>. You must specify a valid property for the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A resource property name. For example, <code>TrainingJobName</code>. For valid property names, see <code>SearchRecord</code>. You must specify a valid property for the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:</p>
        /// <dl>
        /// <dt>
        /// Equals
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
        /// </dd>
        /// <dt>
        /// NotEquals
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
        /// </dd>
        /// <dt>
        /// Exists
        /// </dt>
        /// <dd>
        /// <p>The <code>Name</code> property exists.</p>
        /// </dd>
        /// <dt>
        /// NotExists
        /// </dt>
        /// <dd>
        /// <p>The <code>Name</code> property does not exist.</p>
        /// </dd>
        /// <dt>
        /// GreaterThan
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// GreaterThanOrEqualTo
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// LessThan
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// LessThanOrEqualTo
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// In
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is one of the comma delimited strings in <code>Value</code>. Only supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// Contains
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> contains the string <code>Value</code>. Only supported for text properties.</p>
        /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator multiple times when the value of <code>Name</code> is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Experiment.DisplayName</code> </p> </li>
        /// <li> <p> <code>Experiment.ExperimentName</code> </p> </li>
        /// <li> <p> <code>Experiment.Tags</code> </p> </li>
        /// <li> <p> <code>Trial.DisplayName</code> </p> </li>
        /// <li> <p> <code>Trial.TrialName</code> </p> </li>
        /// <li> <p> <code>Trial.Tags</code> </p> </li>
        /// <li> <p> <code>TrialComponent.DisplayName</code> </p> </li>
        /// <li> <p> <code>TrialComponent.TrialComponentName</code> </p> </li>
        /// <li> <p> <code>TrialComponent.Tags</code> </p> </li>
        /// <li> <p> <code>TrialComponent.InputArtifacts</code> </p> </li>
        /// <li> <p> <code>TrialComponent.OutputArtifacts</code> </p> </li>
        /// </ul>
        /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator for all other values of <code>Name</code>. In these cases, if you include multiple <code>Contains</code> operators in the <code>SearchExpression</code>, the result is the following error message: "<code>'CONTAINS' operator usage limit of 1 exceeded.</code>"</p>
        /// </dd>
        /// </dl>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:</p>
        /// <dl>
        /// <dt>
        /// Equals
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
        /// </dd>
        /// <dt>
        /// NotEquals
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
        /// </dd>
        /// <dt>
        /// Exists
        /// </dt>
        /// <dd>
        /// <p>The <code>Name</code> property exists.</p>
        /// </dd>
        /// <dt>
        /// NotExists
        /// </dt>
        /// <dd>
        /// <p>The <code>Name</code> property does not exist.</p>
        /// </dd>
        /// <dt>
        /// GreaterThan
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// GreaterThanOrEqualTo
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// LessThan
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// LessThanOrEqualTo
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>. Not supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// In
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is one of the comma delimited strings in <code>Value</code>. Only supported for text properties.</p>
        /// </dd>
        /// <dt>
        /// Contains
        /// </dt>
        /// <dd>
        /// <p>The value of <code>Name</code> contains the string <code>Value</code>. Only supported for text properties.</p>
        /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator multiple times when the value of <code>Name</code> is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Experiment.DisplayName</code> </p> </li>
        /// <li> <p> <code>Experiment.ExperimentName</code> </p> </li>
        /// <li> <p> <code>Experiment.Tags</code> </p> </li>
        /// <li> <p> <code>Trial.DisplayName</code> </p> </li>
        /// <li> <p> <code>Trial.TrialName</code> </p> </li>
        /// <li> <p> <code>Trial.Tags</code> </p> </li>
        /// <li> <p> <code>TrialComponent.DisplayName</code> </p> </li>
        /// <li> <p> <code>TrialComponent.TrialComponentName</code> </p> </li>
        /// <li> <p> <code>TrialComponent.Tags</code> </p> </li>
        /// <li> <p> <code>TrialComponent.InputArtifacts</code> </p> </li>
        /// <li> <p> <code>TrialComponent.OutputArtifacts</code> </p> </li>
        /// </ul>
        /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator for all other values of <code>Name</code>. In these cases, if you include multiple <code>Contains</code> operators in the <code>SearchExpression</code>, the result is the following error message: "<code>'CONTAINS' operator usage limit of 1 exceeded.</code>"</p>
        /// </dd>
        /// </dl>
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which resources satisfy the filter's condition. For numerical properties, <code>Value</code> must be an integer or floating-point decimal. For timestamp properties, <code>Value</code> must be an ISO 8601 date-time string of the following format: <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which resources satisfy the filter's condition. For numerical properties, <code>Value</code> must be an integer or floating-point decimal. For timestamp properties, <code>Value</code> must be an ISO 8601 date-time string of the following format: <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                operator: self.operator,
                value: self.value,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operator {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    Exists,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThan,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThanOrEqualTo,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    LessThan,
    #[allow(missing_docs)] // documentation missing in model
    LessThanOrEqualTo,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    #[allow(missing_docs)] // documentation missing in model
    NotExists,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Operator {
    fn from(s: &str) -> Self {
        match s {
            "Contains" => Operator::Contains,
            "Equals" => Operator::Equals,
            "Exists" => Operator::Exists,
            "GreaterThan" => Operator::GreaterThan,
            "GreaterThanOrEqualTo" => Operator::GreaterThanOrEqualTo,
            "In" => Operator::In,
            "LessThan" => Operator::LessThan,
            "LessThanOrEqualTo" => Operator::LessThanOrEqualTo,
            "NotEquals" => Operator::NotEquals,
            "NotExists" => Operator::NotExists,
            other => Operator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Operator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operator::from(s))
    }
}
impl Operator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Operator::Contains => "Contains",
            Operator::Equals => "Equals",
            Operator::Exists => "Exists",
            Operator::GreaterThan => "GreaterThan",
            Operator::GreaterThanOrEqualTo => "GreaterThanOrEqualTo",
            Operator::In => "In",
            Operator::LessThan => "LessThan",
            Operator::LessThanOrEqualTo => "LessThanOrEqualTo",
            Operator::NotEquals => "NotEquals",
            Operator::NotExists => "NotExists",
            Operator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Contains",
            "Equals",
            "Exists",
            "GreaterThan",
            "GreaterThanOrEqualTo",
            "In",
            "LessThan",
            "LessThanOrEqualTo",
            "NotEquals",
            "NotExists",
        ]
    }
}
impl AsRef<str> for Operator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Endpoint,
    #[allow(missing_docs)] // documentation missing in model
    Experiment,
    #[allow(missing_docs)] // documentation missing in model
    ExperimentTrial,
    #[allow(missing_docs)] // documentation missing in model
    ExperimentTrialComponent,
    #[allow(missing_docs)] // documentation missing in model
    FeatureGroup,
    #[allow(missing_docs)] // documentation missing in model
    ModelPackage,
    #[allow(missing_docs)] // documentation missing in model
    ModelPackageGroup,
    #[allow(missing_docs)] // documentation missing in model
    Pipeline,
    #[allow(missing_docs)] // documentation missing in model
    PipelineExecution,
    #[allow(missing_docs)] // documentation missing in model
    Project,
    #[allow(missing_docs)] // documentation missing in model
    TrainingJob,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "Endpoint" => ResourceType::Endpoint,
            "Experiment" => ResourceType::Experiment,
            "ExperimentTrial" => ResourceType::ExperimentTrial,
            "ExperimentTrialComponent" => ResourceType::ExperimentTrialComponent,
            "FeatureGroup" => ResourceType::FeatureGroup,
            "ModelPackage" => ResourceType::ModelPackage,
            "ModelPackageGroup" => ResourceType::ModelPackageGroup,
            "Pipeline" => ResourceType::Pipeline,
            "PipelineExecution" => ResourceType::PipelineExecution,
            "Project" => ResourceType::Project,
            "TrainingJob" => ResourceType::TrainingJob,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Endpoint => "Endpoint",
            ResourceType::Experiment => "Experiment",
            ResourceType::ExperimentTrial => "ExperimentTrial",
            ResourceType::ExperimentTrialComponent => "ExperimentTrialComponent",
            ResourceType::FeatureGroup => "FeatureGroup",
            ResourceType::ModelPackage => "ModelPackage",
            ResourceType::ModelPackageGroup => "ModelPackageGroup",
            ResourceType::Pipeline => "Pipeline",
            ResourceType::PipelineExecution => "PipelineExecution",
            ResourceType::Project => "Project",
            ResourceType::TrainingJob => "TrainingJob",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Endpoint",
            "Experiment",
            "ExperimentTrial",
            "ExperimentTrialComponent",
            "FeatureGroup",
            "ModelPackage",
            "ModelPackageGroup",
            "Pipeline",
            "PipelineExecution",
            "Project",
            "TrainingJob",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A description of an error that occurred while rendering the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderingError {
    /// <p>A unique identifier for a specific class of errors.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A human-readable message describing the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl RenderingError {
    /// <p>A unique identifier for a specific class of errors.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A human-readable message describing the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for RenderingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderingError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`RenderingError`](crate::model::RenderingError)
pub mod rendering_error {

    /// A builder for [`RenderingError`](crate::model::RenderingError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for a specific class of errors.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>A unique identifier for a specific class of errors.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A human-readable message describing the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A human-readable message describing the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RenderingError`](crate::model::RenderingError)
        pub fn build(self) -> crate::model::RenderingError {
            crate::model::RenderingError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl RenderingError {
    /// Creates a new builder-style object to manufacture [`RenderingError`](crate::model::RenderingError)
    pub fn builder() -> crate::model::rendering_error::Builder {
        crate::model::rendering_error::Builder::default()
    }
}

/// <p>Contains input values for a task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderableTask {
    /// <p>A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable <code>task.input</code>. For example, if you define a variable <code>task.input.text</code> in your template, you can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
    pub input: std::option::Option<std::string::String>,
}
impl RenderableTask {
    /// <p>A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable <code>task.input</code>. For example, if you define a variable <code>task.input.text</code> in your template, you can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
    pub fn input(&self) -> std::option::Option<&str> {
        self.input.as_deref()
    }
}
impl std::fmt::Debug for RenderableTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderableTask");
        formatter.field("input", &self.input);
        formatter.finish()
    }
}
/// See [`RenderableTask`](crate::model::RenderableTask)
pub mod renderable_task {

    /// A builder for [`RenderableTask`](crate::model::RenderableTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable <code>task.input</code>. For example, if you define a variable <code>task.input.text</code> in your template, you can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        /// <p>A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable <code>task.input</code>. For example, if you define a variable <code>task.input.text</code> in your template, you can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        /// Consumes the builder and constructs a [`RenderableTask`](crate::model::RenderableTask)
        pub fn build(self) -> crate::model::RenderableTask {
            crate::model::RenderableTask { input: self.input }
        }
    }
}
impl RenderableTask {
    /// Creates a new builder-style object to manufacture [`RenderableTask`](crate::model::RenderableTask)
    pub fn builder() -> crate::model::renderable_task::Builder {
        crate::model::renderable_task::Builder::default()
    }
}

/// <p>The Liquid template for the worker user interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiTemplate {
    /// <p>The content of the Liquid template for the worker user interface.</p>
    pub content: std::option::Option<std::string::String>,
}
impl UiTemplate {
    /// <p>The content of the Liquid template for the worker user interface.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl std::fmt::Debug for UiTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiTemplate");
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`UiTemplate`](crate::model::UiTemplate)
pub mod ui_template {

    /// A builder for [`UiTemplate`](crate::model::UiTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The content of the Liquid template for the worker user interface.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the Liquid template for the worker user interface.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`UiTemplate`](crate::model::UiTemplate)
        pub fn build(self) -> crate::model::UiTemplate {
            crate::model::UiTemplate {
                content: self.content,
            }
        }
    }
}
impl UiTemplate {
    /// Creates a new builder-style object to manufacture [`UiTemplate`](crate::model::UiTemplate)
    pub fn builder() -> crate::model::ui_template::Builder {
        crate::model::ui_template::Builder::default()
    }
}

/// <p>A directed edge connecting two lineage entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Edge {
    /// <p>The Amazon Resource Name (ARN) of the source lineage entity of the directed edge.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination lineage entity of the directed edge.</p>
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p>The type of the Association(Edge) between the source and destination. For example <code>ContributedTo</code>, <code>Produced</code>, or <code>DerivedFrom</code>.</p>
    pub association_type: std::option::Option<crate::model::AssociationEdgeType>,
}
impl Edge {
    /// <p>The Amazon Resource Name (ARN) of the source lineage entity of the directed edge.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the destination lineage entity of the directed edge.</p>
    pub fn destination_arn(&self) -> std::option::Option<&str> {
        self.destination_arn.as_deref()
    }
    /// <p>The type of the Association(Edge) between the source and destination. For example <code>ContributedTo</code>, <code>Produced</code>, or <code>DerivedFrom</code>.</p>
    pub fn association_type(&self) -> std::option::Option<&crate::model::AssociationEdgeType> {
        self.association_type.as_ref()
    }
}
impl std::fmt::Debug for Edge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Edge");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("association_type", &self.association_type);
        formatter.finish()
    }
}
/// See [`Edge`](crate::model::Edge)
pub mod edge {

    /// A builder for [`Edge`](crate::model::Edge)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) association_type: std::option::Option<crate::model::AssociationEdgeType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source lineage entity of the directed edge.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source lineage entity of the directed edge.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination lineage entity of the directed edge.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination lineage entity of the directed edge.</p>
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p>The type of the Association(Edge) between the source and destination. For example <code>ContributedTo</code>, <code>Produced</code>, or <code>DerivedFrom</code>.</p>
        pub fn association_type(mut self, input: crate::model::AssociationEdgeType) -> Self {
            self.association_type = Some(input);
            self
        }
        /// <p>The type of the Association(Edge) between the source and destination. For example <code>ContributedTo</code>, <code>Produced</code>, or <code>DerivedFrom</code>.</p>
        pub fn set_association_type(
            mut self,
            input: std::option::Option<crate::model::AssociationEdgeType>,
        ) -> Self {
            self.association_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Edge`](crate::model::Edge)
        pub fn build(self) -> crate::model::Edge {
            crate::model::Edge {
                source_arn: self.source_arn,
                destination_arn: self.destination_arn,
                association_type: self.association_type,
            }
        }
    }
}
impl Edge {
    /// Creates a new builder-style object to manufacture [`Edge`](crate::model::Edge)
    pub fn builder() -> crate::model::edge::Builder {
        crate::model::edge::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationEdgeType {
    #[allow(missing_docs)] // documentation missing in model
    AssociatedWith,
    #[allow(missing_docs)] // documentation missing in model
    ContributedTo,
    #[allow(missing_docs)] // documentation missing in model
    DerivedFrom,
    #[allow(missing_docs)] // documentation missing in model
    Produced,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationEdgeType {
    fn from(s: &str) -> Self {
        match s {
            "AssociatedWith" => AssociationEdgeType::AssociatedWith,
            "ContributedTo" => AssociationEdgeType::ContributedTo,
            "DerivedFrom" => AssociationEdgeType::DerivedFrom,
            "Produced" => AssociationEdgeType::Produced,
            other => AssociationEdgeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationEdgeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociationEdgeType::from(s))
    }
}
impl AssociationEdgeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssociationEdgeType::AssociatedWith => "AssociatedWith",
            AssociationEdgeType::ContributedTo => "ContributedTo",
            AssociationEdgeType::DerivedFrom => "DerivedFrom",
            AssociationEdgeType::Produced => "Produced",
            AssociationEdgeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AssociatedWith", "ContributedTo", "DerivedFrom", "Produced"]
    }
}
impl AsRef<str> for AssociationEdgeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A lineage entity connected to the starting entity(ies).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Vertex {
    /// <p>The Amazon Resource Name (ARN) of the lineage entity resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of the lineage entity resource. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, etc...</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The type of resource of the lineage entity.</p>
    pub lineage_type: std::option::Option<crate::model::LineageType>,
}
impl Vertex {
    /// <p>The Amazon Resource Name (ARN) of the lineage entity resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of the lineage entity resource. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, etc...</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The type of resource of the lineage entity.</p>
    pub fn lineage_type(&self) -> std::option::Option<&crate::model::LineageType> {
        self.lineage_type.as_ref()
    }
}
impl std::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Vertex");
        formatter.field("arn", &self.arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("lineage_type", &self.lineage_type);
        formatter.finish()
    }
}
/// See [`Vertex`](crate::model::Vertex)
pub mod vertex {

    /// A builder for [`Vertex`](crate::model::Vertex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) lineage_type: std::option::Option<crate::model::LineageType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the lineage entity resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lineage entity resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of the lineage entity resource. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, etc...</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the lineage entity resource. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, etc...</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The type of resource of the lineage entity.</p>
        pub fn lineage_type(mut self, input: crate::model::LineageType) -> Self {
            self.lineage_type = Some(input);
            self
        }
        /// <p>The type of resource of the lineage entity.</p>
        pub fn set_lineage_type(
            mut self,
            input: std::option::Option<crate::model::LineageType>,
        ) -> Self {
            self.lineage_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Vertex`](crate::model::Vertex)
        pub fn build(self) -> crate::model::Vertex {
            crate::model::Vertex {
                arn: self.arn,
                r#type: self.r#type,
                lineage_type: self.lineage_type,
            }
        }
    }
}
impl Vertex {
    /// Creates a new builder-style object to manufacture [`Vertex`](crate::model::Vertex)
    pub fn builder() -> crate::model::vertex::Builder {
        crate::model::vertex::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineageType {
    #[allow(missing_docs)] // documentation missing in model
    Action,
    #[allow(missing_docs)] // documentation missing in model
    Artifact,
    #[allow(missing_docs)] // documentation missing in model
    Context,
    #[allow(missing_docs)] // documentation missing in model
    TrialComponent,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LineageType {
    fn from(s: &str) -> Self {
        match s {
            "Action" => LineageType::Action,
            "Artifact" => LineageType::Artifact,
            "Context" => LineageType::Context,
            "TrialComponent" => LineageType::TrialComponent,
            other => LineageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LineageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineageType::from(s))
    }
}
impl LineageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineageType::Action => "Action",
            LineageType::Artifact => "Artifact",
            LineageType::Context => "Context",
            LineageType::TrialComponent => "TrialComponent",
            LineageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Action", "Artifact", "Context", "TrialComponent"]
    }
}
impl AsRef<str> for LineageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A set of filters to narrow the set of lineage entities connected to the <code>StartArn</code>(s) returned by the <code>QueryLineage</code> API action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryFilters {
    /// <p>Filter the lineage entities connected to the <code>StartArn</code> by type. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, or <code>ModelDeployment</code>.</p>
    pub types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by the type of the lineage entity.</p>
    pub lineage_types: std::option::Option<std::vec::Vec<crate::model::LineageType>>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by created date.</p>
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the create date.</p>
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) before the last modified date.</p>
    pub modified_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the last modified date.</p>
    pub modified_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by a set if property key value pairs. If multiple pairs are provided, an entity is included in the results if it matches any of the provided pairs.</p>
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl QueryFilters {
    /// <p>Filter the lineage entities connected to the <code>StartArn</code> by type. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, or <code>ModelDeployment</code>.</p>
    pub fn types(&self) -> std::option::Option<&[std::string::String]> {
        self.types.as_deref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by the type of the lineage entity.</p>
    pub fn lineage_types(&self) -> std::option::Option<&[crate::model::LineageType]> {
        self.lineage_types.as_deref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by created date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the create date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) before the last modified date.</p>
    pub fn modified_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.modified_before.as_ref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the last modified date.</p>
    pub fn modified_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.modified_after.as_ref()
    }
    /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by a set if property key value pairs. If multiple pairs are provided, an entity is included in the results if it matches any of the provided pairs.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.properties.as_ref()
    }
}
impl std::fmt::Debug for QueryFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryFilters");
        formatter.field("types", &self.types);
        formatter.field("lineage_types", &self.lineage_types);
        formatter.field("created_before", &self.created_before);
        formatter.field("created_after", &self.created_after);
        formatter.field("modified_before", &self.modified_before);
        formatter.field("modified_after", &self.modified_after);
        formatter.field("properties", &self.properties);
        formatter.finish()
    }
}
/// See [`QueryFilters`](crate::model::QueryFilters)
pub mod query_filters {

    /// A builder for [`QueryFilters`](crate::model::QueryFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) lineage_types: std::option::Option<std::vec::Vec<crate::model::LineageType>>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) modified_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) modified_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>Filter the lineage entities connected to the <code>StartArn</code> by type. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, or <code>ModelDeployment</code>.</p>
        pub fn types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input.into());
            self.types = Some(v);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code> by type. For example: <code>DataSet</code>, <code>Model</code>, <code>Endpoint</code>, or <code>ModelDeployment</code>.</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Appends an item to `lineage_types`.
        ///
        /// To override the contents of this collection use [`set_lineage_types`](Self::set_lineage_types).
        ///
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by the type of the lineage entity.</p>
        pub fn lineage_types(mut self, input: crate::model::LineageType) -> Self {
            let mut v = self.lineage_types.unwrap_or_default();
            v.push(input);
            self.lineage_types = Some(v);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by the type of the lineage entity.</p>
        pub fn set_lineage_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LineageType>>,
        ) -> Self {
            self.lineage_types = input;
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by created date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by created date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the create date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the create date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) before the last modified date.</p>
        pub fn modified_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.modified_before = Some(input);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) before the last modified date.</p>
        pub fn set_modified_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.modified_before = input;
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the last modified date.</p>
        pub fn modified_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.modified_after = Some(input);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) after the last modified date.</p>
        pub fn set_modified_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.modified_after = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by a set if property key value pairs. If multiple pairs are provided, an entity is included in the results if it matches any of the provided pairs.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.properties = Some(hash_map);
            self
        }
        /// <p>Filter the lineage entities connected to the <code>StartArn</code>(s) by a set if property key value pairs. If multiple pairs are provided, an entity is included in the results if it matches any of the provided pairs.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryFilters`](crate::model::QueryFilters)
        pub fn build(self) -> crate::model::QueryFilters {
            crate::model::QueryFilters {
                types: self.types,
                lineage_types: self.lineage_types,
                created_before: self.created_before,
                created_after: self.created_after,
                modified_before: self.modified_before,
                modified_after: self.modified_after,
                properties: self.properties,
            }
        }
    }
}
impl QueryFilters {
    /// Creates a new builder-style object to manufacture [`QueryFilters`](crate::model::QueryFilters)
    pub fn builder() -> crate::model::query_filters::Builder {
        crate::model::query_filters::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Direction {
    #[allow(missing_docs)] // documentation missing in model
    Ascendants,
    #[allow(missing_docs)] // documentation missing in model
    Both,
    #[allow(missing_docs)] // documentation missing in model
    Descendants,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Direction {
    fn from(s: &str) -> Self {
        match s {
            "Ascendants" => Direction::Ascendants,
            "Both" => Direction::Both,
            "Descendants" => Direction::Descendants,
            other => Direction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Direction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Direction::from(s))
    }
}
impl Direction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Direction::Ascendants => "Ascendants",
            Direction::Both => "Both",
            Direction::Descendants => "Descendants",
            Direction::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascendants", "Both", "Descendants"]
    }
}
impl AsRef<str> for Direction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => SortOrder::Ascending,
            "Descending" => SortOrder::Descending,
            other => SortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "Ascending",
            SortOrder::Descending => "Descending",
            SortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListWorkteamsSortByOptions {
    #[allow(missing_docs)] // documentation missing in model
    CreateDate,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListWorkteamsSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreateDate" => ListWorkteamsSortByOptions::CreateDate,
            "Name" => ListWorkteamsSortByOptions::Name,
            other => ListWorkteamsSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListWorkteamsSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListWorkteamsSortByOptions::from(s))
    }
}
impl ListWorkteamsSortByOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListWorkteamsSortByOptions::CreateDate => "CreateDate",
            ListWorkteamsSortByOptions::Name => "Name",
            ListWorkteamsSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreateDate", "Name"]
    }
}
impl AsRef<str> for ListWorkteamsSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListWorkforcesSortByOptions {
    #[allow(missing_docs)] // documentation missing in model
    CreateDate,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListWorkforcesSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreateDate" => ListWorkforcesSortByOptions::CreateDate,
            "Name" => ListWorkforcesSortByOptions::Name,
            other => ListWorkforcesSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListWorkforcesSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListWorkforcesSortByOptions::from(s))
    }
}
impl ListWorkforcesSortByOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListWorkforcesSortByOptions::CreateDate => "CreateDate",
            ListWorkforcesSortByOptions::Name => "Name",
            ListWorkforcesSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreateDate", "Name"]
    }
}
impl AsRef<str> for ListWorkforcesSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The user profile details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserProfileDetails {
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::UserProfileStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl UserProfileDetails {
    /// <p>The domain ID.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The user profile name.</p>
    pub fn user_profile_name(&self) -> std::option::Option<&str> {
        self.user_profile_name.as_deref()
    }
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::UserProfileStatus> {
        self.status.as_ref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last modified time.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for UserProfileDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserProfileDetails");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`UserProfileDetails`](crate::model::UserProfileDetails)
pub mod user_profile_details {

    /// A builder for [`UserProfileDetails`](crate::model::UserProfileDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::UserProfileStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The domain ID.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The user profile name.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        /// <p>The user profile name.</p>
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::UserProfileStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::UserProfileStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UserProfileDetails`](crate::model::UserProfileDetails)
        pub fn build(self) -> crate::model::UserProfileDetails {
            crate::model::UserProfileDetails {
                domain_id: self.domain_id,
                user_profile_name: self.user_profile_name,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl UserProfileDetails {
    /// Creates a new builder-style object to manufacture [`UserProfileDetails`](crate::model::UserProfileDetails)
    pub fn builder() -> crate::model::user_profile_details::Builder {
        crate::model::user_profile_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserProfileStatus {
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UserProfileStatus {
    fn from(s: &str) -> Self {
        match s {
            "Delete_Failed" => UserProfileStatus::DeleteFailed,
            "Deleting" => UserProfileStatus::Deleting,
            "Failed" => UserProfileStatus::Failed,
            "InService" => UserProfileStatus::InService,
            "Pending" => UserProfileStatus::Pending,
            "Update_Failed" => UserProfileStatus::UpdateFailed,
            "Updating" => UserProfileStatus::Updating,
            other => UserProfileStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UserProfileStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserProfileStatus::from(s))
    }
}
impl UserProfileStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserProfileStatus::DeleteFailed => "Delete_Failed",
            UserProfileStatus::Deleting => "Deleting",
            UserProfileStatus::Failed => "Failed",
            UserProfileStatus::InService => "InService",
            UserProfileStatus::Pending => "Pending",
            UserProfileStatus::UpdateFailed => "Update_Failed",
            UserProfileStatus::Updating => "Updating",
            UserProfileStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Delete_Failed",
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Update_Failed",
            "Updating",
        ]
    }
}
impl AsRef<str> for UserProfileStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserProfileSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UserProfileSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => UserProfileSortKey::CreationTime,
            "LastModifiedTime" => UserProfileSortKey::LastModifiedTime,
            other => UserProfileSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UserProfileSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserProfileSortKey::from(s))
    }
}
impl UserProfileSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserProfileSortKey::CreationTime => "CreationTime",
            UserProfileSortKey::LastModifiedTime => "LastModifiedTime",
            UserProfileSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime"]
    }
}
impl AsRef<str> for UserProfileSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of a trial. To get the complete set of properties, call the <code>DescribeTrial</code> API and provide the <code>TrialName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialSummary {
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub trial_arn: std::option::Option<std::string::String>,
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the trial.</p>
    pub trial_source: std::option::Option<crate::model::TrialSource>,
    /// <p>When the trial was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the trial was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TrialSummary {
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub fn trial_arn(&self) -> std::option::Option<&str> {
        self.trial_arn.as_deref()
    }
    /// <p>The name of the trial.</p>
    pub fn trial_name(&self) -> std::option::Option<&str> {
        self.trial_name.as_deref()
    }
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The source of the trial.</p>
    pub fn trial_source(&self) -> std::option::Option<&crate::model::TrialSource> {
        self.trial_source.as_ref()
    }
    /// <p>When the trial was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the trial was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for TrialSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialSummary");
        formatter.field("trial_arn", &self.trial_arn);
        formatter.field("trial_name", &self.trial_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_source", &self.trial_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`TrialSummary`](crate::model::TrialSummary)
pub mod trial_summary {

    /// A builder for [`TrialSummary`](crate::model::TrialSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_arn: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_source: std::option::Option<crate::model::TrialSource>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn trial_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn set_trial_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_arn = input;
            self
        }
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        /// <p>The name of the trial.</p>
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the trial.</p>
        pub fn trial_source(mut self, input: crate::model::TrialSource) -> Self {
            self.trial_source = Some(input);
            self
        }
        /// <p>The source of the trial.</p>
        pub fn set_trial_source(
            mut self,
            input: std::option::Option<crate::model::TrialSource>,
        ) -> Self {
            self.trial_source = input;
            self
        }
        /// <p>When the trial was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the trial was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the trial was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the trial was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialSummary`](crate::model::TrialSummary)
        pub fn build(self) -> crate::model::TrialSummary {
            crate::model::TrialSummary {
                trial_arn: self.trial_arn,
                trial_name: self.trial_name,
                display_name: self.display_name,
                trial_source: self.trial_source,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl TrialSummary {
    /// Creates a new builder-style object to manufacture [`TrialSummary`](crate::model::TrialSummary)
    pub fn builder() -> crate::model::trial_summary::Builder {
        crate::model::trial_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortTrialsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortTrialsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortTrialsBy::CreationTime,
            "Name" => SortTrialsBy::Name,
            other => SortTrialsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortTrialsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortTrialsBy::from(s))
    }
}
impl SortTrialsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortTrialsBy::CreationTime => "CreationTime",
            SortTrialsBy::Name => "Name",
            SortTrialsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortTrialsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of a trial component. To get all the properties, call the <code>DescribeTrialComponent</code> API and provide the <code>TrialComponentName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSummary {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>The status of the component. States include:</p>
    /// <ul>
    /// <li> <p>InProgress</p> </li>
    /// <li> <p>Completed</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the component ended.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who created the trial component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the component was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who last modified the component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl TrialComponentSummary {
    /// <p>The name of the trial component.</p>
    pub fn trial_component_name(&self) -> std::option::Option<&str> {
        self.trial_component_name.as_deref()
    }
    /// <p>The ARN of the trial component.</p>
    pub fn trial_component_arn(&self) -> std::option::Option<&str> {
        self.trial_component_arn.as_deref()
    }
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub fn trial_component_source(
        &self,
    ) -> std::option::Option<&crate::model::TrialComponentSource> {
        self.trial_component_source.as_ref()
    }
    /// <p>The status of the component. States include:</p>
    /// <ul>
    /// <li> <p>InProgress</p> </li>
    /// <li> <p>Completed</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::TrialComponentStatus> {
        self.status.as_ref()
    }
    /// <p>When the component started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>When the component ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>When the component was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Who created the trial component.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
    /// <p>When the component was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Who last modified the component.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.last_modified_by.as_ref()
    }
}
impl std::fmt::Debug for TrialComponentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSummary");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_component_source", &self.trial_component_source);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}
/// See [`TrialComponentSummary`](crate::model::TrialComponentSummary)
pub mod trial_component_summary {

    /// A builder for [`TrialComponentSummary`](crate::model::TrialComponentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) status: std::option::Option<crate::model::TrialComponentStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        /// <p>The name of the trial component.</p>
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The ARN of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the trial component.</p>
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn trial_component_source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.trial_component_source = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn set_trial_component_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.trial_component_source = input;
            self
        }
        /// <p>The status of the component. States include:</p>
        /// <ul>
        /// <li> <p>InProgress</p> </li>
        /// <li> <p>Completed</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::TrialComponentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the component. States include:</p>
        /// <ul>
        /// <li> <p>InProgress</p> </li>
        /// <li> <p>Completed</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the component started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>When the component started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the component ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>When the component ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the component was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Who created the trial component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Who created the trial component.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Who last modified the component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        /// <p>Who last modified the component.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSummary`](crate::model::TrialComponentSummary)
        pub fn build(self) -> crate::model::TrialComponentSummary {
            crate::model::TrialComponentSummary {
                trial_component_name: self.trial_component_name,
                trial_component_arn: self.trial_component_arn,
                display_name: self.display_name,
                trial_component_source: self.trial_component_source,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
            }
        }
    }
}
impl TrialComponentSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentSummary`](crate::model::TrialComponentSummary)
    pub fn builder() -> crate::model::trial_component_summary::Builder {
        crate::model::trial_component_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortTrialComponentsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortTrialComponentsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortTrialComponentsBy::CreationTime,
            "Name" => SortTrialComponentsBy::Name,
            other => SortTrialComponentsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortTrialComponentsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortTrialComponentsBy::from(s))
    }
}
impl SortTrialComponentsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortTrialComponentsBy::CreationTime => "CreationTime",
            SortTrialComponentsBy::Name => "Name",
            SortTrialComponentsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortTrialComponentsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of a transform job. Multiple <code>TransformJobSummary</code> objects are returned as a list after in response to a <code>ListTransformJobs</code> call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobSummary {
    /// <p>The name of the transform job.</p>
    pub transform_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub transform_job_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.</p>
    pub transform_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates when the transform job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the transform job.</p>
    pub transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
    /// <p>If the transform job failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl TransformJobSummary {
    /// <p>The name of the transform job.</p>
    pub fn transform_job_name(&self) -> std::option::Option<&str> {
        self.transform_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub fn transform_job_arn(&self) -> std::option::Option<&str> {
        self.transform_job_arn.as_deref()
    }
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.</p>
    pub fn transform_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.transform_end_time.as_ref()
    }
    /// <p>Indicates when the transform job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the transform job.</p>
    pub fn transform_job_status(&self) -> std::option::Option<&crate::model::TransformJobStatus> {
        self.transform_job_status.as_ref()
    }
    /// <p>If the transform job failed, the reason it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for TransformJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobSummary");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("transform_end_time", &self.transform_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("transform_job_status", &self.transform_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`TransformJobSummary`](crate::model::TransformJobSummary)
pub mod transform_job_summary {

    /// A builder for [`TransformJobSummary`](crate::model::TransformJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_job_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) transform_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the transform job.</p>
        pub fn transform_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_name = Some(input.into());
            self
        }
        /// <p>The name of the transform job.</p>
        pub fn set_transform_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn transform_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn set_transform_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_arn = input;
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.</p>
        pub fn transform_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.transform_end_time = Some(input);
            self
        }
        /// <p>Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.</p>
        pub fn set_transform_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.transform_end_time = input;
            self
        }
        /// <p>Indicates when the transform job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Indicates when the transform job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the transform job.</p>
        pub fn transform_job_status(mut self, input: crate::model::TransformJobStatus) -> Self {
            self.transform_job_status = Some(input);
            self
        }
        /// <p>The status of the transform job.</p>
        pub fn set_transform_job_status(
            mut self,
            input: std::option::Option<crate::model::TransformJobStatus>,
        ) -> Self {
            self.transform_job_status = input;
            self
        }
        /// <p>If the transform job failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the transform job failed, the reason it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobSummary`](crate::model::TransformJobSummary)
        pub fn build(self) -> crate::model::TransformJobSummary {
            crate::model::TransformJobSummary {
                transform_job_name: self.transform_job_name,
                transform_job_arn: self.transform_job_arn,
                creation_time: self.creation_time,
                transform_end_time: self.transform_end_time,
                last_modified_time: self.last_modified_time,
                transform_job_status: self.transform_job_status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl TransformJobSummary {
    /// Creates a new builder-style object to manufacture [`TransformJobSummary`](crate::model::TransformJobSummary)
    pub fn builder() -> crate::model::transform_job_summary::Builder {
        crate::model::transform_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortBy::CreationTime,
            "Name" => SortBy::Name,
            "Status" => SortBy::Status,
            other => SortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortBy::from(s))
    }
}
impl SortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortBy::CreationTime => "CreationTime",
            SortBy::Name => "Name",
            SortBy::Status => "Status",
            SortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for SortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The container for the summary information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTrainingJobSummary {
    /// <p>The training job definition name.</p>
    pub training_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The name of the training job.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>The HyperParameter tuning job that launched the training job.</p>
    pub tuning_job_name: std::option::Option<std::string::String>,
    /// <p>The date and time that the training job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the training job started.</p>
    pub training_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specifies the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
    pub training_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the training job.</p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    /// <p>A list of the hyperparameters for which you specified ranges to search.</p>
    pub tuned_hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The reason that the training job failed. </p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The <code>FinalHyperParameterTuningJobObjectiveMetric</code> object that specifies the value of the objective metric of the tuning job that launched this training job.</p>
    pub final_hyper_parameter_tuning_job_objective_metric:
        std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
    /// <p>The status of the objective metric for the training job:</p>
    /// <ul>
    /// <li> <p>Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p>Pending: The training job is in progress and evaluation of its final objective metric is pending.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p>Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p> </li>
    /// </ul>
    pub objective_status: std::option::Option<crate::model::ObjectiveStatus>,
}
impl HyperParameterTrainingJobSummary {
    /// <p>The training job definition name.</p>
    pub fn training_job_definition_name(&self) -> std::option::Option<&str> {
        self.training_job_definition_name.as_deref()
    }
    /// <p>The name of the training job.</p>
    pub fn training_job_name(&self) -> std::option::Option<&str> {
        self.training_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub fn training_job_arn(&self) -> std::option::Option<&str> {
        self.training_job_arn.as_deref()
    }
    /// <p>The HyperParameter tuning job that launched the training job.</p>
    pub fn tuning_job_name(&self) -> std::option::Option<&str> {
        self.tuning_job_name.as_deref()
    }
    /// <p>The date and time that the training job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time that the training job started.</p>
    pub fn training_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_start_time.as_ref()
    }
    /// <p>Specifies the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
    pub fn training_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_end_time.as_ref()
    }
    /// <p>The status of the training job.</p>
    pub fn training_job_status(&self) -> std::option::Option<&crate::model::TrainingJobStatus> {
        self.training_job_status.as_ref()
    }
    /// <p>A list of the hyperparameters for which you specified ranges to search.</p>
    pub fn tuned_hyper_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tuned_hyper_parameters.as_ref()
    }
    /// <p>The reason that the training job failed. </p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The <code>FinalHyperParameterTuningJobObjectiveMetric</code> object that specifies the value of the objective metric of the tuning job that launched this training job.</p>
    pub fn final_hyper_parameter_tuning_job_objective_metric(
        &self,
    ) -> std::option::Option<&crate::model::FinalHyperParameterTuningJobObjectiveMetric> {
        self.final_hyper_parameter_tuning_job_objective_metric
            .as_ref()
    }
    /// <p>The status of the objective metric for the training job:</p>
    /// <ul>
    /// <li> <p>Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p>Pending: The training job is in progress and evaluation of its final objective metric is pending.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p>Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p> </li>
    /// </ul>
    pub fn objective_status(&self) -> std::option::Option<&crate::model::ObjectiveStatus> {
        self.objective_status.as_ref()
    }
}
impl std::fmt::Debug for HyperParameterTrainingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTrainingJobSummary");
        formatter.field(
            "training_job_definition_name",
            &self.training_job_definition_name,
        );
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tuning_job_name", &self.tuning_job_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.field("tuned_hyper_parameters", &self.tuned_hyper_parameters);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field(
            "final_hyper_parameter_tuning_job_objective_metric",
            &self.final_hyper_parameter_tuning_job_objective_metric,
        );
        formatter.field("objective_status", &self.objective_status);
        formatter.finish()
    }
}
/// See [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
pub mod hyper_parameter_training_job_summary {

    /// A builder for [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tuning_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
        pub(crate) tuned_hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) final_hyper_parameter_tuning_job_objective_metric:
            std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
        pub(crate) objective_status: std::option::Option<crate::model::ObjectiveStatus>,
    }
    impl Builder {
        /// <p>The training job definition name.</p>
        pub fn training_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.training_job_definition_name = Some(input.into());
            self
        }
        /// <p>The training job definition name.</p>
        pub fn set_training_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_definition_name = input;
            self
        }
        /// <p>The name of the training job.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        /// <p>The name of the training job.</p>
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>The HyperParameter tuning job that launched the training job.</p>
        pub fn tuning_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_job_name = Some(input.into());
            self
        }
        /// <p>The HyperParameter tuning job that launched the training job.</p>
        pub fn set_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_job_name = input;
            self
        }
        /// <p>The date and time that the training job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time that the training job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the training job started.</p>
        pub fn training_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_start_time = Some(input);
            self
        }
        /// <p>The date and time that the training job started.</p>
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>Specifies the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
        pub fn training_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_end_time = Some(input);
            self
        }
        /// <p>Specifies the time when the training job ends on training instances. You are billed for the time interval between the value of <code>TrainingStartTime</code> and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.</p>
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>The status of the training job.</p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        /// <p>The status of the training job.</p>
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        /// Adds a key-value pair to `tuned_hyper_parameters`.
        ///
        /// To override the contents of this collection use [`set_tuned_hyper_parameters`](Self::set_tuned_hyper_parameters).
        ///
        /// <p>A list of the hyperparameters for which you specified ranges to search.</p>
        pub fn tuned_hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tuned_hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tuned_hyper_parameters = Some(hash_map);
            self
        }
        /// <p>A list of the hyperparameters for which you specified ranges to search.</p>
        pub fn set_tuned_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tuned_hyper_parameters = input;
            self
        }
        /// <p>The reason that the training job failed. </p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason that the training job failed. </p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The <code>FinalHyperParameterTuningJobObjectiveMetric</code> object that specifies the value of the objective metric of the tuning job that launched this training job.</p>
        pub fn final_hyper_parameter_tuning_job_objective_metric(
            mut self,
            input: crate::model::FinalHyperParameterTuningJobObjectiveMetric,
        ) -> Self {
            self.final_hyper_parameter_tuning_job_objective_metric = Some(input);
            self
        }
        /// <p>The <code>FinalHyperParameterTuningJobObjectiveMetric</code> object that specifies the value of the objective metric of the tuning job that launched this training job.</p>
        pub fn set_final_hyper_parameter_tuning_job_objective_metric(
            mut self,
            input: std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
        ) -> Self {
            self.final_hyper_parameter_tuning_job_objective_metric = input;
            self
        }
        /// <p>The status of the objective metric for the training job:</p>
        /// <ul>
        /// <li> <p>Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p>Pending: The training job is in progress and evaluation of its final objective metric is pending.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p>Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p> </li>
        /// </ul>
        pub fn objective_status(mut self, input: crate::model::ObjectiveStatus) -> Self {
            self.objective_status = Some(input);
            self
        }
        /// <p>The status of the objective metric for the training job:</p>
        /// <ul>
        /// <li> <p>Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p>Pending: The training job is in progress and evaluation of its final objective metric is pending.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p>Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p> </li>
        /// </ul>
        pub fn set_objective_status(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatus>,
        ) -> Self {
            self.objective_status = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
        pub fn build(self) -> crate::model::HyperParameterTrainingJobSummary {
            crate::model::HyperParameterTrainingJobSummary {
                training_job_definition_name: self.training_job_definition_name,
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                tuning_job_name: self.tuning_job_name,
                creation_time: self.creation_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                training_job_status: self.training_job_status,
                tuned_hyper_parameters: self.tuned_hyper_parameters,
                failure_reason: self.failure_reason,
                final_hyper_parameter_tuning_job_objective_metric: self
                    .final_hyper_parameter_tuning_job_objective_metric,
                objective_status: self.objective_status,
            }
        }
    }
}
impl HyperParameterTrainingJobSummary {
    /// Creates a new builder-style object to manufacture [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
    pub fn builder() -> crate::model::hyper_parameter_training_job_summary::Builder {
        crate::model::hyper_parameter_training_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ObjectiveStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ObjectiveStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ObjectiveStatus::Failed,
            "Pending" => ObjectiveStatus::Pending,
            "Succeeded" => ObjectiveStatus::Succeeded,
            other => ObjectiveStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ObjectiveStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ObjectiveStatus::from(s))
    }
}
impl ObjectiveStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ObjectiveStatus::Failed => "Failed",
            ObjectiveStatus::Pending => "Pending",
            ObjectiveStatus::Succeeded => "Succeeded",
            ObjectiveStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Failed", "Pending", "Succeeded"]
    }
}
impl AsRef<str> for ObjectiveStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Shows the final value for the objective metric for a training job that was launched by a hyperparameter tuning job. You define the objective metric in the <code>HyperParameterTuningJobObjective</code> parameter of <code>HyperParameterTuningJobConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinalHyperParameterTuningJobObjectiveMetric {
    /// <p>Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.</p>
    pub r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
    /// <p>The name of the objective metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The value of the objective metric.</p>
    pub value: f32,
}
impl FinalHyperParameterTuningJobObjectiveMetric {
    /// <p>Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.</p>
    pub fn r#type(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobObjectiveType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the objective metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The value of the objective metric.</p>
    pub fn value(&self) -> f32 {
        self.value
    }
}
impl std::fmt::Debug for FinalHyperParameterTuningJobObjectiveMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinalHyperParameterTuningJobObjectiveMetric");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
pub mod final_hyper_parameter_tuning_job_objective_metric {

    /// A builder for [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.</p>
        pub fn r#type(mut self, input: crate::model::HyperParameterTuningJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the objective metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the objective metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the objective metric.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the objective metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
        pub fn build(self) -> crate::model::FinalHyperParameterTuningJobObjectiveMetric {
            crate::model::FinalHyperParameterTuningJobObjectiveMetric {
                r#type: self.r#type,
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl FinalHyperParameterTuningJobObjectiveMetric {
    /// Creates a new builder-style object to manufacture [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
    pub fn builder() -> crate::model::final_hyper_parameter_tuning_job_objective_metric::Builder {
        crate::model::final_hyper_parameter_tuning_job_objective_metric::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobObjectiveType {
    #[allow(missing_docs)] // documentation missing in model
    Maximize,
    #[allow(missing_docs)] // documentation missing in model
    Minimize,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobObjectiveType {
    fn from(s: &str) -> Self {
        match s {
            "Maximize" => HyperParameterTuningJobObjectiveType::Maximize,
            "Minimize" => HyperParameterTuningJobObjectiveType::Minimize,
            other => HyperParameterTuningJobObjectiveType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobObjectiveType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobObjectiveType::from(s))
    }
}
impl HyperParameterTuningJobObjectiveType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobObjectiveType::Maximize => "Maximize",
            HyperParameterTuningJobObjectiveType::Minimize => "Minimize",
            HyperParameterTuningJobObjectiveType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Maximize", "Minimize"]
    }
}
impl AsRef<str> for HyperParameterTuningJobObjectiveType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobSortByOptions {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    FinalObjectiveMetricValue,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => TrainingJobSortByOptions::CreationTime,
            "FinalObjectiveMetricValue" => TrainingJobSortByOptions::FinalObjectiveMetricValue,
            "Name" => TrainingJobSortByOptions::Name,
            "Status" => TrainingJobSortByOptions::Status,
            other => TrainingJobSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobSortByOptions::from(s))
    }
}
impl TrainingJobSortByOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobSortByOptions::CreationTime => "CreationTime",
            TrainingJobSortByOptions::FinalObjectiveMetricValue => "FinalObjectiveMetricValue",
            TrainingJobSortByOptions::Name => "Name",
            TrainingJobSortByOptions::Status => "Status",
            TrainingJobSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "FinalObjectiveMetricValue",
            "Name",
            "Status",
        ]
    }
}
impl AsRef<str> for TrainingJobSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobSummary {
    /// <p>The name of the training job that you want a summary for.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the training job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (<code>Completed</code>, <code>Failed</code>, or <code>Stopped</code>). </p>
    pub training_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> Timestamp when the training job was last modified. </p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the training job.</p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
}
impl TrainingJobSummary {
    /// <p>The name of the training job that you want a summary for.</p>
    pub fn training_job_name(&self) -> std::option::Option<&str> {
        self.training_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub fn training_job_arn(&self) -> std::option::Option<&str> {
        self.training_job_arn.as_deref()
    }
    /// <p>A timestamp that shows when the training job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (<code>Completed</code>, <code>Failed</code>, or <code>Stopped</code>). </p>
    pub fn training_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_end_time.as_ref()
    }
    /// <p> Timestamp when the training job was last modified. </p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the training job.</p>
    pub fn training_job_status(&self) -> std::option::Option<&crate::model::TrainingJobStatus> {
        self.training_job_status.as_ref()
    }
}
impl std::fmt::Debug for TrainingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobSummary");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.finish()
    }
}
/// See [`TrainingJobSummary`](crate::model::TrainingJobSummary)
pub mod training_job_summary {

    /// A builder for [`TrainingJobSummary`](crate::model::TrainingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    }
    impl Builder {
        /// <p>The name of the training job that you want a summary for.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        /// <p>The name of the training job that you want a summary for.</p>
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>A timestamp that shows when the training job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the training job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (<code>Completed</code>, <code>Failed</code>, or <code>Stopped</code>). </p>
        pub fn training_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_end_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (<code>Completed</code>, <code>Failed</code>, or <code>Stopped</code>). </p>
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p> Timestamp when the training job was last modified. </p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p> Timestamp when the training job was last modified. </p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the training job.</p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        /// <p>The status of the training job.</p>
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobSummary`](crate::model::TrainingJobSummary)
        pub fn build(self) -> crate::model::TrainingJobSummary {
            crate::model::TrainingJobSummary {
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                creation_time: self.creation_time,
                training_end_time: self.training_end_time,
                last_modified_time: self.last_modified_time,
                training_job_status: self.training_job_status,
            }
        }
    }
}
impl TrainingJobSummary {
    /// Creates a new builder-style object to manufacture [`TrainingJobSummary`](crate::model::TrainingJobSummary)
    pub fn builder() -> crate::model::training_job_summary::Builder {
        crate::model::training_job_summary::Builder::default()
    }
}

/// <p>Describes a work team of a vendor that does the a labelling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscribedWorkteam {
    /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
    pub marketplace_title: std::option::Option<std::string::String>,
    /// <p>The name of the vendor in the Amazon Marketplace.</p>
    pub seller_name: std::option::Option<std::string::String>,
    /// <p>The description of the vendor from the Amazon Marketplace.</p>
    pub marketplace_description: std::option::Option<std::string::String>,
    /// <p>Marketplace product listing ID.</p>
    pub listing_id: std::option::Option<std::string::String>,
}
impl SubscribedWorkteam {
    /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
    pub fn workteam_arn(&self) -> std::option::Option<&str> {
        self.workteam_arn.as_deref()
    }
    /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
    pub fn marketplace_title(&self) -> std::option::Option<&str> {
        self.marketplace_title.as_deref()
    }
    /// <p>The name of the vendor in the Amazon Marketplace.</p>
    pub fn seller_name(&self) -> std::option::Option<&str> {
        self.seller_name.as_deref()
    }
    /// <p>The description of the vendor from the Amazon Marketplace.</p>
    pub fn marketplace_description(&self) -> std::option::Option<&str> {
        self.marketplace_description.as_deref()
    }
    /// <p>Marketplace product listing ID.</p>
    pub fn listing_id(&self) -> std::option::Option<&str> {
        self.listing_id.as_deref()
    }
}
impl std::fmt::Debug for SubscribedWorkteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscribedWorkteam");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("marketplace_title", &self.marketplace_title);
        formatter.field("seller_name", &self.seller_name);
        formatter.field("marketplace_description", &self.marketplace_description);
        formatter.field("listing_id", &self.listing_id);
        formatter.finish()
    }
}
/// See [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
pub mod subscribed_workteam {

    /// A builder for [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) marketplace_title: std::option::Option<std::string::String>,
        pub(crate) seller_name: std::option::Option<std::string::String>,
        pub(crate) marketplace_description: std::option::Option<std::string::String>,
        pub(crate) listing_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
        pub fn marketplace_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.marketplace_title = Some(input.into());
            self
        }
        /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
        pub fn set_marketplace_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.marketplace_title = input;
            self
        }
        /// <p>The name of the vendor in the Amazon Marketplace.</p>
        pub fn seller_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.seller_name = Some(input.into());
            self
        }
        /// <p>The name of the vendor in the Amazon Marketplace.</p>
        pub fn set_seller_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.seller_name = input;
            self
        }
        /// <p>The description of the vendor from the Amazon Marketplace.</p>
        pub fn marketplace_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.marketplace_description = Some(input.into());
            self
        }
        /// <p>The description of the vendor from the Amazon Marketplace.</p>
        pub fn set_marketplace_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.marketplace_description = input;
            self
        }
        /// <p>Marketplace product listing ID.</p>
        pub fn listing_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.listing_id = Some(input.into());
            self
        }
        /// <p>Marketplace product listing ID.</p>
        pub fn set_listing_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.listing_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
        pub fn build(self) -> crate::model::SubscribedWorkteam {
            crate::model::SubscribedWorkteam {
                workteam_arn: self.workteam_arn,
                marketplace_title: self.marketplace_title,
                seller_name: self.seller_name,
                marketplace_description: self.marketplace_description,
                listing_id: self.listing_id,
            }
        }
    }
}
impl SubscribedWorkteam {
    /// Creates a new builder-style object to manufacture [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
    pub fn builder() -> crate::model::subscribed_workteam::Builder {
        crate::model::subscribed_workteam::Builder::default()
    }
}

/// <p>Details of the Studio Lifecycle Configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioLifecycleConfigDetails {
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration.</p>
    pub studio_lifecycle_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Studio Lifecycle Configuration.</p>
    pub studio_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The creation time of the Studio Lifecycle Configuration.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The App type to which the Lifecycle Configuration is attached.</p>
    pub studio_lifecycle_config_app_type:
        std::option::Option<crate::model::StudioLifecycleConfigAppType>,
}
impl StudioLifecycleConfigDetails {
    /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration.</p>
    pub fn studio_lifecycle_config_arn(&self) -> std::option::Option<&str> {
        self.studio_lifecycle_config_arn.as_deref()
    }
    /// <p>The name of the Studio Lifecycle Configuration.</p>
    pub fn studio_lifecycle_config_name(&self) -> std::option::Option<&str> {
        self.studio_lifecycle_config_name.as_deref()
    }
    /// <p>The creation time of the Studio Lifecycle Configuration.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The App type to which the Lifecycle Configuration is attached.</p>
    pub fn studio_lifecycle_config_app_type(
        &self,
    ) -> std::option::Option<&crate::model::StudioLifecycleConfigAppType> {
        self.studio_lifecycle_config_app_type.as_ref()
    }
}
impl std::fmt::Debug for StudioLifecycleConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioLifecycleConfigDetails");
        formatter.field(
            "studio_lifecycle_config_arn",
            &self.studio_lifecycle_config_arn,
        );
        formatter.field(
            "studio_lifecycle_config_name",
            &self.studio_lifecycle_config_name,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "studio_lifecycle_config_app_type",
            &self.studio_lifecycle_config_app_type,
        );
        formatter.finish()
    }
}
/// See [`StudioLifecycleConfigDetails`](crate::model::StudioLifecycleConfigDetails)
pub mod studio_lifecycle_config_details {

    /// A builder for [`StudioLifecycleConfigDetails`](crate::model::StudioLifecycleConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) studio_lifecycle_config_arn: std::option::Option<std::string::String>,
        pub(crate) studio_lifecycle_config_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) studio_lifecycle_config_app_type:
            std::option::Option<crate::model::StudioLifecycleConfigAppType>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration.</p>
        pub fn studio_lifecycle_config_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.studio_lifecycle_config_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Lifecycle Configuration.</p>
        pub fn set_studio_lifecycle_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_lifecycle_config_arn = input;
            self
        }
        /// <p>The name of the Studio Lifecycle Configuration.</p>
        pub fn studio_lifecycle_config_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.studio_lifecycle_config_name = Some(input.into());
            self
        }
        /// <p>The name of the Studio Lifecycle Configuration.</p>
        pub fn set_studio_lifecycle_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_lifecycle_config_name = input;
            self
        }
        /// <p>The creation time of the Studio Lifecycle Configuration.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the Studio Lifecycle Configuration.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The App type to which the Lifecycle Configuration is attached.</p>
        pub fn studio_lifecycle_config_app_type(
            mut self,
            input: crate::model::StudioLifecycleConfigAppType,
        ) -> Self {
            self.studio_lifecycle_config_app_type = Some(input);
            self
        }
        /// <p>The App type to which the Lifecycle Configuration is attached.</p>
        pub fn set_studio_lifecycle_config_app_type(
            mut self,
            input: std::option::Option<crate::model::StudioLifecycleConfigAppType>,
        ) -> Self {
            self.studio_lifecycle_config_app_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioLifecycleConfigDetails`](crate::model::StudioLifecycleConfigDetails)
        pub fn build(self) -> crate::model::StudioLifecycleConfigDetails {
            crate::model::StudioLifecycleConfigDetails {
                studio_lifecycle_config_arn: self.studio_lifecycle_config_arn,
                studio_lifecycle_config_name: self.studio_lifecycle_config_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                studio_lifecycle_config_app_type: self.studio_lifecycle_config_app_type,
            }
        }
    }
}
impl StudioLifecycleConfigDetails {
    /// Creates a new builder-style object to manufacture [`StudioLifecycleConfigDetails`](crate::model::StudioLifecycleConfigDetails)
    pub fn builder() -> crate::model::studio_lifecycle_config_details::Builder {
        crate::model::studio_lifecycle_config_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioLifecycleConfigAppType {
    #[allow(missing_docs)] // documentation missing in model
    JupyterServer,
    #[allow(missing_docs)] // documentation missing in model
    KernelGateway,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioLifecycleConfigAppType {
    fn from(s: &str) -> Self {
        match s {
            "JupyterServer" => StudioLifecycleConfigAppType::JupyterServer,
            "KernelGateway" => StudioLifecycleConfigAppType::KernelGateway,
            other => StudioLifecycleConfigAppType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioLifecycleConfigAppType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioLifecycleConfigAppType::from(s))
    }
}
impl StudioLifecycleConfigAppType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioLifecycleConfigAppType::JupyterServer => "JupyterServer",
            StudioLifecycleConfigAppType::KernelGateway => "KernelGateway",
            StudioLifecycleConfigAppType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["JupyterServer", "KernelGateway"]
    }
}
impl AsRef<str> for StudioLifecycleConfigAppType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioLifecycleConfigSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioLifecycleConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => StudioLifecycleConfigSortKey::CreationTime,
            "LastModifiedTime" => StudioLifecycleConfigSortKey::LastModifiedTime,
            "Name" => StudioLifecycleConfigSortKey::Name,
            other => StudioLifecycleConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioLifecycleConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioLifecycleConfigSortKey::from(s))
    }
}
impl StudioLifecycleConfigSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioLifecycleConfigSortKey::CreationTime => "CreationTime",
            StudioLifecycleConfigSortKey::LastModifiedTime => "LastModifiedTime",
            StudioLifecycleConfigSortKey::Name => "Name",
            StudioLifecycleConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for StudioLifecycleConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectSummary {
    /// <p>The name of the project.</p>
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The description of the project.</p>
    pub project_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the project.</p>
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The time that the project was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the project.</p>
    pub project_status: std::option::Option<crate::model::ProjectStatus>,
}
impl ProjectSummary {
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The description of the project.</p>
    pub fn project_description(&self) -> std::option::Option<&str> {
        self.project_description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub fn project_arn(&self) -> std::option::Option<&str> {
        self.project_arn.as_deref()
    }
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<&str> {
        self.project_id.as_deref()
    }
    /// <p>The time that the project was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The status of the project.</p>
    pub fn project_status(&self) -> std::option::Option<&crate::model::ProjectStatus> {
        self.project_status.as_ref()
    }
}
impl std::fmt::Debug for ProjectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectSummary");
        formatter.field("project_name", &self.project_name);
        formatter.field("project_description", &self.project_description);
        formatter.field("project_arn", &self.project_arn);
        formatter.field("project_id", &self.project_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("project_status", &self.project_status);
        formatter.finish()
    }
}
/// See [`ProjectSummary`](crate::model::ProjectSummary)
pub mod project_summary {

    /// A builder for [`ProjectSummary`](crate::model::ProjectSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) project_description: std::option::Option<std::string::String>,
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) project_status: std::option::Option<crate::model::ProjectStatus>,
    }
    impl Builder {
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The description of the project.</p>
        pub fn project_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_description = Some(input.into());
            self
        }
        /// <p>The description of the project.</p>
        pub fn set_project_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input;
            self
        }
        /// <p>The time that the project was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the project was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of the project.</p>
        pub fn project_status(mut self, input: crate::model::ProjectStatus) -> Self {
            self.project_status = Some(input);
            self
        }
        /// <p>The status of the project.</p>
        pub fn set_project_status(
            mut self,
            input: std::option::Option<crate::model::ProjectStatus>,
        ) -> Self {
            self.project_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectSummary`](crate::model::ProjectSummary)
        pub fn build(self) -> crate::model::ProjectSummary {
            crate::model::ProjectSummary {
                project_name: self.project_name,
                project_description: self.project_description,
                project_arn: self.project_arn,
                project_id: self.project_id,
                creation_time: self.creation_time,
                project_status: self.project_status,
            }
        }
    }
}
impl ProjectSummary {
    /// Creates a new builder-style object to manufacture [`ProjectSummary`](crate::model::ProjectSummary)
    pub fn builder() -> crate::model::project_summary::Builder {
        crate::model::project_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => ProjectSortOrder::Ascending,
            "Descending" => ProjectSortOrder::Descending,
            other => ProjectSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectSortOrder::from(s))
    }
}
impl ProjectSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProjectSortOrder::Ascending => "Ascending",
            ProjectSortOrder::Descending => "Descending",
            ProjectSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for ProjectSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ProjectSortBy::CreationTime,
            "Name" => ProjectSortBy::Name,
            other => ProjectSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectSortBy::from(s))
    }
}
impl ProjectSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProjectSortBy::CreationTime => "CreationTime",
            ProjectSortBy::Name => "Name",
            ProjectSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ProjectSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of information about a processing job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJobSummary {
    /// <p>The name of the processing job.</p>
    pub processing_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The time at which the processing job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the processing job completed.</p>
    pub processing_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that indicates the last time the processing job was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the processing job.</p>
    pub processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
    pub exit_message: std::option::Option<std::string::String>,
}
impl ProcessingJobSummary {
    /// <p>The name of the processing job.</p>
    pub fn processing_job_name(&self) -> std::option::Option<&str> {
        self.processing_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
    pub fn processing_job_arn(&self) -> std::option::Option<&str> {
        self.processing_job_arn.as_deref()
    }
    /// <p>The time at which the processing job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the processing job completed.</p>
    pub fn processing_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.processing_end_time.as_ref()
    }
    /// <p>A timestamp that indicates the last time the processing job was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the processing job.</p>
    pub fn processing_job_status(&self) -> std::option::Option<&crate::model::ProcessingJobStatus> {
        self.processing_job_status.as_ref()
    }
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
    pub fn exit_message(&self) -> std::option::Option<&str> {
        self.exit_message.as_deref()
    }
}
impl std::fmt::Debug for ProcessingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJobSummary");
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("processing_end_time", &self.processing_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("processing_job_status", &self.processing_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("exit_message", &self.exit_message);
        formatter.finish()
    }
}
/// See [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
pub mod processing_job_summary {

    /// A builder for [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) processing_job_name: std::option::Option<std::string::String>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) processing_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) exit_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the processing job.</p>
        pub fn processing_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_name = Some(input.into());
            self
        }
        /// <p>The name of the processing job.</p>
        pub fn set_processing_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The time at which the processing job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the processing job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the processing job completed.</p>
        pub fn processing_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.processing_end_time = Some(input);
            self
        }
        /// <p>The time at which the processing job completed.</p>
        pub fn set_processing_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.processing_end_time = input;
            self
        }
        /// <p>A timestamp that indicates the last time the processing job was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that indicates the last time the processing job was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn processing_job_status(mut self, input: crate::model::ProcessingJobStatus) -> Self {
            self.processing_job_status = Some(input);
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn set_processing_job_status(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStatus>,
        ) -> Self {
            self.processing_job_status = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if it failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
        pub fn exit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.exit_message = Some(input.into());
            self
        }
        /// <p>An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.</p>
        pub fn set_exit_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.exit_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
        pub fn build(self) -> crate::model::ProcessingJobSummary {
            crate::model::ProcessingJobSummary {
                processing_job_name: self.processing_job_name,
                processing_job_arn: self.processing_job_arn,
                creation_time: self.creation_time,
                processing_end_time: self.processing_end_time,
                last_modified_time: self.last_modified_time,
                processing_job_status: self.processing_job_status,
                failure_reason: self.failure_reason,
                exit_message: self.exit_message,
            }
        }
    }
}
impl ProcessingJobSummary {
    /// Creates a new builder-style object to manufacture [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
    pub fn builder() -> crate::model::processing_job_summary::Builder {
        crate::model::processing_job_summary::Builder::default()
    }
}

/// <p>A summary of a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineSummary {
    /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    pub pipeline_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the pipeline.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the pipeline was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that a pipeline execution began.</p>
    pub last_execution_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PipelineSummary {
    /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
    pub fn pipeline_arn(&self) -> std::option::Option<&str> {
        self.pipeline_arn.as_deref()
    }
    /// <p>The name of the pipeline.</p>
    pub fn pipeline_name(&self) -> std::option::Option<&str> {
        self.pipeline_name.as_deref()
    }
    /// <p>The display name of the pipeline.</p>
    pub fn pipeline_display_name(&self) -> std::option::Option<&str> {
        self.pipeline_display_name.as_deref()
    }
    /// <p>The description of the pipeline.</p>
    pub fn pipeline_description(&self) -> std::option::Option<&str> {
        self.pipeline_description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The creation time of the pipeline.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that the pipeline was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The last time that a pipeline execution began.</p>
    pub fn last_execution_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_execution_time.as_ref()
    }
}
impl std::fmt::Debug for PipelineSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineSummary");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_execution_time", &self.last_execution_time);
        formatter.finish()
    }
}
/// See [`PipelineSummary`](crate::model::PipelineSummary)
pub mod pipeline_summary {

    /// A builder for [`PipelineSummary`](crate::model::PipelineSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_description: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_execution_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_name = Some(input.into());
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_name = input;
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn pipeline_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn set_pipeline_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_display_name = input;
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn pipeline_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_description = Some(input.into());
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn set_pipeline_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The last time that a pipeline execution began.</p>
        pub fn last_execution_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_execution_time = Some(input);
            self
        }
        /// <p>The last time that a pipeline execution began.</p>
        pub fn set_last_execution_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_execution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineSummary`](crate::model::PipelineSummary)
        pub fn build(self) -> crate::model::PipelineSummary {
            crate::model::PipelineSummary {
                pipeline_arn: self.pipeline_arn,
                pipeline_name: self.pipeline_name,
                pipeline_display_name: self.pipeline_display_name,
                pipeline_description: self.pipeline_description,
                role_arn: self.role_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                last_execution_time: self.last_execution_time,
            }
        }
    }
}
impl PipelineSummary {
    /// Creates a new builder-style object to manufacture [`PipelineSummary`](crate::model::PipelineSummary)
    pub fn builder() -> crate::model::pipeline_summary::Builder {
        crate::model::pipeline_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortPipelinesBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortPipelinesBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortPipelinesBy::CreationTime,
            "Name" => SortPipelinesBy::Name,
            other => SortPipelinesBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortPipelinesBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortPipelinesBy::from(s))
    }
}
impl SortPipelinesBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortPipelinesBy::CreationTime => "CreationTime",
            SortPipelinesBy::Name => "Name",
            SortPipelinesBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortPipelinesBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An execution of a step in a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionStep {
    /// <p>The name of the step that is executed.</p>
    pub step_name: std::option::Option<std::string::String>,
    /// <p>The display name of the step.</p>
    pub step_display_name: std::option::Option<std::string::String>,
    /// <p>The description of the step.</p>
    pub step_description: std::option::Option<std::string::String>,
    /// <p>The time that the step started executing.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the step stopped executing.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the step execution.</p>
    pub step_status: std::option::Option<crate::model::StepStatus>,
    /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
    pub cache_hit_result: std::option::Option<crate::model::CacheHitResult>,
    /// <p>The current attempt of the execution step. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pipelines-retry-policy.html">Retry Policy for SageMaker Pipelines steps</a>.</p>
    pub attempt_count: i32,
    /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Metadata for the step execution.</p>
    pub metadata: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
}
impl PipelineExecutionStep {
    /// <p>The name of the step that is executed.</p>
    pub fn step_name(&self) -> std::option::Option<&str> {
        self.step_name.as_deref()
    }
    /// <p>The display name of the step.</p>
    pub fn step_display_name(&self) -> std::option::Option<&str> {
        self.step_display_name.as_deref()
    }
    /// <p>The description of the step.</p>
    pub fn step_description(&self) -> std::option::Option<&str> {
        self.step_description.as_deref()
    }
    /// <p>The time that the step started executing.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The time that the step stopped executing.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The status of the step execution.</p>
    pub fn step_status(&self) -> std::option::Option<&crate::model::StepStatus> {
        self.step_status.as_ref()
    }
    /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
    pub fn cache_hit_result(&self) -> std::option::Option<&crate::model::CacheHitResult> {
        self.cache_hit_result.as_ref()
    }
    /// <p>The current attempt of the execution step. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pipelines-retry-policy.html">Retry Policy for SageMaker Pipelines steps</a>.</p>
    pub fn attempt_count(&self) -> i32 {
        self.attempt_count
    }
    /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Metadata for the step execution.</p>
    pub fn metadata(&self) -> std::option::Option<&crate::model::PipelineExecutionStepMetadata> {
        self.metadata.as_ref()
    }
}
impl std::fmt::Debug for PipelineExecutionStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionStep");
        formatter.field("step_name", &self.step_name);
        formatter.field("step_display_name", &self.step_display_name);
        formatter.field("step_description", &self.step_description);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("step_status", &self.step_status);
        formatter.field("cache_hit_result", &self.cache_hit_result);
        formatter.field("attempt_count", &self.attempt_count);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("metadata", &self.metadata);
        formatter.finish()
    }
}
/// See [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
pub mod pipeline_execution_step {

    /// A builder for [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_name: std::option::Option<std::string::String>,
        pub(crate) step_display_name: std::option::Option<std::string::String>,
        pub(crate) step_description: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) step_status: std::option::Option<crate::model::StepStatus>,
        pub(crate) cache_hit_result: std::option::Option<crate::model::CacheHitResult>,
        pub(crate) attempt_count: std::option::Option<i32>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
    }
    impl Builder {
        /// <p>The name of the step that is executed.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        /// <p>The name of the step that is executed.</p>
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// <p>The display name of the step.</p>
        pub fn step_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the step.</p>
        pub fn set_step_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.step_display_name = input;
            self
        }
        /// <p>The description of the step.</p>
        pub fn step_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_description = Some(input.into());
            self
        }
        /// <p>The description of the step.</p>
        pub fn set_step_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.step_description = input;
            self
        }
        /// <p>The time that the step started executing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time that the step started executing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time that the step stopped executing.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the step stopped executing.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The status of the step execution.</p>
        pub fn step_status(mut self, input: crate::model::StepStatus) -> Self {
            self.step_status = Some(input);
            self
        }
        /// <p>The status of the step execution.</p>
        pub fn set_step_status(
            mut self,
            input: std::option::Option<crate::model::StepStatus>,
        ) -> Self {
            self.step_status = input;
            self
        }
        /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
        pub fn cache_hit_result(mut self, input: crate::model::CacheHitResult) -> Self {
            self.cache_hit_result = Some(input);
            self
        }
        /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
        pub fn set_cache_hit_result(
            mut self,
            input: std::option::Option<crate::model::CacheHitResult>,
        ) -> Self {
            self.cache_hit_result = input;
            self
        }
        /// <p>The current attempt of the execution step. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pipelines-retry-policy.html">Retry Policy for SageMaker Pipelines steps</a>.</p>
        pub fn attempt_count(mut self, input: i32) -> Self {
            self.attempt_count = Some(input);
            self
        }
        /// <p>The current attempt of the execution step. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pipelines-retry-policy.html">Retry Policy for SageMaker Pipelines steps</a>.</p>
        pub fn set_attempt_count(mut self, input: std::option::Option<i32>) -> Self {
            self.attempt_count = input;
            self
        }
        /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Metadata for the step execution.</p>
        pub fn metadata(mut self, input: crate::model::PipelineExecutionStepMetadata) -> Self {
            self.metadata = Some(input);
            self
        }
        /// <p>Metadata for the step execution.</p>
        pub fn set_metadata(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
        pub fn build(self) -> crate::model::PipelineExecutionStep {
            crate::model::PipelineExecutionStep {
                step_name: self.step_name,
                step_display_name: self.step_display_name,
                step_description: self.step_description,
                start_time: self.start_time,
                end_time: self.end_time,
                step_status: self.step_status,
                cache_hit_result: self.cache_hit_result,
                attempt_count: self.attempt_count.unwrap_or_default(),
                failure_reason: self.failure_reason,
                metadata: self.metadata,
            }
        }
    }
}
impl PipelineExecutionStep {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
    pub fn builder() -> crate::model::pipeline_execution_step::Builder {
        crate::model::pipeline_execution_step::Builder::default()
    }
}

/// <p>Metadata for a step execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub training_job: std::option::Option<crate::model::TrainingJobStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
    pub processing_job: std::option::Option<crate::model::ProcessingJobStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub transform_job: std::option::Option<crate::model::TransformJobStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
    pub tuning_job: std::option::Option<crate::model::TuningJobStepMetaData>,
    /// <p>The Amazon Resource Name (ARN) of the model that was created by this step execution.</p>
    pub model: std::option::Option<crate::model::ModelStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the model package the model was registered to by this step execution.</p>
    pub register_model: std::option::Option<crate::model::RegisterModelStepMetadata>,
    /// <p>The outcome of the condition evaluation that was run by this step execution.</p>
    pub condition: std::option::Option<crate::model::ConditionStepMetadata>,
    /// <p>The URL of the Amazon SQS queue used by this step execution, the pipeline generated token, and a list of output parameters.</p>
    pub callback: std::option::Option<crate::model::CallbackStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution and a list of output parameters.</p>
    pub lambda: std::option::Option<crate::model::LambdaStepMetadata>,
    /// <p>The configurations and outcomes of the check step execution. This includes: </p>
    /// <ul>
    /// <li> <p>The type of the check conducted,</p> </li>
    /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
    /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
    /// <li> <p>The model package group name provided.</p> </li>
    /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
    /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
    /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
    /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
    /// </ul>
    pub quality_check: std::option::Option<crate::model::QualityCheckStepMetadata>,
    /// <p>Container for the metadata for a Clarify check step. The configurations and outcomes of the check step execution. This includes: </p>
    /// <ul>
    /// <li> <p>The type of the check conducted,</p> </li>
    /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
    /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
    /// <li> <p>The model package group name provided.</p> </li>
    /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
    /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
    /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
    /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
    /// </ul>
    pub clarify_check: std::option::Option<crate::model::ClarifyCheckStepMetadata>,
    /// <p>The configurations and outcomes of an EMR step execution.</p>
    pub emr: std::option::Option<crate::model::EmrStepMetadata>,
    /// <p>The configurations and outcomes of a Fail step execution.</p>
    pub fail: std::option::Option<crate::model::FailStepMetadata>,
}
impl PipelineExecutionStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub fn training_job(&self) -> std::option::Option<&crate::model::TrainingJobStepMetadata> {
        self.training_job.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
    pub fn processing_job(&self) -> std::option::Option<&crate::model::ProcessingJobStepMetadata> {
        self.processing_job.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub fn transform_job(&self) -> std::option::Option<&crate::model::TransformJobStepMetadata> {
        self.transform_job.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
    pub fn tuning_job(&self) -> std::option::Option<&crate::model::TuningJobStepMetaData> {
        self.tuning_job.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model that was created by this step execution.</p>
    pub fn model(&self) -> std::option::Option<&crate::model::ModelStepMetadata> {
        self.model.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model package the model was registered to by this step execution.</p>
    pub fn register_model(&self) -> std::option::Option<&crate::model::RegisterModelStepMetadata> {
        self.register_model.as_ref()
    }
    /// <p>The outcome of the condition evaluation that was run by this step execution.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::ConditionStepMetadata> {
        self.condition.as_ref()
    }
    /// <p>The URL of the Amazon SQS queue used by this step execution, the pipeline generated token, and a list of output parameters.</p>
    pub fn callback(&self) -> std::option::Option<&crate::model::CallbackStepMetadata> {
        self.callback.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution and a list of output parameters.</p>
    pub fn lambda(&self) -> std::option::Option<&crate::model::LambdaStepMetadata> {
        self.lambda.as_ref()
    }
    /// <p>The configurations and outcomes of the check step execution. This includes: </p>
    /// <ul>
    /// <li> <p>The type of the check conducted,</p> </li>
    /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
    /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
    /// <li> <p>The model package group name provided.</p> </li>
    /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
    /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
    /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
    /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
    /// </ul>
    pub fn quality_check(&self) -> std::option::Option<&crate::model::QualityCheckStepMetadata> {
        self.quality_check.as_ref()
    }
    /// <p>Container for the metadata for a Clarify check step. The configurations and outcomes of the check step execution. This includes: </p>
    /// <ul>
    /// <li> <p>The type of the check conducted,</p> </li>
    /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
    /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
    /// <li> <p>The model package group name provided.</p> </li>
    /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
    /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
    /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
    /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
    /// </ul>
    pub fn clarify_check(&self) -> std::option::Option<&crate::model::ClarifyCheckStepMetadata> {
        self.clarify_check.as_ref()
    }
    /// <p>The configurations and outcomes of an EMR step execution.</p>
    pub fn emr(&self) -> std::option::Option<&crate::model::EmrStepMetadata> {
        self.emr.as_ref()
    }
    /// <p>The configurations and outcomes of a Fail step execution.</p>
    pub fn fail(&self) -> std::option::Option<&crate::model::FailStepMetadata> {
        self.fail.as_ref()
    }
}
impl std::fmt::Debug for PipelineExecutionStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionStepMetadata");
        formatter.field("training_job", &self.training_job);
        formatter.field("processing_job", &self.processing_job);
        formatter.field("transform_job", &self.transform_job);
        formatter.field("tuning_job", &self.tuning_job);
        formatter.field("model", &self.model);
        formatter.field("register_model", &self.register_model);
        formatter.field("condition", &self.condition);
        formatter.field("callback", &self.callback);
        formatter.field("lambda", &self.lambda);
        formatter.field("quality_check", &self.quality_check);
        formatter.field("clarify_check", &self.clarify_check);
        formatter.field("emr", &self.emr);
        formatter.field("fail", &self.fail);
        formatter.finish()
    }
}
/// See [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
pub mod pipeline_execution_step_metadata {

    /// A builder for [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job: std::option::Option<crate::model::TrainingJobStepMetadata>,
        pub(crate) processing_job: std::option::Option<crate::model::ProcessingJobStepMetadata>,
        pub(crate) transform_job: std::option::Option<crate::model::TransformJobStepMetadata>,
        pub(crate) tuning_job: std::option::Option<crate::model::TuningJobStepMetaData>,
        pub(crate) model: std::option::Option<crate::model::ModelStepMetadata>,
        pub(crate) register_model: std::option::Option<crate::model::RegisterModelStepMetadata>,
        pub(crate) condition: std::option::Option<crate::model::ConditionStepMetadata>,
        pub(crate) callback: std::option::Option<crate::model::CallbackStepMetadata>,
        pub(crate) lambda: std::option::Option<crate::model::LambdaStepMetadata>,
        pub(crate) quality_check: std::option::Option<crate::model::QualityCheckStepMetadata>,
        pub(crate) clarify_check: std::option::Option<crate::model::ClarifyCheckStepMetadata>,
        pub(crate) emr: std::option::Option<crate::model::EmrStepMetadata>,
        pub(crate) fail: std::option::Option<crate::model::FailStepMetadata>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJobStepMetadata) -> Self {
            self.training_job = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStepMetadata>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
        pub fn processing_job(mut self, input: crate::model::ProcessingJobStepMetadata) -> Self {
            self.processing_job = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
        pub fn set_processing_job(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStepMetadata>,
        ) -> Self {
            self.processing_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn transform_job(mut self, input: crate::model::TransformJobStepMetadata) -> Self {
            self.transform_job = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn set_transform_job(
            mut self,
            input: std::option::Option<crate::model::TransformJobStepMetadata>,
        ) -> Self {
            self.transform_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
        pub fn tuning_job(mut self, input: crate::model::TuningJobStepMetaData) -> Self {
            self.tuning_job = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
        pub fn set_tuning_job(
            mut self,
            input: std::option::Option<crate::model::TuningJobStepMetaData>,
        ) -> Self {
            self.tuning_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model that was created by this step execution.</p>
        pub fn model(mut self, input: crate::model::ModelStepMetadata) -> Self {
            self.model = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model that was created by this step execution.</p>
        pub fn set_model(
            mut self,
            input: std::option::Option<crate::model::ModelStepMetadata>,
        ) -> Self {
            self.model = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package the model was registered to by this step execution.</p>
        pub fn register_model(mut self, input: crate::model::RegisterModelStepMetadata) -> Self {
            self.register_model = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package the model was registered to by this step execution.</p>
        pub fn set_register_model(
            mut self,
            input: std::option::Option<crate::model::RegisterModelStepMetadata>,
        ) -> Self {
            self.register_model = input;
            self
        }
        /// <p>The outcome of the condition evaluation that was run by this step execution.</p>
        pub fn condition(mut self, input: crate::model::ConditionStepMetadata) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The outcome of the condition evaluation that was run by this step execution.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::ConditionStepMetadata>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>The URL of the Amazon SQS queue used by this step execution, the pipeline generated token, and a list of output parameters.</p>
        pub fn callback(mut self, input: crate::model::CallbackStepMetadata) -> Self {
            self.callback = Some(input);
            self
        }
        /// <p>The URL of the Amazon SQS queue used by this step execution, the pipeline generated token, and a list of output parameters.</p>
        pub fn set_callback(
            mut self,
            input: std::option::Option<crate::model::CallbackStepMetadata>,
        ) -> Self {
            self.callback = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution and a list of output parameters.</p>
        pub fn lambda(mut self, input: crate::model::LambdaStepMetadata) -> Self {
            self.lambda = Some(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution and a list of output parameters.</p>
        pub fn set_lambda(
            mut self,
            input: std::option::Option<crate::model::LambdaStepMetadata>,
        ) -> Self {
            self.lambda = input;
            self
        }
        /// <p>The configurations and outcomes of the check step execution. This includes: </p>
        /// <ul>
        /// <li> <p>The type of the check conducted,</p> </li>
        /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
        /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
        /// <li> <p>The model package group name provided.</p> </li>
        /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
        /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
        /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
        /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
        /// </ul>
        pub fn quality_check(mut self, input: crate::model::QualityCheckStepMetadata) -> Self {
            self.quality_check = Some(input);
            self
        }
        /// <p>The configurations and outcomes of the check step execution. This includes: </p>
        /// <ul>
        /// <li> <p>The type of the check conducted,</p> </li>
        /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
        /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
        /// <li> <p>The model package group name provided.</p> </li>
        /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
        /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
        /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
        /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
        /// </ul>
        pub fn set_quality_check(
            mut self,
            input: std::option::Option<crate::model::QualityCheckStepMetadata>,
        ) -> Self {
            self.quality_check = input;
            self
        }
        /// <p>Container for the metadata for a Clarify check step. The configurations and outcomes of the check step execution. This includes: </p>
        /// <ul>
        /// <li> <p>The type of the check conducted,</p> </li>
        /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
        /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
        /// <li> <p>The model package group name provided.</p> </li>
        /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
        /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
        /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
        /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
        /// </ul>
        pub fn clarify_check(mut self, input: crate::model::ClarifyCheckStepMetadata) -> Self {
            self.clarify_check = Some(input);
            self
        }
        /// <p>Container for the metadata for a Clarify check step. The configurations and outcomes of the check step execution. This includes: </p>
        /// <ul>
        /// <li> <p>The type of the check conducted,</p> </li>
        /// <li> <p>The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.</p> </li>
        /// <li> <p>The Amazon S3 URIs of newly calculated baseline constraints and statistics.</p> </li>
        /// <li> <p>The model package group name provided.</p> </li>
        /// <li> <p>The Amazon S3 URI of the violation report if violations detected.</p> </li>
        /// <li> <p>The Amazon Resource Name (ARN) of check processing job initiated by the step execution.</p> </li>
        /// <li> <p>The boolean flags indicating if the drift check is skipped.</p> </li>
        /// <li> <p>If step property <code>BaselineUsedForDriftCheck</code> is set the same as <code>CalculatedBaseline</code>.</p> </li>
        /// </ul>
        pub fn set_clarify_check(
            mut self,
            input: std::option::Option<crate::model::ClarifyCheckStepMetadata>,
        ) -> Self {
            self.clarify_check = input;
            self
        }
        /// <p>The configurations and outcomes of an EMR step execution.</p>
        pub fn emr(mut self, input: crate::model::EmrStepMetadata) -> Self {
            self.emr = Some(input);
            self
        }
        /// <p>The configurations and outcomes of an EMR step execution.</p>
        pub fn set_emr(
            mut self,
            input: std::option::Option<crate::model::EmrStepMetadata>,
        ) -> Self {
            self.emr = input;
            self
        }
        /// <p>The configurations and outcomes of a Fail step execution.</p>
        pub fn fail(mut self, input: crate::model::FailStepMetadata) -> Self {
            self.fail = Some(input);
            self
        }
        /// <p>The configurations and outcomes of a Fail step execution.</p>
        pub fn set_fail(
            mut self,
            input: std::option::Option<crate::model::FailStepMetadata>,
        ) -> Self {
            self.fail = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
        pub fn build(self) -> crate::model::PipelineExecutionStepMetadata {
            crate::model::PipelineExecutionStepMetadata {
                training_job: self.training_job,
                processing_job: self.processing_job,
                transform_job: self.transform_job,
                tuning_job: self.tuning_job,
                model: self.model,
                register_model: self.register_model,
                condition: self.condition,
                callback: self.callback,
                lambda: self.lambda,
                quality_check: self.quality_check,
                clarify_check: self.clarify_check,
                emr: self.emr,
                fail: self.fail,
            }
        }
    }
}
impl PipelineExecutionStepMetadata {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
    pub fn builder() -> crate::model::pipeline_execution_step_metadata::Builder {
        crate::model::pipeline_execution_step_metadata::Builder::default()
    }
}

/// <p>The container for the metadata for Fail step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailStepMetadata {
    /// <p>A message that you define and then is processed and rendered by the Fail step when the error occurs.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl FailStepMetadata {
    /// <p>A message that you define and then is processed and rendered by the Fail step when the error occurs.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for FailStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailStepMetadata");
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`FailStepMetadata`](crate::model::FailStepMetadata)
pub mod fail_step_metadata {

    /// A builder for [`FailStepMetadata`](crate::model::FailStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message that you define and then is processed and rendered by the Fail step when the error occurs.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message that you define and then is processed and rendered by the Fail step when the error occurs.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailStepMetadata`](crate::model::FailStepMetadata)
        pub fn build(self) -> crate::model::FailStepMetadata {
            crate::model::FailStepMetadata {
                error_message: self.error_message,
            }
        }
    }
}
impl FailStepMetadata {
    /// Creates a new builder-style object to manufacture [`FailStepMetadata`](crate::model::FailStepMetadata)
    pub fn builder() -> crate::model::fail_step_metadata::Builder {
        crate::model::fail_step_metadata::Builder::default()
    }
}

/// <p>The configurations and outcomes of an Amazon EMR step execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmrStepMetadata {
    /// <p>The identifier of the EMR cluster.</p>
    pub cluster_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the EMR cluster step.</p>
    pub step_id: std::option::Option<std::string::String>,
    /// <p>The name of the EMR cluster step.</p>
    pub step_name: std::option::Option<std::string::String>,
    /// <p>The path to the log file where the cluster step's failure root cause is recorded.</p>
    pub log_file_path: std::option::Option<std::string::String>,
}
impl EmrStepMetadata {
    /// <p>The identifier of the EMR cluster.</p>
    pub fn cluster_id(&self) -> std::option::Option<&str> {
        self.cluster_id.as_deref()
    }
    /// <p>The identifier of the EMR cluster step.</p>
    pub fn step_id(&self) -> std::option::Option<&str> {
        self.step_id.as_deref()
    }
    /// <p>The name of the EMR cluster step.</p>
    pub fn step_name(&self) -> std::option::Option<&str> {
        self.step_name.as_deref()
    }
    /// <p>The path to the log file where the cluster step's failure root cause is recorded.</p>
    pub fn log_file_path(&self) -> std::option::Option<&str> {
        self.log_file_path.as_deref()
    }
}
impl std::fmt::Debug for EmrStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmrStepMetadata");
        formatter.field("cluster_id", &self.cluster_id);
        formatter.field("step_id", &self.step_id);
        formatter.field("step_name", &self.step_name);
        formatter.field("log_file_path", &self.log_file_path);
        formatter.finish()
    }
}
/// See [`EmrStepMetadata`](crate::model::EmrStepMetadata)
pub mod emr_step_metadata {

    /// A builder for [`EmrStepMetadata`](crate::model::EmrStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_id: std::option::Option<std::string::String>,
        pub(crate) step_id: std::option::Option<std::string::String>,
        pub(crate) step_name: std::option::Option<std::string::String>,
        pub(crate) log_file_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the EMR cluster.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_id = Some(input.into());
            self
        }
        /// <p>The identifier of the EMR cluster.</p>
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_id = input;
            self
        }
        /// <p>The identifier of the EMR cluster step.</p>
        pub fn step_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_id = Some(input.into());
            self
        }
        /// <p>The identifier of the EMR cluster step.</p>
        pub fn set_step_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_id = input;
            self
        }
        /// <p>The name of the EMR cluster step.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        /// <p>The name of the EMR cluster step.</p>
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// <p>The path to the log file where the cluster step's failure root cause is recorded.</p>
        pub fn log_file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_file_path = Some(input.into());
            self
        }
        /// <p>The path to the log file where the cluster step's failure root cause is recorded.</p>
        pub fn set_log_file_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_file_path = input;
            self
        }
        /// Consumes the builder and constructs a [`EmrStepMetadata`](crate::model::EmrStepMetadata)
        pub fn build(self) -> crate::model::EmrStepMetadata {
            crate::model::EmrStepMetadata {
                cluster_id: self.cluster_id,
                step_id: self.step_id,
                step_name: self.step_name,
                log_file_path: self.log_file_path,
            }
        }
    }
}
impl EmrStepMetadata {
    /// Creates a new builder-style object to manufacture [`EmrStepMetadata`](crate::model::EmrStepMetadata)
    pub fn builder() -> crate::model::emr_step_metadata::Builder {
        crate::model::emr_step_metadata::Builder::default()
    }
}

/// <p>The container for the metadata for the ClarifyCheck step. For more information, see the topic on <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/build-and-manage-steps.html#step-type-clarify-check">ClarifyCheck step</a> in the <i>Amazon SageMaker Developer Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClarifyCheckStepMetadata {
    /// <p>The type of the Clarify Check step</p>
    pub check_type: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of baseline constraints file to be used for the drift check.</p>
    pub baseline_used_for_drift_check_constraints: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
    pub calculated_baseline_constraints: std::option::Option<std::string::String>,
    /// <p>The model package group name.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the violation report if violations are detected.</p>
    pub violation_report: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the check processing job that was run by this step's execution.</p>
    pub check_job_arn: std::option::Option<std::string::String>,
    /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
    pub skip_check: bool,
    /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> property. </p>
    pub register_new_baseline: bool,
}
impl ClarifyCheckStepMetadata {
    /// <p>The type of the Clarify Check step</p>
    pub fn check_type(&self) -> std::option::Option<&str> {
        self.check_type.as_deref()
    }
    /// <p>The Amazon S3 URI of baseline constraints file to be used for the drift check.</p>
    pub fn baseline_used_for_drift_check_constraints(&self) -> std::option::Option<&str> {
        self.baseline_used_for_drift_check_constraints.as_deref()
    }
    /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
    pub fn calculated_baseline_constraints(&self) -> std::option::Option<&str> {
        self.calculated_baseline_constraints.as_deref()
    }
    /// <p>The model package group name.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The Amazon S3 URI of the violation report if violations are detected.</p>
    pub fn violation_report(&self) -> std::option::Option<&str> {
        self.violation_report.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the check processing job that was run by this step's execution.</p>
    pub fn check_job_arn(&self) -> std::option::Option<&str> {
        self.check_job_arn.as_deref()
    }
    /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
    pub fn skip_check(&self) -> bool {
        self.skip_check
    }
    /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> property. </p>
    pub fn register_new_baseline(&self) -> bool {
        self.register_new_baseline
    }
}
impl std::fmt::Debug for ClarifyCheckStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClarifyCheckStepMetadata");
        formatter.field("check_type", &self.check_type);
        formatter.field(
            "baseline_used_for_drift_check_constraints",
            &self.baseline_used_for_drift_check_constraints,
        );
        formatter.field(
            "calculated_baseline_constraints",
            &self.calculated_baseline_constraints,
        );
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("violation_report", &self.violation_report);
        formatter.field("check_job_arn", &self.check_job_arn);
        formatter.field("skip_check", &self.skip_check);
        formatter.field("register_new_baseline", &self.register_new_baseline);
        formatter.finish()
    }
}
/// See [`ClarifyCheckStepMetadata`](crate::model::ClarifyCheckStepMetadata)
pub mod clarify_check_step_metadata {

    /// A builder for [`ClarifyCheckStepMetadata`](crate::model::ClarifyCheckStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_type: std::option::Option<std::string::String>,
        pub(crate) baseline_used_for_drift_check_constraints:
            std::option::Option<std::string::String>,
        pub(crate) calculated_baseline_constraints: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) violation_report: std::option::Option<std::string::String>,
        pub(crate) check_job_arn: std::option::Option<std::string::String>,
        pub(crate) skip_check: std::option::Option<bool>,
        pub(crate) register_new_baseline: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The type of the Clarify Check step</p>
        pub fn check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_type = Some(input.into());
            self
        }
        /// <p>The type of the Clarify Check step</p>
        pub fn set_check_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_type = input;
            self
        }
        /// <p>The Amazon S3 URI of baseline constraints file to be used for the drift check.</p>
        pub fn baseline_used_for_drift_check_constraints(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_constraints = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of baseline constraints file to be used for the drift check.</p>
        pub fn set_baseline_used_for_drift_check_constraints(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_constraints = input;
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
        pub fn calculated_baseline_constraints(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.calculated_baseline_constraints = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
        pub fn set_calculated_baseline_constraints(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calculated_baseline_constraints = input;
            self
        }
        /// <p>The model package group name.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The model package group name.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon S3 URI of the violation report if violations are detected.</p>
        pub fn violation_report(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_report = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the violation report if violations are detected.</p>
        pub fn set_violation_report(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_report = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the check processing job that was run by this step's execution.</p>
        pub fn check_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the check processing job that was run by this step's execution.</p>
        pub fn set_check_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.check_job_arn = input;
            self
        }
        /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
        pub fn skip_check(mut self, input: bool) -> Self {
            self.skip_check = Some(input);
            self
        }
        /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
        pub fn set_skip_check(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_check = input;
            self
        }
        /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> property. </p>
        pub fn register_new_baseline(mut self, input: bool) -> Self {
            self.register_new_baseline = Some(input);
            self
        }
        /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> property. </p>
        pub fn set_register_new_baseline(mut self, input: std::option::Option<bool>) -> Self {
            self.register_new_baseline = input;
            self
        }
        /// Consumes the builder and constructs a [`ClarifyCheckStepMetadata`](crate::model::ClarifyCheckStepMetadata)
        pub fn build(self) -> crate::model::ClarifyCheckStepMetadata {
            crate::model::ClarifyCheckStepMetadata {
                check_type: self.check_type,
                baseline_used_for_drift_check_constraints: self
                    .baseline_used_for_drift_check_constraints,
                calculated_baseline_constraints: self.calculated_baseline_constraints,
                model_package_group_name: self.model_package_group_name,
                violation_report: self.violation_report,
                check_job_arn: self.check_job_arn,
                skip_check: self.skip_check.unwrap_or_default(),
                register_new_baseline: self.register_new_baseline.unwrap_or_default(),
            }
        }
    }
}
impl ClarifyCheckStepMetadata {
    /// Creates a new builder-style object to manufacture [`ClarifyCheckStepMetadata`](crate::model::ClarifyCheckStepMetadata)
    pub fn builder() -> crate::model::clarify_check_step_metadata::Builder {
        crate::model::clarify_check_step_metadata::Builder::default()
    }
}

/// <p>Container for the metadata for a Quality check step. For more information, see the topic on <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/build-and-manage-steps.html#step-type-quality-check">QualityCheck step</a> in the <i>Amazon SageMaker Developer Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QualityCheckStepMetadata {
    /// <p>The type of the Quality check step.</p>
    pub check_type: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the baseline statistics file used for the drift check.</p>
    pub baseline_used_for_drift_check_statistics: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the baseline constraints file used for the drift check.</p>
    pub baseline_used_for_drift_check_constraints: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the newly calculated baseline statistics file.</p>
    pub calculated_baseline_statistics: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
    pub calculated_baseline_constraints: std::option::Option<std::string::String>,
    /// <p>The model package group name.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI of violation report if violations are detected.</p>
    pub violation_report: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Quality check processing job that was run by this step execution.</p>
    pub check_job_arn: std::option::Option<std::string::String>,
    /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
    pub skip_check: bool,
    /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> and <code> BaselineUsedForDriftCheckStatistics</code> properties. </p>
    pub register_new_baseline: bool,
}
impl QualityCheckStepMetadata {
    /// <p>The type of the Quality check step.</p>
    pub fn check_type(&self) -> std::option::Option<&str> {
        self.check_type.as_deref()
    }
    /// <p>The Amazon S3 URI of the baseline statistics file used for the drift check.</p>
    pub fn baseline_used_for_drift_check_statistics(&self) -> std::option::Option<&str> {
        self.baseline_used_for_drift_check_statistics.as_deref()
    }
    /// <p>The Amazon S3 URI of the baseline constraints file used for the drift check.</p>
    pub fn baseline_used_for_drift_check_constraints(&self) -> std::option::Option<&str> {
        self.baseline_used_for_drift_check_constraints.as_deref()
    }
    /// <p>The Amazon S3 URI of the newly calculated baseline statistics file.</p>
    pub fn calculated_baseline_statistics(&self) -> std::option::Option<&str> {
        self.calculated_baseline_statistics.as_deref()
    }
    /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
    pub fn calculated_baseline_constraints(&self) -> std::option::Option<&str> {
        self.calculated_baseline_constraints.as_deref()
    }
    /// <p>The model package group name.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The Amazon S3 URI of violation report if violations are detected.</p>
    pub fn violation_report(&self) -> std::option::Option<&str> {
        self.violation_report.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Quality check processing job that was run by this step execution.</p>
    pub fn check_job_arn(&self) -> std::option::Option<&str> {
        self.check_job_arn.as_deref()
    }
    /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
    pub fn skip_check(&self) -> bool {
        self.skip_check
    }
    /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> and <code> BaselineUsedForDriftCheckStatistics</code> properties. </p>
    pub fn register_new_baseline(&self) -> bool {
        self.register_new_baseline
    }
}
impl std::fmt::Debug for QualityCheckStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QualityCheckStepMetadata");
        formatter.field("check_type", &self.check_type);
        formatter.field(
            "baseline_used_for_drift_check_statistics",
            &self.baseline_used_for_drift_check_statistics,
        );
        formatter.field(
            "baseline_used_for_drift_check_constraints",
            &self.baseline_used_for_drift_check_constraints,
        );
        formatter.field(
            "calculated_baseline_statistics",
            &self.calculated_baseline_statistics,
        );
        formatter.field(
            "calculated_baseline_constraints",
            &self.calculated_baseline_constraints,
        );
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("violation_report", &self.violation_report);
        formatter.field("check_job_arn", &self.check_job_arn);
        formatter.field("skip_check", &self.skip_check);
        formatter.field("register_new_baseline", &self.register_new_baseline);
        formatter.finish()
    }
}
/// See [`QualityCheckStepMetadata`](crate::model::QualityCheckStepMetadata)
pub mod quality_check_step_metadata {

    /// A builder for [`QualityCheckStepMetadata`](crate::model::QualityCheckStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_type: std::option::Option<std::string::String>,
        pub(crate) baseline_used_for_drift_check_statistics:
            std::option::Option<std::string::String>,
        pub(crate) baseline_used_for_drift_check_constraints:
            std::option::Option<std::string::String>,
        pub(crate) calculated_baseline_statistics: std::option::Option<std::string::String>,
        pub(crate) calculated_baseline_constraints: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) violation_report: std::option::Option<std::string::String>,
        pub(crate) check_job_arn: std::option::Option<std::string::String>,
        pub(crate) skip_check: std::option::Option<bool>,
        pub(crate) register_new_baseline: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The type of the Quality check step.</p>
        pub fn check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_type = Some(input.into());
            self
        }
        /// <p>The type of the Quality check step.</p>
        pub fn set_check_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_type = input;
            self
        }
        /// <p>The Amazon S3 URI of the baseline statistics file used for the drift check.</p>
        pub fn baseline_used_for_drift_check_statistics(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_statistics = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the baseline statistics file used for the drift check.</p>
        pub fn set_baseline_used_for_drift_check_statistics(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_statistics = input;
            self
        }
        /// <p>The Amazon S3 URI of the baseline constraints file used for the drift check.</p>
        pub fn baseline_used_for_drift_check_constraints(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_constraints = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the baseline constraints file used for the drift check.</p>
        pub fn set_baseline_used_for_drift_check_constraints(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baseline_used_for_drift_check_constraints = input;
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline statistics file.</p>
        pub fn calculated_baseline_statistics(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.calculated_baseline_statistics = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline statistics file.</p>
        pub fn set_calculated_baseline_statistics(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calculated_baseline_statistics = input;
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
        pub fn calculated_baseline_constraints(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.calculated_baseline_constraints = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of the newly calculated baseline constraints file.</p>
        pub fn set_calculated_baseline_constraints(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calculated_baseline_constraints = input;
            self
        }
        /// <p>The model package group name.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The model package group name.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon S3 URI of violation report if violations are detected.</p>
        pub fn violation_report(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_report = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI of violation report if violations are detected.</p>
        pub fn set_violation_report(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_report = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Quality check processing job that was run by this step execution.</p>
        pub fn check_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Quality check processing job that was run by this step execution.</p>
        pub fn set_check_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.check_job_arn = input;
            self
        }
        /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
        pub fn skip_check(mut self, input: bool) -> Self {
            self.skip_check = Some(input);
            self
        }
        /// <p>This flag indicates if the drift check against the previous baseline will be skipped or not. If it is set to <code>False</code>, the previous baseline of the configured check type must be available.</p>
        pub fn set_skip_check(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_check = input;
            self
        }
        /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> and <code> BaselineUsedForDriftCheckStatistics</code> properties. </p>
        pub fn register_new_baseline(mut self, input: bool) -> Self {
            self.register_new_baseline = Some(input);
            self
        }
        /// <p>This flag indicates if a newly calculated baseline can be accessed through step properties <code>BaselineUsedForDriftCheckConstraints</code> and <code>BaselineUsedForDriftCheckStatistics</code>. If it is set to <code>False</code>, the previous baseline of the configured check type must also be available. These can be accessed through the <code>BaselineUsedForDriftCheckConstraints</code> and <code> BaselineUsedForDriftCheckStatistics</code> properties. </p>
        pub fn set_register_new_baseline(mut self, input: std::option::Option<bool>) -> Self {
            self.register_new_baseline = input;
            self
        }
        /// Consumes the builder and constructs a [`QualityCheckStepMetadata`](crate::model::QualityCheckStepMetadata)
        pub fn build(self) -> crate::model::QualityCheckStepMetadata {
            crate::model::QualityCheckStepMetadata {
                check_type: self.check_type,
                baseline_used_for_drift_check_statistics: self
                    .baseline_used_for_drift_check_statistics,
                baseline_used_for_drift_check_constraints: self
                    .baseline_used_for_drift_check_constraints,
                calculated_baseline_statistics: self.calculated_baseline_statistics,
                calculated_baseline_constraints: self.calculated_baseline_constraints,
                model_package_group_name: self.model_package_group_name,
                violation_report: self.violation_report,
                check_job_arn: self.check_job_arn,
                skip_check: self.skip_check.unwrap_or_default(),
                register_new_baseline: self.register_new_baseline.unwrap_or_default(),
            }
        }
    }
}
impl QualityCheckStepMetadata {
    /// Creates a new builder-style object to manufacture [`QualityCheckStepMetadata`](crate::model::QualityCheckStepMetadata)
    pub fn builder() -> crate::model::quality_check_step_metadata::Builder {
        crate::model::quality_check_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a Lambda step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LambdaStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A list of the output parameters of the Lambda step.</p>
    pub output_parameters: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
}
impl LambdaStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A list of the output parameters of the Lambda step.</p>
    pub fn output_parameters(&self) -> std::option::Option<&[crate::model::OutputParameter]> {
        self.output_parameters.as_deref()
    }
}
impl std::fmt::Debug for LambdaStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LambdaStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.field("output_parameters", &self.output_parameters);
        formatter.finish()
    }
}
/// See [`LambdaStepMetadata`](crate::model::LambdaStepMetadata)
pub mod lambda_step_metadata {

    /// A builder for [`LambdaStepMetadata`](crate::model::LambdaStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) output_parameters:
            std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `output_parameters`.
        ///
        /// To override the contents of this collection use [`set_output_parameters`](Self::set_output_parameters).
        ///
        /// <p>A list of the output parameters of the Lambda step.</p>
        pub fn output_parameters(mut self, input: crate::model::OutputParameter) -> Self {
            let mut v = self.output_parameters.unwrap_or_default();
            v.push(input);
            self.output_parameters = Some(v);
            self
        }
        /// <p>A list of the output parameters of the Lambda step.</p>
        pub fn set_output_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
        ) -> Self {
            self.output_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaStepMetadata`](crate::model::LambdaStepMetadata)
        pub fn build(self) -> crate::model::LambdaStepMetadata {
            crate::model::LambdaStepMetadata {
                arn: self.arn,
                output_parameters: self.output_parameters,
            }
        }
    }
}
impl LambdaStepMetadata {
    /// Creates a new builder-style object to manufacture [`LambdaStepMetadata`](crate::model::LambdaStepMetadata)
    pub fn builder() -> crate::model::lambda_step_metadata::Builder {
        crate::model::lambda_step_metadata::Builder::default()
    }
}

/// <p>Metadata about a callback step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CallbackStepMetadata {
    /// <p>The pipeline generated token from the Amazon SQS queue.</p>
    pub callback_token: std::option::Option<std::string::String>,
    /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
    pub sqs_queue_url: std::option::Option<std::string::String>,
    /// <p>A list of the output parameters of the callback step.</p>
    pub output_parameters: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
}
impl CallbackStepMetadata {
    /// <p>The pipeline generated token from the Amazon SQS queue.</p>
    pub fn callback_token(&self) -> std::option::Option<&str> {
        self.callback_token.as_deref()
    }
    /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
    pub fn sqs_queue_url(&self) -> std::option::Option<&str> {
        self.sqs_queue_url.as_deref()
    }
    /// <p>A list of the output parameters of the callback step.</p>
    pub fn output_parameters(&self) -> std::option::Option<&[crate::model::OutputParameter]> {
        self.output_parameters.as_deref()
    }
}
impl std::fmt::Debug for CallbackStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CallbackStepMetadata");
        formatter.field("callback_token", &self.callback_token);
        formatter.field("sqs_queue_url", &self.sqs_queue_url);
        formatter.field("output_parameters", &self.output_parameters);
        formatter.finish()
    }
}
/// See [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
pub mod callback_step_metadata {

    /// A builder for [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) callback_token: std::option::Option<std::string::String>,
        pub(crate) sqs_queue_url: std::option::Option<std::string::String>,
        pub(crate) output_parameters:
            std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
    }
    impl Builder {
        /// <p>The pipeline generated token from the Amazon SQS queue.</p>
        pub fn callback_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.callback_token = Some(input.into());
            self
        }
        /// <p>The pipeline generated token from the Amazon SQS queue.</p>
        pub fn set_callback_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.callback_token = input;
            self
        }
        /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
        pub fn sqs_queue_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.sqs_queue_url = Some(input.into());
            self
        }
        /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
        pub fn set_sqs_queue_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sqs_queue_url = input;
            self
        }
        /// Appends an item to `output_parameters`.
        ///
        /// To override the contents of this collection use [`set_output_parameters`](Self::set_output_parameters).
        ///
        /// <p>A list of the output parameters of the callback step.</p>
        pub fn output_parameters(mut self, input: crate::model::OutputParameter) -> Self {
            let mut v = self.output_parameters.unwrap_or_default();
            v.push(input);
            self.output_parameters = Some(v);
            self
        }
        /// <p>A list of the output parameters of the callback step.</p>
        pub fn set_output_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
        ) -> Self {
            self.output_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
        pub fn build(self) -> crate::model::CallbackStepMetadata {
            crate::model::CallbackStepMetadata {
                callback_token: self.callback_token,
                sqs_queue_url: self.sqs_queue_url,
                output_parameters: self.output_parameters,
            }
        }
    }
}
impl CallbackStepMetadata {
    /// Creates a new builder-style object to manufacture [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
    pub fn builder() -> crate::model::callback_step_metadata::Builder {
        crate::model::callback_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a Condition step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionStepMetadata {
    /// <p>The outcome of the Condition step evaluation.</p>
    pub outcome: std::option::Option<crate::model::ConditionOutcome>,
}
impl ConditionStepMetadata {
    /// <p>The outcome of the Condition step evaluation.</p>
    pub fn outcome(&self) -> std::option::Option<&crate::model::ConditionOutcome> {
        self.outcome.as_ref()
    }
}
impl std::fmt::Debug for ConditionStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionStepMetadata");
        formatter.field("outcome", &self.outcome);
        formatter.finish()
    }
}
/// See [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
pub mod condition_step_metadata {

    /// A builder for [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outcome: std::option::Option<crate::model::ConditionOutcome>,
    }
    impl Builder {
        /// <p>The outcome of the Condition step evaluation.</p>
        pub fn outcome(mut self, input: crate::model::ConditionOutcome) -> Self {
            self.outcome = Some(input);
            self
        }
        /// <p>The outcome of the Condition step evaluation.</p>
        pub fn set_outcome(
            mut self,
            input: std::option::Option<crate::model::ConditionOutcome>,
        ) -> Self {
            self.outcome = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
        pub fn build(self) -> crate::model::ConditionStepMetadata {
            crate::model::ConditionStepMetadata {
                outcome: self.outcome,
            }
        }
    }
}
impl ConditionStepMetadata {
    /// Creates a new builder-style object to manufacture [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
    pub fn builder() -> crate::model::condition_step_metadata::Builder {
        crate::model::condition_step_metadata::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionOutcome {
    #[allow(missing_docs)] // documentation missing in model
    False,
    #[allow(missing_docs)] // documentation missing in model
    True,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConditionOutcome {
    fn from(s: &str) -> Self {
        match s {
            "False" => ConditionOutcome::False,
            "True" => ConditionOutcome::True,
            other => ConditionOutcome::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConditionOutcome {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConditionOutcome::from(s))
    }
}
impl ConditionOutcome {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConditionOutcome::False => "False",
            ConditionOutcome::True => "True",
            ConditionOutcome::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["False", "True"]
    }
}
impl AsRef<str> for ConditionOutcome {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metadata for a register model job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl RegisterModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for RegisterModelStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterModelStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
pub mod register_model_step_metadata {

    /// A builder for [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
        pub fn build(self) -> crate::model::RegisterModelStepMetadata {
            crate::model::RegisterModelStepMetadata { arn: self.arn }
        }
    }
}
impl RegisterModelStepMetadata {
    /// Creates a new builder-style object to manufacture [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
    pub fn builder() -> crate::model::register_model_step_metadata::Builder {
        crate::model::register_model_step_metadata::Builder::default()
    }
}

/// <p>Metadata for Model steps.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the created model.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl ModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the created model.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for ModelStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`ModelStepMetadata`](crate::model::ModelStepMetadata)
pub mod model_step_metadata {

    /// A builder for [`ModelStepMetadata`](crate::model::ModelStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the created model.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the created model.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelStepMetadata`](crate::model::ModelStepMetadata)
        pub fn build(self) -> crate::model::ModelStepMetadata {
            crate::model::ModelStepMetadata { arn: self.arn }
        }
    }
}
impl ModelStepMetadata {
    /// Creates a new builder-style object to manufacture [`ModelStepMetadata`](crate::model::ModelStepMetadata)
    pub fn builder() -> crate::model::model_step_metadata::Builder {
        crate::model::model_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a tuning step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TuningJobStepMetaData {
    /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl TuningJobStepMetaData {
    /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for TuningJobStepMetaData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TuningJobStepMetaData");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TuningJobStepMetaData`](crate::model::TuningJobStepMetaData)
pub mod tuning_job_step_meta_data {

    /// A builder for [`TuningJobStepMetaData`](crate::model::TuningJobStepMetaData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TuningJobStepMetaData`](crate::model::TuningJobStepMetaData)
        pub fn build(self) -> crate::model::TuningJobStepMetaData {
            crate::model::TuningJobStepMetaData { arn: self.arn }
        }
    }
}
impl TuningJobStepMetaData {
    /// Creates a new builder-style object to manufacture [`TuningJobStepMetaData`](crate::model::TuningJobStepMetaData)
    pub fn builder() -> crate::model::tuning_job_step_meta_data::Builder {
        crate::model::tuning_job_step_meta_data::Builder::default()
    }
}

/// <p>Metadata for a transform job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl TransformJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for TransformJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
pub mod transform_job_step_metadata {

    /// A builder for [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
        pub fn build(self) -> crate::model::TransformJobStepMetadata {
            crate::model::TransformJobStepMetadata { arn: self.arn }
        }
    }
}
impl TransformJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
    pub fn builder() -> crate::model::transform_job_step_metadata::Builder {
        crate::model::transform_job_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a processing job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl ProcessingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for ProcessingJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
pub mod processing_job_step_metadata {

    /// A builder for [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
        pub fn build(self) -> crate::model::ProcessingJobStepMetadata {
            crate::model::ProcessingJobStepMetadata { arn: self.arn }
        }
    }
}
impl ProcessingJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
    pub fn builder() -> crate::model::processing_job_step_metadata::Builder {
        crate::model::processing_job_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a training job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl TrainingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for TrainingJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
pub mod training_job_step_metadata {

    /// A builder for [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
        pub fn build(self) -> crate::model::TrainingJobStepMetadata {
            crate::model::TrainingJobStepMetadata { arn: self.arn }
        }
    }
}
impl TrainingJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
    pub fn builder() -> crate::model::training_job_step_metadata::Builder {
        crate::model::training_job_step_metadata::Builder::default()
    }
}

/// <p>Details on the cache hit of a pipeline execution step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheHitResult {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub source_pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl CacheHitResult {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub fn source_pipeline_execution_arn(&self) -> std::option::Option<&str> {
        self.source_pipeline_execution_arn.as_deref()
    }
}
impl std::fmt::Debug for CacheHitResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheHitResult");
        formatter.field(
            "source_pipeline_execution_arn",
            &self.source_pipeline_execution_arn,
        );
        formatter.finish()
    }
}
/// See [`CacheHitResult`](crate::model::CacheHitResult)
pub mod cache_hit_result {

    /// A builder for [`CacheHitResult`](crate::model::CacheHitResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_pipeline_execution_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn source_pipeline_execution_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.source_pipeline_execution_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn set_source_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_pipeline_execution_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheHitResult`](crate::model::CacheHitResult)
        pub fn build(self) -> crate::model::CacheHitResult {
            crate::model::CacheHitResult {
                source_pipeline_execution_arn: self.source_pipeline_execution_arn,
            }
        }
    }
}
impl CacheHitResult {
    /// Creates a new builder-style object to manufacture [`CacheHitResult`](crate::model::CacheHitResult)
    pub fn builder() -> crate::model::cache_hit_result::Builder {
        crate::model::cache_hit_result::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepStatus {
    #[allow(missing_docs)] // documentation missing in model
    Executing,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StepStatus {
    fn from(s: &str) -> Self {
        match s {
            "Executing" => StepStatus::Executing,
            "Failed" => StepStatus::Failed,
            "Starting" => StepStatus::Starting,
            "Stopped" => StepStatus::Stopped,
            "Stopping" => StepStatus::Stopping,
            "Succeeded" => StepStatus::Succeeded,
            other => StepStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StepStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StepStatus::from(s))
    }
}
impl StepStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StepStatus::Executing => "Executing",
            StepStatus::Failed => "Failed",
            StepStatus::Starting => "Starting",
            StepStatus::Stopped => "Stopped",
            StepStatus::Stopping => "Stopping",
            StepStatus::Succeeded => "Succeeded",
            StepStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Executing",
            "Failed",
            "Starting",
            "Stopped",
            "Stopping",
            "Succeeded",
        ]
    }
}
impl AsRef<str> for StepStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A pipeline execution summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionSummary {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
    /// <p>The start time of the pipeline execution.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the pipeline execution.</p>
    pub pipeline_execution_status: std::option::Option<crate::model::PipelineExecutionStatus>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: std::option::Option<std::string::String>,
    /// <p>A message generated by SageMaker Pipelines describing why the pipeline execution failed.</p>
    pub pipeline_execution_failure_reason: std::option::Option<std::string::String>,
}
impl PipelineExecutionSummary {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub fn pipeline_execution_arn(&self) -> std::option::Option<&str> {
        self.pipeline_execution_arn.as_deref()
    }
    /// <p>The start time of the pipeline execution.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The status of the pipeline execution.</p>
    pub fn pipeline_execution_status(
        &self,
    ) -> std::option::Option<&crate::model::PipelineExecutionStatus> {
        self.pipeline_execution_status.as_ref()
    }
    /// <p>The description of the pipeline execution.</p>
    pub fn pipeline_execution_description(&self) -> std::option::Option<&str> {
        self.pipeline_execution_description.as_deref()
    }
    /// <p>The display name of the pipeline execution.</p>
    pub fn pipeline_execution_display_name(&self) -> std::option::Option<&str> {
        self.pipeline_execution_display_name.as_deref()
    }
    /// <p>A message generated by SageMaker Pipelines describing why the pipeline execution failed.</p>
    pub fn pipeline_execution_failure_reason(&self) -> std::option::Option<&str> {
        self.pipeline_execution_failure_reason.as_deref()
    }
}
impl std::fmt::Debug for PipelineExecutionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionSummary");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field("start_time", &self.start_time);
        formatter.field("pipeline_execution_status", &self.pipeline_execution_status);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.field(
            "pipeline_execution_failure_reason",
            &self.pipeline_execution_failure_reason,
        );
        formatter.finish()
    }
}
/// See [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
pub mod pipeline_execution_summary {

    /// A builder for [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_execution_arn: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) pipeline_execution_status:
            std::option::Option<crate::model::PipelineExecutionStatus>,
        pub(crate) pipeline_execution_description: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn pipeline_execution_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_execution_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn set_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_arn = input;
            self
        }
        /// <p>The start time of the pipeline execution.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the pipeline execution.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The status of the pipeline execution.</p>
        pub fn pipeline_execution_status(
            mut self,
            input: crate::model::PipelineExecutionStatus,
        ) -> Self {
            self.pipeline_execution_status = Some(input);
            self
        }
        /// <p>The status of the pipeline execution.</p>
        pub fn set_pipeline_execution_status(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStatus>,
        ) -> Self {
            self.pipeline_execution_status = input;
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn pipeline_execution_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = Some(input.into());
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn set_pipeline_execution_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = input;
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn pipeline_execution_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn set_pipeline_execution_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = input;
            self
        }
        /// <p>A message generated by SageMaker Pipelines describing why the pipeline execution failed.</p>
        pub fn pipeline_execution_failure_reason(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_failure_reason = Some(input.into());
            self
        }
        /// <p>A message generated by SageMaker Pipelines describing why the pipeline execution failed.</p>
        pub fn set_pipeline_execution_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
        pub fn build(self) -> crate::model::PipelineExecutionSummary {
            crate::model::PipelineExecutionSummary {
                pipeline_execution_arn: self.pipeline_execution_arn,
                start_time: self.start_time,
                pipeline_execution_status: self.pipeline_execution_status,
                pipeline_execution_description: self.pipeline_execution_description,
                pipeline_execution_display_name: self.pipeline_execution_display_name,
                pipeline_execution_failure_reason: self.pipeline_execution_failure_reason,
            }
        }
    }
}
impl PipelineExecutionSummary {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
    pub fn builder() -> crate::model::pipeline_execution_summary::Builder {
        crate::model::pipeline_execution_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortPipelineExecutionsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    PipelineExecutionArn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortPipelineExecutionsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortPipelineExecutionsBy::CreationTime,
            "PipelineExecutionArn" => SortPipelineExecutionsBy::PipelineExecutionArn,
            other => SortPipelineExecutionsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortPipelineExecutionsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortPipelineExecutionsBy::from(s))
    }
}
impl SortPipelineExecutionsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortPipelineExecutionsBy::CreationTime => "CreationTime",
            SortPipelineExecutionsBy::PipelineExecutionArn => "PipelineExecutionArn",
            SortPipelineExecutionsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "PipelineExecutionArn"]
    }
}
impl AsRef<str> for SortPipelineExecutionsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an SageMaker notebook instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceSummary {
    /// <p>The name of the notebook instance that you want a summary for.</p>
    pub notebook_instance_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
    pub notebook_instance_arn: std::option::Option<std::string::String>,
    /// <p>The status of the notebook instance.</p>
    pub notebook_instance_status: std::option::Option<crate::model::NotebookInstanceStatus>,
    /// <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The type of ML compute instance that the notebook instance is running on.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>A timestamp that shows when the notebook instance was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that shows when the notebook instance was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p>
    /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
    pub default_code_repository: std::option::Option<std::string::String>,
    /// <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
    pub additional_code_repositories: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl NotebookInstanceSummary {
    /// <p>The name of the notebook instance that you want a summary for.</p>
    pub fn notebook_instance_name(&self) -> std::option::Option<&str> {
        self.notebook_instance_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
    pub fn notebook_instance_arn(&self) -> std::option::Option<&str> {
        self.notebook_instance_arn.as_deref()
    }
    /// <p>The status of the notebook instance.</p>
    pub fn notebook_instance_status(
        &self,
    ) -> std::option::Option<&crate::model::NotebookInstanceStatus> {
        self.notebook_instance_status.as_ref()
    }
    /// <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The type of ML compute instance that the notebook instance is running on.</p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::InstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>A timestamp that shows when the notebook instance was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that shows when the notebook instance was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p>
    /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
    pub fn notebook_instance_lifecycle_config_name(&self) -> std::option::Option<&str> {
        self.notebook_instance_lifecycle_config_name.as_deref()
    }
    /// <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
    pub fn default_code_repository(&self) -> std::option::Option<&str> {
        self.default_code_repository.as_deref()
    }
    /// <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
    pub fn additional_code_repositories(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_code_repositories.as_deref()
    }
}
impl std::fmt::Debug for NotebookInstanceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceSummary");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field("notebook_instance_arn", &self.notebook_instance_arn);
        formatter.field("notebook_instance_status", &self.notebook_instance_status);
        formatter.field("url", &self.url);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("default_code_repository", &self.default_code_repository);
        formatter.field(
            "additional_code_repositories",
            &self.additional_code_repositories,
        );
        formatter.finish()
    }
}
/// See [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
pub mod notebook_instance_summary {

    /// A builder for [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_instance_name: std::option::Option<std::string::String>,
        pub(crate) notebook_instance_arn: std::option::Option<std::string::String>,
        pub(crate) notebook_instance_status:
            std::option::Option<crate::model::NotebookInstanceStatus>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) notebook_instance_lifecycle_config_name:
            std::option::Option<std::string::String>,
        pub(crate) default_code_repository: std::option::Option<std::string::String>,
        pub(crate) additional_code_repositories:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the notebook instance that you want a summary for.</p>
        pub fn notebook_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_instance_name = Some(input.into());
            self
        }
        /// <p>The name of the notebook instance that you want a summary for.</p>
        pub fn set_notebook_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
        pub fn notebook_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_instance_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
        pub fn set_notebook_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_arn = input;
            self
        }
        /// <p>The status of the notebook instance.</p>
        pub fn notebook_instance_status(
            mut self,
            input: crate::model::NotebookInstanceStatus,
        ) -> Self {
            self.notebook_instance_status = Some(input);
            self
        }
        /// <p>The status of the notebook instance.</p>
        pub fn set_notebook_instance_status(
            mut self,
            input: std::option::Option<crate::model::NotebookInstanceStatus>,
        ) -> Self {
            self.notebook_instance_status = input;
            self
        }
        /// <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The type of ML compute instance that the notebook instance is running on.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The type of ML compute instance that the notebook instance is running on.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>A timestamp that shows when the notebook instance was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the notebook instance was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the notebook instance was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the notebook instance was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p>
        /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
        pub fn notebook_instance_lifecycle_config_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = Some(input.into());
            self
        }
        /// <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p>
        /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
        pub fn set_notebook_instance_lifecycle_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = input;
            self
        }
        /// <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        pub fn default_code_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_code_repository = Some(input.into());
            self
        }
        /// <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        pub fn set_default_code_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_code_repository = input;
            self
        }
        /// Appends an item to `additional_code_repositories`.
        ///
        /// To override the contents of this collection use [`set_additional_code_repositories`](Self::set_additional_code_repositories).
        ///
        /// <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        pub fn additional_code_repositories(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.additional_code_repositories.unwrap_or_default();
            v.push(input.into());
            self.additional_code_repositories = Some(v);
            self
        }
        /// <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        pub fn set_additional_code_repositories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.additional_code_repositories = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
        pub fn build(self) -> crate::model::NotebookInstanceSummary {
            crate::model::NotebookInstanceSummary {
                notebook_instance_name: self.notebook_instance_name,
                notebook_instance_arn: self.notebook_instance_arn,
                notebook_instance_status: self.notebook_instance_status,
                url: self.url,
                instance_type: self.instance_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                notebook_instance_lifecycle_config_name: self
                    .notebook_instance_lifecycle_config_name,
                default_code_repository: self.default_code_repository,
                additional_code_repositories: self.additional_code_repositories,
            }
        }
    }
}
impl NotebookInstanceSummary {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
    pub fn builder() -> crate::model::notebook_instance_summary::Builder {
        crate::model::notebook_instance_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "Deleting" => NotebookInstanceStatus::Deleting,
            "Failed" => NotebookInstanceStatus::Failed,
            "InService" => NotebookInstanceStatus::InService,
            "Pending" => NotebookInstanceStatus::Pending,
            "Stopped" => NotebookInstanceStatus::Stopped,
            "Stopping" => NotebookInstanceStatus::Stopping,
            "Updating" => NotebookInstanceStatus::Updating,
            other => NotebookInstanceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceStatus::from(s))
    }
}
impl NotebookInstanceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceStatus::Deleting => "Deleting",
            NotebookInstanceStatus::Failed => "Failed",
            NotebookInstanceStatus::InService => "InService",
            NotebookInstanceStatus::Pending => "Pending",
            NotebookInstanceStatus::Stopped => "Stopped",
            NotebookInstanceStatus::Stopping => "Stopping",
            NotebookInstanceStatus::Updating => "Updating",
            NotebookInstanceStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Stopped",
            "Stopping",
            "Updating",
        ]
    }
}
impl AsRef<str> for NotebookInstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => NotebookInstanceSortOrder::Ascending,
            "Descending" => NotebookInstanceSortOrder::Descending,
            other => NotebookInstanceSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceSortOrder::from(s))
    }
}
impl NotebookInstanceSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceSortOrder::Ascending => "Ascending",
            NotebookInstanceSortOrder::Descending => "Descending",
            NotebookInstanceSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for NotebookInstanceSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => NotebookInstanceSortKey::CreationTime,
            "Name" => NotebookInstanceSortKey::Name,
            "Status" => NotebookInstanceSortKey::Status,
            other => NotebookInstanceSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceSortKey::from(s))
    }
}
impl NotebookInstanceSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceSortKey::CreationTime => "CreationTime",
            NotebookInstanceSortKey::Name => "Name",
            NotebookInstanceSortKey::Status => "Status",
            NotebookInstanceSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for NotebookInstanceSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of a notebook instance lifecycle configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceLifecycleConfigSummary {
    /// <p>The name of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl NotebookInstanceLifecycleConfigSummary {
    /// <p>The name of the lifecycle configuration.</p>
    pub fn notebook_instance_lifecycle_config_name(&self) -> std::option::Option<&str> {
        self.notebook_instance_lifecycle_config_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
    pub fn notebook_instance_lifecycle_config_arn(&self) -> std::option::Option<&str> {
        self.notebook_instance_lifecycle_config_arn.as_deref()
    }
    /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for NotebookInstanceLifecycleConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceLifecycleConfigSummary");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field(
            "notebook_instance_lifecycle_config_arn",
            &self.notebook_instance_lifecycle_config_arn,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
pub mod notebook_instance_lifecycle_config_summary {

    /// A builder for [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_instance_lifecycle_config_name:
            std::option::Option<std::string::String>,
        pub(crate) notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the lifecycle configuration.</p>
        pub fn notebook_instance_lifecycle_config_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = Some(input.into());
            self
        }
        /// <p>The name of the lifecycle configuration.</p>
        pub fn set_notebook_instance_lifecycle_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
        pub fn notebook_instance_lifecycle_config_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
        pub fn set_notebook_instance_lifecycle_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_arn = input;
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
        pub fn build(self) -> crate::model::NotebookInstanceLifecycleConfigSummary {
            crate::model::NotebookInstanceLifecycleConfigSummary {
                notebook_instance_lifecycle_config_name: self
                    .notebook_instance_lifecycle_config_name,
                notebook_instance_lifecycle_config_arn: self.notebook_instance_lifecycle_config_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl NotebookInstanceLifecycleConfigSummary {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
    pub fn builder() -> crate::model::notebook_instance_lifecycle_config_summary::Builder {
        crate::model::notebook_instance_lifecycle_config_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceLifecycleConfigSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceLifecycleConfigSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => NotebookInstanceLifecycleConfigSortOrder::Ascending,
            "Descending" => NotebookInstanceLifecycleConfigSortOrder::Descending,
            other => NotebookInstanceLifecycleConfigSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceLifecycleConfigSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceLifecycleConfigSortOrder::from(s))
    }
}
impl NotebookInstanceLifecycleConfigSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceLifecycleConfigSortOrder::Ascending => "Ascending",
            NotebookInstanceLifecycleConfigSortOrder::Descending => "Descending",
            NotebookInstanceLifecycleConfigSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for NotebookInstanceLifecycleConfigSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceLifecycleConfigSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceLifecycleConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => NotebookInstanceLifecycleConfigSortKey::CreationTime,
            "LastModifiedTime" => NotebookInstanceLifecycleConfigSortKey::LastModifiedTime,
            "Name" => NotebookInstanceLifecycleConfigSortKey::Name,
            other => NotebookInstanceLifecycleConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceLifecycleConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceLifecycleConfigSortKey::from(s))
    }
}
impl NotebookInstanceLifecycleConfigSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceLifecycleConfigSortKey::CreationTime => "CreationTime",
            NotebookInstanceLifecycleConfigSortKey::LastModifiedTime => "LastModifiedTime",
            NotebookInstanceLifecycleConfigSortKey::Name => "Name",
            NotebookInstanceLifecycleConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for NotebookInstanceLifecycleConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summarizes the monitoring schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringScheduleSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the monitoring schedule.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the monitoring schedule was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the monitoring schedule.</p>
    pub monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
    /// <p>The name of the endpoint using the monitoring schedule.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring job definition that the schedule is for.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job definition that the schedule is for.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl MonitoringScheduleSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub fn monitoring_schedule_name(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub fn monitoring_schedule_arn(&self) -> std::option::Option<&str> {
        self.monitoring_schedule_arn.as_deref()
    }
    /// <p>The creation time of the monitoring schedule.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the monitoring schedule was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the monitoring schedule.</p>
    pub fn monitoring_schedule_status(&self) -> std::option::Option<&crate::model::ScheduleStatus> {
        self.monitoring_schedule_status.as_ref()
    }
    /// <p>The name of the endpoint using the monitoring schedule.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The name of the monitoring job definition that the schedule is for.</p>
    pub fn monitoring_job_definition_name(&self) -> std::option::Option<&str> {
        self.monitoring_job_definition_name.as_deref()
    }
    /// <p>The type of the monitoring job definition that the schedule is for.</p>
    pub fn monitoring_type(&self) -> std::option::Option<&crate::model::MonitoringType> {
        self.monitoring_type.as_ref()
    }
}
impl std::fmt::Debug for MonitoringScheduleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringScheduleSummary");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_schedule_status",
            &self.monitoring_schedule_status,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
pub mod monitoring_schedule_summary {

    /// A builder for [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The creation time of the monitoring schedule.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the monitoring schedule.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the monitoring schedule was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time the monitoring schedule was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the monitoring schedule.</p>
        pub fn monitoring_schedule_status(mut self, input: crate::model::ScheduleStatus) -> Self {
            self.monitoring_schedule_status = Some(input);
            self
        }
        /// <p>The status of the monitoring schedule.</p>
        pub fn set_monitoring_schedule_status(
            mut self,
            input: std::option::Option<crate::model::ScheduleStatus>,
        ) -> Self {
            self.monitoring_schedule_status = input;
            self
        }
        /// <p>The name of the endpoint using the monitoring schedule.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint using the monitoring schedule.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The name of the monitoring job definition that the schedule is for.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring job definition that the schedule is for.</p>
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job definition that the schedule is for.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        /// <p>The type of the monitoring job definition that the schedule is for.</p>
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
        pub fn build(self) -> crate::model::MonitoringScheduleSummary {
            crate::model::MonitoringScheduleSummary {
                monitoring_schedule_name: self.monitoring_schedule_name,
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedule_status: self.monitoring_schedule_status,
                endpoint_name: self.endpoint_name,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringScheduleSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
    pub fn builder() -> crate::model::monitoring_schedule_summary::Builder {
        crate::model::monitoring_schedule_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringScheduleSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringScheduleSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringScheduleSortKey::CreationTime,
            "Name" => MonitoringScheduleSortKey::Name,
            "Status" => MonitoringScheduleSortKey::Status,
            other => MonitoringScheduleSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringScheduleSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringScheduleSortKey::from(s))
    }
}
impl MonitoringScheduleSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringScheduleSortKey::CreationTime => "CreationTime",
            MonitoringScheduleSortKey::Name => "Name",
            MonitoringScheduleSortKey::Status => "Status",
            MonitoringScheduleSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for MonitoringScheduleSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringExecutionSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledTime,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringExecutionSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringExecutionSortKey::CreationTime,
            "ScheduledTime" => MonitoringExecutionSortKey::ScheduledTime,
            "Status" => MonitoringExecutionSortKey::Status,
            other => MonitoringExecutionSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringExecutionSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringExecutionSortKey::from(s))
    }
}
impl MonitoringExecutionSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringExecutionSortKey::CreationTime => "CreationTime",
            MonitoringExecutionSortKey::ScheduledTime => "ScheduledTime",
            MonitoringExecutionSortKey::Status => "Status",
            MonitoringExecutionSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "ScheduledTime", "Status"]
    }
}
impl AsRef<str> for MonitoringExecutionSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelSummary {
    /// <p>The name of the model that you want a summary for.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that indicates when the model was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ModelSummary {
    /// <p>The name of the model that you want a summary for.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
    /// <p>A timestamp that indicates when the model was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for ModelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelSummary");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_arn", &self.model_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`ModelSummary`](crate::model::ModelSummary)
pub mod model_summary {

    /// A builder for [`ModelSummary`](crate::model::ModelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the model that you want a summary for.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model that you want a summary for.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>A timestamp that indicates when the model was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that indicates when the model was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelSummary`](crate::model::ModelSummary)
        pub fn build(self) -> crate::model::ModelSummary {
            crate::model::ModelSummary {
                model_name: self.model_name,
                model_arn: self.model_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl ModelSummary {
    /// Creates a new builder-style object to manufacture [`ModelSummary`](crate::model::ModelSummary)
    pub fn builder() -> crate::model::model_summary::Builder {
        crate::model::model_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderKey {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OrderKey {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => OrderKey::Ascending,
            "Descending" => OrderKey::Descending,
            other => OrderKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OrderKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderKey::from(s))
    }
}
impl OrderKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderKey::Ascending => "Ascending",
            OrderKey::Descending => "Descending",
            OrderKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for OrderKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelSortKey::CreationTime,
            "Name" => ModelSortKey::Name,
            other => ModelSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelSortKey::from(s))
    }
}
impl ModelSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelSortKey::CreationTime => "CreationTime",
            ModelSortKey::Name => "Name",
            ModelSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringJobDefinitionSummary {
    /// <p>The name of the monitoring job.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub monitoring_job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The time that the monitoring job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the endpoint that the job monitors.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl MonitoringJobDefinitionSummary {
    /// <p>The name of the monitoring job.</p>
    pub fn monitoring_job_definition_name(&self) -> std::option::Option<&str> {
        self.monitoring_job_definition_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub fn monitoring_job_definition_arn(&self) -> std::option::Option<&str> {
        self.monitoring_job_definition_arn.as_deref()
    }
    /// <p>The time that the monitoring job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The name of the endpoint that the job monitors.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
}
impl std::fmt::Debug for MonitoringJobDefinitionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringJobDefinitionSummary");
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field(
            "monitoring_job_definition_arn",
            &self.monitoring_job_definition_arn,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
pub mod monitoring_job_definition_summary {

    /// A builder for [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the monitoring job.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        /// <p>The name of the monitoring job.</p>
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn monitoring_job_definition_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn set_monitoring_job_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_arn = input;
            self
        }
        /// <p>The time that the monitoring job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the monitoring job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The name of the endpoint that the job monitors.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint that the job monitors.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
        pub fn build(self) -> crate::model::MonitoringJobDefinitionSummary {
            crate::model::MonitoringJobDefinitionSummary {
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_job_definition_arn: self.monitoring_job_definition_arn,
                creation_time: self.creation_time,
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl MonitoringJobDefinitionSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
    pub fn builder() -> crate::model::monitoring_job_definition_summary::Builder {
        crate::model::monitoring_job_definition_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringJobDefinitionSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringJobDefinitionSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringJobDefinitionSortKey::CreationTime,
            "Name" => MonitoringJobDefinitionSortKey::Name,
            other => MonitoringJobDefinitionSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringJobDefinitionSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringJobDefinitionSortKey::from(s))
    }
}
impl MonitoringJobDefinitionSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringJobDefinitionSortKey::CreationTime => "CreationTime",
            MonitoringJobDefinitionSortKey::Name => "Name",
            MonitoringJobDefinitionSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for MonitoringJobDefinitionSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageSummary {
    /// <p>The name of the model package.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>If the model package is a versioned model, the model group that the versioned model belongs to.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>If the model package is a versioned model, the version of the model.</p>
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the model package.</p>
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the model package was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The overall status of the model package.</p>
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
    /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
    /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
    /// </ul>
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
}
impl ModelPackageSummary {
    /// <p>The name of the model package.</p>
    pub fn model_package_name(&self) -> std::option::Option<&str> {
        self.model_package_name.as_deref()
    }
    /// <p>If the model package is a versioned model, the model group that the versioned model belongs to.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>If the model package is a versioned model, the version of the model.</p>
    pub fn model_package_version(&self) -> std::option::Option<i32> {
        self.model_package_version
    }
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub fn model_package_arn(&self) -> std::option::Option<&str> {
        self.model_package_arn.as_deref()
    }
    /// <p>A brief description of the model package.</p>
    pub fn model_package_description(&self) -> std::option::Option<&str> {
        self.model_package_description.as_deref()
    }
    /// <p>A timestamp that shows when the model package was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The overall status of the model package.</p>
    pub fn model_package_status(&self) -> std::option::Option<&crate::model::ModelPackageStatus> {
        self.model_package_status.as_ref()
    }
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
    /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
    /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
    /// </ul>
    pub fn model_approval_status(&self) -> std::option::Option<&crate::model::ModelApprovalStatus> {
        self.model_approval_status.as_ref()
    }
}
impl std::fmt::Debug for ModelPackageSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageSummary");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.finish()
    }
}
/// See [`ModelPackageSummary`](crate::model::ModelPackageSummary)
pub mod model_package_summary {

    /// A builder for [`ModelPackageSummary`](crate::model::ModelPackageSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_version: std::option::Option<i32>,
        pub(crate) model_package_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
        pub(crate) model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    }
    impl Builder {
        /// <p>The name of the model package.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        /// <p>The name of the model package.</p>
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>If the model package is a versioned model, the model group that the versioned model belongs to.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>If the model package is a versioned model, the model group that the versioned model belongs to.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>If the model package is a versioned model, the version of the model.</p>
        pub fn model_package_version(mut self, input: i32) -> Self {
            self.model_package_version = Some(input);
            self
        }
        /// <p>If the model package is a versioned model, the version of the model.</p>
        pub fn set_model_package_version(mut self, input: std::option::Option<i32>) -> Self {
            self.model_package_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn model_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn set_model_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_arn = input;
            self
        }
        /// <p>A brief description of the model package.</p>
        pub fn model_package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_description = Some(input.into());
            self
        }
        /// <p>A brief description of the model package.</p>
        pub fn set_model_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_description = input;
            self
        }
        /// <p>A timestamp that shows when the model package was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the model package was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The overall status of the model package.</p>
        pub fn model_package_status(mut self, input: crate::model::ModelPackageStatus) -> Self {
            self.model_package_status = Some(input);
            self
        }
        /// <p>The overall status of the model package.</p>
        pub fn set_model_package_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatus>,
        ) -> Self {
            self.model_package_status = input;
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
        /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
        /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
        /// </ul>
        pub fn model_approval_status(mut self, input: crate::model::ModelApprovalStatus) -> Self {
            self.model_approval_status = Some(input);
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li> <p> <code>APPROVED</code> - The model is approved</p> </li>
        /// <li> <p> <code>REJECTED</code> - The model is rejected.</p> </li>
        /// <li> <p> <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual approval.</p> </li>
        /// </ul>
        pub fn set_model_approval_status(
            mut self,
            input: std::option::Option<crate::model::ModelApprovalStatus>,
        ) -> Self {
            self.model_approval_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageSummary`](crate::model::ModelPackageSummary)
        pub fn build(self) -> crate::model::ModelPackageSummary {
            crate::model::ModelPackageSummary {
                model_package_name: self.model_package_name,
                model_package_group_name: self.model_package_group_name,
                model_package_version: self.model_package_version,
                model_package_arn: self.model_package_arn,
                model_package_description: self.model_package_description,
                creation_time: self.creation_time,
                model_package_status: self.model_package_status,
                model_approval_status: self.model_approval_status,
            }
        }
    }
}
impl ModelPackageSummary {
    /// Creates a new builder-style object to manufacture [`ModelPackageSummary`](crate::model::ModelPackageSummary)
    pub fn builder() -> crate::model::model_package_summary::Builder {
        crate::model::model_package_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelPackageSortBy::CreationTime,
            "Name" => ModelPackageSortBy::Name,
            other => ModelPackageSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageSortBy::from(s))
    }
}
impl ModelPackageSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageSortBy::CreationTime => "CreationTime",
            ModelPackageSortBy::Name => "Name",
            ModelPackageSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelPackageSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageType {
    #[allow(missing_docs)] // documentation missing in model
    Both,
    #[allow(missing_docs)] // documentation missing in model
    Unversioned,
    #[allow(missing_docs)] // documentation missing in model
    Versioned,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageType {
    fn from(s: &str) -> Self {
        match s {
            "Both" => ModelPackageType::Both,
            "Unversioned" => ModelPackageType::Unversioned,
            "Versioned" => ModelPackageType::Versioned,
            other => ModelPackageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageType::from(s))
    }
}
impl ModelPackageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageType::Both => "Both",
            ModelPackageType::Unversioned => "Unversioned",
            ModelPackageType::Versioned => "Versioned",
            ModelPackageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Both", "Unversioned", "Versioned"]
    }
}
impl AsRef<str> for ModelPackageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a model group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageGroupSummary {
    /// <p>The name of the model group.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub model_package_group_arn: std::option::Option<std::string::String>,
    /// <p>A description of the model group.</p>
    pub model_package_group_description: std::option::Option<std::string::String>,
    /// <p>The time that the model group was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the model group.</p>
    pub model_package_group_status: std::option::Option<crate::model::ModelPackageGroupStatus>,
}
impl ModelPackageGroupSummary {
    /// <p>The name of the model group.</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub fn model_package_group_arn(&self) -> std::option::Option<&str> {
        self.model_package_group_arn.as_deref()
    }
    /// <p>A description of the model group.</p>
    pub fn model_package_group_description(&self) -> std::option::Option<&str> {
        self.model_package_group_description.as_deref()
    }
    /// <p>The time that the model group was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The status of the model group.</p>
    pub fn model_package_group_status(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackageGroupStatus> {
        self.model_package_group_status.as_ref()
    }
}
impl std::fmt::Debug for ModelPackageGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageGroupSummary");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "model_package_group_status",
            &self.model_package_group_status,
        );
        formatter.finish()
    }
}
/// See [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
pub mod model_package_group_summary {

    /// A builder for [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_group_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) model_package_group_status:
            std::option::Option<crate::model::ModelPackageGroupStatus>,
    }
    impl Builder {
        /// <p>The name of the model group.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The name of the model group.</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn model_package_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn set_model_package_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_arn = input;
            self
        }
        /// <p>A description of the model group.</p>
        pub fn model_package_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_package_group_description = Some(input.into());
            self
        }
        /// <p>A description of the model group.</p>
        pub fn set_model_package_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_description = input;
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of the model group.</p>
        pub fn model_package_group_status(
            mut self,
            input: crate::model::ModelPackageGroupStatus,
        ) -> Self {
            self.model_package_group_status = Some(input);
            self
        }
        /// <p>The status of the model group.</p>
        pub fn set_model_package_group_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroupStatus>,
        ) -> Self {
            self.model_package_group_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
        pub fn build(self) -> crate::model::ModelPackageGroupSummary {
            crate::model::ModelPackageGroupSummary {
                model_package_group_name: self.model_package_group_name,
                model_package_group_arn: self.model_package_group_arn,
                model_package_group_description: self.model_package_group_description,
                creation_time: self.creation_time,
                model_package_group_status: self.model_package_group_status,
            }
        }
    }
}
impl ModelPackageGroupSummary {
    /// Creates a new builder-style object to manufacture [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
    pub fn builder() -> crate::model::model_package_group_summary::Builder {
        crate::model::model_package_group_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageGroupSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageGroupSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelPackageGroupSortBy::CreationTime,
            "Name" => ModelPackageGroupSortBy::Name,
            other => ModelPackageGroupSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageGroupSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageGroupSortBy::from(s))
    }
}
impl ModelPackageGroupSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageGroupSortBy::CreationTime => "CreationTime",
            ModelPackageGroupSortBy::Name => "Name",
            ModelPackageGroupSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelPackageGroupSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the model metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelMetadataSummary {
    /// <p>The machine learning domain of the model.</p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The machine learning framework of the model.</p>
    pub framework: std::option::Option<std::string::String>,
    /// <p>The machine learning task of the model.</p>
    pub task: std::option::Option<std::string::String>,
    /// <p>The name of the model.</p>
    pub model: std::option::Option<std::string::String>,
    /// <p>The framework version of the model.</p>
    pub framework_version: std::option::Option<std::string::String>,
}
impl ModelMetadataSummary {
    /// <p>The machine learning domain of the model.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The machine learning framework of the model.</p>
    pub fn framework(&self) -> std::option::Option<&str> {
        self.framework.as_deref()
    }
    /// <p>The machine learning task of the model.</p>
    pub fn task(&self) -> std::option::Option<&str> {
        self.task.as_deref()
    }
    /// <p>The name of the model.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The framework version of the model.</p>
    pub fn framework_version(&self) -> std::option::Option<&str> {
        self.framework_version.as_deref()
    }
}
impl std::fmt::Debug for ModelMetadataSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelMetadataSummary");
        formatter.field("domain", &self.domain);
        formatter.field("framework", &self.framework);
        formatter.field("task", &self.task);
        formatter.field("model", &self.model);
        formatter.field("framework_version", &self.framework_version);
        formatter.finish()
    }
}
/// See [`ModelMetadataSummary`](crate::model::ModelMetadataSummary)
pub mod model_metadata_summary {

    /// A builder for [`ModelMetadataSummary`](crate::model::ModelMetadataSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) framework: std::option::Option<std::string::String>,
        pub(crate) task: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) framework_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The machine learning domain of the model.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The machine learning domain of the model.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The machine learning framework of the model.</p>
        pub fn framework(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework = Some(input.into());
            self
        }
        /// <p>The machine learning framework of the model.</p>
        pub fn set_framework(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework = input;
            self
        }
        /// <p>The machine learning task of the model.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.task = Some(input.into());
            self
        }
        /// <p>The machine learning task of the model.</p>
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task = input;
            self
        }
        /// <p>The name of the model.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The framework version of the model.</p>
        pub fn framework_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_version = Some(input.into());
            self
        }
        /// <p>The framework version of the model.</p>
        pub fn set_framework_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.framework_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetadataSummary`](crate::model::ModelMetadataSummary)
        pub fn build(self) -> crate::model::ModelMetadataSummary {
            crate::model::ModelMetadataSummary {
                domain: self.domain,
                framework: self.framework,
                task: self.task,
                model: self.model,
                framework_version: self.framework_version,
            }
        }
    }
}
impl ModelMetadataSummary {
    /// Creates a new builder-style object to manufacture [`ModelMetadataSummary`](crate::model::ModelMetadataSummary)
    pub fn builder() -> crate::model::model_metadata_summary::Builder {
        crate::model::model_metadata_summary::Builder::default()
    }
}

/// <p>One or more filters that searches for the specified resource or resources in a search. All resource objects that satisfy the expression's condition are included in the search results</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelMetadataSearchExpression {
    /// <p>A list of filter objects.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::ModelMetadataFilter>>,
}
impl ModelMetadataSearchExpression {
    /// <p>A list of filter objects.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::ModelMetadataFilter]> {
        self.filters.as_deref()
    }
}
impl std::fmt::Debug for ModelMetadataSearchExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelMetadataSearchExpression");
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}
/// See [`ModelMetadataSearchExpression`](crate::model::ModelMetadataSearchExpression)
pub mod model_metadata_search_expression {

    /// A builder for [`ModelMetadataSearchExpression`](crate::model::ModelMetadataSearchExpression)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::ModelMetadataFilter>>,
    }
    impl Builder {
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>A list of filter objects.</p>
        pub fn filters(mut self, input: crate::model::ModelMetadataFilter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>A list of filter objects.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelMetadataFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetadataSearchExpression`](crate::model::ModelMetadataSearchExpression)
        pub fn build(self) -> crate::model::ModelMetadataSearchExpression {
            crate::model::ModelMetadataSearchExpression {
                filters: self.filters,
            }
        }
    }
}
impl ModelMetadataSearchExpression {
    /// Creates a new builder-style object to manufacture [`ModelMetadataSearchExpression`](crate::model::ModelMetadataSearchExpression)
    pub fn builder() -> crate::model::model_metadata_search_expression::Builder {
        crate::model::model_metadata_search_expression::Builder::default()
    }
}

/// <p>Part of the search expression. You can specify the name and value (domain, task, framework, framework version, task, and model).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelMetadataFilter {
    /// <p>The name of the of the model to filter by.</p>
    pub name: std::option::Option<crate::model::ModelMetadataFilterType>,
    /// <p>The value to filter the model metadata.</p>
    pub value: std::option::Option<std::string::String>,
}
impl ModelMetadataFilter {
    /// <p>The name of the of the model to filter by.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::ModelMetadataFilterType> {
        self.name.as_ref()
    }
    /// <p>The value to filter the model metadata.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ModelMetadataFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelMetadataFilter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ModelMetadataFilter`](crate::model::ModelMetadataFilter)
pub mod model_metadata_filter {

    /// A builder for [`ModelMetadataFilter`](crate::model::ModelMetadataFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::ModelMetadataFilterType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the of the model to filter by.</p>
        pub fn name(mut self, input: crate::model::ModelMetadataFilterType) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the of the model to filter by.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::ModelMetadataFilterType>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value to filter the model metadata.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value to filter the model metadata.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetadataFilter`](crate::model::ModelMetadataFilter)
        pub fn build(self) -> crate::model::ModelMetadataFilter {
            crate::model::ModelMetadataFilter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl ModelMetadataFilter {
    /// Creates a new builder-style object to manufacture [`ModelMetadataFilter`](crate::model::ModelMetadataFilter)
    pub fn builder() -> crate::model::model_metadata_filter::Builder {
        crate::model::model_metadata_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelMetadataFilterType {
    #[allow(missing_docs)] // documentation missing in model
    Domain,
    #[allow(missing_docs)] // documentation missing in model
    Framework,
    #[allow(missing_docs)] // documentation missing in model
    Frameworkversion,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelMetadataFilterType {
    fn from(s: &str) -> Self {
        match s {
            "Domain" => ModelMetadataFilterType::Domain,
            "Framework" => ModelMetadataFilterType::Framework,
            "FrameworkVersion" => ModelMetadataFilterType::Frameworkversion,
            "Task" => ModelMetadataFilterType::Task,
            other => ModelMetadataFilterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelMetadataFilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelMetadataFilterType::from(s))
    }
}
impl ModelMetadataFilterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelMetadataFilterType::Domain => "Domain",
            ModelMetadataFilterType::Framework => "Framework",
            ModelMetadataFilterType::Frameworkversion => "FrameworkVersion",
            ModelMetadataFilterType::Task => "Task",
            ModelMetadataFilterType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Domain", "Framework", "FrameworkVersion", "Task"]
    }
}
impl AsRef<str> for ModelMetadataFilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of a lineage group. A lineage group provides a group of shareable lineage entity resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LineageGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
    pub lineage_group_arn: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the lineage group.</p>
    pub lineage_group_name: std::option::Option<std::string::String>,
    /// <p>The display name of the lineage group summary.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The creation time of the lineage group summary.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last modified time of the lineage group summary.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl LineageGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
    pub fn lineage_group_arn(&self) -> std::option::Option<&str> {
        self.lineage_group_arn.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the lineage group.</p>
    pub fn lineage_group_name(&self) -> std::option::Option<&str> {
        self.lineage_group_name.as_deref()
    }
    /// <p>The display name of the lineage group summary.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The creation time of the lineage group summary.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last modified time of the lineage group summary.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for LineageGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LineageGroupSummary");
        formatter.field("lineage_group_arn", &self.lineage_group_arn);
        formatter.field("lineage_group_name", &self.lineage_group_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`LineageGroupSummary`](crate::model::LineageGroupSummary)
pub mod lineage_group_summary {

    /// A builder for [`LineageGroupSummary`](crate::model::LineageGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lineage_group_arn: std::option::Option<std::string::String>,
        pub(crate) lineage_group_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
        pub fn lineage_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lineage_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lineage group resource.</p>
        pub fn set_lineage_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lineage_group_arn = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the lineage group.</p>
        pub fn lineage_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lineage_group_name = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the lineage group.</p>
        pub fn set_lineage_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lineage_group_name = input;
            self
        }
        /// <p>The display name of the lineage group summary.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The display name of the lineage group summary.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The creation time of the lineage group summary.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the lineage group summary.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last modified time of the lineage group summary.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the lineage group summary.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`LineageGroupSummary`](crate::model::LineageGroupSummary)
        pub fn build(self) -> crate::model::LineageGroupSummary {
            crate::model::LineageGroupSummary {
                lineage_group_arn: self.lineage_group_arn,
                lineage_group_name: self.lineage_group_name,
                display_name: self.display_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl LineageGroupSummary {
    /// Creates a new builder-style object to manufacture [`LineageGroupSummary`](crate::model::LineageGroupSummary)
    pub fn builder() -> crate::model::lineage_group_summary::Builder {
        crate::model::lineage_group_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortLineageGroupsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortLineageGroupsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortLineageGroupsBy::CreationTime,
            "Name" => SortLineageGroupsBy::Name,
            other => SortLineageGroupsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortLineageGroupsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortLineageGroupsBy::from(s))
    }
}
impl SortLineageGroupsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortLineageGroupsBy::CreationTime => "CreationTime",
            SortLineageGroupsBy::Name => "Name",
            SortLineageGroupsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortLineageGroupsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for a work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobForWorkteamSummary {
    /// <p>The name of the labeling job that the work team is assigned to.</p>
    pub labeling_job_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for a labeling job. You can use this to refer to a specific labeling job.</p>
    pub job_reference_code: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
    pub work_requester_account_id: std::option::Option<std::string::String>,
    /// <p>The date and time that the labeling job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides information about the progress of a labeling job.</p>
    pub label_counters: std::option::Option<crate::model::LabelCountersForWorkteam>,
    /// <p>The configured number of workers per data object.</p>
    pub number_of_human_workers_per_data_object: std::option::Option<i32>,
}
impl LabelingJobForWorkteamSummary {
    /// <p>The name of the labeling job that the work team is assigned to.</p>
    pub fn labeling_job_name(&self) -> std::option::Option<&str> {
        self.labeling_job_name.as_deref()
    }
    /// <p>A unique identifier for a labeling job. You can use this to refer to a specific labeling job.</p>
    pub fn job_reference_code(&self) -> std::option::Option<&str> {
        self.job_reference_code.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
    pub fn work_requester_account_id(&self) -> std::option::Option<&str> {
        self.work_requester_account_id.as_deref()
    }
    /// <p>The date and time that the labeling job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Provides information about the progress of a labeling job.</p>
    pub fn label_counters(&self) -> std::option::Option<&crate::model::LabelCountersForWorkteam> {
        self.label_counters.as_ref()
    }
    /// <p>The configured number of workers per data object.</p>
    pub fn number_of_human_workers_per_data_object(&self) -> std::option::Option<i32> {
        self.number_of_human_workers_per_data_object
    }
}
impl std::fmt::Debug for LabelingJobForWorkteamSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobForWorkteamSummary");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("job_reference_code", &self.job_reference_code);
        formatter.field("work_requester_account_id", &self.work_requester_account_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("label_counters", &self.label_counters);
        formatter.field(
            "number_of_human_workers_per_data_object",
            &self.number_of_human_workers_per_data_object,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
pub mod labeling_job_for_workteam_summary {

    /// A builder for [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_name: std::option::Option<std::string::String>,
        pub(crate) job_reference_code: std::option::Option<std::string::String>,
        pub(crate) work_requester_account_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) label_counters: std::option::Option<crate::model::LabelCountersForWorkteam>,
        pub(crate) number_of_human_workers_per_data_object: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the labeling job that the work team is assigned to.</p>
        pub fn labeling_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_name = Some(input.into());
            self
        }
        /// <p>The name of the labeling job that the work team is assigned to.</p>
        pub fn set_labeling_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_name = input;
            self
        }
        /// <p>A unique identifier for a labeling job. You can use this to refer to a specific labeling job.</p>
        pub fn job_reference_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_reference_code = Some(input.into());
            self
        }
        /// <p>A unique identifier for a labeling job. You can use this to refer to a specific labeling job.</p>
        pub fn set_job_reference_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_reference_code = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
        pub fn work_requester_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_requester_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
        pub fn set_work_requester_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.work_requester_account_id = input;
            self
        }
        /// <p>The date and time that the labeling job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time that the labeling job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Provides information about the progress of a labeling job.</p>
        pub fn label_counters(mut self, input: crate::model::LabelCountersForWorkteam) -> Self {
            self.label_counters = Some(input);
            self
        }
        /// <p>Provides information about the progress of a labeling job.</p>
        pub fn set_label_counters(
            mut self,
            input: std::option::Option<crate::model::LabelCountersForWorkteam>,
        ) -> Self {
            self.label_counters = input;
            self
        }
        /// <p>The configured number of workers per data object.</p>
        pub fn number_of_human_workers_per_data_object(mut self, input: i32) -> Self {
            self.number_of_human_workers_per_data_object = Some(input);
            self
        }
        /// <p>The configured number of workers per data object.</p>
        pub fn set_number_of_human_workers_per_data_object(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_human_workers_per_data_object = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
        pub fn build(self) -> crate::model::LabelingJobForWorkteamSummary {
            crate::model::LabelingJobForWorkteamSummary {
                labeling_job_name: self.labeling_job_name,
                job_reference_code: self.job_reference_code,
                work_requester_account_id: self.work_requester_account_id,
                creation_time: self.creation_time,
                label_counters: self.label_counters,
                number_of_human_workers_per_data_object: self
                    .number_of_human_workers_per_data_object,
            }
        }
    }
}
impl LabelingJobForWorkteamSummary {
    /// Creates a new builder-style object to manufacture [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
    pub fn builder() -> crate::model::labeling_job_for_workteam_summary::Builder {
        crate::model::labeling_job_for_workteam_summary::Builder::default()
    }
}

/// <p>Provides counts for human-labeled tasks in the labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelCountersForWorkteam {
    /// <p>The total number of data objects labeled by a human worker.</p>
    pub human_labeled: i32,
    /// <p>The total number of data objects that need to be labeled by a human worker.</p>
    pub pending_human: i32,
    /// <p>The total number of tasks in the labeling job.</p>
    pub total: i32,
}
impl LabelCountersForWorkteam {
    /// <p>The total number of data objects labeled by a human worker.</p>
    pub fn human_labeled(&self) -> i32 {
        self.human_labeled
    }
    /// <p>The total number of data objects that need to be labeled by a human worker.</p>
    pub fn pending_human(&self) -> i32 {
        self.pending_human
    }
    /// <p>The total number of tasks in the labeling job.</p>
    pub fn total(&self) -> i32 {
        self.total
    }
}
impl std::fmt::Debug for LabelCountersForWorkteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelCountersForWorkteam");
        formatter.field("human_labeled", &self.human_labeled);
        formatter.field("pending_human", &self.pending_human);
        formatter.field("total", &self.total);
        formatter.finish()
    }
}
/// See [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
pub mod label_counters_for_workteam {

    /// A builder for [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_labeled: std::option::Option<i32>,
        pub(crate) pending_human: std::option::Option<i32>,
        pub(crate) total: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of data objects labeled by a human worker.</p>
        pub fn human_labeled(mut self, input: i32) -> Self {
            self.human_labeled = Some(input);
            self
        }
        /// <p>The total number of data objects labeled by a human worker.</p>
        pub fn set_human_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.human_labeled = input;
            self
        }
        /// <p>The total number of data objects that need to be labeled by a human worker.</p>
        pub fn pending_human(mut self, input: i32) -> Self {
            self.pending_human = Some(input);
            self
        }
        /// <p>The total number of data objects that need to be labeled by a human worker.</p>
        pub fn set_pending_human(mut self, input: std::option::Option<i32>) -> Self {
            self.pending_human = input;
            self
        }
        /// <p>The total number of tasks in the labeling job.</p>
        pub fn total(mut self, input: i32) -> Self {
            self.total = Some(input);
            self
        }
        /// <p>The total number of tasks in the labeling job.</p>
        pub fn set_total(mut self, input: std::option::Option<i32>) -> Self {
            self.total = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
        pub fn build(self) -> crate::model::LabelCountersForWorkteam {
            crate::model::LabelCountersForWorkteam {
                human_labeled: self.human_labeled.unwrap_or_default(),
                pending_human: self.pending_human.unwrap_or_default(),
                total: self.total.unwrap_or_default(),
            }
        }
    }
}
impl LabelCountersForWorkteam {
    /// Creates a new builder-style object to manufacture [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
    pub fn builder() -> crate::model::label_counters_for_workteam::Builder {
        crate::model::label_counters_for_workteam::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListLabelingJobsForWorkteamSortByOptions {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListLabelingJobsForWorkteamSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ListLabelingJobsForWorkteamSortByOptions::CreationTime,
            other => ListLabelingJobsForWorkteamSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListLabelingJobsForWorkteamSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListLabelingJobsForWorkteamSortByOptions::from(s))
    }
}
impl ListLabelingJobsForWorkteamSortByOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListLabelingJobsForWorkteamSortByOptions::CreationTime => "CreationTime",
            ListLabelingJobsForWorkteamSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for ListLabelingJobsForWorkteamSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobSummary {
    /// <p>The name of the labeling job.</p>
    pub labeling_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was created.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The date and time that the job was created (timestamp).</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the job was last modified (timestamp).</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the labeling job. </p>
    pub labeling_job_status: std::option::Option<crate::model::LabelingJobStatus>,
    /// <p>Counts showing the progress of the labeling job.</p>
    pub label_counters: std::option::Option<crate::model::LabelCounters>,
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.</p>
    pub pre_human_task_lambda_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation Consolidation</a>.</p>
    pub annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
    /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field contains a description of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The location of the output produced by the labeling job.</p>
    pub labeling_job_output: std::option::Option<crate::model::LabelingJobOutput>,
    /// <p>Input configuration for the labeling job.</p>
    pub input_config: std::option::Option<crate::model::LabelingJobInputConfig>,
}
impl LabelingJobSummary {
    /// <p>The name of the labeling job.</p>
    pub fn labeling_job_name(&self) -> std::option::Option<&str> {
        self.labeling_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was created.</p>
    pub fn labeling_job_arn(&self) -> std::option::Option<&str> {
        self.labeling_job_arn.as_deref()
    }
    /// <p>The date and time that the job was created (timestamp).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time that the job was last modified (timestamp).</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The current status of the labeling job. </p>
    pub fn labeling_job_status(&self) -> std::option::Option<&crate::model::LabelingJobStatus> {
        self.labeling_job_status.as_ref()
    }
    /// <p>Counts showing the progress of the labeling job.</p>
    pub fn label_counters(&self) -> std::option::Option<&crate::model::LabelCounters> {
        self.label_counters.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
    pub fn workteam_arn(&self) -> std::option::Option<&str> {
        self.workteam_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.</p>
    pub fn pre_human_task_lambda_arn(&self) -> std::option::Option<&str> {
        self.pre_human_task_lambda_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation Consolidation</a>.</p>
    pub fn annotation_consolidation_lambda_arn(&self) -> std::option::Option<&str> {
        self.annotation_consolidation_lambda_arn.as_deref()
    }
    /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field contains a description of the error.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The location of the output produced by the labeling job.</p>
    pub fn labeling_job_output(&self) -> std::option::Option<&crate::model::LabelingJobOutput> {
        self.labeling_job_output.as_ref()
    }
    /// <p>Input configuration for the labeling job.</p>
    pub fn input_config(&self) -> std::option::Option<&crate::model::LabelingJobInputConfig> {
        self.input_config.as_ref()
    }
}
impl std::fmt::Debug for LabelingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobSummary");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("labeling_job_status", &self.labeling_job_status);
        formatter.field("label_counters", &self.label_counters);
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("pre_human_task_lambda_arn", &self.pre_human_task_lambda_arn);
        formatter.field(
            "annotation_consolidation_lambda_arn",
            &self.annotation_consolidation_lambda_arn,
        );
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("labeling_job_output", &self.labeling_job_output);
        formatter.field("input_config", &self.input_config);
        formatter.finish()
    }
}
/// See [`LabelingJobSummary`](crate::model::LabelingJobSummary)
pub mod labeling_job_summary {

    /// A builder for [`LabelingJobSummary`](crate::model::LabelingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_name: std::option::Option<std::string::String>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) labeling_job_status: std::option::Option<crate::model::LabelingJobStatus>,
        pub(crate) label_counters: std::option::Option<crate::model::LabelCounters>,
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) pre_human_task_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) labeling_job_output: std::option::Option<crate::model::LabelingJobOutput>,
        pub(crate) input_config: std::option::Option<crate::model::LabelingJobInputConfig>,
    }
    impl Builder {
        /// <p>The name of the labeling job.</p>
        pub fn labeling_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_name = Some(input.into());
            self
        }
        /// <p>The name of the labeling job.</p>
        pub fn set_labeling_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was created.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was created.</p>
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The date and time that the job was created (timestamp).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time that the job was created (timestamp).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the job was last modified (timestamp).</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the job was last modified (timestamp).</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The current status of the labeling job. </p>
        pub fn labeling_job_status(mut self, input: crate::model::LabelingJobStatus) -> Self {
            self.labeling_job_status = Some(input);
            self
        }
        /// <p>The current status of the labeling job. </p>
        pub fn set_labeling_job_status(
            mut self,
            input: std::option::Option<crate::model::LabelingJobStatus>,
        ) -> Self {
            self.labeling_job_status = input;
            self
        }
        /// <p>Counts showing the progress of the labeling job.</p>
        pub fn label_counters(mut self, input: crate::model::LabelCounters) -> Self {
            self.label_counters = Some(input);
            self
        }
        /// <p>Counts showing the progress of the labeling job.</p>
        pub fn set_label_counters(
            mut self,
            input: std::option::Option<crate::model::LabelCounters>,
        ) -> Self {
            self.label_counters = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.</p>
        pub fn pre_human_task_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_human_task_lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.</p>
        pub fn set_pre_human_task_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_human_task_lambda_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation Consolidation</a>.</p>
        pub fn annotation_consolidation_lambda_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation Consolidation</a>.</p>
        pub fn set_annotation_consolidation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = input;
            self
        }
        /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field contains a description of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field contains a description of the error.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The location of the output produced by the labeling job.</p>
        pub fn labeling_job_output(mut self, input: crate::model::LabelingJobOutput) -> Self {
            self.labeling_job_output = Some(input);
            self
        }
        /// <p>The location of the output produced by the labeling job.</p>
        pub fn set_labeling_job_output(
            mut self,
            input: std::option::Option<crate::model::LabelingJobOutput>,
        ) -> Self {
            self.labeling_job_output = input;
            self
        }
        /// <p>Input configuration for the labeling job.</p>
        pub fn input_config(mut self, input: crate::model::LabelingJobInputConfig) -> Self {
            self.input_config = Some(input);
            self
        }
        /// <p>Input configuration for the labeling job.</p>
        pub fn set_input_config(
            mut self,
            input: std::option::Option<crate::model::LabelingJobInputConfig>,
        ) -> Self {
            self.input_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobSummary`](crate::model::LabelingJobSummary)
        pub fn build(self) -> crate::model::LabelingJobSummary {
            crate::model::LabelingJobSummary {
                labeling_job_name: self.labeling_job_name,
                labeling_job_arn: self.labeling_job_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                labeling_job_status: self.labeling_job_status,
                label_counters: self.label_counters,
                workteam_arn: self.workteam_arn,
                pre_human_task_lambda_arn: self.pre_human_task_lambda_arn,
                annotation_consolidation_lambda_arn: self.annotation_consolidation_lambda_arn,
                failure_reason: self.failure_reason,
                labeling_job_output: self.labeling_job_output,
                input_config: self.input_config,
            }
        }
    }
}
impl LabelingJobSummary {
    /// Creates a new builder-style object to manufacture [`LabelingJobSummary`](crate::model::LabelingJobSummary)
    pub fn builder() -> crate::model::labeling_job_summary::Builder {
        crate::model::labeling_job_summary::Builder::default()
    }
}

/// <p>Input configuration information for a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobInputConfig {
    /// <p>The location of the input data.</p>
    pub data_source: std::option::Option<crate::model::LabelingJobDataSource>,
    /// <p>Attributes of the data specified by the customer.</p>
    pub data_attributes: std::option::Option<crate::model::LabelingJobDataAttributes>,
}
impl LabelingJobInputConfig {
    /// <p>The location of the input data.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::LabelingJobDataSource> {
        self.data_source.as_ref()
    }
    /// <p>Attributes of the data specified by the customer.</p>
    pub fn data_attributes(&self) -> std::option::Option<&crate::model::LabelingJobDataAttributes> {
        self.data_attributes.as_ref()
    }
}
impl std::fmt::Debug for LabelingJobInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobInputConfig");
        formatter.field("data_source", &self.data_source);
        formatter.field("data_attributes", &self.data_attributes);
        formatter.finish()
    }
}
/// See [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
pub mod labeling_job_input_config {

    /// A builder for [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::LabelingJobDataSource>,
        pub(crate) data_attributes: std::option::Option<crate::model::LabelingJobDataAttributes>,
    }
    impl Builder {
        /// <p>The location of the input data.</p>
        pub fn data_source(mut self, input: crate::model::LabelingJobDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The location of the input data.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Attributes of the data specified by the customer.</p>
        pub fn data_attributes(mut self, input: crate::model::LabelingJobDataAttributes) -> Self {
            self.data_attributes = Some(input);
            self
        }
        /// <p>Attributes of the data specified by the customer.</p>
        pub fn set_data_attributes(
            mut self,
            input: std::option::Option<crate::model::LabelingJobDataAttributes>,
        ) -> Self {
            self.data_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
        pub fn build(self) -> crate::model::LabelingJobInputConfig {
            crate::model::LabelingJobInputConfig {
                data_source: self.data_source,
                data_attributes: self.data_attributes,
            }
        }
    }
}
impl LabelingJobInputConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
    pub fn builder() -> crate::model::labeling_job_input_config::Builder {
        crate::model::labeling_job_input_config::Builder::default()
    }
}

/// <p>Attributes of the data specified by the customer. Use these to describe the data to be labeled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobDataAttributes {
    /// <p>Declares that your content is free of personally identifiable information or adult content. SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.</p>
    pub content_classifiers: std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
}
impl LabelingJobDataAttributes {
    /// <p>Declares that your content is free of personally identifiable information or adult content. SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.</p>
    pub fn content_classifiers(&self) -> std::option::Option<&[crate::model::ContentClassifier]> {
        self.content_classifiers.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobDataAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobDataAttributes");
        formatter.field("content_classifiers", &self.content_classifiers);
        formatter.finish()
    }
}
/// See [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
pub mod labeling_job_data_attributes {

    /// A builder for [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_classifiers:
            std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
    }
    impl Builder {
        /// Appends an item to `content_classifiers`.
        ///
        /// To override the contents of this collection use [`set_content_classifiers`](Self::set_content_classifiers).
        ///
        /// <p>Declares that your content is free of personally identifiable information or adult content. SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.</p>
        pub fn content_classifiers(mut self, input: crate::model::ContentClassifier) -> Self {
            let mut v = self.content_classifiers.unwrap_or_default();
            v.push(input);
            self.content_classifiers = Some(v);
            self
        }
        /// <p>Declares that your content is free of personally identifiable information or adult content. SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.</p>
        pub fn set_content_classifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
        ) -> Self {
            self.content_classifiers = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
        pub fn build(self) -> crate::model::LabelingJobDataAttributes {
            crate::model::LabelingJobDataAttributes {
                content_classifiers: self.content_classifiers,
            }
        }
    }
}
impl LabelingJobDataAttributes {
    /// Creates a new builder-style object to manufacture [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
    pub fn builder() -> crate::model::labeling_job_data_attributes::Builder {
        crate::model::labeling_job_data_attributes::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentClassifier {
    #[allow(missing_docs)] // documentation missing in model
    FreeOfAdultContent,
    #[allow(missing_docs)] // documentation missing in model
    FreeOfPersonallyIdentifiableInformation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContentClassifier {
    fn from(s: &str) -> Self {
        match s {
            "FreeOfAdultContent" => ContentClassifier::FreeOfAdultContent,
            "FreeOfPersonallyIdentifiableInformation" => {
                ContentClassifier::FreeOfPersonallyIdentifiableInformation
            }
            other => ContentClassifier::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContentClassifier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentClassifier::from(s))
    }
}
impl ContentClassifier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentClassifier::FreeOfAdultContent => "FreeOfAdultContent",
            ContentClassifier::FreeOfPersonallyIdentifiableInformation => {
                "FreeOfPersonallyIdentifiableInformation"
            }
            ContentClassifier::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "FreeOfAdultContent",
            "FreeOfPersonallyIdentifiableInformation",
        ]
    }
}
impl AsRef<str> for ContentClassifier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the location of input data.</p>
/// <p>You must specify at least one of the following: <code>S3DataSource</code> or <code>SnsDataSource</code>.</p>
/// <p>Use <code>SnsDataSource</code> to specify an SNS input topic for a streaming labeling job. If you do not specify and SNS input topic ARN, Ground Truth will create a one-time labeling job.</p>
/// <p>Use <code>S3DataSource</code> to specify an input manifest file for both streaming and one-time labeling jobs. Adding an <code>S3DataSource</code> is optional if you use <code>SnsDataSource</code> to create a streaming labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobDataSource {
    /// <p>The Amazon S3 location of the input data objects.</p>
    pub s3_data_source: std::option::Option<crate::model::LabelingJobS3DataSource>,
    /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
    pub sns_data_source: std::option::Option<crate::model::LabelingJobSnsDataSource>,
}
impl LabelingJobDataSource {
    /// <p>The Amazon S3 location of the input data objects.</p>
    pub fn s3_data_source(&self) -> std::option::Option<&crate::model::LabelingJobS3DataSource> {
        self.s3_data_source.as_ref()
    }
    /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
    pub fn sns_data_source(&self) -> std::option::Option<&crate::model::LabelingJobSnsDataSource> {
        self.sns_data_source.as_ref()
    }
}
impl std::fmt::Debug for LabelingJobDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.field("sns_data_source", &self.sns_data_source);
        formatter.finish()
    }
}
/// See [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
pub mod labeling_job_data_source {

    /// A builder for [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::LabelingJobS3DataSource>,
        pub(crate) sns_data_source: std::option::Option<crate::model::LabelingJobSnsDataSource>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the input data objects.</p>
        pub fn s3_data_source(mut self, input: crate::model::LabelingJobS3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        /// <p>The Amazon S3 location of the input data objects.</p>
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobS3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
        pub fn sns_data_source(mut self, input: crate::model::LabelingJobSnsDataSource) -> Self {
            self.sns_data_source = Some(input);
            self
        }
        /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
        pub fn set_sns_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobSnsDataSource>,
        ) -> Self {
            self.sns_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
        pub fn build(self) -> crate::model::LabelingJobDataSource {
            crate::model::LabelingJobDataSource {
                s3_data_source: self.s3_data_source,
                sns_data_source: self.sns_data_source,
            }
        }
    }
}
impl LabelingJobDataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
    pub fn builder() -> crate::model::labeling_job_data_source::Builder {
        crate::model::labeling_job_data_source::Builder::default()
    }
}

/// <p>An Amazon SNS data source used for streaming labeling jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobSnsDataSource {
    /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic you will use to send new data objects to a streaming labeling job.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
}
impl LabelingJobSnsDataSource {
    /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic you will use to send new data objects to a streaming labeling job.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobSnsDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobSnsDataSource");
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.finish()
    }
}
/// See [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
pub mod labeling_job_sns_data_source {

    /// A builder for [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic you will use to send new data objects to a streaming labeling job.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic you will use to send new data objects to a streaming labeling job.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
        pub fn build(self) -> crate::model::LabelingJobSnsDataSource {
            crate::model::LabelingJobSnsDataSource {
                sns_topic_arn: self.sns_topic_arn,
            }
        }
    }
}
impl LabelingJobSnsDataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
    pub fn builder() -> crate::model::labeling_job_sns_data_source::Builder {
        crate::model::labeling_job_sns_data_source::Builder::default()
    }
}

/// <p>The Amazon S3 location of the input data objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobS3DataSource {
    /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
    /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of the following keys: <code>source-ref</code> or <code>source</code>. The value of the keys are interpreted as follows:</p>
    /// <ul>
    /// <li> <p> <code>source-ref</code>: The source of the object is the Amazon S3 object specified in the value. Use this value when the object is a binary object, such as an image.</p> </li>
    /// <li> <p> <code>source</code>: The source of the object is the value. Use this value when the object is a text value.</p> </li>
    /// </ul>
    /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to create an input manifest file.</p>
    pub manifest_s3_uri: std::option::Option<std::string::String>,
}
impl LabelingJobS3DataSource {
    /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
    /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of the following keys: <code>source-ref</code> or <code>source</code>. The value of the keys are interpreted as follows:</p>
    /// <ul>
    /// <li> <p> <code>source-ref</code>: The source of the object is the Amazon S3 object specified in the value. Use this value when the object is a binary object, such as an image.</p> </li>
    /// <li> <p> <code>source</code>: The source of the object is the value. Use this value when the object is a text value.</p> </li>
    /// </ul>
    /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to create an input manifest file.</p>
    pub fn manifest_s3_uri(&self) -> std::option::Option<&str> {
        self.manifest_s3_uri.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobS3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobS3DataSource");
        formatter.field("manifest_s3_uri", &self.manifest_s3_uri);
        formatter.finish()
    }
}
/// See [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
pub mod labeling_job_s3_data_source {

    /// A builder for [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
        /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of the following keys: <code>source-ref</code> or <code>source</code>. The value of the keys are interpreted as follows:</p>
        /// <ul>
        /// <li> <p> <code>source-ref</code>: The source of the object is the Amazon S3 object specified in the value. Use this value when the object is a binary object, such as an image.</p> </li>
        /// <li> <p> <code>source</code>: The source of the object is the value. Use this value when the object is a text value.</p> </li>
        /// </ul>
        /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to create an input manifest file.</p>
        pub fn manifest_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
        /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of the following keys: <code>source-ref</code> or <code>source</code>. The value of the keys are interpreted as follows:</p>
        /// <ul>
        /// <li> <p> <code>source-ref</code>: The source of the object is the Amazon S3 object specified in the value. Use this value when the object is a binary object, such as an image.</p> </li>
        /// <li> <p> <code>source</code>: The source of the object is the value. Use this value when the object is a text value.</p> </li>
        /// </ul>
        /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to create an input manifest file.</p>
        pub fn set_manifest_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
        pub fn build(self) -> crate::model::LabelingJobS3DataSource {
            crate::model::LabelingJobS3DataSource {
                manifest_s3_uri: self.manifest_s3_uri,
            }
        }
    }
}
impl LabelingJobS3DataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
    pub fn builder() -> crate::model::labeling_job_s3_data_source::Builder {
        crate::model::labeling_job_s3_data_source::Builder::default()
    }
}

/// <p>Specifies the location of the output produced by the labeling job. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobOutput {
    /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
    pub output_dataset_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the most recent SageMaker model trained as part of automated data labeling. </p>
    pub final_active_learning_model_arn: std::option::Option<std::string::String>,
}
impl LabelingJobOutput {
    /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
    pub fn output_dataset_s3_uri(&self) -> std::option::Option<&str> {
        self.output_dataset_s3_uri.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the most recent SageMaker model trained as part of automated data labeling. </p>
    pub fn final_active_learning_model_arn(&self) -> std::option::Option<&str> {
        self.final_active_learning_model_arn.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobOutput");
        formatter.field("output_dataset_s3_uri", &self.output_dataset_s3_uri);
        formatter.field(
            "final_active_learning_model_arn",
            &self.final_active_learning_model_arn,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobOutput`](crate::model::LabelingJobOutput)
pub mod labeling_job_output {

    /// A builder for [`LabelingJobOutput`](crate::model::LabelingJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_dataset_s3_uri: std::option::Option<std::string::String>,
        pub(crate) final_active_learning_model_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
        pub fn output_dataset_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_dataset_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
        pub fn set_output_dataset_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_dataset_s3_uri = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the most recent SageMaker model trained as part of automated data labeling. </p>
        pub fn final_active_learning_model_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.final_active_learning_model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the most recent SageMaker model trained as part of automated data labeling. </p>
        pub fn set_final_active_learning_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.final_active_learning_model_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobOutput`](crate::model::LabelingJobOutput)
        pub fn build(self) -> crate::model::LabelingJobOutput {
            crate::model::LabelingJobOutput {
                output_dataset_s3_uri: self.output_dataset_s3_uri,
                final_active_learning_model_arn: self.final_active_learning_model_arn,
            }
        }
    }
}
impl LabelingJobOutput {
    /// Creates a new builder-style object to manufacture [`LabelingJobOutput`](crate::model::LabelingJobOutput)
    pub fn builder() -> crate::model::labeling_job_output::Builder {
        crate::model::labeling_job_output::Builder::default()
    }
}

/// <p>Provides a breakdown of the number of objects labeled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelCounters {
    /// <p>The total number of objects labeled.</p>
    pub total_labeled: i32,
    /// <p>The total number of objects labeled by a human worker.</p>
    pub human_labeled: i32,
    /// <p>The total number of objects labeled by automated data labeling.</p>
    pub machine_labeled: i32,
    /// <p>The total number of objects that could not be labeled due to an error.</p>
    pub failed_non_retryable_error: i32,
    /// <p>The total number of objects not yet labeled.</p>
    pub unlabeled: i32,
}
impl LabelCounters {
    /// <p>The total number of objects labeled.</p>
    pub fn total_labeled(&self) -> i32 {
        self.total_labeled
    }
    /// <p>The total number of objects labeled by a human worker.</p>
    pub fn human_labeled(&self) -> i32 {
        self.human_labeled
    }
    /// <p>The total number of objects labeled by automated data labeling.</p>
    pub fn machine_labeled(&self) -> i32 {
        self.machine_labeled
    }
    /// <p>The total number of objects that could not be labeled due to an error.</p>
    pub fn failed_non_retryable_error(&self) -> i32 {
        self.failed_non_retryable_error
    }
    /// <p>The total number of objects not yet labeled.</p>
    pub fn unlabeled(&self) -> i32 {
        self.unlabeled
    }
}
impl std::fmt::Debug for LabelCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelCounters");
        formatter.field("total_labeled", &self.total_labeled);
        formatter.field("human_labeled", &self.human_labeled);
        formatter.field("machine_labeled", &self.machine_labeled);
        formatter.field(
            "failed_non_retryable_error",
            &self.failed_non_retryable_error,
        );
        formatter.field("unlabeled", &self.unlabeled);
        formatter.finish()
    }
}
/// See [`LabelCounters`](crate::model::LabelCounters)
pub mod label_counters {

    /// A builder for [`LabelCounters`](crate::model::LabelCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_labeled: std::option::Option<i32>,
        pub(crate) human_labeled: std::option::Option<i32>,
        pub(crate) machine_labeled: std::option::Option<i32>,
        pub(crate) failed_non_retryable_error: std::option::Option<i32>,
        pub(crate) unlabeled: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of objects labeled.</p>
        pub fn total_labeled(mut self, input: i32) -> Self {
            self.total_labeled = Some(input);
            self
        }
        /// <p>The total number of objects labeled.</p>
        pub fn set_total_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.total_labeled = input;
            self
        }
        /// <p>The total number of objects labeled by a human worker.</p>
        pub fn human_labeled(mut self, input: i32) -> Self {
            self.human_labeled = Some(input);
            self
        }
        /// <p>The total number of objects labeled by a human worker.</p>
        pub fn set_human_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.human_labeled = input;
            self
        }
        /// <p>The total number of objects labeled by automated data labeling.</p>
        pub fn machine_labeled(mut self, input: i32) -> Self {
            self.machine_labeled = Some(input);
            self
        }
        /// <p>The total number of objects labeled by automated data labeling.</p>
        pub fn set_machine_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.machine_labeled = input;
            self
        }
        /// <p>The total number of objects that could not be labeled due to an error.</p>
        pub fn failed_non_retryable_error(mut self, input: i32) -> Self {
            self.failed_non_retryable_error = Some(input);
            self
        }
        /// <p>The total number of objects that could not be labeled due to an error.</p>
        pub fn set_failed_non_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_non_retryable_error = input;
            self
        }
        /// <p>The total number of objects not yet labeled.</p>
        pub fn unlabeled(mut self, input: i32) -> Self {
            self.unlabeled = Some(input);
            self
        }
        /// <p>The total number of objects not yet labeled.</p>
        pub fn set_unlabeled(mut self, input: std::option::Option<i32>) -> Self {
            self.unlabeled = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelCounters`](crate::model::LabelCounters)
        pub fn build(self) -> crate::model::LabelCounters {
            crate::model::LabelCounters {
                total_labeled: self.total_labeled.unwrap_or_default(),
                human_labeled: self.human_labeled.unwrap_or_default(),
                machine_labeled: self.machine_labeled.unwrap_or_default(),
                failed_non_retryable_error: self.failed_non_retryable_error.unwrap_or_default(),
                unlabeled: self.unlabeled.unwrap_or_default(),
            }
        }
    }
}
impl LabelCounters {
    /// Creates a new builder-style object to manufacture [`LabelCounters`](crate::model::LabelCounters)
    pub fn builder() -> crate::model::label_counters::Builder {
        crate::model::label_counters::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LabelingJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LabelingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => LabelingJobStatus::Completed,
            "Failed" => LabelingJobStatus::Failed,
            "InProgress" => LabelingJobStatus::InProgress,
            "Initializing" => LabelingJobStatus::Initializing,
            "Stopped" => LabelingJobStatus::Stopped,
            "Stopping" => LabelingJobStatus::Stopping,
            other => LabelingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LabelingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LabelingJobStatus::from(s))
    }
}
impl LabelingJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LabelingJobStatus::Completed => "Completed",
            LabelingJobStatus::Failed => "Failed",
            LabelingJobStatus::InProgress => "InProgress",
            LabelingJobStatus::Initializing => "Initializing",
            LabelingJobStatus::Stopped => "Stopped",
            LabelingJobStatus::Stopping => "Stopping",
            LabelingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Failed",
            "InProgress",
            "Initializing",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for LabelingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that contains a list of recommendation jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceRecommendationsJob {
    /// <p>The name of the job.</p>
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job description.</p>
    pub job_description: std::option::Option<std::string::String>,
    /// <p>The recommendation job type.</p>
    pub job_type: std::option::Option<crate::model::RecommendationJobType>,
    /// <p>The Amazon Resource Name (ARN) of the recommendation job.</p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job.</p>
    pub status: std::option::Option<crate::model::RecommendationJobStatus>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that shows when the job completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>If the job fails, provides information why the job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl InferenceRecommendationsJob {
    /// <p>The name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job description.</p>
    pub fn job_description(&self) -> std::option::Option<&str> {
        self.job_description.as_deref()
    }
    /// <p>The recommendation job type.</p>
    pub fn job_type(&self) -> std::option::Option<&crate::model::RecommendationJobType> {
        self.job_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the recommendation job.</p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RecommendationJobStatus> {
        self.status.as_ref()
    }
    /// <p>A timestamp that shows when the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that shows when the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>A timestamp that shows when the job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>If the job fails, provides information why the job failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for InferenceRecommendationsJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceRecommendationsJob");
        formatter.field("job_name", &self.job_name);
        formatter.field("job_description", &self.job_description);
        formatter.field("job_type", &self.job_type);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`InferenceRecommendationsJob`](crate::model::InferenceRecommendationsJob)
pub mod inference_recommendations_job {

    /// A builder for [`InferenceRecommendationsJob`](crate::model::InferenceRecommendationsJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_description: std::option::Option<std::string::String>,
        pub(crate) job_type: std::option::Option<crate::model::RecommendationJobType>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RecommendationJobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The job description.</p>
        pub fn job_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_description = Some(input.into());
            self
        }
        /// <p>The job description.</p>
        pub fn set_job_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_description = input;
            self
        }
        /// <p>The recommendation job type.</p>
        pub fn job_type(mut self, input: crate::model::RecommendationJobType) -> Self {
            self.job_type = Some(input);
            self
        }
        /// <p>The recommendation job type.</p>
        pub fn set_job_type(
            mut self,
            input: std::option::Option<crate::model::RecommendationJobType>,
        ) -> Self {
            self.job_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommendation job.</p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommendation job.</p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job.</p>
        pub fn status(mut self, input: crate::model::RecommendationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RecommendationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>A timestamp that shows when the job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>If the job fails, provides information why the job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the job fails, provides information why the job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceRecommendationsJob`](crate::model::InferenceRecommendationsJob)
        pub fn build(self) -> crate::model::InferenceRecommendationsJob {
            crate::model::InferenceRecommendationsJob {
                job_name: self.job_name,
                job_description: self.job_description,
                job_type: self.job_type,
                job_arn: self.job_arn,
                status: self.status,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                role_arn: self.role_arn,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl InferenceRecommendationsJob {
    /// Creates a new builder-style object to manufacture [`InferenceRecommendationsJob`](crate::model::InferenceRecommendationsJob)
    pub fn builder() -> crate::model::inference_recommendations_job::Builder {
        crate::model::inference_recommendations_job::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecommendationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => RecommendationJobStatus::Completed,
            "FAILED" => RecommendationJobStatus::Failed,
            "IN_PROGRESS" => RecommendationJobStatus::InProgress,
            "PENDING" => RecommendationJobStatus::Pending,
            "STOPPED" => RecommendationJobStatus::Stopped,
            "STOPPING" => RecommendationJobStatus::Stopping,
            other => RecommendationJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecommendationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationJobStatus::from(s))
    }
}
impl RecommendationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationJobStatus::Completed => "COMPLETED",
            RecommendationJobStatus::Failed => "FAILED",
            RecommendationJobStatus::InProgress => "IN_PROGRESS",
            RecommendationJobStatus::Pending => "PENDING",
            RecommendationJobStatus::Stopped => "STOPPED",
            RecommendationJobStatus::Stopping => "STOPPING",
            RecommendationJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "PENDING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for RecommendationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationJobType {
    #[allow(missing_docs)] // documentation missing in model
    Advanced,
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecommendationJobType {
    fn from(s: &str) -> Self {
        match s {
            "Advanced" => RecommendationJobType::Advanced,
            "Default" => RecommendationJobType::Default,
            other => RecommendationJobType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecommendationJobType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationJobType::from(s))
    }
}
impl RecommendationJobType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationJobType::Advanced => "Advanced",
            RecommendationJobType::Default => "Default",
            RecommendationJobType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Advanced", "Default"]
    }
}
impl AsRef<str> for RecommendationJobType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListInferenceRecommendationsJobsSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListInferenceRecommendationsJobsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ListInferenceRecommendationsJobsSortBy::CreationTime,
            "Name" => ListInferenceRecommendationsJobsSortBy::Name,
            "Status" => ListInferenceRecommendationsJobsSortBy::Status,
            other => ListInferenceRecommendationsJobsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListInferenceRecommendationsJobsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListInferenceRecommendationsJobsSortBy::from(s))
    }
}
impl ListInferenceRecommendationsJobsSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListInferenceRecommendationsJobsSortBy::CreationTime => "CreationTime",
            ListInferenceRecommendationsJobsSortBy::Name => "Name",
            ListInferenceRecommendationsJobsSortBy::Status => "Status",
            ListInferenceRecommendationsJobsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for ListInferenceRecommendationsJobsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A version of a SageMaker <code>Image</code>. A version represents an existing container image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageVersion {
    /// <p>When the version was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When a create or delete operation fails, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the version.</p>
    pub image_version_arn: std::option::Option<std::string::String>,
    /// <p>The status of the version.</p>
    pub image_version_status: std::option::Option<crate::model::ImageVersionStatus>,
    /// <p>When the version was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version number.</p>
    pub version: std::option::Option<i32>,
}
impl ImageVersion {
    /// <p>When the version was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When a create or delete operation fails, the reason for the failure.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
    pub fn image_arn(&self) -> std::option::Option<&str> {
        self.image_arn.as_deref()
    }
    /// <p>The ARN of the version.</p>
    pub fn image_version_arn(&self) -> std::option::Option<&str> {
        self.image_version_arn.as_deref()
    }
    /// <p>The status of the version.</p>
    pub fn image_version_status(&self) -> std::option::Option<&crate::model::ImageVersionStatus> {
        self.image_version_status.as_ref()
    }
    /// <p>When the version was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The version number.</p>
    pub fn version(&self) -> std::option::Option<i32> {
        self.version
    }
}
impl std::fmt::Debug for ImageVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageVersion");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_version_arn", &self.image_version_arn);
        formatter.field("image_version_status", &self.image_version_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ImageVersion`](crate::model::ImageVersion)
pub mod image_version {

    /// A builder for [`ImageVersion`](crate::model::ImageVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) image_arn: std::option::Option<std::string::String>,
        pub(crate) image_version_arn: std::option::Option<std::string::String>,
        pub(crate) image_version_status: std::option::Option<crate::model::ImageVersionStatus>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When the version was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the version was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When a create or delete operation fails, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>When a create or delete operation fails, the reason for the failure.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_arn = input;
            self
        }
        /// <p>The ARN of the version.</p>
        pub fn image_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the version.</p>
        pub fn set_image_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_version_arn = input;
            self
        }
        /// <p>The status of the version.</p>
        pub fn image_version_status(mut self, input: crate::model::ImageVersionStatus) -> Self {
            self.image_version_status = Some(input);
            self
        }
        /// <p>The status of the version.</p>
        pub fn set_image_version_status(
            mut self,
            input: std::option::Option<crate::model::ImageVersionStatus>,
        ) -> Self {
            self.image_version_status = input;
            self
        }
        /// <p>When the version was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the version was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The version number.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageVersion`](crate::model::ImageVersion)
        pub fn build(self) -> crate::model::ImageVersion {
            crate::model::ImageVersion {
                creation_time: self.creation_time,
                failure_reason: self.failure_reason,
                image_arn: self.image_arn,
                image_version_arn: self.image_version_arn,
                image_version_status: self.image_version_status,
                last_modified_time: self.last_modified_time,
                version: self.version,
            }
        }
    }
}
impl ImageVersion {
    /// Creates a new builder-style object to manufacture [`ImageVersion`](crate::model::ImageVersion)
    pub fn builder() -> crate::model::image_version::Builder {
        crate::model::image_version::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ImageVersionStatus::Created,
            "CREATE_FAILED" => ImageVersionStatus::CreateFailed,
            "CREATING" => ImageVersionStatus::Creating,
            "DELETE_FAILED" => ImageVersionStatus::DeleteFailed,
            "DELETING" => ImageVersionStatus::Deleting,
            other => ImageVersionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionStatus::from(s))
    }
}
impl ImageVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionStatus::Created => "CREATED",
            ImageVersionStatus::CreateFailed => "CREATE_FAILED",
            ImageVersionStatus::Creating => "CREATING",
            ImageVersionStatus::DeleteFailed => "DELETE_FAILED",
            ImageVersionStatus::Deleting => "DELETING",
            ImageVersionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
        ]
    }
}
impl AsRef<str> for ImageVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => ImageVersionSortOrder::Ascending,
            "DESCENDING" => ImageVersionSortOrder::Descending,
            other => ImageVersionSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionSortOrder::from(s))
    }
}
impl ImageVersionSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionSortOrder::Ascending => "ASCENDING",
            ImageVersionSortOrder::Descending => "DESCENDING",
            ImageVersionSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for ImageVersionSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Version,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ImageVersionSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ImageVersionSortBy::LastModifiedTime,
            "VERSION" => ImageVersionSortBy::Version,
            other => ImageVersionSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionSortBy::from(s))
    }
}
impl ImageVersionSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionSortBy::CreationTime => "CREATION_TIME",
            ImageVersionSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ImageVersionSortBy::Version => "VERSION",
            ImageVersionSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "LAST_MODIFIED_TIME", "VERSION"]
    }
}
impl AsRef<str> for ImageVersionSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A SageMaker image. A SageMaker image represents a set of container images that are derived from a common base container image. Each of these container images is represented by a SageMaker <code>ImageVersion</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Image {
    /// <p>When the image was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the image as displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The name of the image.</p>
    pub image_name: std::option::Option<std::string::String>,
    /// <p>The status of the image.</p>
    pub image_status: std::option::Option<crate::model::ImageStatus>,
    /// <p>When the image was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl Image {
    /// <p>When the image was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The description of the image.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the image as displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    pub fn image_arn(&self) -> std::option::Option<&str> {
        self.image_arn.as_deref()
    }
    /// <p>The name of the image.</p>
    pub fn image_name(&self) -> std::option::Option<&str> {
        self.image_name.as_deref()
    }
    /// <p>The status of the image.</p>
    pub fn image_status(&self) -> std::option::Option<&crate::model::ImageStatus> {
        self.image_status.as_ref()
    }
    /// <p>When the image was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Image");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("display_name", &self.display_name);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_name", &self.image_name);
        formatter.field("image_status", &self.image_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`Image`](crate::model::Image)
pub mod image {

    /// A builder for [`Image`](crate::model::Image)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) image_arn: std::option::Option<std::string::String>,
        pub(crate) image_name: std::option::Option<std::string::String>,
        pub(crate) image_status: std::option::Option<crate::model::ImageStatus>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>When the image was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the image was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the image.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the image as displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the image as displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image.</p>
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_arn = input;
            self
        }
        /// <p>The name of the image.</p>
        pub fn image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_name = Some(input.into());
            self
        }
        /// <p>The name of the image.</p>
        pub fn set_image_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_name = input;
            self
        }
        /// <p>The status of the image.</p>
        pub fn image_status(mut self, input: crate::model::ImageStatus) -> Self {
            self.image_status = Some(input);
            self
        }
        /// <p>The status of the image.</p>
        pub fn set_image_status(
            mut self,
            input: std::option::Option<crate::model::ImageStatus>,
        ) -> Self {
            self.image_status = input;
            self
        }
        /// <p>When the image was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the image was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Image`](crate::model::Image)
        pub fn build(self) -> crate::model::Image {
            crate::model::Image {
                creation_time: self.creation_time,
                description: self.description,
                display_name: self.display_name,
                failure_reason: self.failure_reason,
                image_arn: self.image_arn,
                image_name: self.image_name,
                image_status: self.image_status,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::model::Image)
    pub fn builder() -> crate::model::image::Builder {
        crate::model::image::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ImageStatus::Created,
            "CREATE_FAILED" => ImageStatus::CreateFailed,
            "CREATING" => ImageStatus::Creating,
            "DELETE_FAILED" => ImageStatus::DeleteFailed,
            "DELETING" => ImageStatus::Deleting,
            "UPDATE_FAILED" => ImageStatus::UpdateFailed,
            "UPDATING" => ImageStatus::Updating,
            other => ImageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageStatus::from(s))
    }
}
impl ImageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageStatus::Created => "CREATED",
            ImageStatus::CreateFailed => "CREATE_FAILED",
            ImageStatus::Creating => "CREATING",
            ImageStatus::DeleteFailed => "DELETE_FAILED",
            ImageStatus::Deleting => "DELETING",
            ImageStatus::UpdateFailed => "UPDATE_FAILED",
            ImageStatus::Updating => "UPDATING",
            ImageStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
            "UPDATE_FAILED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ImageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => ImageSortOrder::Ascending,
            "DESCENDING" => ImageSortOrder::Descending,
            other => ImageSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageSortOrder::from(s))
    }
}
impl ImageSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageSortOrder::Ascending => "ASCENDING",
            ImageSortOrder::Descending => "DESCENDING",
            ImageSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for ImageSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    ImageName,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ImageSortBy::CreationTime,
            "IMAGE_NAME" => ImageSortBy::ImageName,
            "LAST_MODIFIED_TIME" => ImageSortBy::LastModifiedTime,
            other => ImageSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageSortBy::from(s))
    }
}
impl ImageSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageSortBy::CreationTime => "CREATION_TIME",
            ImageSortBy::ImageName => "IMAGE_NAME",
            ImageSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ImageSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "IMAGE_NAME", "LAST_MODIFIED_TIME"]
    }
}
impl AsRef<str> for ImageSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobSummary {
    /// <p>The name of the tuning job.</p>
    pub hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the tuning job.</p>
    pub hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the tuning job.</p>
    pub hyper_parameter_tuning_job_status:
        std::option::Option<crate::model::HyperParameterTuningJobStatus>,
    /// <p>Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to use for each iteration. Currently, the only valid value is Bayesian.</p>
    pub strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
    /// <p>The date and time that the tuning job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the tuning job ended.</p>
    pub hyper_parameter_tuning_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the tuning job was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The <code>TrainingJobStatusCounters</code> object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.</p>
    pub training_job_status_counters: std::option::Option<crate::model::TrainingJobStatusCounters>,
    /// <p>The <code>ObjectiveStatusCounters</code> object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.</p>
    pub objective_status_counters: std::option::Option<crate::model::ObjectiveStatusCounters>,
    /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.</p>
    pub resource_limits: std::option::Option<crate::model::ResourceLimits>,
}
impl HyperParameterTuningJobSummary {
    /// <p>The name of the tuning job.</p>
    pub fn hyper_parameter_tuning_job_name(&self) -> std::option::Option<&str> {
        self.hyper_parameter_tuning_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the tuning job.</p>
    pub fn hyper_parameter_tuning_job_arn(&self) -> std::option::Option<&str> {
        self.hyper_parameter_tuning_job_arn.as_deref()
    }
    /// <p>The status of the tuning job.</p>
    pub fn hyper_parameter_tuning_job_status(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobStatus> {
        self.hyper_parameter_tuning_job_status.as_ref()
    }
    /// <p>Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to use for each iteration. Currently, the only valid value is Bayesian.</p>
    pub fn strategy(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobStrategyType> {
        self.strategy.as_ref()
    }
    /// <p>The date and time that the tuning job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time that the tuning job ended.</p>
    pub fn hyper_parameter_tuning_end_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.hyper_parameter_tuning_end_time.as_ref()
    }
    /// <p>The date and time that the tuning job was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The <code>TrainingJobStatusCounters</code> object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.</p>
    pub fn training_job_status_counters(
        &self,
    ) -> std::option::Option<&crate::model::TrainingJobStatusCounters> {
        self.training_job_status_counters.as_ref()
    }
    /// <p>The <code>ObjectiveStatusCounters</code> object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.</p>
    pub fn objective_status_counters(
        &self,
    ) -> std::option::Option<&crate::model::ObjectiveStatusCounters> {
        self.objective_status_counters.as_ref()
    }
    /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.</p>
    pub fn resource_limits(&self) -> std::option::Option<&crate::model::ResourceLimits> {
        self.resource_limits.as_ref()
    }
}
impl std::fmt::Debug for HyperParameterTuningJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobSummary");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.field(
            "hyper_parameter_tuning_job_arn",
            &self.hyper_parameter_tuning_job_arn,
        );
        formatter.field(
            "hyper_parameter_tuning_job_status",
            &self.hyper_parameter_tuning_job_status,
        );
        formatter.field("strategy", &self.strategy);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "hyper_parameter_tuning_end_time",
            &self.hyper_parameter_tuning_end_time,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "training_job_status_counters",
            &self.training_job_status_counters,
        );
        formatter.field("objective_status_counters", &self.objective_status_counters);
        formatter.field("resource_limits", &self.resource_limits);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
pub mod hyper_parameter_tuning_job_summary {

    /// A builder for [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
        pub(crate) hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
        pub(crate) hyper_parameter_tuning_job_status:
            std::option::Option<crate::model::HyperParameterTuningJobStatus>,
        pub(crate) strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) hyper_parameter_tuning_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_job_status_counters:
            std::option::Option<crate::model::TrainingJobStatusCounters>,
        pub(crate) objective_status_counters:
            std::option::Option<crate::model::ObjectiveStatusCounters>,
        pub(crate) resource_limits: std::option::Option<crate::model::ResourceLimits>,
    }
    impl Builder {
        /// <p>The name of the tuning job.</p>
        pub fn hyper_parameter_tuning_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = Some(input.into());
            self
        }
        /// <p>The name of the tuning job.</p>
        pub fn set_hyper_parameter_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the tuning job.</p>
        pub fn hyper_parameter_tuning_job_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the tuning job.</p>
        pub fn set_hyper_parameter_tuning_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_arn = input;
            self
        }
        /// <p>The status of the tuning job.</p>
        pub fn hyper_parameter_tuning_job_status(
            mut self,
            input: crate::model::HyperParameterTuningJobStatus,
        ) -> Self {
            self.hyper_parameter_tuning_job_status = Some(input);
            self
        }
        /// <p>The status of the tuning job.</p>
        pub fn set_hyper_parameter_tuning_job_status(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStatus>,
        ) -> Self {
            self.hyper_parameter_tuning_job_status = input;
            self
        }
        /// <p>Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to use for each iteration. Currently, the only valid value is Bayesian.</p>
        pub fn strategy(
            mut self,
            input: crate::model::HyperParameterTuningJobStrategyType,
        ) -> Self {
            self.strategy = Some(input);
            self
        }
        /// <p>Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to use for each iteration. Currently, the only valid value is Bayesian.</p>
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        ) -> Self {
            self.strategy = input;
            self
        }
        /// <p>The date and time that the tuning job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time that the tuning job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the tuning job ended.</p>
        pub fn hyper_parameter_tuning_end_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.hyper_parameter_tuning_end_time = Some(input);
            self
        }
        /// <p>The date and time that the tuning job ended.</p>
        pub fn set_hyper_parameter_tuning_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.hyper_parameter_tuning_end_time = input;
            self
        }
        /// <p>The date and time that the tuning job was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the tuning job was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The <code>TrainingJobStatusCounters</code> object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.</p>
        pub fn training_job_status_counters(
            mut self,
            input: crate::model::TrainingJobStatusCounters,
        ) -> Self {
            self.training_job_status_counters = Some(input);
            self
        }
        /// <p>The <code>TrainingJobStatusCounters</code> object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.</p>
        pub fn set_training_job_status_counters(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatusCounters>,
        ) -> Self {
            self.training_job_status_counters = input;
            self
        }
        /// <p>The <code>ObjectiveStatusCounters</code> object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.</p>
        pub fn objective_status_counters(
            mut self,
            input: crate::model::ObjectiveStatusCounters,
        ) -> Self {
            self.objective_status_counters = Some(input);
            self
        }
        /// <p>The <code>ObjectiveStatusCounters</code> object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.</p>
        pub fn set_objective_status_counters(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatusCounters>,
        ) -> Self {
            self.objective_status_counters = input;
            self
        }
        /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.</p>
        pub fn resource_limits(mut self, input: crate::model::ResourceLimits) -> Self {
            self.resource_limits = Some(input);
            self
        }
        /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.</p>
        pub fn set_resource_limits(
            mut self,
            input: std::option::Option<crate::model::ResourceLimits>,
        ) -> Self {
            self.resource_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
        pub fn build(self) -> crate::model::HyperParameterTuningJobSummary {
            crate::model::HyperParameterTuningJobSummary {
                hyper_parameter_tuning_job_name: self.hyper_parameter_tuning_job_name,
                hyper_parameter_tuning_job_arn: self.hyper_parameter_tuning_job_arn,
                hyper_parameter_tuning_job_status: self.hyper_parameter_tuning_job_status,
                strategy: self.strategy,
                creation_time: self.creation_time,
                hyper_parameter_tuning_end_time: self.hyper_parameter_tuning_end_time,
                last_modified_time: self.last_modified_time,
                training_job_status_counters: self.training_job_status_counters,
                objective_status_counters: self.objective_status_counters,
                resource_limits: self.resource_limits,
            }
        }
    }
}
impl HyperParameterTuningJobSummary {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_summary::Builder {
        crate::model::hyper_parameter_tuning_job_summary::Builder::default()
    }
}

/// <p>Specifies the maximum number of training jobs and parallel training jobs that a hyperparameter tuning job can launch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimits {
    /// <p>The maximum number of training jobs that a hyperparameter tuning job can launch.</p>
    pub max_number_of_training_jobs: i32,
    /// <p>The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.</p>
    pub max_parallel_training_jobs: i32,
}
impl ResourceLimits {
    /// <p>The maximum number of training jobs that a hyperparameter tuning job can launch.</p>
    pub fn max_number_of_training_jobs(&self) -> i32 {
        self.max_number_of_training_jobs
    }
    /// <p>The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.</p>
    pub fn max_parallel_training_jobs(&self) -> i32 {
        self.max_parallel_training_jobs
    }
}
impl std::fmt::Debug for ResourceLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimits");
        formatter.field(
            "max_number_of_training_jobs",
            &self.max_number_of_training_jobs,
        );
        formatter.field(
            "max_parallel_training_jobs",
            &self.max_parallel_training_jobs,
        );
        formatter.finish()
    }
}
/// See [`ResourceLimits`](crate::model::ResourceLimits)
pub mod resource_limits {

    /// A builder for [`ResourceLimits`](crate::model::ResourceLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_number_of_training_jobs: std::option::Option<i32>,
        pub(crate) max_parallel_training_jobs: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of training jobs that a hyperparameter tuning job can launch.</p>
        pub fn max_number_of_training_jobs(mut self, input: i32) -> Self {
            self.max_number_of_training_jobs = Some(input);
            self
        }
        /// <p>The maximum number of training jobs that a hyperparameter tuning job can launch.</p>
        pub fn set_max_number_of_training_jobs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_number_of_training_jobs = input;
            self
        }
        /// <p>The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.</p>
        pub fn max_parallel_training_jobs(mut self, input: i32) -> Self {
            self.max_parallel_training_jobs = Some(input);
            self
        }
        /// <p>The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.</p>
        pub fn set_max_parallel_training_jobs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parallel_training_jobs = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimits`](crate::model::ResourceLimits)
        pub fn build(self) -> crate::model::ResourceLimits {
            crate::model::ResourceLimits {
                max_number_of_training_jobs: self.max_number_of_training_jobs.unwrap_or_default(),
                max_parallel_training_jobs: self.max_parallel_training_jobs.unwrap_or_default(),
            }
        }
    }
}
impl ResourceLimits {
    /// Creates a new builder-style object to manufacture [`ResourceLimits`](crate::model::ResourceLimits)
    pub fn builder() -> crate::model::resource_limits::Builder {
        crate::model::resource_limits::Builder::default()
    }
}

/// <p>Specifies the number of training jobs that this hyperparameter tuning job launched, categorized by the status of their objective metric. The objective metric status shows whether the final objective metric for the training job has been evaluated by the tuning job and used in the hyperparameter tuning process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ObjectiveStatusCounters {
    /// <p>The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p>
    pub succeeded: i32,
    /// <p>The number of training jobs that are in progress and pending evaluation of their final objective metric.</p>
    pub pending: i32,
    /// <p>The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p>
    pub failed: i32,
}
impl ObjectiveStatusCounters {
    /// <p>The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p>
    pub fn succeeded(&self) -> i32 {
        self.succeeded
    }
    /// <p>The number of training jobs that are in progress and pending evaluation of their final objective metric.</p>
    pub fn pending(&self) -> i32 {
        self.pending
    }
    /// <p>The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p>
    pub fn failed(&self) -> i32 {
        self.failed
    }
}
impl std::fmt::Debug for ObjectiveStatusCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ObjectiveStatusCounters");
        formatter.field("succeeded", &self.succeeded);
        formatter.field("pending", &self.pending);
        formatter.field("failed", &self.failed);
        formatter.finish()
    }
}
/// See [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
pub mod objective_status_counters {

    /// A builder for [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) succeeded: std::option::Option<i32>,
        pub(crate) pending: std::option::Option<i32>,
        pub(crate) failed: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p>
        pub fn succeeded(mut self, input: i32) -> Self {
            self.succeeded = Some(input);
            self
        }
        /// <p>The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.</p>
        pub fn set_succeeded(mut self, input: std::option::Option<i32>) -> Self {
            self.succeeded = input;
            self
        }
        /// <p>The number of training jobs that are in progress and pending evaluation of their final objective metric.</p>
        pub fn pending(mut self, input: i32) -> Self {
            self.pending = Some(input);
            self
        }
        /// <p>The number of training jobs that are in progress and pending evaluation of their final objective metric.</p>
        pub fn set_pending(mut self, input: std::option::Option<i32>) -> Self {
            self.pending = input;
            self
        }
        /// <p>The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p>
        pub fn failed(mut self, input: i32) -> Self {
            self.failed = Some(input);
            self
        }
        /// <p>The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.</p>
        pub fn set_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.failed = input;
            self
        }
        /// Consumes the builder and constructs a [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
        pub fn build(self) -> crate::model::ObjectiveStatusCounters {
            crate::model::ObjectiveStatusCounters {
                succeeded: self.succeeded.unwrap_or_default(),
                pending: self.pending.unwrap_or_default(),
                failed: self.failed.unwrap_or_default(),
            }
        }
    }
}
impl ObjectiveStatusCounters {
    /// Creates a new builder-style object to manufacture [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
    pub fn builder() -> crate::model::objective_status_counters::Builder {
        crate::model::objective_status_counters::Builder::default()
    }
}

/// <p>The numbers of training jobs launched by a hyperparameter tuning job, categorized by status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobStatusCounters {
    /// <p>The number of completed training jobs launched by the hyperparameter tuning job.</p>
    pub completed: i32,
    /// <p>The number of in-progress training jobs launched by a hyperparameter tuning job.</p>
    pub in_progress: i32,
    /// <p>The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.</p>
    pub retryable_error: i32,
    /// <p>The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.</p>
    pub non_retryable_error: i32,
    /// <p>The number of training jobs launched by a hyperparameter tuning job that were manually stopped.</p>
    pub stopped: i32,
}
impl TrainingJobStatusCounters {
    /// <p>The number of completed training jobs launched by the hyperparameter tuning job.</p>
    pub fn completed(&self) -> i32 {
        self.completed
    }
    /// <p>The number of in-progress training jobs launched by a hyperparameter tuning job.</p>
    pub fn in_progress(&self) -> i32 {
        self.in_progress
    }
    /// <p>The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.</p>
    pub fn retryable_error(&self) -> i32 {
        self.retryable_error
    }
    /// <p>The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.</p>
    pub fn non_retryable_error(&self) -> i32 {
        self.non_retryable_error
    }
    /// <p>The number of training jobs launched by a hyperparameter tuning job that were manually stopped.</p>
    pub fn stopped(&self) -> i32 {
        self.stopped
    }
}
impl std::fmt::Debug for TrainingJobStatusCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobStatusCounters");
        formatter.field("completed", &self.completed);
        formatter.field("in_progress", &self.in_progress);
        formatter.field("retryable_error", &self.retryable_error);
        formatter.field("non_retryable_error", &self.non_retryable_error);
        formatter.field("stopped", &self.stopped);
        formatter.finish()
    }
}
/// See [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
pub mod training_job_status_counters {

    /// A builder for [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) completed: std::option::Option<i32>,
        pub(crate) in_progress: std::option::Option<i32>,
        pub(crate) retryable_error: std::option::Option<i32>,
        pub(crate) non_retryable_error: std::option::Option<i32>,
        pub(crate) stopped: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of completed training jobs launched by the hyperparameter tuning job.</p>
        pub fn completed(mut self, input: i32) -> Self {
            self.completed = Some(input);
            self
        }
        /// <p>The number of completed training jobs launched by the hyperparameter tuning job.</p>
        pub fn set_completed(mut self, input: std::option::Option<i32>) -> Self {
            self.completed = input;
            self
        }
        /// <p>The number of in-progress training jobs launched by a hyperparameter tuning job.</p>
        pub fn in_progress(mut self, input: i32) -> Self {
            self.in_progress = Some(input);
            self
        }
        /// <p>The number of in-progress training jobs launched by a hyperparameter tuning job.</p>
        pub fn set_in_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.in_progress = input;
            self
        }
        /// <p>The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.</p>
        pub fn retryable_error(mut self, input: i32) -> Self {
            self.retryable_error = Some(input);
            self
        }
        /// <p>The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.</p>
        pub fn set_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.retryable_error = input;
            self
        }
        /// <p>The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.</p>
        pub fn non_retryable_error(mut self, input: i32) -> Self {
            self.non_retryable_error = Some(input);
            self
        }
        /// <p>The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.</p>
        pub fn set_non_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.non_retryable_error = input;
            self
        }
        /// <p>The number of training jobs launched by a hyperparameter tuning job that were manually stopped.</p>
        pub fn stopped(mut self, input: i32) -> Self {
            self.stopped = Some(input);
            self
        }
        /// <p>The number of training jobs launched by a hyperparameter tuning job that were manually stopped.</p>
        pub fn set_stopped(mut self, input: std::option::Option<i32>) -> Self {
            self.stopped = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
        pub fn build(self) -> crate::model::TrainingJobStatusCounters {
            crate::model::TrainingJobStatusCounters {
                completed: self.completed.unwrap_or_default(),
                in_progress: self.in_progress.unwrap_or_default(),
                retryable_error: self.retryable_error.unwrap_or_default(),
                non_retryable_error: self.non_retryable_error.unwrap_or_default(),
                stopped: self.stopped.unwrap_or_default(),
            }
        }
    }
}
impl TrainingJobStatusCounters {
    /// Creates a new builder-style object to manufacture [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
    pub fn builder() -> crate::model::training_job_status_counters::Builder {
        crate::model::training_job_status_counters::Builder::default()
    }
}

/// <p>The strategy hyperparameter tuning uses to
/// find
/// the best combination of hyperparameters for your model. Currently,
/// the only
/// supported
/// value is <code>Bayesian</code>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobStrategyType {
    #[allow(missing_docs)] // documentation missing in model
    Bayesian,
    #[allow(missing_docs)] // documentation missing in model
    Random,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobStrategyType {
    fn from(s: &str) -> Self {
        match s {
            "Bayesian" => HyperParameterTuningJobStrategyType::Bayesian,
            "Random" => HyperParameterTuningJobStrategyType::Random,
            other => HyperParameterTuningJobStrategyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobStrategyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobStrategyType::from(s))
    }
}
impl HyperParameterTuningJobStrategyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobStrategyType::Bayesian => "Bayesian",
            HyperParameterTuningJobStrategyType::Random => "Random",
            HyperParameterTuningJobStrategyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Bayesian", "Random"]
    }
}
impl AsRef<str> for HyperParameterTuningJobStrategyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => HyperParameterTuningJobStatus::Completed,
            "Failed" => HyperParameterTuningJobStatus::Failed,
            "InProgress" => HyperParameterTuningJobStatus::InProgress,
            "Stopped" => HyperParameterTuningJobStatus::Stopped,
            "Stopping" => HyperParameterTuningJobStatus::Stopping,
            other => HyperParameterTuningJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobStatus::from(s))
    }
}
impl HyperParameterTuningJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobStatus::Completed => "Completed",
            HyperParameterTuningJobStatus::Failed => "Failed",
            HyperParameterTuningJobStatus::InProgress => "InProgress",
            HyperParameterTuningJobStatus::Stopped => "Stopped",
            HyperParameterTuningJobStatus::Stopping => "Stopping",
            HyperParameterTuningJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for HyperParameterTuningJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobSortByOptions {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => HyperParameterTuningJobSortByOptions::CreationTime,
            "Name" => HyperParameterTuningJobSortByOptions::Name,
            "Status" => HyperParameterTuningJobSortByOptions::Status,
            other => HyperParameterTuningJobSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobSortByOptions::from(s))
    }
}
impl HyperParameterTuningJobSortByOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobSortByOptions::CreationTime => "CreationTime",
            HyperParameterTuningJobSortByOptions::Name => "Name",
            HyperParameterTuningJobSortByOptions::Status => "Status",
            HyperParameterTuningJobSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for HyperParameterTuningJobSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for human task user interface information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanTaskUiSummary {
    /// <p>The name of the human task user interface.</p>
    pub human_task_ui_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp when SageMaker created the human task user interface.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl HumanTaskUiSummary {
    /// <p>The name of the human task user interface.</p>
    pub fn human_task_ui_name(&self) -> std::option::Option<&str> {
        self.human_task_ui_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    pub fn human_task_ui_arn(&self) -> std::option::Option<&str> {
        self.human_task_ui_arn.as_deref()
    }
    /// <p>A timestamp when SageMaker created the human task user interface.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for HumanTaskUiSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanTaskUiSummary");
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
pub mod human_task_ui_summary {

    /// A builder for [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_task_ui_name: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the human task user interface.</p>
        pub fn human_task_ui_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_name = Some(input.into());
            self
        }
        /// <p>The name of the human task user interface.</p>
        pub fn set_human_task_ui_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// <p>A timestamp when SageMaker created the human task user interface.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp when SageMaker created the human task user interface.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
        pub fn build(self) -> crate::model::HumanTaskUiSummary {
            crate::model::HumanTaskUiSummary {
                human_task_ui_name: self.human_task_ui_name,
                human_task_ui_arn: self.human_task_ui_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl HumanTaskUiSummary {
    /// Creates a new builder-style object to manufacture [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
    pub fn builder() -> crate::model::human_task_ui_summary::Builder {
        crate::model::human_task_ui_summary::Builder::default()
    }
}

/// <p>Contains summary information about the flow definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlowDefinitionSummary {
    /// <p>The name of the flow definition.</p>
    pub flow_definition_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    pub flow_definition_arn: std::option::Option<std::string::String>,
    /// <p>The status of the flow definition. Valid values:</p>
    pub flow_definition_status: std::option::Option<crate::model::FlowDefinitionStatus>,
    /// <p>The timestamp when SageMaker created the flow definition.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl FlowDefinitionSummary {
    /// <p>The name of the flow definition.</p>
    pub fn flow_definition_name(&self) -> std::option::Option<&str> {
        self.flow_definition_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    pub fn flow_definition_arn(&self) -> std::option::Option<&str> {
        self.flow_definition_arn.as_deref()
    }
    /// <p>The status of the flow definition. Valid values:</p>
    pub fn flow_definition_status(
        &self,
    ) -> std::option::Option<&crate::model::FlowDefinitionStatus> {
        self.flow_definition_status.as_ref()
    }
    /// <p>The timestamp when SageMaker created the flow definition.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for FlowDefinitionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlowDefinitionSummary");
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.field("flow_definition_arn", &self.flow_definition_arn);
        formatter.field("flow_definition_status", &self.flow_definition_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
pub mod flow_definition_summary {

    /// A builder for [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flow_definition_name: std::option::Option<std::string::String>,
        pub(crate) flow_definition_arn: std::option::Option<std::string::String>,
        pub(crate) flow_definition_status: std::option::Option<crate::model::FlowDefinitionStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the flow definition.</p>
        pub fn flow_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_definition_name = Some(input.into());
            self
        }
        /// <p>The name of the flow definition.</p>
        pub fn set_flow_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.flow_definition_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
        pub fn flow_definition_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_definition_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
        pub fn set_flow_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.flow_definition_arn = input;
            self
        }
        /// <p>The status of the flow definition. Valid values:</p>
        pub fn flow_definition_status(mut self, input: crate::model::FlowDefinitionStatus) -> Self {
            self.flow_definition_status = Some(input);
            self
        }
        /// <p>The status of the flow definition. Valid values:</p>
        pub fn set_flow_definition_status(
            mut self,
            input: std::option::Option<crate::model::FlowDefinitionStatus>,
        ) -> Self {
            self.flow_definition_status = input;
            self
        }
        /// <p>The timestamp when SageMaker created the flow definition.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when SageMaker created the flow definition.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
        pub fn build(self) -> crate::model::FlowDefinitionSummary {
            crate::model::FlowDefinitionSummary {
                flow_definition_name: self.flow_definition_name,
                flow_definition_arn: self.flow_definition_arn,
                flow_definition_status: self.flow_definition_status,
                creation_time: self.creation_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl FlowDefinitionSummary {
    /// Creates a new builder-style object to manufacture [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
    pub fn builder() -> crate::model::flow_definition_summary::Builder {
        crate::model::flow_definition_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FlowDefinitionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FlowDefinitionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => FlowDefinitionStatus::Active,
            "Deleting" => FlowDefinitionStatus::Deleting,
            "Failed" => FlowDefinitionStatus::Failed,
            "Initializing" => FlowDefinitionStatus::Initializing,
            other => FlowDefinitionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FlowDefinitionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FlowDefinitionStatus::from(s))
    }
}
impl FlowDefinitionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FlowDefinitionStatus::Active => "Active",
            FlowDefinitionStatus::Deleting => "Deleting",
            FlowDefinitionStatus::Failed => "Failed",
            FlowDefinitionStatus::Initializing => "Initializing",
            FlowDefinitionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Deleting", "Failed", "Initializing"]
    }
}
impl AsRef<str> for FlowDefinitionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The name, Arn, <code>CreationTime</code>, <code>FeatureGroup</code> values, <code>LastUpdatedTime</code> and <code>EnableOnlineStorage</code> status of a <code>FeatureGroup</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureGroupSummary {
    /// <p>The name of <code>FeatureGroup</code>.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
    pub feature_group_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of a FeatureGroup. The status can be any of the following: <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>, <code>Deleting</code> or <code>DetailFail</code>. </p>
    pub feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns either: <code>Active</code> or <code>Blocked</code>.</p>
    pub offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
}
impl FeatureGroupSummary {
    /// <p>The name of <code>FeatureGroup</code>.</p>
    pub fn feature_group_name(&self) -> std::option::Option<&str> {
        self.feature_group_name.as_deref()
    }
    /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
    pub fn feature_group_arn(&self) -> std::option::Option<&str> {
        self.feature_group_arn.as_deref()
    }
    /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The status of a FeatureGroup. The status can be any of the following: <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>, <code>Deleting</code> or <code>DetailFail</code>. </p>
    pub fn feature_group_status(&self) -> std::option::Option<&crate::model::FeatureGroupStatus> {
        self.feature_group_status.as_ref()
    }
    /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns either: <code>Active</code> or <code>Blocked</code>.</p>
    pub fn offline_store_status(&self) -> std::option::Option<&crate::model::OfflineStoreStatus> {
        self.offline_store_status.as_ref()
    }
}
impl std::fmt::Debug for FeatureGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureGroupSummary");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("feature_group_status", &self.feature_group_status);
        formatter.field("offline_store_status", &self.offline_store_status);
        formatter.finish()
    }
}
/// See [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
pub mod feature_group_summary {

    /// A builder for [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
        pub(crate) feature_group_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
        pub(crate) offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
    }
    impl Builder {
        /// <p>The name of <code>FeatureGroup</code>.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        /// <p>The name of <code>FeatureGroup</code>.</p>
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
        pub fn feature_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_arn = Some(input.into());
            self
        }
        /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
        pub fn set_feature_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_arn = input;
            self
        }
        /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of a FeatureGroup. The status can be any of the following: <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>, <code>Deleting</code> or <code>DetailFail</code>. </p>
        pub fn feature_group_status(mut self, input: crate::model::FeatureGroupStatus) -> Self {
            self.feature_group_status = Some(input);
            self
        }
        /// <p>The status of a FeatureGroup. The status can be any of the following: <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>, <code>Deleting</code> or <code>DetailFail</code>. </p>
        pub fn set_feature_group_status(
            mut self,
            input: std::option::Option<crate::model::FeatureGroupStatus>,
        ) -> Self {
            self.feature_group_status = input;
            self
        }
        /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns either: <code>Active</code> or <code>Blocked</code>.</p>
        pub fn offline_store_status(mut self, input: crate::model::OfflineStoreStatus) -> Self {
            self.offline_store_status = Some(input);
            self
        }
        /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns either: <code>Active</code> or <code>Blocked</code>.</p>
        pub fn set_offline_store_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatus>,
        ) -> Self {
            self.offline_store_status = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
        pub fn build(self) -> crate::model::FeatureGroupSummary {
            crate::model::FeatureGroupSummary {
                feature_group_name: self.feature_group_name,
                feature_group_arn: self.feature_group_arn,
                creation_time: self.creation_time,
                feature_group_status: self.feature_group_status,
                offline_store_status: self.offline_store_status,
            }
        }
    }
}
impl FeatureGroupSummary {
    /// Creates a new builder-style object to manufacture [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
    pub fn builder() -> crate::model::feature_group_summary::Builder {
        crate::model::feature_group_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    FeatureGroupStatus,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    OfflineStoreStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => FeatureGroupSortBy::CreationTime,
            "FeatureGroupStatus" => FeatureGroupSortBy::FeatureGroupStatus,
            "Name" => FeatureGroupSortBy::Name,
            "OfflineStoreStatus" => FeatureGroupSortBy::OfflineStoreStatus,
            other => FeatureGroupSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupSortBy::from(s))
    }
}
impl FeatureGroupSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupSortBy::CreationTime => "CreationTime",
            FeatureGroupSortBy::FeatureGroupStatus => "FeatureGroupStatus",
            FeatureGroupSortBy::Name => "Name",
            FeatureGroupSortBy::OfflineStoreStatus => "OfflineStoreStatus",
            FeatureGroupSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "FeatureGroupStatus",
            "Name",
            "OfflineStoreStatus",
        ]
    }
}
impl AsRef<str> for FeatureGroupSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => FeatureGroupSortOrder::Ascending,
            "Descending" => FeatureGroupSortOrder::Descending,
            other => FeatureGroupSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupSortOrder::from(s))
    }
}
impl FeatureGroupSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupSortOrder::Ascending => "Ascending",
            FeatureGroupSortOrder::Descending => "Descending",
            FeatureGroupSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for FeatureGroupSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of an experiment. To get the complete set of properties, call the <code>DescribeExperiment</code> API and provide the <code>ExperimentName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentSummary {
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub experiment_arn: std::option::Option<std::string::String>,
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the experiment.</p>
    pub experiment_source: std::option::Option<crate::model::ExperimentSource>,
    /// <p>When the experiment was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the experiment was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExperimentSummary {
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub fn experiment_arn(&self) -> std::option::Option<&str> {
        self.experiment_arn.as_deref()
    }
    /// <p>The name of the experiment.</p>
    pub fn experiment_name(&self) -> std::option::Option<&str> {
        self.experiment_name.as_deref()
    }
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The source of the experiment.</p>
    pub fn experiment_source(&self) -> std::option::Option<&crate::model::ExperimentSource> {
        self.experiment_source.as_ref()
    }
    /// <p>When the experiment was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the experiment was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for ExperimentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentSummary");
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_source", &self.experiment_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ExperimentSummary`](crate::model::ExperimentSummary)
pub mod experiment_summary {

    /// A builder for [`ExperimentSummary`](crate::model::ExperimentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_arn: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) experiment_source: std::option::Option<crate::model::ExperimentSource>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn experiment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn set_experiment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_arn = input;
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn experiment_source(mut self, input: crate::model::ExperimentSource) -> Self {
            self.experiment_source = Some(input);
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn set_experiment_source(
            mut self,
            input: std::option::Option<crate::model::ExperimentSource>,
        ) -> Self {
            self.experiment_source = input;
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentSummary`](crate::model::ExperimentSummary)
        pub fn build(self) -> crate::model::ExperimentSummary {
            crate::model::ExperimentSummary {
                experiment_arn: self.experiment_arn,
                experiment_name: self.experiment_name,
                display_name: self.display_name,
                experiment_source: self.experiment_source,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ExperimentSummary {
    /// Creates a new builder-style object to manufacture [`ExperimentSummary`](crate::model::ExperimentSummary)
    pub fn builder() -> crate::model::experiment_summary::Builder {
        crate::model::experiment_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortExperimentsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortExperimentsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortExperimentsBy::CreationTime,
            "Name" => SortExperimentsBy::Name,
            other => SortExperimentsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortExperimentsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortExperimentsBy::from(s))
    }
}
impl SortExperimentsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortExperimentsBy::CreationTime => "CreationTime",
            SortExperimentsBy::Name => "Name",
            SortExperimentsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortExperimentsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointSummary {
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that shows when the endpoint was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the endpoint.</p>
    /// <ul>
    /// <li> <p> <code>OutOfService</code>: Endpoint is not available to take incoming requests.</p> </li>
    /// <li> <p> <code>Creating</code>: <code>CreateEndpoint</code> is executing.</p> </li>
    /// <li> <p> <code>Updating</code>: <code>UpdateEndpoint</code> or <code>UpdateEndpointWeightsAndCapacities</code> is executing.</p> </li>
    /// <li> <p> <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.</p> </li>
    /// <li> <p> <code>RollingBack</code>: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an <code>InService</code> status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an <code>UpdateEndpointWeightsAndCapacities</code> call or when the <code>UpdateEndpointWeightsAndCapacities</code> operation is called explicitly.</p> </li>
    /// <li> <p> <code>InService</code>: Endpoint is available to process incoming requests.</p> </li>
    /// <li> <p> <code>Deleting</code>: <code>DeleteEndpoint</code> is executing.</p> </li>
    /// <li> <p> <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use <code>DescribeEndpointOutput$FailureReason</code> for information about the failure. <code>DeleteEndpoint</code> is the only operation that can be performed on a failed endpoint.</p> </li>
    /// </ul>
    /// <p>To get a list of endpoints with a specified status, use the <code>ListEndpointsInput$StatusEquals</code> filter.</p>
    pub endpoint_status: std::option::Option<crate::model::EndpointStatus>,
}
impl EndpointSummary {
    /// <p>The name of the endpoint.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
    /// <p>A timestamp that shows when the endpoint was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A timestamp that shows when the endpoint was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the endpoint.</p>
    /// <ul>
    /// <li> <p> <code>OutOfService</code>: Endpoint is not available to take incoming requests.</p> </li>
    /// <li> <p> <code>Creating</code>: <code>CreateEndpoint</code> is executing.</p> </li>
    /// <li> <p> <code>Updating</code>: <code>UpdateEndpoint</code> or <code>UpdateEndpointWeightsAndCapacities</code> is executing.</p> </li>
    /// <li> <p> <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.</p> </li>
    /// <li> <p> <code>RollingBack</code>: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an <code>InService</code> status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an <code>UpdateEndpointWeightsAndCapacities</code> call or when the <code>UpdateEndpointWeightsAndCapacities</code> operation is called explicitly.</p> </li>
    /// <li> <p> <code>InService</code>: Endpoint is available to process incoming requests.</p> </li>
    /// <li> <p> <code>Deleting</code>: <code>DeleteEndpoint</code> is executing.</p> </li>
    /// <li> <p> <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use <code>DescribeEndpointOutput$FailureReason</code> for information about the failure. <code>DeleteEndpoint</code> is the only operation that can be performed on a failed endpoint.</p> </li>
    /// </ul>
    /// <p>To get a list of endpoints with a specified status, use the <code>ListEndpointsInput$StatusEquals</code> filter.</p>
    pub fn endpoint_status(&self) -> std::option::Option<&crate::model::EndpointStatus> {
        self.endpoint_status.as_ref()
    }
}
impl std::fmt::Debug for EndpointSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointSummary");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.finish()
    }
}
/// See [`EndpointSummary`](crate::model::EndpointSummary)
pub mod endpoint_summary {

    /// A builder for [`EndpointSummary`](crate::model::EndpointSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) endpoint_status: std::option::Option<crate::model::EndpointStatus>,
    }
    impl Builder {
        /// <p>The name of the endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the endpoint was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the endpoint was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the endpoint.</p>
        /// <ul>
        /// <li> <p> <code>OutOfService</code>: Endpoint is not available to take incoming requests.</p> </li>
        /// <li> <p> <code>Creating</code>: <code>CreateEndpoint</code> is executing.</p> </li>
        /// <li> <p> <code>Updating</code>: <code>UpdateEndpoint</code> or <code>UpdateEndpointWeightsAndCapacities</code> is executing.</p> </li>
        /// <li> <p> <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.</p> </li>
        /// <li> <p> <code>RollingBack</code>: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an <code>InService</code> status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an <code>UpdateEndpointWeightsAndCapacities</code> call or when the <code>UpdateEndpointWeightsAndCapacities</code> operation is called explicitly.</p> </li>
        /// <li> <p> <code>InService</code>: Endpoint is available to process incoming requests.</p> </li>
        /// <li> <p> <code>Deleting</code>: <code>DeleteEndpoint</code> is executing.</p> </li>
        /// <li> <p> <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use <code>DescribeEndpointOutput$FailureReason</code> for information about the failure. <code>DeleteEndpoint</code> is the only operation that can be performed on a failed endpoint.</p> </li>
        /// </ul>
        /// <p>To get a list of endpoints with a specified status, use the <code>ListEndpointsInput$StatusEquals</code> filter.</p>
        pub fn endpoint_status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.endpoint_status = Some(input);
            self
        }
        /// <p>The status of the endpoint.</p>
        /// <ul>
        /// <li> <p> <code>OutOfService</code>: Endpoint is not available to take incoming requests.</p> </li>
        /// <li> <p> <code>Creating</code>: <code>CreateEndpoint</code> is executing.</p> </li>
        /// <li> <p> <code>Updating</code>: <code>UpdateEndpoint</code> or <code>UpdateEndpointWeightsAndCapacities</code> is executing.</p> </li>
        /// <li> <p> <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.</p> </li>
        /// <li> <p> <code>RollingBack</code>: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an <code>InService</code> status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an <code>UpdateEndpointWeightsAndCapacities</code> call or when the <code>UpdateEndpointWeightsAndCapacities</code> operation is called explicitly.</p> </li>
        /// <li> <p> <code>InService</code>: Endpoint is available to process incoming requests.</p> </li>
        /// <li> <p> <code>Deleting</code>: <code>DeleteEndpoint</code> is executing.</p> </li>
        /// <li> <p> <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use <code>DescribeEndpointOutput$FailureReason</code> for information about the failure. <code>DeleteEndpoint</code> is the only operation that can be performed on a failed endpoint.</p> </li>
        /// </ul>
        /// <p>To get a list of endpoints with a specified status, use the <code>ListEndpointsInput$StatusEquals</code> filter.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointSummary`](crate::model::EndpointSummary)
        pub fn build(self) -> crate::model::EndpointSummary {
            crate::model::EndpointSummary {
                endpoint_name: self.endpoint_name,
                endpoint_arn: self.endpoint_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                endpoint_status: self.endpoint_status,
            }
        }
    }
}
impl EndpointSummary {
    /// Creates a new builder-style object to manufacture [`EndpointSummary`](crate::model::EndpointSummary)
    pub fn builder() -> crate::model::endpoint_summary::Builder {
        crate::model::endpoint_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => EndpointSortKey::CreationTime,
            "Name" => EndpointSortKey::Name,
            "Status" => EndpointSortKey::Status,
            other => EndpointSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointSortKey::from(s))
    }
}
impl EndpointSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointSortKey::CreationTime => "CreationTime",
            EndpointSortKey::Name => "Name",
            EndpointSortKey::Status => "Status",
            EndpointSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for EndpointSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an endpoint configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointConfigSummary {
    /// <p>The name of the endpoint configuration.</p>
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
    pub endpoint_config_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint configuration was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl EndpointConfigSummary {
    /// <p>The name of the endpoint configuration.</p>
    pub fn endpoint_config_name(&self) -> std::option::Option<&str> {
        self.endpoint_config_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
    pub fn endpoint_config_arn(&self) -> std::option::Option<&str> {
        self.endpoint_config_arn.as_deref()
    }
    /// <p>A timestamp that shows when the endpoint configuration was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for EndpointConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointConfigSummary");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("endpoint_config_arn", &self.endpoint_config_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
pub mod endpoint_config_summary {

    /// A builder for [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_config_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_config_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the endpoint configuration.</p>
        pub fn endpoint_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint configuration.</p>
        pub fn set_endpoint_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
        pub fn endpoint_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
        pub fn set_endpoint_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_arn = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint configuration was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the endpoint configuration was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
        pub fn build(self) -> crate::model::EndpointConfigSummary {
            crate::model::EndpointConfigSummary {
                endpoint_config_name: self.endpoint_config_name,
                endpoint_config_arn: self.endpoint_config_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl EndpointConfigSummary {
    /// Creates a new builder-style object to manufacture [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
    pub fn builder() -> crate::model::endpoint_config_summary::Builder {
        crate::model::endpoint_config_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointConfigSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => EndpointConfigSortKey::CreationTime,
            "Name" => EndpointConfigSortKey::Name,
            other => EndpointConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointConfigSortKey::from(s))
    }
}
impl EndpointConfigSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointConfigSortKey::CreationTime => "CreationTime",
            EndpointConfigSortKey::Name => "Name",
            EndpointConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for EndpointConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of edge packaging job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgePackagingJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
    pub edge_packaging_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the edge packaging job.</p>
    pub edge_packaging_job_name: std::option::Option<std::string::String>,
    /// <p>The status of the edge packaging job.</p>
    pub edge_packaging_job_status: std::option::Option<crate::model::EdgePackagingJobStatus>,
    /// <p>The name of the SageMaker Neo compilation job.</p>
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The version of the model.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of when the edge packaging job was last updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl EdgePackagingJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
    pub fn edge_packaging_job_arn(&self) -> std::option::Option<&str> {
        self.edge_packaging_job_arn.as_deref()
    }
    /// <p>The name of the edge packaging job.</p>
    pub fn edge_packaging_job_name(&self) -> std::option::Option<&str> {
        self.edge_packaging_job_name.as_deref()
    }
    /// <p>The status of the edge packaging job.</p>
    pub fn edge_packaging_job_status(
        &self,
    ) -> std::option::Option<&crate::model::EdgePackagingJobStatus> {
        self.edge_packaging_job_status.as_ref()
    }
    /// <p>The name of the SageMaker Neo compilation job.</p>
    pub fn compilation_job_name(&self) -> std::option::Option<&str> {
        self.compilation_job_name.as_deref()
    }
    /// <p>The name of the model.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The version of the model.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The timestamp of when the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The timestamp of when the edge packaging job was last updated.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for EdgePackagingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgePackagingJobSummary");
        formatter.field("edge_packaging_job_arn", &self.edge_packaging_job_arn);
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.field("edge_packaging_job_status", &self.edge_packaging_job_status);
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
pub mod edge_packaging_job_summary {

    /// A builder for [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) edge_packaging_job_arn: std::option::Option<std::string::String>,
        pub(crate) edge_packaging_job_name: std::option::Option<std::string::String>,
        pub(crate) edge_packaging_job_status:
            std::option::Option<crate::model::EdgePackagingJobStatus>,
        pub(crate) compilation_job_name: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
        pub fn edge_packaging_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_packaging_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
        pub fn set_edge_packaging_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_packaging_job_arn = input;
            self
        }
        /// <p>The name of the edge packaging job.</p>
        pub fn edge_packaging_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_packaging_job_name = Some(input.into());
            self
        }
        /// <p>The name of the edge packaging job.</p>
        pub fn set_edge_packaging_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_packaging_job_name = input;
            self
        }
        /// <p>The status of the edge packaging job.</p>
        pub fn edge_packaging_job_status(
            mut self,
            input: crate::model::EdgePackagingJobStatus,
        ) -> Self {
            self.edge_packaging_job_status = Some(input);
            self
        }
        /// <p>The status of the edge packaging job.</p>
        pub fn set_edge_packaging_job_status(
            mut self,
            input: std::option::Option<crate::model::EdgePackagingJobStatus>,
        ) -> Self {
            self.edge_packaging_job_status = input;
            self
        }
        /// <p>The name of the SageMaker Neo compilation job.</p>
        pub fn compilation_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_name = Some(input.into());
            self
        }
        /// <p>The name of the SageMaker Neo compilation job.</p>
        pub fn set_compilation_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_name = input;
            self
        }
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The version of the model.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The timestamp of when the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The timestamp of when the edge packaging job was last updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp of when the edge packaging job was last updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
        pub fn build(self) -> crate::model::EdgePackagingJobSummary {
            crate::model::EdgePackagingJobSummary {
                edge_packaging_job_arn: self.edge_packaging_job_arn,
                edge_packaging_job_name: self.edge_packaging_job_name,
                edge_packaging_job_status: self.edge_packaging_job_status,
                compilation_job_name: self.compilation_job_name,
                model_name: self.model_name,
                model_version: self.model_version,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl EdgePackagingJobSummary {
    /// Creates a new builder-style object to manufacture [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
    pub fn builder() -> crate::model::edge_packaging_job_summary::Builder {
        crate::model::edge_packaging_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePackagingJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePackagingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => EdgePackagingJobStatus::Completed,
            "FAILED" => EdgePackagingJobStatus::Failed,
            "INPROGRESS" => EdgePackagingJobStatus::InProgress,
            "STARTING" => EdgePackagingJobStatus::Starting,
            "STOPPED" => EdgePackagingJobStatus::Stopped,
            "STOPPING" => EdgePackagingJobStatus::Stopping,
            other => EdgePackagingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePackagingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePackagingJobStatus::from(s))
    }
}
impl EdgePackagingJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EdgePackagingJobStatus::Completed => "COMPLETED",
            EdgePackagingJobStatus::Failed => "FAILED",
            EdgePackagingJobStatus::InProgress => "INPROGRESS",
            EdgePackagingJobStatus::Starting => "STARTING",
            EdgePackagingJobStatus::Stopped => "STOPPED",
            EdgePackagingJobStatus::Stopping => "STOPPING",
            EdgePackagingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "INPROGRESS",
            "STARTING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for EdgePackagingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListEdgePackagingJobsSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    ModelName,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    EdgePackagingJobStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListEdgePackagingJobsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ListEdgePackagingJobsSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ListEdgePackagingJobsSortBy::LastModifiedTime,
            "MODEL_NAME" => ListEdgePackagingJobsSortBy::ModelName,
            "NAME" => ListEdgePackagingJobsSortBy::Name,
            "STATUS" => ListEdgePackagingJobsSortBy::EdgePackagingJobStatus,
            other => ListEdgePackagingJobsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListEdgePackagingJobsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListEdgePackagingJobsSortBy::from(s))
    }
}
impl ListEdgePackagingJobsSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListEdgePackagingJobsSortBy::CreationTime => "CREATION_TIME",
            ListEdgePackagingJobsSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ListEdgePackagingJobsSortBy::ModelName => "MODEL_NAME",
            ListEdgePackagingJobsSortBy::Name => "NAME",
            ListEdgePackagingJobsSortBy::EdgePackagingJobStatus => "STATUS",
            ListEdgePackagingJobsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATION_TIME",
            "LAST_MODIFIED_TIME",
            "MODEL_NAME",
            "NAME",
            "STATUS",
        ]
    }
}
impl AsRef<str> for ListEdgePackagingJobsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The domain's details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainDetails {
    /// <p>The domain's Amazon Resource Name (ARN).</p>
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The domain name.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::DomainStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The domain's URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl DomainDetails {
    /// <p>The domain's Amazon Resource Name (ARN).</p>
    pub fn domain_arn(&self) -> std::option::Option<&str> {
        self.domain_arn.as_deref()
    }
    /// <p>The domain ID.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The domain name.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DomainStatus> {
        self.status.as_ref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last modified time.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The domain's URL.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl std::fmt::Debug for DomainDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainDetails");
        formatter.field("domain_arn", &self.domain_arn);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`DomainDetails`](crate::model::DomainDetails)
pub mod domain_details {

    /// A builder for [`DomainDetails`](crate::model::DomainDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_arn: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DomainStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The domain's Amazon Resource Name (ARN).</p>
        pub fn domain_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_arn = Some(input.into());
            self
        }
        /// <p>The domain's Amazon Resource Name (ARN).</p>
        pub fn set_domain_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_arn = input;
            self
        }
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The domain ID.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The domain name.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::DomainStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DomainStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The domain's URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The domain's URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainDetails`](crate::model::DomainDetails)
        pub fn build(self) -> crate::model::DomainDetails {
            crate::model::DomainDetails {
                domain_arn: self.domain_arn,
                domain_id: self.domain_id,
                domain_name: self.domain_name,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                url: self.url,
            }
        }
    }
}
impl DomainDetails {
    /// Creates a new builder-style object to manufacture [`DomainDetails`](crate::model::DomainDetails)
    pub fn builder() -> crate::model::domain_details::Builder {
        crate::model::domain_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainStatus {
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "Delete_Failed" => DomainStatus::DeleteFailed,
            "Deleting" => DomainStatus::Deleting,
            "Failed" => DomainStatus::Failed,
            "InService" => DomainStatus::InService,
            "Pending" => DomainStatus::Pending,
            "Update_Failed" => DomainStatus::UpdateFailed,
            "Updating" => DomainStatus::Updating,
            other => DomainStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainStatus::from(s))
    }
}
impl DomainStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainStatus::DeleteFailed => "Delete_Failed",
            DomainStatus::Deleting => "Deleting",
            DomainStatus::Failed => "Failed",
            DomainStatus::InService => "InService",
            DomainStatus::Pending => "Pending",
            DomainStatus::UpdateFailed => "Update_Failed",
            DomainStatus::Updating => "Updating",
            DomainStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Delete_Failed",
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Update_Failed",
            "Updating",
        ]
    }
}
impl AsRef<str> for DomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of the device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceSummary {
    /// <p>The unique identifier of the device.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the device.</p>
    pub device_arn: std::option::Option<std::string::String>,
    /// <p>A description of the device.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the fleet the device belongs to.</p>
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
    pub iot_thing_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last registration or de-reregistration.</p>
    pub registration_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last heartbeat received from the device.</p>
    pub latest_heartbeat: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Models on the device.</p>
    pub models: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
    /// <p>Edge Manager agent version.</p>
    pub agent_version: std::option::Option<std::string::String>,
}
impl DeviceSummary {
    /// <p>The unique identifier of the device.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of the device.</p>
    pub fn device_arn(&self) -> std::option::Option<&str> {
        self.device_arn.as_deref()
    }
    /// <p>A description of the device.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the fleet the device belongs to.</p>
    pub fn device_fleet_name(&self) -> std::option::Option<&str> {
        self.device_fleet_name.as_deref()
    }
    /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
    pub fn iot_thing_name(&self) -> std::option::Option<&str> {
        self.iot_thing_name.as_deref()
    }
    /// <p>The timestamp of the last registration or de-reregistration.</p>
    pub fn registration_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.registration_time.as_ref()
    }
    /// <p>The last heartbeat received from the device.</p>
    pub fn latest_heartbeat(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_heartbeat.as_ref()
    }
    /// <p>Models on the device.</p>
    pub fn models(&self) -> std::option::Option<&[crate::model::EdgeModelSummary]> {
        self.models.as_deref()
    }
    /// <p>Edge Manager agent version.</p>
    pub fn agent_version(&self) -> std::option::Option<&str> {
        self.agent_version.as_deref()
    }
}
impl std::fmt::Debug for DeviceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceSummary");
        formatter.field("device_name", &self.device_name);
        formatter.field("device_arn", &self.device_arn);
        formatter.field("description", &self.description);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("iot_thing_name", &self.iot_thing_name);
        formatter.field("registration_time", &self.registration_time);
        formatter.field("latest_heartbeat", &self.latest_heartbeat);
        formatter.field("models", &self.models);
        formatter.field("agent_version", &self.agent_version);
        formatter.finish()
    }
}
/// See [`DeviceSummary`](crate::model::DeviceSummary)
pub mod device_summary {

    /// A builder for [`DeviceSummary`](crate::model::DeviceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) device_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_fleet_name: std::option::Option<std::string::String>,
        pub(crate) iot_thing_name: std::option::Option<std::string::String>,
        pub(crate) registration_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_heartbeat: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) models: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
        pub(crate) agent_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The unique identifier of the device.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the device.</p>
        pub fn device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the device.</p>
        pub fn set_device_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_arn = input;
            self
        }
        /// <p>A description of the device.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the device.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the fleet the device belongs to.</p>
        pub fn device_fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet the device belongs to.</p>
        pub fn set_device_fleet_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_name = input;
            self
        }
        /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
        pub fn iot_thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.iot_thing_name = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
        pub fn set_iot_thing_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iot_thing_name = input;
            self
        }
        /// <p>The timestamp of the last registration or de-reregistration.</p>
        pub fn registration_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.registration_time = Some(input);
            self
        }
        /// <p>The timestamp of the last registration or de-reregistration.</p>
        pub fn set_registration_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.registration_time = input;
            self
        }
        /// <p>The last heartbeat received from the device.</p>
        pub fn latest_heartbeat(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_heartbeat = Some(input);
            self
        }
        /// <p>The last heartbeat received from the device.</p>
        pub fn set_latest_heartbeat(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_heartbeat = input;
            self
        }
        /// Appends an item to `models`.
        ///
        /// To override the contents of this collection use [`set_models`](Self::set_models).
        ///
        /// <p>Models on the device.</p>
        pub fn models(mut self, input: crate::model::EdgeModelSummary) -> Self {
            let mut v = self.models.unwrap_or_default();
            v.push(input);
            self.models = Some(v);
            self
        }
        /// <p>Models on the device.</p>
        pub fn set_models(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
        ) -> Self {
            self.models = input;
            self
        }
        /// <p>Edge Manager agent version.</p>
        pub fn agent_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_version = Some(input.into());
            self
        }
        /// <p>Edge Manager agent version.</p>
        pub fn set_agent_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceSummary`](crate::model::DeviceSummary)
        pub fn build(self) -> crate::model::DeviceSummary {
            crate::model::DeviceSummary {
                device_name: self.device_name,
                device_arn: self.device_arn,
                description: self.description,
                device_fleet_name: self.device_fleet_name,
                iot_thing_name: self.iot_thing_name,
                registration_time: self.registration_time,
                latest_heartbeat: self.latest_heartbeat,
                models: self.models,
                agent_version: self.agent_version,
            }
        }
    }
}
impl DeviceSummary {
    /// Creates a new builder-style object to manufacture [`DeviceSummary`](crate::model::DeviceSummary)
    pub fn builder() -> crate::model::device_summary::Builder {
        crate::model::device_summary::Builder::default()
    }
}

/// <p>Summary of model on edge device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModelSummary {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The version model.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl EdgeModelSummary {
    /// <p>The name of the model.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The version model.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for EdgeModelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModelSummary");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`EdgeModelSummary`](crate::model::EdgeModelSummary)
pub mod edge_model_summary {

    /// A builder for [`EdgeModelSummary`](crate::model::EdgeModelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The version model.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version model.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModelSummary`](crate::model::EdgeModelSummary)
        pub fn build(self) -> crate::model::EdgeModelSummary {
            crate::model::EdgeModelSummary {
                model_name: self.model_name,
                model_version: self.model_version,
            }
        }
    }
}
impl EdgeModelSummary {
    /// Creates a new builder-style object to manufacture [`EdgeModelSummary`](crate::model::EdgeModelSummary)
    pub fn builder() -> crate::model::edge_model_summary::Builder {
        crate::model::edge_model_summary::Builder::default()
    }
}

/// <p>Summary of the device fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceFleetSummary {
    /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
    pub device_fleet_arn: std::option::Option<std::string::String>,
    /// <p>Name of the device fleet.</p>
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the device fleet was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Timestamp of when the device fleet was last updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeviceFleetSummary {
    /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
    pub fn device_fleet_arn(&self) -> std::option::Option<&str> {
        self.device_fleet_arn.as_deref()
    }
    /// <p>Name of the device fleet.</p>
    pub fn device_fleet_name(&self) -> std::option::Option<&str> {
        self.device_fleet_name.as_deref()
    }
    /// <p>Timestamp of when the device fleet was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Timestamp of when the device fleet was last updated.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for DeviceFleetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceFleetSummary");
        formatter.field("device_fleet_arn", &self.device_fleet_arn);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
pub mod device_fleet_summary {

    /// A builder for [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_fleet_arn: std::option::Option<std::string::String>,
        pub(crate) device_fleet_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
        pub fn device_fleet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
        pub fn set_device_fleet_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_arn = input;
            self
        }
        /// <p>Name of the device fleet.</p>
        pub fn device_fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_name = Some(input.into());
            self
        }
        /// <p>Name of the device fleet.</p>
        pub fn set_device_fleet_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_name = input;
            self
        }
        /// <p>Timestamp of when the device fleet was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>Timestamp of when the device fleet was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Timestamp of when the device fleet was last updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Timestamp of when the device fleet was last updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
        pub fn build(self) -> crate::model::DeviceFleetSummary {
            crate::model::DeviceFleetSummary {
                device_fleet_arn: self.device_fleet_arn,
                device_fleet_name: self.device_fleet_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl DeviceFleetSummary {
    /// Creates a new builder-style object to manufacture [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
    pub fn builder() -> crate::model::device_fleet_summary::Builder {
        crate::model::device_fleet_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListDeviceFleetsSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListDeviceFleetsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ListDeviceFleetsSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ListDeviceFleetsSortBy::LastModifiedTime,
            "NAME" => ListDeviceFleetsSortBy::Name,
            other => ListDeviceFleetsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListDeviceFleetsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListDeviceFleetsSortBy::from(s))
    }
}
impl ListDeviceFleetsSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListDeviceFleetsSortBy::CreationTime => "CREATION_TIME",
            ListDeviceFleetsSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ListDeviceFleetsSortBy::Name => "NAME",
            ListDeviceFleetsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "LAST_MODIFIED_TIME", "NAME"]
    }
}
impl AsRef<str> for ListDeviceFleetsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of a context. A context provides a logical grouping of other entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContextSummary {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    pub context_arn: std::option::Option<std::string::String>,
    /// <p>The name of the context.</p>
    pub context_name: std::option::Option<std::string::String>,
    /// <p>The source of the context.</p>
    pub source: std::option::Option<crate::model::ContextSource>,
    /// <p>The type of the context.</p>
    pub context_type: std::option::Option<std::string::String>,
    /// <p>When the context was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the context was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ContextSummary {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    pub fn context_arn(&self) -> std::option::Option<&str> {
        self.context_arn.as_deref()
    }
    /// <p>The name of the context.</p>
    pub fn context_name(&self) -> std::option::Option<&str> {
        self.context_name.as_deref()
    }
    /// <p>The source of the context.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::ContextSource> {
        self.source.as_ref()
    }
    /// <p>The type of the context.</p>
    pub fn context_type(&self) -> std::option::Option<&str> {
        self.context_type.as_deref()
    }
    /// <p>When the context was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the context was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for ContextSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContextSummary");
        formatter.field("context_arn", &self.context_arn);
        formatter.field("context_name", &self.context_name);
        formatter.field("source", &self.source);
        formatter.field("context_type", &self.context_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ContextSummary`](crate::model::ContextSummary)
pub mod context_summary {

    /// A builder for [`ContextSummary`](crate::model::ContextSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) context_arn: std::option::Option<std::string::String>,
        pub(crate) context_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ContextSource>,
        pub(crate) context_type: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the context.</p>
        pub fn context_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the context.</p>
        pub fn set_context_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_arn = input;
            self
        }
        /// <p>The name of the context.</p>
        pub fn context_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_name = Some(input.into());
            self
        }
        /// <p>The name of the context.</p>
        pub fn set_context_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_name = input;
            self
        }
        /// <p>The source of the context.</p>
        pub fn source(mut self, input: crate::model::ContextSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the context.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ContextSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the context.</p>
        pub fn context_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_type = Some(input.into());
            self
        }
        /// <p>The type of the context.</p>
        pub fn set_context_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_type = input;
            self
        }
        /// <p>When the context was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the context was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the context was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the context was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ContextSummary`](crate::model::ContextSummary)
        pub fn build(self) -> crate::model::ContextSummary {
            crate::model::ContextSummary {
                context_arn: self.context_arn,
                context_name: self.context_name,
                source: self.source,
                context_type: self.context_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ContextSummary {
    /// Creates a new builder-style object to manufacture [`ContextSummary`](crate::model::ContextSummary)
    pub fn builder() -> crate::model::context_summary::Builder {
        crate::model::context_summary::Builder::default()
    }
}

/// <p>A structure describing the source of a context.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContextSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>The type of the source.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The ID of the source.</p>
    pub source_id: std::option::Option<std::string::String>,
}
impl ContextSource {
    /// <p>The URI of the source.</p>
    pub fn source_uri(&self) -> std::option::Option<&str> {
        self.source_uri.as_deref()
    }
    /// <p>The type of the source.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The ID of the source.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
}
impl std::fmt::Debug for ContextSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContextSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_type", &self.source_type);
        formatter.field("source_id", &self.source_id);
        formatter.finish()
    }
}
/// See [`ContextSource`](crate::model::ContextSource)
pub mod context_source {

    /// A builder for [`ContextSource`](crate::model::ContextSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        /// <p>The URI of the source.</p>
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        /// <p>The type of the source.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The type of the source.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The ID of the source.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The ID of the source.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ContextSource`](crate::model::ContextSource)
        pub fn build(self) -> crate::model::ContextSource {
            crate::model::ContextSource {
                source_uri: self.source_uri,
                source_type: self.source_type,
                source_id: self.source_id,
            }
        }
    }
}
impl ContextSource {
    /// Creates a new builder-style object to manufacture [`ContextSource`](crate::model::ContextSource)
    pub fn builder() -> crate::model::context_source::Builder {
        crate::model::context_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortContextsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortContextsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortContextsBy::CreationTime,
            "Name" => SortContextsBy::Name,
            other => SortContextsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortContextsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortContextsBy::from(s))
    }
}
impl SortContextsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortContextsBy::CreationTime => "CreationTime",
            SortContextsBy::Name => "Name",
            SortContextsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortContextsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of a model compilation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompilationJobSummary {
    /// <p>The name of the model compilation job that you want a summary for.</p>
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
    pub compilation_job_arn: std::option::Option<std::string::String>,
    /// <p>The time when the model compilation job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the model compilation job started.</p>
    pub compilation_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the model compilation job completed.</p>
    pub compilation_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of device that the model will run on after the compilation job has completed.</p>
    pub compilation_target_device: std::option::Option<crate::model::TargetDevice>,
    /// <p>The type of OS that the model will run on after the compilation job has completed.</p>
    pub compilation_target_platform_os: std::option::Option<crate::model::TargetPlatformOs>,
    /// <p>The type of architecture that the model will run on after the compilation job has completed.</p>
    pub compilation_target_platform_arch: std::option::Option<crate::model::TargetPlatformArch>,
    /// <p>The type of accelerator that the model will run on after the compilation job has completed.</p>
    pub compilation_target_platform_accelerator:
        std::option::Option<crate::model::TargetPlatformAccelerator>,
    /// <p>The time when the model compilation job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the model compilation job.</p>
    pub compilation_job_status: std::option::Option<crate::model::CompilationJobStatus>,
}
impl CompilationJobSummary {
    /// <p>The name of the model compilation job that you want a summary for.</p>
    pub fn compilation_job_name(&self) -> std::option::Option<&str> {
        self.compilation_job_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
    pub fn compilation_job_arn(&self) -> std::option::Option<&str> {
        self.compilation_job_arn.as_deref()
    }
    /// <p>The time when the model compilation job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time when the model compilation job started.</p>
    pub fn compilation_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.compilation_start_time.as_ref()
    }
    /// <p>The time when the model compilation job completed.</p>
    pub fn compilation_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.compilation_end_time.as_ref()
    }
    /// <p>The type of device that the model will run on after the compilation job has completed.</p>
    pub fn compilation_target_device(&self) -> std::option::Option<&crate::model::TargetDevice> {
        self.compilation_target_device.as_ref()
    }
    /// <p>The type of OS that the model will run on after the compilation job has completed.</p>
    pub fn compilation_target_platform_os(
        &self,
    ) -> std::option::Option<&crate::model::TargetPlatformOs> {
        self.compilation_target_platform_os.as_ref()
    }
    /// <p>The type of architecture that the model will run on after the compilation job has completed.</p>
    pub fn compilation_target_platform_arch(
        &self,
    ) -> std::option::Option<&crate::model::TargetPlatformArch> {
        self.compilation_target_platform_arch.as_ref()
    }
    /// <p>The type of accelerator that the model will run on after the compilation job has completed.</p>
    pub fn compilation_target_platform_accelerator(
        &self,
    ) -> std::option::Option<&crate::model::TargetPlatformAccelerator> {
        self.compilation_target_platform_accelerator.as_ref()
    }
    /// <p>The time when the model compilation job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The status of the model compilation job.</p>
    pub fn compilation_job_status(
        &self,
    ) -> std::option::Option<&crate::model::CompilationJobStatus> {
        self.compilation_job_status.as_ref()
    }
}
impl std::fmt::Debug for CompilationJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompilationJobSummary");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("compilation_job_arn", &self.compilation_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("compilation_start_time", &self.compilation_start_time);
        formatter.field("compilation_end_time", &self.compilation_end_time);
        formatter.field("compilation_target_device", &self.compilation_target_device);
        formatter.field(
            "compilation_target_platform_os",
            &self.compilation_target_platform_os,
        );
        formatter.field(
            "compilation_target_platform_arch",
            &self.compilation_target_platform_arch,
        );
        formatter.field(
            "compilation_target_platform_accelerator",
            &self.compilation_target_platform_accelerator,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("compilation_job_status", &self.compilation_job_status);
        formatter.finish()
    }
}
/// See [`CompilationJobSummary`](crate::model::CompilationJobSummary)
pub mod compilation_job_summary {

    /// A builder for [`CompilationJobSummary`](crate::model::CompilationJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compilation_job_name: std::option::Option<std::string::String>,
        pub(crate) compilation_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) compilation_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) compilation_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) compilation_target_device: std::option::Option<crate::model::TargetDevice>,
        pub(crate) compilation_target_platform_os:
            std::option::Option<crate::model::TargetPlatformOs>,
        pub(crate) compilation_target_platform_arch:
            std::option::Option<crate::model::TargetPlatformArch>,
        pub(crate) compilation_target_platform_accelerator:
            std::option::Option<crate::model::TargetPlatformAccelerator>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) compilation_job_status: std::option::Option<crate::model::CompilationJobStatus>,
    }
    impl Builder {
        /// <p>The name of the model compilation job that you want a summary for.</p>
        pub fn compilation_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_name = Some(input.into());
            self
        }
        /// <p>The name of the model compilation job that you want a summary for.</p>
        pub fn set_compilation_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
        pub fn compilation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
        pub fn set_compilation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_arn = input;
            self
        }
        /// <p>The time when the model compilation job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the model compilation job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time when the model compilation job started.</p>
        pub fn compilation_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.compilation_start_time = Some(input);
            self
        }
        /// <p>The time when the model compilation job started.</p>
        pub fn set_compilation_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.compilation_start_time = input;
            self
        }
        /// <p>The time when the model compilation job completed.</p>
        pub fn compilation_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.compilation_end_time = Some(input);
            self
        }
        /// <p>The time when the model compilation job completed.</p>
        pub fn set_compilation_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.compilation_end_time = input;
            self
        }
        /// <p>The type of device that the model will run on after the compilation job has completed.</p>
        pub fn compilation_target_device(mut self, input: crate::model::TargetDevice) -> Self {
            self.compilation_target_device = Some(input);
            self
        }
        /// <p>The type of device that the model will run on after the compilation job has completed.</p>
        pub fn set_compilation_target_device(
            mut self,
            input: std::option::Option<crate::model::TargetDevice>,
        ) -> Self {
            self.compilation_target_device = input;
            self
        }
        /// <p>The type of OS that the model will run on after the compilation job has completed.</p>
        pub fn compilation_target_platform_os(
            mut self,
            input: crate::model::TargetPlatformOs,
        ) -> Self {
            self.compilation_target_platform_os = Some(input);
            self
        }
        /// <p>The type of OS that the model will run on after the compilation job has completed.</p>
        pub fn set_compilation_target_platform_os(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformOs>,
        ) -> Self {
            self.compilation_target_platform_os = input;
            self
        }
        /// <p>The type of architecture that the model will run on after the compilation job has completed.</p>
        pub fn compilation_target_platform_arch(
            mut self,
            input: crate::model::TargetPlatformArch,
        ) -> Self {
            self.compilation_target_platform_arch = Some(input);
            self
        }
        /// <p>The type of architecture that the model will run on after the compilation job has completed.</p>
        pub fn set_compilation_target_platform_arch(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformArch>,
        ) -> Self {
            self.compilation_target_platform_arch = input;
            self
        }
        /// <p>The type of accelerator that the model will run on after the compilation job has completed.</p>
        pub fn compilation_target_platform_accelerator(
            mut self,
            input: crate::model::TargetPlatformAccelerator,
        ) -> Self {
            self.compilation_target_platform_accelerator = Some(input);
            self
        }
        /// <p>The type of accelerator that the model will run on after the compilation job has completed.</p>
        pub fn set_compilation_target_platform_accelerator(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformAccelerator>,
        ) -> Self {
            self.compilation_target_platform_accelerator = input;
            self
        }
        /// <p>The time when the model compilation job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time when the model compilation job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the model compilation job.</p>
        pub fn compilation_job_status(mut self, input: crate::model::CompilationJobStatus) -> Self {
            self.compilation_job_status = Some(input);
            self
        }
        /// <p>The status of the model compilation job.</p>
        pub fn set_compilation_job_status(
            mut self,
            input: std::option::Option<crate::model::CompilationJobStatus>,
        ) -> Self {
            self.compilation_job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`CompilationJobSummary`](crate::model::CompilationJobSummary)
        pub fn build(self) -> crate::model::CompilationJobSummary {
            crate::model::CompilationJobSummary {
                compilation_job_name: self.compilation_job_name,
                compilation_job_arn: self.compilation_job_arn,
                creation_time: self.creation_time,
                compilation_start_time: self.compilation_start_time,
                compilation_end_time: self.compilation_end_time,
                compilation_target_device: self.compilation_target_device,
                compilation_target_platform_os: self.compilation_target_platform_os,
                compilation_target_platform_arch: self.compilation_target_platform_arch,
                compilation_target_platform_accelerator: self
                    .compilation_target_platform_accelerator,
                last_modified_time: self.last_modified_time,
                compilation_job_status: self.compilation_job_status,
            }
        }
    }
}
impl CompilationJobSummary {
    /// Creates a new builder-style object to manufacture [`CompilationJobSummary`](crate::model::CompilationJobSummary)
    pub fn builder() -> crate::model::compilation_job_summary::Builder {
        crate::model::compilation_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CompilationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Inprogress,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CompilationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => CompilationJobStatus::Completed,
            "FAILED" => CompilationJobStatus::Failed,
            "INPROGRESS" => CompilationJobStatus::Inprogress,
            "STARTING" => CompilationJobStatus::Starting,
            "STOPPED" => CompilationJobStatus::Stopped,
            "STOPPING" => CompilationJobStatus::Stopping,
            other => CompilationJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CompilationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CompilationJobStatus::from(s))
    }
}
impl CompilationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CompilationJobStatus::Completed => "COMPLETED",
            CompilationJobStatus::Failed => "FAILED",
            CompilationJobStatus::Inprogress => "INPROGRESS",
            CompilationJobStatus::Starting => "STARTING",
            CompilationJobStatus::Stopped => "STOPPED",
            CompilationJobStatus::Stopping => "STOPPING",
            CompilationJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "INPROGRESS",
            "STARTING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for CompilationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformAccelerator {
    #[allow(missing_docs)] // documentation missing in model
    IntelGraphics,
    #[allow(missing_docs)] // documentation missing in model
    Mali,
    #[allow(missing_docs)] // documentation missing in model
    Nna,
    #[allow(missing_docs)] // documentation missing in model
    Nvidia,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformAccelerator {
    fn from(s: &str) -> Self {
        match s {
            "INTEL_GRAPHICS" => TargetPlatformAccelerator::IntelGraphics,
            "MALI" => TargetPlatformAccelerator::Mali,
            "NNA" => TargetPlatformAccelerator::Nna,
            "NVIDIA" => TargetPlatformAccelerator::Nvidia,
            other => TargetPlatformAccelerator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformAccelerator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformAccelerator::from(s))
    }
}
impl TargetPlatformAccelerator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformAccelerator::IntelGraphics => "INTEL_GRAPHICS",
            TargetPlatformAccelerator::Mali => "MALI",
            TargetPlatformAccelerator::Nna => "NNA",
            TargetPlatformAccelerator::Nvidia => "NVIDIA",
            TargetPlatformAccelerator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["INTEL_GRAPHICS", "MALI", "NNA", "NVIDIA"]
    }
}
impl AsRef<str> for TargetPlatformAccelerator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformArch {
    #[allow(missing_docs)] // documentation missing in model
    Arm64,
    #[allow(missing_docs)] // documentation missing in model
    ArmEabi,
    #[allow(missing_docs)] // documentation missing in model
    ArmEabihf,
    #[allow(missing_docs)] // documentation missing in model
    X86,
    #[allow(missing_docs)] // documentation missing in model
    X8664,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformArch {
    fn from(s: &str) -> Self {
        match s {
            "ARM64" => TargetPlatformArch::Arm64,
            "ARM_EABI" => TargetPlatformArch::ArmEabi,
            "ARM_EABIHF" => TargetPlatformArch::ArmEabihf,
            "X86" => TargetPlatformArch::X86,
            "X86_64" => TargetPlatformArch::X8664,
            other => TargetPlatformArch::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformArch {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformArch::from(s))
    }
}
impl TargetPlatformArch {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformArch::Arm64 => "ARM64",
            TargetPlatformArch::ArmEabi => "ARM_EABI",
            TargetPlatformArch::ArmEabihf => "ARM_EABIHF",
            TargetPlatformArch::X86 => "X86",
            TargetPlatformArch::X8664 => "X86_64",
            TargetPlatformArch::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ARM64", "ARM_EABI", "ARM_EABIHF", "X86", "X86_64"]
    }
}
impl AsRef<str> for TargetPlatformArch {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformOs {
    #[allow(missing_docs)] // documentation missing in model
    Android,
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformOs {
    fn from(s: &str) -> Self {
        match s {
            "ANDROID" => TargetPlatformOs::Android,
            "LINUX" => TargetPlatformOs::Linux,
            other => TargetPlatformOs::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformOs {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformOs::from(s))
    }
}
impl TargetPlatformOs {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformOs::Android => "ANDROID",
            TargetPlatformOs::Linux => "LINUX",
            TargetPlatformOs::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ANDROID", "LINUX"]
    }
}
impl AsRef<str> for TargetPlatformOs {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetDevice {
    #[allow(missing_docs)] // documentation missing in model
    Aisage,
    #[allow(missing_docs)] // documentation missing in model
    AmbaCv2,
    #[allow(missing_docs)] // documentation missing in model
    AmbaCv22,
    #[allow(missing_docs)] // documentation missing in model
    AmbaCv25,
    #[allow(missing_docs)] // documentation missing in model
    Coreml,
    #[allow(missing_docs)] // documentation missing in model
    Deeplens,
    #[allow(missing_docs)] // documentation missing in model
    Imx8Mplus,
    #[allow(missing_docs)] // documentation missing in model
    Imx8Qm,
    #[allow(missing_docs)] // documentation missing in model
    JacintoTda4Vm,
    #[allow(missing_docs)] // documentation missing in model
    JetsonNano,
    #[allow(missing_docs)] // documentation missing in model
    JetsonTx1,
    #[allow(missing_docs)] // documentation missing in model
    JetsonTx2,
    #[allow(missing_docs)] // documentation missing in model
    JetsonXavier,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    #[allow(missing_docs)] // documentation missing in model
    MlC4,
    #[allow(missing_docs)] // documentation missing in model
    MlC5,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2,
    #[allow(missing_docs)] // documentation missing in model
    MlG4Dn,
    #[allow(missing_docs)] // documentation missing in model
    MlInf1,
    #[allow(missing_docs)] // documentation missing in model
    MlM4,
    #[allow(missing_docs)] // documentation missing in model
    MlM5,
    #[allow(missing_docs)] // documentation missing in model
    MlP2,
    #[allow(missing_docs)] // documentation missing in model
    MlP3,
    #[allow(missing_docs)] // documentation missing in model
    Qcs603,
    #[allow(missing_docs)] // documentation missing in model
    Qcs605,
    #[allow(missing_docs)] // documentation missing in model
    Rasp3B,
    #[allow(missing_docs)] // documentation missing in model
    Rk3288,
    #[allow(missing_docs)] // documentation missing in model
    Rk3399,
    #[allow(missing_docs)] // documentation missing in model
    SbeC,
    #[allow(missing_docs)] // documentation missing in model
    SitaraAm57X,
    #[allow(missing_docs)] // documentation missing in model
    X86Win32,
    #[allow(missing_docs)] // documentation missing in model
    X86Win64,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetDevice {
    fn from(s: &str) -> Self {
        match s {
            "aisage" => TargetDevice::Aisage,
            "amba_cv2" => TargetDevice::AmbaCv2,
            "amba_cv22" => TargetDevice::AmbaCv22,
            "amba_cv25" => TargetDevice::AmbaCv25,
            "coreml" => TargetDevice::Coreml,
            "deeplens" => TargetDevice::Deeplens,
            "imx8mplus" => TargetDevice::Imx8Mplus,
            "imx8qm" => TargetDevice::Imx8Qm,
            "jacinto_tda4vm" => TargetDevice::JacintoTda4Vm,
            "jetson_nano" => TargetDevice::JetsonNano,
            "jetson_tx1" => TargetDevice::JetsonTx1,
            "jetson_tx2" => TargetDevice::JetsonTx2,
            "jetson_xavier" => TargetDevice::JetsonXavier,
            "lambda" => TargetDevice::Lambda,
            "ml_c4" => TargetDevice::MlC4,
            "ml_c5" => TargetDevice::MlC5,
            "ml_eia2" => TargetDevice::MlEia2,
            "ml_g4dn" => TargetDevice::MlG4Dn,
            "ml_inf1" => TargetDevice::MlInf1,
            "ml_m4" => TargetDevice::MlM4,
            "ml_m5" => TargetDevice::MlM5,
            "ml_p2" => TargetDevice::MlP2,
            "ml_p3" => TargetDevice::MlP3,
            "qcs603" => TargetDevice::Qcs603,
            "qcs605" => TargetDevice::Qcs605,
            "rasp3b" => TargetDevice::Rasp3B,
            "rk3288" => TargetDevice::Rk3288,
            "rk3399" => TargetDevice::Rk3399,
            "sbe_c" => TargetDevice::SbeC,
            "sitara_am57x" => TargetDevice::SitaraAm57X,
            "x86_win32" => TargetDevice::X86Win32,
            "x86_win64" => TargetDevice::X86Win64,
            other => TargetDevice::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetDevice {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetDevice::from(s))
    }
}
impl TargetDevice {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetDevice::Aisage => "aisage",
            TargetDevice::AmbaCv2 => "amba_cv2",
            TargetDevice::AmbaCv22 => "amba_cv22",
            TargetDevice::AmbaCv25 => "amba_cv25",
            TargetDevice::Coreml => "coreml",
            TargetDevice::Deeplens => "deeplens",
            TargetDevice::Imx8Mplus => "imx8mplus",
            TargetDevice::Imx8Qm => "imx8qm",
            TargetDevice::JacintoTda4Vm => "jacinto_tda4vm",
            TargetDevice::JetsonNano => "jetson_nano",
            TargetDevice::JetsonTx1 => "jetson_tx1",
            TargetDevice::JetsonTx2 => "jetson_tx2",
            TargetDevice::JetsonXavier => "jetson_xavier",
            TargetDevice::Lambda => "lambda",
            TargetDevice::MlC4 => "ml_c4",
            TargetDevice::MlC5 => "ml_c5",
            TargetDevice::MlEia2 => "ml_eia2",
            TargetDevice::MlG4Dn => "ml_g4dn",
            TargetDevice::MlInf1 => "ml_inf1",
            TargetDevice::MlM4 => "ml_m4",
            TargetDevice::MlM5 => "ml_m5",
            TargetDevice::MlP2 => "ml_p2",
            TargetDevice::MlP3 => "ml_p3",
            TargetDevice::Qcs603 => "qcs603",
            TargetDevice::Qcs605 => "qcs605",
            TargetDevice::Rasp3B => "rasp3b",
            TargetDevice::Rk3288 => "rk3288",
            TargetDevice::Rk3399 => "rk3399",
            TargetDevice::SbeC => "sbe_c",
            TargetDevice::SitaraAm57X => "sitara_am57x",
            TargetDevice::X86Win32 => "x86_win32",
            TargetDevice::X86Win64 => "x86_win64",
            TargetDevice::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "aisage",
            "amba_cv2",
            "amba_cv22",
            "amba_cv25",
            "coreml",
            "deeplens",
            "imx8mplus",
            "imx8qm",
            "jacinto_tda4vm",
            "jetson_nano",
            "jetson_tx1",
            "jetson_tx2",
            "jetson_xavier",
            "lambda",
            "ml_c4",
            "ml_c5",
            "ml_eia2",
            "ml_g4dn",
            "ml_inf1",
            "ml_m4",
            "ml_m5",
            "ml_p2",
            "ml_p3",
            "qcs603",
            "qcs605",
            "rasp3b",
            "rk3288",
            "rk3399",
            "sbe_c",
            "sitara_am57x",
            "x86_win32",
            "x86_win64",
        ]
    }
}
impl AsRef<str> for TargetDevice {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListCompilationJobsSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListCompilationJobsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ListCompilationJobsSortBy::CreationTime,
            "Name" => ListCompilationJobsSortBy::Name,
            "Status" => ListCompilationJobsSortBy::Status,
            other => ListCompilationJobsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListCompilationJobsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListCompilationJobsSortBy::from(s))
    }
}
impl ListCompilationJobsSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListCompilationJobsSortBy::CreationTime => "CreationTime",
            ListCompilationJobsSortBy::Name => "Name",
            ListCompilationJobsSortBy::Status => "Status",
            ListCompilationJobsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for ListCompilationJobsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies summary information about a Git repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeRepositorySummary {
    /// <p>The name of the Git repository.</p>
    pub code_repository_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
    pub code_repository_arn: std::option::Option<std::string::String>,
    /// <p>The date and time that the Git repository was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the Git repository was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Configuration details for the Git repository, including the URL where it is located and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.</p>
    pub git_config: std::option::Option<crate::model::GitConfig>,
}
impl CodeRepositorySummary {
    /// <p>The name of the Git repository.</p>
    pub fn code_repository_name(&self) -> std::option::Option<&str> {
        self.code_repository_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
    pub fn code_repository_arn(&self) -> std::option::Option<&str> {
        self.code_repository_arn.as_deref()
    }
    /// <p>The date and time that the Git repository was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time that the Git repository was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Configuration details for the Git repository, including the URL where it is located and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.</p>
    pub fn git_config(&self) -> std::option::Option<&crate::model::GitConfig> {
        self.git_config.as_ref()
    }
}
impl std::fmt::Debug for CodeRepositorySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeRepositorySummary");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.field("code_repository_arn", &self.code_repository_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("git_config", &self.git_config);
        formatter.finish()
    }
}
/// See [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
pub mod code_repository_summary {

    /// A builder for [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_repository_name: std::option::Option<std::string::String>,
        pub(crate) code_repository_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) git_config: std::option::Option<crate::model::GitConfig>,
    }
    impl Builder {
        /// <p>The name of the Git repository.</p>
        pub fn code_repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_repository_name = Some(input.into());
            self
        }
        /// <p>The name of the Git repository.</p>
        pub fn set_code_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_repository_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
        pub fn code_repository_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_repository_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
        pub fn set_code_repository_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_repository_arn = input;
            self
        }
        /// <p>The date and time that the Git repository was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time that the Git repository was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the Git repository was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the Git repository was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Configuration details for the Git repository, including the URL where it is located and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.</p>
        pub fn git_config(mut self, input: crate::model::GitConfig) -> Self {
            self.git_config = Some(input);
            self
        }
        /// <p>Configuration details for the Git repository, including the URL where it is located and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.</p>
        pub fn set_git_config(
            mut self,
            input: std::option::Option<crate::model::GitConfig>,
        ) -> Self {
            self.git_config = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
        pub fn build(self) -> crate::model::CodeRepositorySummary {
            crate::model::CodeRepositorySummary {
                code_repository_name: self.code_repository_name,
                code_repository_arn: self.code_repository_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                git_config: self.git_config,
            }
        }
    }
}
impl CodeRepositorySummary {
    /// Creates a new builder-style object to manufacture [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
    pub fn builder() -> crate::model::code_repository_summary::Builder {
        crate::model::code_repository_summary::Builder::default()
    }
}

/// <p>Specifies configuration details for a Git repository in your Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GitConfig {
    /// <p>The URL where the Git repository is located.</p>
    pub repository_url: std::option::Option<std::string::String>,
    /// <p>The default branch for the Git repository.</p>
    pub branch: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
    pub secret_arn: std::option::Option<std::string::String>,
}
impl GitConfig {
    /// <p>The URL where the Git repository is located.</p>
    pub fn repository_url(&self) -> std::option::Option<&str> {
        self.repository_url.as_deref()
    }
    /// <p>The default branch for the Git repository.</p>
    pub fn branch(&self) -> std::option::Option<&str> {
        self.branch.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
impl std::fmt::Debug for GitConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GitConfig");
        formatter.field("repository_url", &self.repository_url);
        formatter.field("branch", &self.branch);
        formatter.field("secret_arn", &self.secret_arn);
        formatter.finish()
    }
}
/// See [`GitConfig`](crate::model::GitConfig)
pub mod git_config {

    /// A builder for [`GitConfig`](crate::model::GitConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_url: std::option::Option<std::string::String>,
        pub(crate) branch: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL where the Git repository is located.</p>
        pub fn repository_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_url = Some(input.into());
            self
        }
        /// <p>The URL where the Git repository is located.</p>
        pub fn set_repository_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_url = input;
            self
        }
        /// <p>The default branch for the Git repository.</p>
        pub fn branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch = Some(input.into());
            self
        }
        /// <p>The default branch for the Git repository.</p>
        pub fn set_branch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.branch = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p> <code>{"username": <i>UserName</i>, "password": <i>Password</i>}</code> </p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GitConfig`](crate::model::GitConfig)
        pub fn build(self) -> crate::model::GitConfig {
            crate::model::GitConfig {
                repository_url: self.repository_url,
                branch: self.branch,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl GitConfig {
    /// Creates a new builder-style object to manufacture [`GitConfig`](crate::model::GitConfig)
    pub fn builder() -> crate::model::git_config::Builder {
        crate::model::git_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeRepositorySortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CodeRepositorySortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => CodeRepositorySortOrder::Ascending,
            "Descending" => CodeRepositorySortOrder::Descending,
            other => CodeRepositorySortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CodeRepositorySortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeRepositorySortOrder::from(s))
    }
}
impl CodeRepositorySortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CodeRepositorySortOrder::Ascending => "Ascending",
            CodeRepositorySortOrder::Descending => "Descending",
            CodeRepositorySortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for CodeRepositorySortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeRepositorySortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CodeRepositorySortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => CodeRepositorySortBy::CreationTime,
            "LastModifiedTime" => CodeRepositorySortBy::LastModifiedTime,
            "Name" => CodeRepositorySortBy::Name,
            other => CodeRepositorySortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CodeRepositorySortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeRepositorySortBy::from(s))
    }
}
impl CodeRepositorySortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CodeRepositorySortBy::CreationTime => "CreationTime",
            CodeRepositorySortBy::LastModifiedTime => "LastModifiedTime",
            CodeRepositorySortBy::Name => "Name",
            CodeRepositorySortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for CodeRepositorySortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a candidate produced by an AutoML training job, including its status, steps, and other properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlCandidate {
    /// <p>The name of the candidate.</p>
    pub candidate_name: std::option::Option<std::string::String>,
    /// <p>The best candidate result from an AutoML training job.</p>
    pub final_auto_ml_job_objective_metric:
        std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
    /// <p>The objective's status.</p>
    pub objective_status: std::option::Option<crate::model::ObjectiveStatus>,
    /// <p>Information about the candidate's steps.</p>
    pub candidate_steps: std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
    /// <p>The candidate's status.</p>
    pub candidate_status: std::option::Option<crate::model::CandidateStatus>,
    /// <p>Information about the inference container definitions.</p>
    pub inference_containers:
        std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The failure reason.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The properties of an AutoML candidate job.</p>
    pub candidate_properties: std::option::Option<crate::model::CandidateProperties>,
}
impl AutoMlCandidate {
    /// <p>The name of the candidate.</p>
    pub fn candidate_name(&self) -> std::option::Option<&str> {
        self.candidate_name.as_deref()
    }
    /// <p>The best candidate result from an AutoML training job.</p>
    pub fn final_auto_ml_job_objective_metric(
        &self,
    ) -> std::option::Option<&crate::model::FinalAutoMlJobObjectiveMetric> {
        self.final_auto_ml_job_objective_metric.as_ref()
    }
    /// <p>The objective's status.</p>
    pub fn objective_status(&self) -> std::option::Option<&crate::model::ObjectiveStatus> {
        self.objective_status.as_ref()
    }
    /// <p>Information about the candidate's steps.</p>
    pub fn candidate_steps(&self) -> std::option::Option<&[crate::model::AutoMlCandidateStep]> {
        self.candidate_steps.as_deref()
    }
    /// <p>The candidate's status.</p>
    pub fn candidate_status(&self) -> std::option::Option<&crate::model::CandidateStatus> {
        self.candidate_status.as_ref()
    }
    /// <p>Information about the inference container definitions.</p>
    pub fn inference_containers(
        &self,
    ) -> std::option::Option<&[crate::model::AutoMlContainerDefinition]> {
        self.inference_containers.as_deref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The end time.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The last modified time.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The failure reason.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The properties of an AutoML candidate job.</p>
    pub fn candidate_properties(&self) -> std::option::Option<&crate::model::CandidateProperties> {
        self.candidate_properties.as_ref()
    }
}
impl std::fmt::Debug for AutoMlCandidate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlCandidate");
        formatter.field("candidate_name", &self.candidate_name);
        formatter.field(
            "final_auto_ml_job_objective_metric",
            &self.final_auto_ml_job_objective_metric,
        );
        formatter.field("objective_status", &self.objective_status);
        formatter.field("candidate_steps", &self.candidate_steps);
        formatter.field("candidate_status", &self.candidate_status);
        formatter.field("inference_containers", &self.inference_containers);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("candidate_properties", &self.candidate_properties);
        formatter.finish()
    }
}
/// See [`AutoMlCandidate`](crate::model::AutoMlCandidate)
pub mod auto_ml_candidate {

    /// A builder for [`AutoMlCandidate`](crate::model::AutoMlCandidate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_name: std::option::Option<std::string::String>,
        pub(crate) final_auto_ml_job_objective_metric:
            std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
        pub(crate) objective_status: std::option::Option<crate::model::ObjectiveStatus>,
        pub(crate) candidate_steps:
            std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
        pub(crate) candidate_status: std::option::Option<crate::model::CandidateStatus>,
        pub(crate) inference_containers:
            std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) candidate_properties: std::option::Option<crate::model::CandidateProperties>,
    }
    impl Builder {
        /// <p>The name of the candidate.</p>
        pub fn candidate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_name = Some(input.into());
            self
        }
        /// <p>The name of the candidate.</p>
        pub fn set_candidate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_name = input;
            self
        }
        /// <p>The best candidate result from an AutoML training job.</p>
        pub fn final_auto_ml_job_objective_metric(
            mut self,
            input: crate::model::FinalAutoMlJobObjectiveMetric,
        ) -> Self {
            self.final_auto_ml_job_objective_metric = Some(input);
            self
        }
        /// <p>The best candidate result from an AutoML training job.</p>
        pub fn set_final_auto_ml_job_objective_metric(
            mut self,
            input: std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
        ) -> Self {
            self.final_auto_ml_job_objective_metric = input;
            self
        }
        /// <p>The objective's status.</p>
        pub fn objective_status(mut self, input: crate::model::ObjectiveStatus) -> Self {
            self.objective_status = Some(input);
            self
        }
        /// <p>The objective's status.</p>
        pub fn set_objective_status(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatus>,
        ) -> Self {
            self.objective_status = input;
            self
        }
        /// Appends an item to `candidate_steps`.
        ///
        /// To override the contents of this collection use [`set_candidate_steps`](Self::set_candidate_steps).
        ///
        /// <p>Information about the candidate's steps.</p>
        pub fn candidate_steps(mut self, input: crate::model::AutoMlCandidateStep) -> Self {
            let mut v = self.candidate_steps.unwrap_or_default();
            v.push(input);
            self.candidate_steps = Some(v);
            self
        }
        /// <p>Information about the candidate's steps.</p>
        pub fn set_candidate_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
        ) -> Self {
            self.candidate_steps = input;
            self
        }
        /// <p>The candidate's status.</p>
        pub fn candidate_status(mut self, input: crate::model::CandidateStatus) -> Self {
            self.candidate_status = Some(input);
            self
        }
        /// <p>The candidate's status.</p>
        pub fn set_candidate_status(
            mut self,
            input: std::option::Option<crate::model::CandidateStatus>,
        ) -> Self {
            self.candidate_status = input;
            self
        }
        /// Appends an item to `inference_containers`.
        ///
        /// To override the contents of this collection use [`set_inference_containers`](Self::set_inference_containers).
        ///
        /// <p>Information about the inference container definitions.</p>
        pub fn inference_containers(
            mut self,
            input: crate::model::AutoMlContainerDefinition,
        ) -> Self {
            let mut v = self.inference_containers.unwrap_or_default();
            v.push(input);
            self.inference_containers = Some(v);
            self
        }
        /// <p>Information about the inference container definitions.</p>
        pub fn set_inference_containers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
        ) -> Self {
            self.inference_containers = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The end time.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The failure reason.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The failure reason.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The properties of an AutoML candidate job.</p>
        pub fn candidate_properties(mut self, input: crate::model::CandidateProperties) -> Self {
            self.candidate_properties = Some(input);
            self
        }
        /// <p>The properties of an AutoML candidate job.</p>
        pub fn set_candidate_properties(
            mut self,
            input: std::option::Option<crate::model::CandidateProperties>,
        ) -> Self {
            self.candidate_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlCandidate`](crate::model::AutoMlCandidate)
        pub fn build(self) -> crate::model::AutoMlCandidate {
            crate::model::AutoMlCandidate {
                candidate_name: self.candidate_name,
                final_auto_ml_job_objective_metric: self.final_auto_ml_job_objective_metric,
                objective_status: self.objective_status,
                candidate_steps: self.candidate_steps,
                candidate_status: self.candidate_status,
                inference_containers: self.inference_containers,
                creation_time: self.creation_time,
                end_time: self.end_time,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                candidate_properties: self.candidate_properties,
            }
        }
    }
}
impl AutoMlCandidate {
    /// Creates a new builder-style object to manufacture [`AutoMlCandidate`](crate::model::AutoMlCandidate)
    pub fn builder() -> crate::model::auto_ml_candidate::Builder {
        crate::model::auto_ml_candidate::Builder::default()
    }
}

/// <p>The properties of an AutoML candidate job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CandidateProperties {
    /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
    pub candidate_artifact_locations: std::option::Option<crate::model::CandidateArtifactLocations>,
    /// <p>Information about the candidate metrics for an AutoML job.</p>
    pub candidate_metrics: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
}
impl CandidateProperties {
    /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
    pub fn candidate_artifact_locations(
        &self,
    ) -> std::option::Option<&crate::model::CandidateArtifactLocations> {
        self.candidate_artifact_locations.as_ref()
    }
    /// <p>Information about the candidate metrics for an AutoML job.</p>
    pub fn candidate_metrics(&self) -> std::option::Option<&[crate::model::MetricDatum]> {
        self.candidate_metrics.as_deref()
    }
}
impl std::fmt::Debug for CandidateProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CandidateProperties");
        formatter.field(
            "candidate_artifact_locations",
            &self.candidate_artifact_locations,
        );
        formatter.field("candidate_metrics", &self.candidate_metrics);
        formatter.finish()
    }
}
/// See [`CandidateProperties`](crate::model::CandidateProperties)
pub mod candidate_properties {

    /// A builder for [`CandidateProperties`](crate::model::CandidateProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_artifact_locations:
            std::option::Option<crate::model::CandidateArtifactLocations>,
        pub(crate) candidate_metrics: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
        pub fn candidate_artifact_locations(
            mut self,
            input: crate::model::CandidateArtifactLocations,
        ) -> Self {
            self.candidate_artifact_locations = Some(input);
            self
        }
        /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
        pub fn set_candidate_artifact_locations(
            mut self,
            input: std::option::Option<crate::model::CandidateArtifactLocations>,
        ) -> Self {
            self.candidate_artifact_locations = input;
            self
        }
        /// Appends an item to `candidate_metrics`.
        ///
        /// To override the contents of this collection use [`set_candidate_metrics`](Self::set_candidate_metrics).
        ///
        /// <p>Information about the candidate metrics for an AutoML job.</p>
        pub fn candidate_metrics(mut self, input: crate::model::MetricDatum) -> Self {
            let mut v = self.candidate_metrics.unwrap_or_default();
            v.push(input);
            self.candidate_metrics = Some(v);
            self
        }
        /// <p>Information about the candidate metrics for an AutoML job.</p>
        pub fn set_candidate_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
        ) -> Self {
            self.candidate_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`CandidateProperties`](crate::model::CandidateProperties)
        pub fn build(self) -> crate::model::CandidateProperties {
            crate::model::CandidateProperties {
                candidate_artifact_locations: self.candidate_artifact_locations,
                candidate_metrics: self.candidate_metrics,
            }
        }
    }
}
impl CandidateProperties {
    /// Creates a new builder-style object to manufacture [`CandidateProperties`](crate::model::CandidateProperties)
    pub fn builder() -> crate::model::candidate_properties::Builder {
        crate::model::candidate_properties::Builder::default()
    }
}

/// <p>Information about the metric for a candidate produced by an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDatum {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
    /// <p>The value of the metric.</p>
    pub value: f32,
    /// <p>The dataset split from which the AutoML job produced the metric.</p>
    pub set: std::option::Option<crate::model::MetricSetSource>,
    /// <p>The name of the standard metric. </p> <note>
    /// <p>For definitions of the standard metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-model-support-validation.html#autopilot-metrics"> <code>Autopilot candidate metrics</code> </a>.</p>
    /// </note>
    pub standard_metric_name: std::option::Option<crate::model::AutoMlMetricExtendedEnum>,
}
impl MetricDatum {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::AutoMlMetricEnum> {
        self.metric_name.as_ref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> f32 {
        self.value
    }
    /// <p>The dataset split from which the AutoML job produced the metric.</p>
    pub fn set(&self) -> std::option::Option<&crate::model::MetricSetSource> {
        self.set.as_ref()
    }
    /// <p>The name of the standard metric. </p> <note>
    /// <p>For definitions of the standard metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-model-support-validation.html#autopilot-metrics"> <code>Autopilot candidate metrics</code> </a>.</p>
    /// </note>
    pub fn standard_metric_name(
        &self,
    ) -> std::option::Option<&crate::model::AutoMlMetricExtendedEnum> {
        self.standard_metric_name.as_ref()
    }
}
impl std::fmt::Debug for MetricDatum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDatum");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.field("set", &self.set);
        formatter.field("standard_metric_name", &self.standard_metric_name);
        formatter.finish()
    }
}
/// See [`MetricDatum`](crate::model::MetricDatum)
pub mod metric_datum {

    /// A builder for [`MetricDatum`](crate::model::MetricDatum)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
        pub(crate) value: std::option::Option<f32>,
        pub(crate) set: std::option::Option<crate::model::MetricSetSource>,
        pub(crate) standard_metric_name:
            std::option::Option<crate::model::AutoMlMetricExtendedEnum>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: crate::model::AutoMlMetricEnum) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricEnum>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// <p>The dataset split from which the AutoML job produced the metric.</p>
        pub fn set(mut self, input: crate::model::MetricSetSource) -> Self {
            self.set = Some(input);
            self
        }
        /// <p>The dataset split from which the AutoML job produced the metric.</p>
        pub fn set_set(
            mut self,
            input: std::option::Option<crate::model::MetricSetSource>,
        ) -> Self {
            self.set = input;
            self
        }
        /// <p>The name of the standard metric. </p> <note>
        /// <p>For definitions of the standard metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-model-support-validation.html#autopilot-metrics"> <code>Autopilot candidate metrics</code> </a>.</p>
        /// </note>
        pub fn standard_metric_name(
            mut self,
            input: crate::model::AutoMlMetricExtendedEnum,
        ) -> Self {
            self.standard_metric_name = Some(input);
            self
        }
        /// <p>The name of the standard metric. </p> <note>
        /// <p>For definitions of the standard metrics, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-model-support-validation.html#autopilot-metrics"> <code>Autopilot candidate metrics</code> </a>.</p>
        /// </note>
        pub fn set_standard_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricExtendedEnum>,
        ) -> Self {
            self.standard_metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDatum`](crate::model::MetricDatum)
        pub fn build(self) -> crate::model::MetricDatum {
            crate::model::MetricDatum {
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
                set: self.set,
                standard_metric_name: self.standard_metric_name,
            }
        }
    }
}
impl MetricDatum {
    /// Creates a new builder-style object to manufacture [`MetricDatum`](crate::model::MetricDatum)
    pub fn builder() -> crate::model::metric_datum::Builder {
        crate::model::metric_datum::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlMetricExtendedEnum {
    #[allow(missing_docs)] // documentation missing in model
    Auc,
    #[allow(missing_docs)] // documentation missing in model
    Accuracy,
    #[allow(missing_docs)] // documentation missing in model
    BalancedAccuracy,
    #[allow(missing_docs)] // documentation missing in model
    F1,
    #[allow(missing_docs)] // documentation missing in model
    F1Macro,
    #[allow(missing_docs)] // documentation missing in model
    LogLoss,
    #[allow(missing_docs)] // documentation missing in model
    Mae,
    #[allow(missing_docs)] // documentation missing in model
    Mse,
    #[allow(missing_docs)] // documentation missing in model
    Precision,
    #[allow(missing_docs)] // documentation missing in model
    PrecisionMacro,
    #[allow(missing_docs)] // documentation missing in model
    R2,
    #[allow(missing_docs)] // documentation missing in model
    Rmse,
    #[allow(missing_docs)] // documentation missing in model
    Recall,
    #[allow(missing_docs)] // documentation missing in model
    RecallMacro,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlMetricExtendedEnum {
    fn from(s: &str) -> Self {
        match s {
            "AUC" => AutoMlMetricExtendedEnum::Auc,
            "Accuracy" => AutoMlMetricExtendedEnum::Accuracy,
            "BalancedAccuracy" => AutoMlMetricExtendedEnum::BalancedAccuracy,
            "F1" => AutoMlMetricExtendedEnum::F1,
            "F1macro" => AutoMlMetricExtendedEnum::F1Macro,
            "LogLoss" => AutoMlMetricExtendedEnum::LogLoss,
            "MAE" => AutoMlMetricExtendedEnum::Mae,
            "MSE" => AutoMlMetricExtendedEnum::Mse,
            "Precision" => AutoMlMetricExtendedEnum::Precision,
            "PrecisionMacro" => AutoMlMetricExtendedEnum::PrecisionMacro,
            "R2" => AutoMlMetricExtendedEnum::R2,
            "RMSE" => AutoMlMetricExtendedEnum::Rmse,
            "Recall" => AutoMlMetricExtendedEnum::Recall,
            "RecallMacro" => AutoMlMetricExtendedEnum::RecallMacro,
            other => AutoMlMetricExtendedEnum::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlMetricExtendedEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlMetricExtendedEnum::from(s))
    }
}
impl AutoMlMetricExtendedEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlMetricExtendedEnum::Auc => "AUC",
            AutoMlMetricExtendedEnum::Accuracy => "Accuracy",
            AutoMlMetricExtendedEnum::BalancedAccuracy => "BalancedAccuracy",
            AutoMlMetricExtendedEnum::F1 => "F1",
            AutoMlMetricExtendedEnum::F1Macro => "F1macro",
            AutoMlMetricExtendedEnum::LogLoss => "LogLoss",
            AutoMlMetricExtendedEnum::Mae => "MAE",
            AutoMlMetricExtendedEnum::Mse => "MSE",
            AutoMlMetricExtendedEnum::Precision => "Precision",
            AutoMlMetricExtendedEnum::PrecisionMacro => "PrecisionMacro",
            AutoMlMetricExtendedEnum::R2 => "R2",
            AutoMlMetricExtendedEnum::Rmse => "RMSE",
            AutoMlMetricExtendedEnum::Recall => "Recall",
            AutoMlMetricExtendedEnum::RecallMacro => "RecallMacro",
            AutoMlMetricExtendedEnum::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AUC",
            "Accuracy",
            "BalancedAccuracy",
            "F1",
            "F1macro",
            "LogLoss",
            "MAE",
            "MSE",
            "Precision",
            "PrecisionMacro",
            "R2",
            "RMSE",
            "Recall",
            "RecallMacro",
        ]
    }
}
impl AsRef<str> for AutoMlMetricExtendedEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricSetSource {
    #[allow(missing_docs)] // documentation missing in model
    Test,
    #[allow(missing_docs)] // documentation missing in model
    Train,
    #[allow(missing_docs)] // documentation missing in model
    Validation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MetricSetSource {
    fn from(s: &str) -> Self {
        match s {
            "Test" => MetricSetSource::Test,
            "Train" => MetricSetSource::Train,
            "Validation" => MetricSetSource::Validation,
            other => MetricSetSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MetricSetSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricSetSource::from(s))
    }
}
impl MetricSetSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricSetSource::Test => "Test",
            MetricSetSource::Train => "Train",
            MetricSetSource::Validation => "Validation",
            MetricSetSource::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Test", "Train", "Validation"]
    }
}
impl AsRef<str> for MetricSetSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlMetricEnum {
    #[allow(missing_docs)] // documentation missing in model
    Auc,
    #[allow(missing_docs)] // documentation missing in model
    Accuracy,
    #[allow(missing_docs)] // documentation missing in model
    F1,
    #[allow(missing_docs)] // documentation missing in model
    F1Macro,
    #[allow(missing_docs)] // documentation missing in model
    Mse,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlMetricEnum {
    fn from(s: &str) -> Self {
        match s {
            "AUC" => AutoMlMetricEnum::Auc,
            "Accuracy" => AutoMlMetricEnum::Accuracy,
            "F1" => AutoMlMetricEnum::F1,
            "F1macro" => AutoMlMetricEnum::F1Macro,
            "MSE" => AutoMlMetricEnum::Mse,
            other => AutoMlMetricEnum::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlMetricEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlMetricEnum::from(s))
    }
}
impl AutoMlMetricEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlMetricEnum::Auc => "AUC",
            AutoMlMetricEnum::Accuracy => "Accuracy",
            AutoMlMetricEnum::F1 => "F1",
            AutoMlMetricEnum::F1Macro => "F1macro",
            AutoMlMetricEnum::Mse => "MSE",
            AutoMlMetricEnum::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AUC", "Accuracy", "F1", "F1macro", "MSE"]
    }
}
impl AsRef<str> for AutoMlMetricEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The location of artifacts for an AutoML candidate job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CandidateArtifactLocations {
    /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML candidate.</p>
    pub explainability: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 prefix to the model insight artifacts generated for the AutoML candidate.</p>
    pub model_insights: std::option::Option<std::string::String>,
}
impl CandidateArtifactLocations {
    /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML candidate.</p>
    pub fn explainability(&self) -> std::option::Option<&str> {
        self.explainability.as_deref()
    }
    /// <p>The Amazon S3 prefix to the model insight artifacts generated for the AutoML candidate.</p>
    pub fn model_insights(&self) -> std::option::Option<&str> {
        self.model_insights.as_deref()
    }
}
impl std::fmt::Debug for CandidateArtifactLocations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CandidateArtifactLocations");
        formatter.field("explainability", &self.explainability);
        formatter.field("model_insights", &self.model_insights);
        formatter.finish()
    }
}
/// See [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
pub mod candidate_artifact_locations {

    /// A builder for [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explainability: std::option::Option<std::string::String>,
        pub(crate) model_insights: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML candidate.</p>
        pub fn explainability(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability = Some(input.into());
            self
        }
        /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML candidate.</p>
        pub fn set_explainability(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability = input;
            self
        }
        /// <p>The Amazon S3 prefix to the model insight artifacts generated for the AutoML candidate.</p>
        pub fn model_insights(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_insights = Some(input.into());
            self
        }
        /// <p>The Amazon S3 prefix to the model insight artifacts generated for the AutoML candidate.</p>
        pub fn set_model_insights(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_insights = input;
            self
        }
        /// Consumes the builder and constructs a [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
        pub fn build(self) -> crate::model::CandidateArtifactLocations {
            crate::model::CandidateArtifactLocations {
                explainability: self.explainability,
                model_insights: self.model_insights,
            }
        }
    }
}
impl CandidateArtifactLocations {
    /// Creates a new builder-style object to manufacture [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
    pub fn builder() -> crate::model::candidate_artifact_locations::Builder {
        crate::model::candidate_artifact_locations::Builder::default()
    }
}

/// <p>A list of container definitions that describe the different containers that make up an AutoML candidate. For more information, see .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlContainerDefinition {
    /// <p>The Amazon Elastic Container Registry (Amazon ECR) path of the container. For more information, see .</p>
    pub image: std::option::Option<std::string::String>,
    /// <p>The location of the model artifacts. For more information, see .</p>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the container. For more information, see .</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl AutoMlContainerDefinition {
    /// <p>The Amazon Elastic Container Registry (Amazon ECR) path of the container. For more information, see .</p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>The location of the model artifacts. For more information, see .</p>
    pub fn model_data_url(&self) -> std::option::Option<&str> {
        self.model_data_url.as_deref()
    }
    /// <p>The environment variables to set in the container. For more information, see .</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
}
impl std::fmt::Debug for AutoMlContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlContainerDefinition");
        formatter.field("image", &self.image);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
pub mod auto_ml_container_definition {

    /// A builder for [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Elastic Container Registry (Amazon ECR) path of the container. For more information, see .</p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The Amazon Elastic Container Registry (Amazon ECR) path of the container. For more information, see .</p>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>The location of the model artifacts. For more information, see .</p>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        /// <p>The location of the model artifacts. For more information, see .</p>
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the container. For more information, see .</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the container. For more information, see .</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
        pub fn build(self) -> crate::model::AutoMlContainerDefinition {
            crate::model::AutoMlContainerDefinition {
                image: self.image,
                model_data_url: self.model_data_url,
                environment: self.environment,
            }
        }
    }
}
impl AutoMlContainerDefinition {
    /// Creates a new builder-style object to manufacture [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
    pub fn builder() -> crate::model::auto_ml_container_definition::Builder {
        crate::model::auto_ml_container_definition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => CandidateStatus::Completed,
            "Failed" => CandidateStatus::Failed,
            "InProgress" => CandidateStatus::InProgress,
            "Stopped" => CandidateStatus::Stopped,
            "Stopping" => CandidateStatus::Stopping,
            other => CandidateStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateStatus::from(s))
    }
}
impl CandidateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CandidateStatus::Completed => "Completed",
            CandidateStatus::Failed => "Failed",
            CandidateStatus::InProgress => "InProgress",
            CandidateStatus::Stopped => "Stopped",
            CandidateStatus::Stopping => "Stopping",
            CandidateStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for CandidateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the steps for a candidate and what step it is working on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlCandidateStep {
    /// <p>Whether the candidate is at the transform, training, or processing step.</p>
    pub candidate_step_type: std::option::Option<crate::model::CandidateStepType>,
    /// <p>The ARN for the candidate's step.</p>
    pub candidate_step_arn: std::option::Option<std::string::String>,
    /// <p>The name for the candidate's step.</p>
    pub candidate_step_name: std::option::Option<std::string::String>,
}
impl AutoMlCandidateStep {
    /// <p>Whether the candidate is at the transform, training, or processing step.</p>
    pub fn candidate_step_type(&self) -> std::option::Option<&crate::model::CandidateStepType> {
        self.candidate_step_type.as_ref()
    }
    /// <p>The ARN for the candidate's step.</p>
    pub fn candidate_step_arn(&self) -> std::option::Option<&str> {
        self.candidate_step_arn.as_deref()
    }
    /// <p>The name for the candidate's step.</p>
    pub fn candidate_step_name(&self) -> std::option::Option<&str> {
        self.candidate_step_name.as_deref()
    }
}
impl std::fmt::Debug for AutoMlCandidateStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlCandidateStep");
        formatter.field("candidate_step_type", &self.candidate_step_type);
        formatter.field("candidate_step_arn", &self.candidate_step_arn);
        formatter.field("candidate_step_name", &self.candidate_step_name);
        formatter.finish()
    }
}
/// See [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
pub mod auto_ml_candidate_step {

    /// A builder for [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_step_type: std::option::Option<crate::model::CandidateStepType>,
        pub(crate) candidate_step_arn: std::option::Option<std::string::String>,
        pub(crate) candidate_step_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the candidate is at the transform, training, or processing step.</p>
        pub fn candidate_step_type(mut self, input: crate::model::CandidateStepType) -> Self {
            self.candidate_step_type = Some(input);
            self
        }
        /// <p>Whether the candidate is at the transform, training, or processing step.</p>
        pub fn set_candidate_step_type(
            mut self,
            input: std::option::Option<crate::model::CandidateStepType>,
        ) -> Self {
            self.candidate_step_type = input;
            self
        }
        /// <p>The ARN for the candidate's step.</p>
        pub fn candidate_step_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_step_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the candidate's step.</p>
        pub fn set_candidate_step_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_step_arn = input;
            self
        }
        /// <p>The name for the candidate's step.</p>
        pub fn candidate_step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_step_name = Some(input.into());
            self
        }
        /// <p>The name for the candidate's step.</p>
        pub fn set_candidate_step_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_step_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
        pub fn build(self) -> crate::model::AutoMlCandidateStep {
            crate::model::AutoMlCandidateStep {
                candidate_step_type: self.candidate_step_type,
                candidate_step_arn: self.candidate_step_arn,
                candidate_step_name: self.candidate_step_name,
            }
        }
    }
}
impl AutoMlCandidateStep {
    /// Creates a new builder-style object to manufacture [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
    pub fn builder() -> crate::model::auto_ml_candidate_step::Builder {
        crate::model::auto_ml_candidate_step::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateStepType {
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    Training,
    #[allow(missing_docs)] // documentation missing in model
    Transform,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateStepType {
    fn from(s: &str) -> Self {
        match s {
            "AWS::SageMaker::ProcessingJob" => CandidateStepType::Processing,
            "AWS::SageMaker::TrainingJob" => CandidateStepType::Training,
            "AWS::SageMaker::TransformJob" => CandidateStepType::Transform,
            other => CandidateStepType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateStepType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateStepType::from(s))
    }
}
impl CandidateStepType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CandidateStepType::Processing => "AWS::SageMaker::ProcessingJob",
            CandidateStepType::Training => "AWS::SageMaker::TrainingJob",
            CandidateStepType::Transform => "AWS::SageMaker::TransformJob",
            CandidateStepType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS::SageMaker::ProcessingJob",
            "AWS::SageMaker::TrainingJob",
            "AWS::SageMaker::TransformJob",
        ]
    }
}
impl AsRef<str> for CandidateStepType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The best candidate result from an AutoML training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinalAutoMlJobObjectiveMetric {
    /// <p>The type of metric with the best result.</p>
    pub r#type: std::option::Option<crate::model::AutoMlJobObjectiveType>,
    /// <p>The name of the metric with the best result. For a description of the possible objective metrics, see <code>AutoMLJobObjective$MetricName</code>.</p>
    pub metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
    /// <p>The value of the metric with the best result.</p>
    pub value: f32,
}
impl FinalAutoMlJobObjectiveMetric {
    /// <p>The type of metric with the best result.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AutoMlJobObjectiveType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the metric with the best result. For a description of the possible objective metrics, see <code>AutoMLJobObjective$MetricName</code>.</p>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::AutoMlMetricEnum> {
        self.metric_name.as_ref()
    }
    /// <p>The value of the metric with the best result.</p>
    pub fn value(&self) -> f32 {
        self.value
    }
}
impl std::fmt::Debug for FinalAutoMlJobObjectiveMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinalAutoMlJobObjectiveMetric");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
pub mod final_auto_ml_job_objective_metric {

    /// A builder for [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::AutoMlJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
        pub(crate) value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The type of metric with the best result.</p>
        pub fn r#type(mut self, input: crate::model::AutoMlJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of metric with the best result.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the metric with the best result. For a description of the possible objective metrics, see <code>AutoMLJobObjective$MetricName</code>.</p>
        pub fn metric_name(mut self, input: crate::model::AutoMlMetricEnum) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The name of the metric with the best result. For a description of the possible objective metrics, see <code>AutoMLJobObjective$MetricName</code>.</p>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricEnum>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the metric with the best result.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric with the best result.</p>
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
        pub fn build(self) -> crate::model::FinalAutoMlJobObjectiveMetric {
            crate::model::FinalAutoMlJobObjectiveMetric {
                r#type: self.r#type,
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl FinalAutoMlJobObjectiveMetric {
    /// Creates a new builder-style object to manufacture [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
    pub fn builder() -> crate::model::final_auto_ml_job_objective_metric::Builder {
        crate::model::final_auto_ml_job_objective_metric::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobObjectiveType {
    #[allow(missing_docs)] // documentation missing in model
    Maximize,
    #[allow(missing_docs)] // documentation missing in model
    Minimize,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobObjectiveType {
    fn from(s: &str) -> Self {
        match s {
            "Maximize" => AutoMlJobObjectiveType::Maximize,
            "Minimize" => AutoMlJobObjectiveType::Minimize,
            other => AutoMlJobObjectiveType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobObjectiveType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobObjectiveType::from(s))
    }
}
impl AutoMlJobObjectiveType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobObjectiveType::Maximize => "Maximize",
            AutoMlJobObjectiveType::Minimize => "Minimize",
            AutoMlJobObjectiveType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Maximize", "Minimize"]
    }
}
impl AsRef<str> for AutoMlJobObjectiveType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    FinalObjectiveMetricValue,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => CandidateSortBy::CreationTime,
            "FinalObjectiveMetricValue" => CandidateSortBy::FinalObjectiveMetricValue,
            "Status" => CandidateSortBy::Status,
            other => CandidateSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateSortBy::from(s))
    }
}
impl CandidateSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CandidateSortBy::CreationTime => "CreationTime",
            CandidateSortBy::FinalObjectiveMetricValue => "FinalObjectiveMetricValue",
            CandidateSortBy::Status => "Status",
            CandidateSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "FinalObjectiveMetricValue", "Status"]
    }
}
impl AsRef<str> for CandidateSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => AutoMlSortOrder::Ascending,
            "Descending" => AutoMlSortOrder::Descending,
            other => AutoMlSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlSortOrder::from(s))
    }
}
impl AutoMlSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlSortOrder::Ascending => "Ascending",
            AutoMlSortOrder::Descending => "Descending",
            AutoMlSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for AutoMlSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary about an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobSummary {
    /// <p>The name of the AutoML job you are requesting.</p>
    pub auto_ml_job_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the AutoML job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the AutoML job.</p>
    pub auto_ml_job_status: std::option::Option<crate::model::AutoMlJobStatus>,
    /// <p>The secondary status of the AutoML job.</p>
    pub auto_ml_job_secondary_status: std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
    /// <p>When the AutoML job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time of an AutoML job.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the AutoML job was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The failure reason of an AutoML job.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The list of reasons for partial failures within an AutoML job.</p>
    pub partial_failure_reasons:
        std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
}
impl AutoMlJobSummary {
    /// <p>The name of the AutoML job you are requesting.</p>
    pub fn auto_ml_job_name(&self) -> std::option::Option<&str> {
        self.auto_ml_job_name.as_deref()
    }
    /// <p>The ARN of the AutoML job.</p>
    pub fn auto_ml_job_arn(&self) -> std::option::Option<&str> {
        self.auto_ml_job_arn.as_deref()
    }
    /// <p>The status of the AutoML job.</p>
    pub fn auto_ml_job_status(&self) -> std::option::Option<&crate::model::AutoMlJobStatus> {
        self.auto_ml_job_status.as_ref()
    }
    /// <p>The secondary status of the AutoML job.</p>
    pub fn auto_ml_job_secondary_status(
        &self,
    ) -> std::option::Option<&crate::model::AutoMlJobSecondaryStatus> {
        self.auto_ml_job_secondary_status.as_ref()
    }
    /// <p>When the AutoML job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The end time of an AutoML job.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>When the AutoML job was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The failure reason of an AutoML job.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The list of reasons for partial failures within an AutoML job.</p>
    pub fn partial_failure_reasons(
        &self,
    ) -> std::option::Option<&[crate::model::AutoMlPartialFailureReason]> {
        self.partial_failure_reasons.as_deref()
    }
}
impl std::fmt::Debug for AutoMlJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobSummary");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("auto_ml_job_status", &self.auto_ml_job_status);
        formatter.field(
            "auto_ml_job_secondary_status",
            &self.auto_ml_job_secondary_status,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("partial_failure_reasons", &self.partial_failure_reasons);
        formatter.finish()
    }
}
/// See [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
pub mod auto_ml_job_summary {

    /// A builder for [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_ml_job_name: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_status: std::option::Option<crate::model::AutoMlJobStatus>,
        pub(crate) auto_ml_job_secondary_status:
            std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) partial_failure_reasons:
            std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
    }
    impl Builder {
        /// <p>The name of the AutoML job you are requesting.</p>
        pub fn auto_ml_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_name = Some(input.into());
            self
        }
        /// <p>The name of the AutoML job you are requesting.</p>
        pub fn set_auto_ml_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_name = input;
            self
        }
        /// <p>The ARN of the AutoML job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the AutoML job.</p>
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The status of the AutoML job.</p>
        pub fn auto_ml_job_status(mut self, input: crate::model::AutoMlJobStatus) -> Self {
            self.auto_ml_job_status = Some(input);
            self
        }
        /// <p>The status of the AutoML job.</p>
        pub fn set_auto_ml_job_status(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobStatus>,
        ) -> Self {
            self.auto_ml_job_status = input;
            self
        }
        /// <p>The secondary status of the AutoML job.</p>
        pub fn auto_ml_job_secondary_status(
            mut self,
            input: crate::model::AutoMlJobSecondaryStatus,
        ) -> Self {
            self.auto_ml_job_secondary_status = Some(input);
            self
        }
        /// <p>The secondary status of the AutoML job.</p>
        pub fn set_auto_ml_job_secondary_status(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
        ) -> Self {
            self.auto_ml_job_secondary_status = input;
            self
        }
        /// <p>When the AutoML job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the AutoML job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The end time of an AutoML job.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of an AutoML job.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the AutoML job was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the AutoML job was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The failure reason of an AutoML job.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The failure reason of an AutoML job.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Appends an item to `partial_failure_reasons`.
        ///
        /// To override the contents of this collection use [`set_partial_failure_reasons`](Self::set_partial_failure_reasons).
        ///
        /// <p>The list of reasons for partial failures within an AutoML job.</p>
        pub fn partial_failure_reasons(
            mut self,
            input: crate::model::AutoMlPartialFailureReason,
        ) -> Self {
            let mut v = self.partial_failure_reasons.unwrap_or_default();
            v.push(input);
            self.partial_failure_reasons = Some(v);
            self
        }
        /// <p>The list of reasons for partial failures within an AutoML job.</p>
        pub fn set_partial_failure_reasons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
        ) -> Self {
            self.partial_failure_reasons = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
        pub fn build(self) -> crate::model::AutoMlJobSummary {
            crate::model::AutoMlJobSummary {
                auto_ml_job_name: self.auto_ml_job_name,
                auto_ml_job_arn: self.auto_ml_job_arn,
                auto_ml_job_status: self.auto_ml_job_status,
                auto_ml_job_secondary_status: self.auto_ml_job_secondary_status,
                creation_time: self.creation_time,
                end_time: self.end_time,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                partial_failure_reasons: self.partial_failure_reasons,
            }
        }
    }
}
impl AutoMlJobSummary {
    /// Creates a new builder-style object to manufacture [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
    pub fn builder() -> crate::model::auto_ml_job_summary::Builder {
        crate::model::auto_ml_job_summary::Builder::default()
    }
}

/// <p>The reason for a partial failure of an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlPartialFailureReason {
    /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
    pub partial_failure_message: std::option::Option<std::string::String>,
}
impl AutoMlPartialFailureReason {
    /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
    pub fn partial_failure_message(&self) -> std::option::Option<&str> {
        self.partial_failure_message.as_deref()
    }
}
impl std::fmt::Debug for AutoMlPartialFailureReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlPartialFailureReason");
        formatter.field("partial_failure_message", &self.partial_failure_message);
        formatter.finish()
    }
}
/// See [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
pub mod auto_ml_partial_failure_reason {

    /// A builder for [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partial_failure_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
        pub fn partial_failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.partial_failure_message = Some(input.into());
            self
        }
        /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
        pub fn set_partial_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partial_failure_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
        pub fn build(self) -> crate::model::AutoMlPartialFailureReason {
            crate::model::AutoMlPartialFailureReason {
                partial_failure_message: self.partial_failure_message,
            }
        }
    }
}
impl AutoMlPartialFailureReason {
    /// Creates a new builder-style object to manufacture [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
    pub fn builder() -> crate::model::auto_ml_partial_failure_reason::Builder {
        crate::model::auto_ml_partial_failure_reason::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobSecondaryStatus {
    #[allow(missing_docs)] // documentation missing in model
    AnalyzingData,
    #[allow(missing_docs)] // documentation missing in model
    CandidateDefinitionsGenerated,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    DeployingModel,
    #[allow(missing_docs)] // documentation missing in model
    ExplainabilityError,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    FeatureEngineering,
    #[allow(missing_docs)] // documentation missing in model
    GeneratingExplainabilityReport,
    #[allow(missing_docs)] // documentation missing in model
    GeneratingModelInsightsReport,
    #[allow(missing_docs)] // documentation missing in model
    MaxAutoMlJobRuntimeReached,
    #[allow(missing_docs)] // documentation missing in model
    MaxCandidatesReached,
    #[allow(missing_docs)] // documentation missing in model
    ModelDeploymentError,
    #[allow(missing_docs)] // documentation missing in model
    ModelInsightsError,
    #[allow(missing_docs)] // documentation missing in model
    ModelTuning,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobSecondaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "AnalyzingData" => AutoMlJobSecondaryStatus::AnalyzingData,
            "CandidateDefinitionsGenerated" => {
                AutoMlJobSecondaryStatus::CandidateDefinitionsGenerated
            }
            "Completed" => AutoMlJobSecondaryStatus::Completed,
            "DeployingModel" => AutoMlJobSecondaryStatus::DeployingModel,
            "ExplainabilityError" => AutoMlJobSecondaryStatus::ExplainabilityError,
            "Failed" => AutoMlJobSecondaryStatus::Failed,
            "FeatureEngineering" => AutoMlJobSecondaryStatus::FeatureEngineering,
            "GeneratingExplainabilityReport" => {
                AutoMlJobSecondaryStatus::GeneratingExplainabilityReport
            }
            "GeneratingModelInsightsReport" => {
                AutoMlJobSecondaryStatus::GeneratingModelInsightsReport
            }
            "MaxAutoMLJobRuntimeReached" => AutoMlJobSecondaryStatus::MaxAutoMlJobRuntimeReached,
            "MaxCandidatesReached" => AutoMlJobSecondaryStatus::MaxCandidatesReached,
            "ModelDeploymentError" => AutoMlJobSecondaryStatus::ModelDeploymentError,
            "ModelInsightsError" => AutoMlJobSecondaryStatus::ModelInsightsError,
            "ModelTuning" => AutoMlJobSecondaryStatus::ModelTuning,
            "Starting" => AutoMlJobSecondaryStatus::Starting,
            "Stopped" => AutoMlJobSecondaryStatus::Stopped,
            "Stopping" => AutoMlJobSecondaryStatus::Stopping,
            other => AutoMlJobSecondaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobSecondaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobSecondaryStatus::from(s))
    }
}
impl AutoMlJobSecondaryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobSecondaryStatus::AnalyzingData => "AnalyzingData",
            AutoMlJobSecondaryStatus::CandidateDefinitionsGenerated => {
                "CandidateDefinitionsGenerated"
            }
            AutoMlJobSecondaryStatus::Completed => "Completed",
            AutoMlJobSecondaryStatus::DeployingModel => "DeployingModel",
            AutoMlJobSecondaryStatus::ExplainabilityError => "ExplainabilityError",
            AutoMlJobSecondaryStatus::Failed => "Failed",
            AutoMlJobSecondaryStatus::FeatureEngineering => "FeatureEngineering",
            AutoMlJobSecondaryStatus::GeneratingExplainabilityReport => {
                "GeneratingExplainabilityReport"
            }
            AutoMlJobSecondaryStatus::GeneratingModelInsightsReport => {
                "GeneratingModelInsightsReport"
            }
            AutoMlJobSecondaryStatus::MaxAutoMlJobRuntimeReached => "MaxAutoMLJobRuntimeReached",
            AutoMlJobSecondaryStatus::MaxCandidatesReached => "MaxCandidatesReached",
            AutoMlJobSecondaryStatus::ModelDeploymentError => "ModelDeploymentError",
            AutoMlJobSecondaryStatus::ModelInsightsError => "ModelInsightsError",
            AutoMlJobSecondaryStatus::ModelTuning => "ModelTuning",
            AutoMlJobSecondaryStatus::Starting => "Starting",
            AutoMlJobSecondaryStatus::Stopped => "Stopped",
            AutoMlJobSecondaryStatus::Stopping => "Stopping",
            AutoMlJobSecondaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AnalyzingData",
            "CandidateDefinitionsGenerated",
            "Completed",
            "DeployingModel",
            "ExplainabilityError",
            "Failed",
            "FeatureEngineering",
            "GeneratingExplainabilityReport",
            "GeneratingModelInsightsReport",
            "MaxAutoMLJobRuntimeReached",
            "MaxCandidatesReached",
            "ModelDeploymentError",
            "ModelInsightsError",
            "ModelTuning",
            "Starting",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for AutoMlJobSecondaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => AutoMlJobStatus::Completed,
            "Failed" => AutoMlJobStatus::Failed,
            "InProgress" => AutoMlJobStatus::InProgress,
            "Stopped" => AutoMlJobStatus::Stopped,
            "Stopping" => AutoMlJobStatus::Stopping,
            other => AutoMlJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobStatus::from(s))
    }
}
impl AutoMlJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobStatus::Completed => "Completed",
            AutoMlJobStatus::Failed => "Failed",
            AutoMlJobStatus::InProgress => "InProgress",
            AutoMlJobStatus::Stopped => "Stopped",
            AutoMlJobStatus::Stopping => "Stopping",
            AutoMlJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for AutoMlJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AutoMlSortBy::CreationTime,
            "Name" => AutoMlSortBy::Name,
            "Status" => AutoMlSortBy::Status,
            other => AutoMlSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlSortBy::from(s))
    }
}
impl AutoMlSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlSortBy::CreationTime => "CreationTime",
            AutoMlSortBy::Name => "Name",
            AutoMlSortBy::Status => "Status",
            AutoMlSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for AutoMlSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of an association. An association is an entity that links other lineage or experiment entities. An example would be an association between a training job and a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationSummary {
    /// <p>The ARN of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p>The source type.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The destination type.</p>
    pub destination_type: std::option::Option<std::string::String>,
    /// <p>The type of the association.</p>
    pub association_type: std::option::Option<crate::model::AssociationEdgeType>,
    /// <p>The name of the source.</p>
    pub source_name: std::option::Option<std::string::String>,
    /// <p>The name of the destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>When the association was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
}
impl AssociationSummary {
    /// <p>The ARN of the source.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub fn destination_arn(&self) -> std::option::Option<&str> {
        self.destination_arn.as_deref()
    }
    /// <p>The source type.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The destination type.</p>
    pub fn destination_type(&self) -> std::option::Option<&str> {
        self.destination_type.as_deref()
    }
    /// <p>The type of the association.</p>
    pub fn association_type(&self) -> std::option::Option<&crate::model::AssociationEdgeType> {
        self.association_type.as_ref()
    }
    /// <p>The name of the source.</p>
    pub fn source_name(&self) -> std::option::Option<&str> {
        self.source_name.as_deref()
    }
    /// <p>The name of the destination.</p>
    pub fn destination_name(&self) -> std::option::Option<&str> {
        self.destination_name.as_deref()
    }
    /// <p>When the association was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
    pub fn created_by(&self) -> std::option::Option<&crate::model::UserContext> {
        self.created_by.as_ref()
    }
}
impl std::fmt::Debug for AssociationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationSummary");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("source_type", &self.source_type);
        formatter.field("destination_type", &self.destination_type);
        formatter.field("association_type", &self.association_type);
        formatter.field("source_name", &self.source_name);
        formatter.field("destination_name", &self.destination_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.finish()
    }
}
/// See [`AssociationSummary`](crate::model::AssociationSummary)
pub mod association_summary {

    /// A builder for [`AssociationSummary`](crate::model::AssociationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) destination_type: std::option::Option<std::string::String>,
        pub(crate) association_type: std::option::Option<crate::model::AssociationEdgeType>,
        pub(crate) source_name: std::option::Option<std::string::String>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The ARN of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination.</p>
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The destination type.</p>
        pub fn destination_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_type = Some(input.into());
            self
        }
        /// <p>The destination type.</p>
        pub fn set_destination_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_type = input;
            self
        }
        /// <p>The type of the association.</p>
        pub fn association_type(mut self, input: crate::model::AssociationEdgeType) -> Self {
            self.association_type = Some(input);
            self
        }
        /// <p>The type of the association.</p>
        pub fn set_association_type(
            mut self,
            input: std::option::Option<crate::model::AssociationEdgeType>,
        ) -> Self {
            self.association_type = input;
            self
        }
        /// <p>The name of the source.</p>
        pub fn source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_name = Some(input.into());
            self
        }
        /// <p>The name of the source.</p>
        pub fn set_source_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_name = input;
            self
        }
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The name of the destination.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>When the association was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the association was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.</p>
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationSummary`](crate::model::AssociationSummary)
        pub fn build(self) -> crate::model::AssociationSummary {
            crate::model::AssociationSummary {
                source_arn: self.source_arn,
                destination_arn: self.destination_arn,
                source_type: self.source_type,
                destination_type: self.destination_type,
                association_type: self.association_type,
                source_name: self.source_name,
                destination_name: self.destination_name,
                creation_time: self.creation_time,
                created_by: self.created_by,
            }
        }
    }
}
impl AssociationSummary {
    /// Creates a new builder-style object to manufacture [`AssociationSummary`](crate::model::AssociationSummary)
    pub fn builder() -> crate::model::association_summary::Builder {
        crate::model::association_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortAssociationsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    DestinationArn,
    #[allow(missing_docs)] // documentation missing in model
    DestinationType,
    #[allow(missing_docs)] // documentation missing in model
    SourceArn,
    #[allow(missing_docs)] // documentation missing in model
    SourceType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortAssociationsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortAssociationsBy::CreationTime,
            "DestinationArn" => SortAssociationsBy::DestinationArn,
            "DestinationType" => SortAssociationsBy::DestinationType,
            "SourceArn" => SortAssociationsBy::SourceArn,
            "SourceType" => SortAssociationsBy::SourceType,
            other => SortAssociationsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortAssociationsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortAssociationsBy::from(s))
    }
}
impl SortAssociationsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortAssociationsBy::CreationTime => "CreationTime",
            SortAssociationsBy::DestinationArn => "DestinationArn",
            SortAssociationsBy::DestinationType => "DestinationType",
            SortAssociationsBy::SourceArn => "SourceArn",
            SortAssociationsBy::SourceType => "SourceType",
            SortAssociationsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "DestinationArn",
            "DestinationType",
            "SourceArn",
            "SourceType",
        ]
    }
}
impl AsRef<str> for SortAssociationsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of an artifact. An artifact represents a URI addressable object or data. Some examples are a dataset and a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSummary {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    pub artifact_arn: std::option::Option<std::string::String>,
    /// <p>The name of the artifact.</p>
    pub artifact_name: std::option::Option<std::string::String>,
    /// <p>The source of the artifact.</p>
    pub source: std::option::Option<crate::model::ArtifactSource>,
    /// <p>The type of the artifact.</p>
    pub artifact_type: std::option::Option<std::string::String>,
    /// <p>When the artifact was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the artifact was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ArtifactSummary {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    pub fn artifact_arn(&self) -> std::option::Option<&str> {
        self.artifact_arn.as_deref()
    }
    /// <p>The name of the artifact.</p>
    pub fn artifact_name(&self) -> std::option::Option<&str> {
        self.artifact_name.as_deref()
    }
    /// <p>The source of the artifact.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::ArtifactSource> {
        self.source.as_ref()
    }
    /// <p>The type of the artifact.</p>
    pub fn artifact_type(&self) -> std::option::Option<&str> {
        self.artifact_type.as_deref()
    }
    /// <p>When the artifact was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the artifact was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for ArtifactSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSummary");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.field("artifact_name", &self.artifact_name);
        formatter.field("source", &self.source);
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ArtifactSummary`](crate::model::ArtifactSummary)
pub mod artifact_summary {

    /// A builder for [`ArtifactSummary`](crate::model::ArtifactSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_arn: std::option::Option<std::string::String>,
        pub(crate) artifact_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ArtifactSource>,
        pub(crate) artifact_type: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
        pub fn artifact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
        pub fn set_artifact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.artifact_arn = input;
            self
        }
        /// <p>The name of the artifact.</p>
        pub fn artifact_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_name = Some(input.into());
            self
        }
        /// <p>The name of the artifact.</p>
        pub fn set_artifact_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_name = input;
            self
        }
        /// <p>The source of the artifact.</p>
        pub fn source(mut self, input: crate::model::ArtifactSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the artifact.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ArtifactSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the artifact.</p>
        pub fn artifact_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_type = Some(input.into());
            self
        }
        /// <p>The type of the artifact.</p>
        pub fn set_artifact_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_type = input;
            self
        }
        /// <p>When the artifact was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the artifact was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the artifact was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the artifact was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSummary`](crate::model::ArtifactSummary)
        pub fn build(self) -> crate::model::ArtifactSummary {
            crate::model::ArtifactSummary {
                artifact_arn: self.artifact_arn,
                artifact_name: self.artifact_name,
                source: self.source,
                artifact_type: self.artifact_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ArtifactSummary {
    /// Creates a new builder-style object to manufacture [`ArtifactSummary`](crate::model::ArtifactSummary)
    pub fn builder() -> crate::model::artifact_summary::Builder {
        crate::model::artifact_summary::Builder::default()
    }
}

/// <p>A structure describing the source of an artifact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>A list of source types.</p>
    pub source_types: std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
}
impl ArtifactSource {
    /// <p>The URI of the source.</p>
    pub fn source_uri(&self) -> std::option::Option<&str> {
        self.source_uri.as_deref()
    }
    /// <p>A list of source types.</p>
    pub fn source_types(&self) -> std::option::Option<&[crate::model::ArtifactSourceType]> {
        self.source_types.as_deref()
    }
}
impl std::fmt::Debug for ArtifactSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_types", &self.source_types);
        formatter.finish()
    }
}
/// See [`ArtifactSource`](crate::model::ArtifactSource)
pub mod artifact_source {

    /// A builder for [`ArtifactSource`](crate::model::ArtifactSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_types:
            std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        /// <p>The URI of the source.</p>
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        /// Appends an item to `source_types`.
        ///
        /// To override the contents of this collection use [`set_source_types`](Self::set_source_types).
        ///
        /// <p>A list of source types.</p>
        pub fn source_types(mut self, input: crate::model::ArtifactSourceType) -> Self {
            let mut v = self.source_types.unwrap_or_default();
            v.push(input);
            self.source_types = Some(v);
            self
        }
        /// <p>A list of source types.</p>
        pub fn set_source_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
        ) -> Self {
            self.source_types = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSource`](crate::model::ArtifactSource)
        pub fn build(self) -> crate::model::ArtifactSource {
            crate::model::ArtifactSource {
                source_uri: self.source_uri,
                source_types: self.source_types,
            }
        }
    }
}
impl ArtifactSource {
    /// Creates a new builder-style object to manufacture [`ArtifactSource`](crate::model::ArtifactSource)
    pub fn builder() -> crate::model::artifact_source::Builder {
        crate::model::artifact_source::Builder::default()
    }
}

/// <p>The ID and ID type of an artifact source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSourceType {
    /// <p>The type of ID.</p>
    pub source_id_type: std::option::Option<crate::model::ArtifactSourceIdType>,
    /// <p>The ID.</p>
    pub value: std::option::Option<std::string::String>,
}
impl ArtifactSourceType {
    /// <p>The type of ID.</p>
    pub fn source_id_type(&self) -> std::option::Option<&crate::model::ArtifactSourceIdType> {
        self.source_id_type.as_ref()
    }
    /// <p>The ID.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ArtifactSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSourceType");
        formatter.field("source_id_type", &self.source_id_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ArtifactSourceType`](crate::model::ArtifactSourceType)
pub mod artifact_source_type {

    /// A builder for [`ArtifactSourceType`](crate::model::ArtifactSourceType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_id_type: std::option::Option<crate::model::ArtifactSourceIdType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of ID.</p>
        pub fn source_id_type(mut self, input: crate::model::ArtifactSourceIdType) -> Self {
            self.source_id_type = Some(input);
            self
        }
        /// <p>The type of ID.</p>
        pub fn set_source_id_type(
            mut self,
            input: std::option::Option<crate::model::ArtifactSourceIdType>,
        ) -> Self {
            self.source_id_type = input;
            self
        }
        /// <p>The ID.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The ID.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSourceType`](crate::model::ArtifactSourceType)
        pub fn build(self) -> crate::model::ArtifactSourceType {
            crate::model::ArtifactSourceType {
                source_id_type: self.source_id_type,
                value: self.value,
            }
        }
    }
}
impl ArtifactSourceType {
    /// Creates a new builder-style object to manufacture [`ArtifactSourceType`](crate::model::ArtifactSourceType)
    pub fn builder() -> crate::model::artifact_source_type::Builder {
        crate::model::artifact_source_type::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArtifactSourceIdType {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Md5Hash,
    #[allow(missing_docs)] // documentation missing in model
    S3Etag,
    #[allow(missing_docs)] // documentation missing in model
    S3Version,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArtifactSourceIdType {
    fn from(s: &str) -> Self {
        match s {
            "Custom" => ArtifactSourceIdType::Custom,
            "MD5Hash" => ArtifactSourceIdType::Md5Hash,
            "S3ETag" => ArtifactSourceIdType::S3Etag,
            "S3Version" => ArtifactSourceIdType::S3Version,
            other => ArtifactSourceIdType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArtifactSourceIdType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArtifactSourceIdType::from(s))
    }
}
impl ArtifactSourceIdType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactSourceIdType::Custom => "Custom",
            ArtifactSourceIdType::Md5Hash => "MD5Hash",
            ArtifactSourceIdType::S3Etag => "S3ETag",
            ArtifactSourceIdType::S3Version => "S3Version",
            ArtifactSourceIdType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Custom", "MD5Hash", "S3ETag", "S3Version"]
    }
}
impl AsRef<str> for ArtifactSourceIdType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortArtifactsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortArtifactsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortArtifactsBy::CreationTime,
            other => SortArtifactsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortArtifactsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortArtifactsBy::from(s))
    }
}
impl SortArtifactsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortArtifactsBy::CreationTime => "CreationTime",
            SortArtifactsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for SortArtifactsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about an Amazon SageMaker app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppDetails {
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The type of app.</p>
    pub app_type: std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    pub app_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::AppStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl AppDetails {
    /// <p>The domain ID.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The user profile name.</p>
    pub fn user_profile_name(&self) -> std::option::Option<&str> {
        self.user_profile_name.as_deref()
    }
    /// <p>The type of app.</p>
    pub fn app_type(&self) -> std::option::Option<&crate::model::AppType> {
        self.app_type.as_ref()
    }
    /// <p>The name of the app.</p>
    pub fn app_name(&self) -> std::option::Option<&str> {
        self.app_name.as_deref()
    }
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AppStatus> {
        self.status.as_ref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for AppDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppDetails");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`AppDetails`](crate::model::AppDetails)
pub mod app_details {

    /// A builder for [`AppDetails`](crate::model::AppDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) app_type: std::option::Option<crate::model::AppType>,
        pub(crate) app_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AppStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The domain ID.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The user profile name.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        /// <p>The user profile name.</p>
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The type of app.</p>
        pub fn app_type(mut self, input: crate::model::AppType) -> Self {
            self.app_type = Some(input);
            self
        }
        /// <p>The type of app.</p>
        pub fn set_app_type(mut self, input: std::option::Option<crate::model::AppType>) -> Self {
            self.app_type = input;
            self
        }
        /// <p>The name of the app.</p>
        pub fn app_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_name = Some(input.into());
            self
        }
        /// <p>The name of the app.</p>
        pub fn set_app_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::AppStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AppStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AppDetails`](crate::model::AppDetails)
        pub fn build(self) -> crate::model::AppDetails {
            crate::model::AppDetails {
                domain_id: self.domain_id,
                user_profile_name: self.user_profile_name,
                app_type: self.app_type,
                app_name: self.app_name,
                status: self.status,
                creation_time: self.creation_time,
            }
        }
    }
}
impl AppDetails {
    /// Creates a new builder-style object to manufacture [`AppDetails`](crate::model::AppDetails)
    pub fn builder() -> crate::model::app_details::Builder {
        crate::model::app_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppStatus {
    fn from(s: &str) -> Self {
        match s {
            "Deleted" => AppStatus::Deleted,
            "Deleting" => AppStatus::Deleting,
            "Failed" => AppStatus::Failed,
            "InService" => AppStatus::InService,
            "Pending" => AppStatus::Pending,
            other => AppStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppStatus::from(s))
    }
}
impl AppStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppStatus::Deleted => "Deleted",
            AppStatus::Deleting => "Deleting",
            AppStatus::Failed => "Failed",
            AppStatus::InService => "InService",
            AppStatus::Pending => "Pending",
            AppStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Deleted", "Deleting", "Failed", "InService", "Pending"]
    }
}
impl AsRef<str> for AppStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppType {
    #[allow(missing_docs)] // documentation missing in model
    JupyterServer,
    #[allow(missing_docs)] // documentation missing in model
    KernelGateway,
    #[allow(missing_docs)] // documentation missing in model
    RSessionGateway,
    #[allow(missing_docs)] // documentation missing in model
    RStudioServerPro,
    #[allow(missing_docs)] // documentation missing in model
    TensorBoard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppType {
    fn from(s: &str) -> Self {
        match s {
            "JupyterServer" => AppType::JupyterServer,
            "KernelGateway" => AppType::KernelGateway,
            "RSessionGateway" => AppType::RSessionGateway,
            "RStudioServerPro" => AppType::RStudioServerPro,
            "TensorBoard" => AppType::TensorBoard,
            other => AppType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppType::from(s))
    }
}
impl AppType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppType::JupyterServer => "JupyterServer",
            AppType::KernelGateway => "KernelGateway",
            AppType::RSessionGateway => "RSessionGateway",
            AppType::RStudioServerPro => "RStudioServerPro",
            AppType::TensorBoard => "TensorBoard",
            AppType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "JupyterServer",
            "KernelGateway",
            "RSessionGateway",
            "RStudioServerPro",
            "TensorBoard",
        ]
    }
}
impl AsRef<str> for AppType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AppSortKey::CreationTime,
            other => AppSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppSortKey::from(s))
    }
}
impl AppSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppSortKey::CreationTime => "CreationTime",
            AppSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for AppSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for running a SageMaker image as a KernelGateway app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppImageConfigDetails {
    /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
    pub app_image_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
    pub app_image_config_name: std::option::Option<std::string::String>,
    /// <p>When the AppImageConfig was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the AppImageConfig was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
    pub kernel_gateway_image_config: std::option::Option<crate::model::KernelGatewayImageConfig>,
}
impl AppImageConfigDetails {
    /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
    pub fn app_image_config_arn(&self) -> std::option::Option<&str> {
        self.app_image_config_arn.as_deref()
    }
    /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
    pub fn app_image_config_name(&self) -> std::option::Option<&str> {
        self.app_image_config_name.as_deref()
    }
    /// <p>When the AppImageConfig was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the AppImageConfig was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
    pub fn kernel_gateway_image_config(
        &self,
    ) -> std::option::Option<&crate::model::KernelGatewayImageConfig> {
        self.kernel_gateway_image_config.as_ref()
    }
}
impl std::fmt::Debug for AppImageConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppImageConfigDetails");
        formatter.field("app_image_config_arn", &self.app_image_config_arn);
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "kernel_gateway_image_config",
            &self.kernel_gateway_image_config,
        );
        formatter.finish()
    }
}
/// See [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
pub mod app_image_config_details {

    /// A builder for [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_image_config_arn: std::option::Option<std::string::String>,
        pub(crate) app_image_config_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) kernel_gateway_image_config:
            std::option::Option<crate::model::KernelGatewayImageConfig>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
        pub fn app_image_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
        pub fn set_app_image_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_arn = input;
            self
        }
        /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
        pub fn app_image_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_name = Some(input.into());
            self
        }
        /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
        pub fn set_app_image_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_name = input;
            self
        }
        /// <p>When the AppImageConfig was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the AppImageConfig was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the AppImageConfig was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the AppImageConfig was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
        pub fn kernel_gateway_image_config(
            mut self,
            input: crate::model::KernelGatewayImageConfig,
        ) -> Self {
            self.kernel_gateway_image_config = Some(input);
            self
        }
        /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
        pub fn set_kernel_gateway_image_config(
            mut self,
            input: std::option::Option<crate::model::KernelGatewayImageConfig>,
        ) -> Self {
            self.kernel_gateway_image_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
        pub fn build(self) -> crate::model::AppImageConfigDetails {
            crate::model::AppImageConfigDetails {
                app_image_config_arn: self.app_image_config_arn,
                app_image_config_name: self.app_image_config_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                kernel_gateway_image_config: self.kernel_gateway_image_config,
            }
        }
    }
}
impl AppImageConfigDetails {
    /// Creates a new builder-style object to manufacture [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
    pub fn builder() -> crate::model::app_image_config_details::Builder {
        crate::model::app_image_config_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppImageConfigSortKey {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LastModifiedTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppImageConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AppImageConfigSortKey::CreationTime,
            "LastModifiedTime" => AppImageConfigSortKey::LastModifiedTime,
            "Name" => AppImageConfigSortKey::Name,
            other => AppImageConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppImageConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppImageConfigSortKey::from(s))
    }
}
impl AppImageConfigSortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppImageConfigSortKey::CreationTime => "CreationTime",
            AppImageConfigSortKey::LastModifiedTime => "LastModifiedTime",
            AppImageConfigSortKey::Name => "Name",
            AppImageConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for AppImageConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmSummary {
    /// <p>The name of the algorithm that is described by the summary.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
    pub algorithm_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the algorithm.</p>
    pub algorithm_description: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the algorithm was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The overall status of the algorithm.</p>
    pub algorithm_status: std::option::Option<crate::model::AlgorithmStatus>,
}
impl AlgorithmSummary {
    /// <p>The name of the algorithm that is described by the summary.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&str> {
        self.algorithm_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
    pub fn algorithm_arn(&self) -> std::option::Option<&str> {
        self.algorithm_arn.as_deref()
    }
    /// <p>A brief description of the algorithm.</p>
    pub fn algorithm_description(&self) -> std::option::Option<&str> {
        self.algorithm_description.as_deref()
    }
    /// <p>A timestamp that shows when the algorithm was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The overall status of the algorithm.</p>
    pub fn algorithm_status(&self) -> std::option::Option<&crate::model::AlgorithmStatus> {
        self.algorithm_status.as_ref()
    }
}
impl std::fmt::Debug for AlgorithmSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmSummary");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("algorithm_arn", &self.algorithm_arn);
        formatter.field("algorithm_description", &self.algorithm_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("algorithm_status", &self.algorithm_status);
        formatter.finish()
    }
}
/// See [`AlgorithmSummary`](crate::model::AlgorithmSummary)
pub mod algorithm_summary {

    /// A builder for [`AlgorithmSummary`](crate::model::AlgorithmSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) algorithm_arn: std::option::Option<std::string::String>,
        pub(crate) algorithm_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) algorithm_status: std::option::Option<crate::model::AlgorithmStatus>,
    }
    impl Builder {
        /// <p>The name of the algorithm that is described by the summary.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        /// <p>The name of the algorithm that is described by the summary.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
        pub fn algorithm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
        pub fn set_algorithm_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_arn = input;
            self
        }
        /// <p>A brief description of the algorithm.</p>
        pub fn algorithm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_description = Some(input.into());
            self
        }
        /// <p>A brief description of the algorithm.</p>
        pub fn set_algorithm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_description = input;
            self
        }
        /// <p>A timestamp that shows when the algorithm was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the algorithm was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The overall status of the algorithm.</p>
        pub fn algorithm_status(mut self, input: crate::model::AlgorithmStatus) -> Self {
            self.algorithm_status = Some(input);
            self
        }
        /// <p>The overall status of the algorithm.</p>
        pub fn set_algorithm_status(
            mut self,
            input: std::option::Option<crate::model::AlgorithmStatus>,
        ) -> Self {
            self.algorithm_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmSummary`](crate::model::AlgorithmSummary)
        pub fn build(self) -> crate::model::AlgorithmSummary {
            crate::model::AlgorithmSummary {
                algorithm_name: self.algorithm_name,
                algorithm_arn: self.algorithm_arn,
                algorithm_description: self.algorithm_description,
                creation_time: self.creation_time,
                algorithm_status: self.algorithm_status,
            }
        }
    }
}
impl AlgorithmSummary {
    /// Creates a new builder-style object to manufacture [`AlgorithmSummary`](crate::model::AlgorithmSummary)
    pub fn builder() -> crate::model::algorithm_summary::Builder {
        crate::model::algorithm_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AlgorithmStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => AlgorithmStatus::Completed,
            "Deleting" => AlgorithmStatus::Deleting,
            "Failed" => AlgorithmStatus::Failed,
            "InProgress" => AlgorithmStatus::InProgress,
            "Pending" => AlgorithmStatus::Pending,
            other => AlgorithmStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AlgorithmStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmStatus::from(s))
    }
}
impl AlgorithmStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmStatus::Completed => "Completed",
            AlgorithmStatus::Deleting => "Deleting",
            AlgorithmStatus::Failed => "Failed",
            AlgorithmStatus::InProgress => "InProgress",
            AlgorithmStatus::Pending => "Pending",
            AlgorithmStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Deleting", "Failed", "InProgress", "Pending"]
    }
}
impl AsRef<str> for AlgorithmStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AlgorithmSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AlgorithmSortBy::CreationTime,
            "Name" => AlgorithmSortBy::Name,
            other => AlgorithmSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AlgorithmSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmSortBy::from(s))
    }
}
impl AlgorithmSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmSortBy::CreationTime => "CreationTime",
            AlgorithmSortBy::Name => "Name",
            AlgorithmSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for AlgorithmSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists the properties of an <i>action</i>. An action represents an action or activity. Some examples are a workflow step and a model deployment. Generally, an action involves at least one input artifact or output artifact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionSummary {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    pub action_arn: std::option::Option<std::string::String>,
    /// <p>The name of the action.</p>
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The source of the action.</p>
    pub source: std::option::Option<crate::model::ActionSource>,
    /// <p>The type of the action.</p>
    pub action_type: std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    pub status: std::option::Option<crate::model::ActionStatus>,
    /// <p>When the action was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the action was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ActionSummary {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    pub fn action_arn(&self) -> std::option::Option<&str> {
        self.action_arn.as_deref()
    }
    /// <p>The name of the action.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
    /// <p>The source of the action.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::ActionSource> {
        self.source.as_ref()
    }
    /// <p>The type of the action.</p>
    pub fn action_type(&self) -> std::option::Option<&str> {
        self.action_type.as_deref()
    }
    /// <p>The status of the action.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ActionStatus> {
        self.status.as_ref()
    }
    /// <p>When the action was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the action was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for ActionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionSummary");
        formatter.field("action_arn", &self.action_arn);
        formatter.field("action_name", &self.action_name);
        formatter.field("source", &self.source);
        formatter.field("action_type", &self.action_type);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ActionSummary`](crate::model::ActionSummary)
pub mod action_summary {

    /// A builder for [`ActionSummary`](crate::model::ActionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_arn: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ActionSource>,
        pub(crate) action_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ActionStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the action.</p>
        pub fn action_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the action.</p>
        pub fn set_action_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_arn = input;
            self
        }
        /// <p>The name of the action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The name of the action.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p>The source of the action.</p>
        pub fn source(mut self, input: crate::model::ActionSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the action.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ActionSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the action.</p>
        pub fn action_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_type = Some(input.into());
            self
        }
        /// <p>The type of the action.</p>
        pub fn set_action_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_type = input;
            self
        }
        /// <p>The status of the action.</p>
        pub fn status(mut self, input: crate::model::ActionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the action.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ActionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the action was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the action was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the action was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the action was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionSummary`](crate::model::ActionSummary)
        pub fn build(self) -> crate::model::ActionSummary {
            crate::model::ActionSummary {
                action_arn: self.action_arn,
                action_name: self.action_name,
                source: self.source,
                action_type: self.action_type,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ActionSummary {
    /// Creates a new builder-style object to manufacture [`ActionSummary`](crate::model::ActionSummary)
    pub fn builder() -> crate::model::action_summary::Builder {
        crate::model::action_summary::Builder::default()
    }
}

/// <p>A structure describing the source of an action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>The type of the source.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The ID of the source.</p>
    pub source_id: std::option::Option<std::string::String>,
}
impl ActionSource {
    /// <p>The URI of the source.</p>
    pub fn source_uri(&self) -> std::option::Option<&str> {
        self.source_uri.as_deref()
    }
    /// <p>The type of the source.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The ID of the source.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
}
impl std::fmt::Debug for ActionSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_type", &self.source_type);
        formatter.field("source_id", &self.source_id);
        formatter.finish()
    }
}
/// See [`ActionSource`](crate::model::ActionSource)
pub mod action_source {

    /// A builder for [`ActionSource`](crate::model::ActionSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        /// <p>The URI of the source.</p>
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        /// <p>The type of the source.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The type of the source.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The ID of the source.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The ID of the source.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionSource`](crate::model::ActionSource)
        pub fn build(self) -> crate::model::ActionSource {
            crate::model::ActionSource {
                source_uri: self.source_uri,
                source_type: self.source_type,
                source_id: self.source_id,
            }
        }
    }
}
impl ActionSource {
    /// Creates a new builder-style object to manufacture [`ActionSource`](crate::model::ActionSource)
    pub fn builder() -> crate::model::action_source::Builder {
        crate::model::action_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortActionsBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortActionsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortActionsBy::CreationTime,
            "Name" => SortActionsBy::Name,
            other => SortActionsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortActionsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortActionsBy::from(s))
    }
}
impl SortActionsBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortActionsBy::CreationTime => "CreationTime",
            SortActionsBy::Name => "Name",
            SortActionsBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortActionsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A property name returned from a <code>GetSearchSuggestions</code> call that specifies a value in the <code>PropertyNameQuery</code> field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyNameSuggestion {
    /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker console.</p>
    pub property_name: std::option::Option<std::string::String>,
}
impl PropertyNameSuggestion {
    /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker console.</p>
    pub fn property_name(&self) -> std::option::Option<&str> {
        self.property_name.as_deref()
    }
}
impl std::fmt::Debug for PropertyNameSuggestion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyNameSuggestion");
        formatter.field("property_name", &self.property_name);
        formatter.finish()
    }
}
/// See [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
pub mod property_name_suggestion {

    /// A builder for [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker console.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker console.</p>
        pub fn set_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
        pub fn build(self) -> crate::model::PropertyNameSuggestion {
            crate::model::PropertyNameSuggestion {
                property_name: self.property_name,
            }
        }
    }
}
impl PropertyNameSuggestion {
    /// Creates a new builder-style object to manufacture [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
    pub fn builder() -> crate::model::property_name_suggestion::Builder {
        crate::model::property_name_suggestion::Builder::default()
    }
}

/// <p>Specified in the <code>GetSearchSuggestions</code> request. Limits the property names that are included in the response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SuggestionQuery {
    /// <p>Defines a property name hint. Only property names that begin with the specified hint are included in the response.</p>
    pub property_name_query: std::option::Option<crate::model::PropertyNameQuery>,
}
impl SuggestionQuery {
    /// <p>Defines a property name hint. Only property names that begin with the specified hint are included in the response.</p>
    pub fn property_name_query(&self) -> std::option::Option<&crate::model::PropertyNameQuery> {
        self.property_name_query.as_ref()
    }
}
impl std::fmt::Debug for SuggestionQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SuggestionQuery");
        formatter.field("property_name_query", &self.property_name_query);
        formatter.finish()
    }
}
/// See [`SuggestionQuery`](crate::model::SuggestionQuery)
pub mod suggestion_query {

    /// A builder for [`SuggestionQuery`](crate::model::SuggestionQuery)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name_query: std::option::Option<crate::model::PropertyNameQuery>,
    }
    impl Builder {
        /// <p>Defines a property name hint. Only property names that begin with the specified hint are included in the response.</p>
        pub fn property_name_query(mut self, input: crate::model::PropertyNameQuery) -> Self {
            self.property_name_query = Some(input);
            self
        }
        /// <p>Defines a property name hint. Only property names that begin with the specified hint are included in the response.</p>
        pub fn set_property_name_query(
            mut self,
            input: std::option::Option<crate::model::PropertyNameQuery>,
        ) -> Self {
            self.property_name_query = input;
            self
        }
        /// Consumes the builder and constructs a [`SuggestionQuery`](crate::model::SuggestionQuery)
        pub fn build(self) -> crate::model::SuggestionQuery {
            crate::model::SuggestionQuery {
                property_name_query: self.property_name_query,
            }
        }
    }
}
impl SuggestionQuery {
    /// Creates a new builder-style object to manufacture [`SuggestionQuery`](crate::model::SuggestionQuery)
    pub fn builder() -> crate::model::suggestion_query::Builder {
        crate::model::suggestion_query::Builder::default()
    }
}

/// <p>Part of the <code>SuggestionQuery</code> type. Specifies a hint for retrieving property names that begin with the specified text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyNameQuery {
    /// <p>Text that begins a property's name.</p>
    pub property_name_hint: std::option::Option<std::string::String>,
}
impl PropertyNameQuery {
    /// <p>Text that begins a property's name.</p>
    pub fn property_name_hint(&self) -> std::option::Option<&str> {
        self.property_name_hint.as_deref()
    }
}
impl std::fmt::Debug for PropertyNameQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyNameQuery");
        formatter.field("property_name_hint", &self.property_name_hint);
        formatter.finish()
    }
}
/// See [`PropertyNameQuery`](crate::model::PropertyNameQuery)
pub mod property_name_query {

    /// A builder for [`PropertyNameQuery`](crate::model::PropertyNameQuery)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name_hint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Text that begins a property's name.</p>
        pub fn property_name_hint(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name_hint = Some(input.into());
            self
        }
        /// <p>Text that begins a property's name.</p>
        pub fn set_property_name_hint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name_hint = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyNameQuery`](crate::model::PropertyNameQuery)
        pub fn build(self) -> crate::model::PropertyNameQuery {
            crate::model::PropertyNameQuery {
                property_name_hint: self.property_name_hint,
            }
        }
    }
}
impl PropertyNameQuery {
    /// Creates a new builder-style object to manufacture [`PropertyNameQuery`](crate::model::PropertyNameQuery)
    pub fn builder() -> crate::model::property_name_query::Builder {
        crate::model::property_name_query::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SagemakerServicecatalogStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SagemakerServicecatalogStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => SagemakerServicecatalogStatus::Disabled,
            "Enabled" => SagemakerServicecatalogStatus::Enabled,
            other => SagemakerServicecatalogStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SagemakerServicecatalogStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SagemakerServicecatalogStatus::from(s))
    }
}
impl SagemakerServicecatalogStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SagemakerServicecatalogStatus::Disabled => "Disabled",
            SagemakerServicecatalogStatus::Enabled => "Enabled",
            SagemakerServicecatalogStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for SagemakerServicecatalogStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status of edge devices with this model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModelStat {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The model version.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The number of devices that have this model version and do not have a heart beat.</p>
    pub offline_device_count: i64,
    /// <p>The number of devices that have this model version and have a heart beat. </p>
    pub connected_device_count: i64,
    /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
    pub active_device_count: i64,
    /// <p>The number of devices with this model version and are producing sample data.</p>
    pub sampling_device_count: i64,
}
impl EdgeModelStat {
    /// <p>The name of the model.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The model version.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The number of devices that have this model version and do not have a heart beat.</p>
    pub fn offline_device_count(&self) -> i64 {
        self.offline_device_count
    }
    /// <p>The number of devices that have this model version and have a heart beat. </p>
    pub fn connected_device_count(&self) -> i64 {
        self.connected_device_count
    }
    /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
    pub fn active_device_count(&self) -> i64 {
        self.active_device_count
    }
    /// <p>The number of devices with this model version and are producing sample data.</p>
    pub fn sampling_device_count(&self) -> i64 {
        self.sampling_device_count
    }
}
impl std::fmt::Debug for EdgeModelStat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModelStat");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("offline_device_count", &self.offline_device_count);
        formatter.field("connected_device_count", &self.connected_device_count);
        formatter.field("active_device_count", &self.active_device_count);
        formatter.field("sampling_device_count", &self.sampling_device_count);
        formatter.finish()
    }
}
/// See [`EdgeModelStat`](crate::model::EdgeModelStat)
pub mod edge_model_stat {

    /// A builder for [`EdgeModelStat`](crate::model::EdgeModelStat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) offline_device_count: std::option::Option<i64>,
        pub(crate) connected_device_count: std::option::Option<i64>,
        pub(crate) active_device_count: std::option::Option<i64>,
        pub(crate) sampling_device_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The model version.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The model version.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The number of devices that have this model version and do not have a heart beat.</p>
        pub fn offline_device_count(mut self, input: i64) -> Self {
            self.offline_device_count = Some(input);
            self
        }
        /// <p>The number of devices that have this model version and do not have a heart beat.</p>
        pub fn set_offline_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.offline_device_count = input;
            self
        }
        /// <p>The number of devices that have this model version and have a heart beat. </p>
        pub fn connected_device_count(mut self, input: i64) -> Self {
            self.connected_device_count = Some(input);
            self
        }
        /// <p>The number of devices that have this model version and have a heart beat. </p>
        pub fn set_connected_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.connected_device_count = input;
            self
        }
        /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
        pub fn active_device_count(mut self, input: i64) -> Self {
            self.active_device_count = Some(input);
            self
        }
        /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
        pub fn set_active_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.active_device_count = input;
            self
        }
        /// <p>The number of devices with this model version and are producing sample data.</p>
        pub fn sampling_device_count(mut self, input: i64) -> Self {
            self.sampling_device_count = Some(input);
            self
        }
        /// <p>The number of devices with this model version and are producing sample data.</p>
        pub fn set_sampling_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.sampling_device_count = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModelStat`](crate::model::EdgeModelStat)
        pub fn build(self) -> crate::model::EdgeModelStat {
            crate::model::EdgeModelStat {
                model_name: self.model_name,
                model_version: self.model_version,
                offline_device_count: self.offline_device_count.unwrap_or_default(),
                connected_device_count: self.connected_device_count.unwrap_or_default(),
                active_device_count: self.active_device_count.unwrap_or_default(),
                sampling_device_count: self.sampling_device_count.unwrap_or_default(),
            }
        }
    }
}
impl EdgeModelStat {
    /// Creates a new builder-style object to manufacture [`EdgeModelStat`](crate::model::EdgeModelStat)
    pub fn builder() -> crate::model::edge_model_stat::Builder {
        crate::model::edge_model_stat::Builder::default()
    }
}

/// <p>Edge Manager agent version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentVersion {
    /// <p>Version of the agent.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The number of Edge Manager agents.</p>
    pub agent_count: i64,
}
impl AgentVersion {
    /// <p>Version of the agent.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The number of Edge Manager agents.</p>
    pub fn agent_count(&self) -> i64 {
        self.agent_count
    }
}
impl std::fmt::Debug for AgentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentVersion");
        formatter.field("version", &self.version);
        formatter.field("agent_count", &self.agent_count);
        formatter.finish()
    }
}
/// See [`AgentVersion`](crate::model::AgentVersion)
pub mod agent_version {

    /// A builder for [`AgentVersion`](crate::model::AgentVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) agent_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Version of the agent.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>Version of the agent.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The number of Edge Manager agents.</p>
        pub fn agent_count(mut self, input: i64) -> Self {
            self.agent_count = Some(input);
            self
        }
        /// <p>The number of Edge Manager agents.</p>
        pub fn set_agent_count(mut self, input: std::option::Option<i64>) -> Self {
            self.agent_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentVersion`](crate::model::AgentVersion)
        pub fn build(self) -> crate::model::AgentVersion {
            crate::model::AgentVersion {
                version: self.version,
                agent_count: self.agent_count.unwrap_or_default(),
            }
        }
    }
}
impl AgentVersion {
    /// Creates a new builder-style object to manufacture [`AgentVersion`](crate::model::AgentVersion)
    pub fn builder() -> crate::model::agent_version::Builder {
        crate::model::agent_version::Builder::default()
    }
}

/// <p>Status of devices.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceStats {
    /// <p>The number of devices connected with a heartbeat.</p>
    pub connected_device_count: i64,
    /// <p>The number of registered devices.</p>
    pub registered_device_count: i64,
}
impl DeviceStats {
    /// <p>The number of devices connected with a heartbeat.</p>
    pub fn connected_device_count(&self) -> i64 {
        self.connected_device_count
    }
    /// <p>The number of registered devices.</p>
    pub fn registered_device_count(&self) -> i64 {
        self.registered_device_count
    }
}
impl std::fmt::Debug for DeviceStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceStats");
        formatter.field("connected_device_count", &self.connected_device_count);
        formatter.field("registered_device_count", &self.registered_device_count);
        formatter.finish()
    }
}
/// See [`DeviceStats`](crate::model::DeviceStats)
pub mod device_stats {

    /// A builder for [`DeviceStats`](crate::model::DeviceStats)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connected_device_count: std::option::Option<i64>,
        pub(crate) registered_device_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of devices connected with a heartbeat.</p>
        pub fn connected_device_count(mut self, input: i64) -> Self {
            self.connected_device_count = Some(input);
            self
        }
        /// <p>The number of devices connected with a heartbeat.</p>
        pub fn set_connected_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.connected_device_count = input;
            self
        }
        /// <p>The number of registered devices.</p>
        pub fn registered_device_count(mut self, input: i64) -> Self {
            self.registered_device_count = Some(input);
            self
        }
        /// <p>The number of registered devices.</p>
        pub fn set_registered_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.registered_device_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceStats`](crate::model::DeviceStats)
        pub fn build(self) -> crate::model::DeviceStats {
            crate::model::DeviceStats {
                connected_device_count: self.connected_device_count.unwrap_or_default(),
                registered_device_count: self.registered_device_count.unwrap_or_default(),
            }
        }
    }
}
impl DeviceStats {
    /// Creates a new builder-style object to manufacture [`DeviceStats`](crate::model::DeviceStats)
    pub fn builder() -> crate::model::device_stats::Builder {
        crate::model::device_stats::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProfilingStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProfilingStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ProfilingStatus::Disabled,
            "Enabled" => ProfilingStatus::Enabled,
            other => ProfilingStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProfilingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProfilingStatus::from(s))
    }
}
impl ProfilingStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProfilingStatus::Disabled => "Disabled",
            ProfilingStatus::Enabled => "Enabled",
            ProfilingStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ProfilingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the status of the rule evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub rule_evaluation_job_arn: std::option::Option<std::string::String>,
    /// <p>Status of the rule evaluation.</p>
    pub rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
    /// <p>Details from the rule evaluation.</p>
    pub status_details: std::option::Option<std::string::String>,
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ProfilerRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub fn rule_configuration_name(&self) -> std::option::Option<&str> {
        self.rule_configuration_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub fn rule_evaluation_job_arn(&self) -> std::option::Option<&str> {
        self.rule_evaluation_job_arn.as_deref()
    }
    /// <p>Status of the rule evaluation.</p>
    pub fn rule_evaluation_status(
        &self,
    ) -> std::option::Option<&crate::model::RuleEvaluationStatus> {
        self.rule_evaluation_status.as_ref()
    }
    /// <p>Details from the rule evaluation.</p>
    pub fn status_details(&self) -> std::option::Option<&str> {
        self.status_details.as_deref()
    }
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for ProfilerRuleEvaluationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerRuleEvaluationStatus");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("rule_evaluation_job_arn", &self.rule_evaluation_job_arn);
        formatter.field("rule_evaluation_status", &self.rule_evaluation_status);
        formatter.field("status_details", &self.status_details);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
pub mod profiler_rule_evaluation_status {

    /// A builder for [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_job_arn: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the rule configuration.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the rule configuration.</p>
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn rule_evaluation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluation_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn set_rule_evaluation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluation_job_arn = input;
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn rule_evaluation_status(mut self, input: crate::model::RuleEvaluationStatus) -> Self {
            self.rule_evaluation_status = Some(input);
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn set_rule_evaluation_status(
            mut self,
            input: std::option::Option<crate::model::RuleEvaluationStatus>,
        ) -> Self {
            self.rule_evaluation_status = input;
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
        pub fn build(self) -> crate::model::ProfilerRuleEvaluationStatus {
            crate::model::ProfilerRuleEvaluationStatus {
                rule_configuration_name: self.rule_configuration_name,
                rule_evaluation_job_arn: self.rule_evaluation_job_arn,
                rule_evaluation_status: self.rule_evaluation_status,
                status_details: self.status_details,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ProfilerRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
    pub fn builder() -> crate::model::profiler_rule_evaluation_status::Builder {
        crate::model::profiler_rule_evaluation_status::Builder::default()
    }
}

/// <p>Configuration information for Debugger system monitoring, framework profiling, and storage paths.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerConfig {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub profiling_interval_in_milliseconds: std::option::Option<i64>,
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub profiling_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ProfilerConfig {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub fn profiling_interval_in_milliseconds(&self) -> std::option::Option<i64> {
        self.profiling_interval_in_milliseconds
    }
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
    pub fn profiling_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.profiling_parameters.as_ref()
    }
}
impl std::fmt::Debug for ProfilerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field(
            "profiling_interval_in_milliseconds",
            &self.profiling_interval_in_milliseconds,
        );
        formatter.field("profiling_parameters", &self.profiling_parameters);
        formatter.finish()
    }
}
/// See [`ProfilerConfig`](crate::model::ProfilerConfig)
pub mod profiler_config {

    /// A builder for [`ProfilerConfig`](crate::model::ProfilerConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) profiling_interval_in_milliseconds: std::option::Option<i64>,
        pub(crate) profiling_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn profiling_interval_in_milliseconds(mut self, input: i64) -> Self {
            self.profiling_interval_in_milliseconds = Some(input);
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn set_profiling_interval_in_milliseconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.profiling_interval_in_milliseconds = input;
            self
        }
        /// Adds a key-value pair to `profiling_parameters`.
        ///
        /// To override the contents of this collection use [`set_profiling_parameters`](Self::set_profiling_parameters).
        ///
        /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn profiling_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.profiling_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.profiling_parameters = Some(hash_map);
            self
        }
        /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>. The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about how to configure the <code>ProfilingParameters</code> parameter, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>. </p>
        pub fn set_profiling_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.profiling_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerConfig`](crate::model::ProfilerConfig)
        pub fn build(self) -> crate::model::ProfilerConfig {
            crate::model::ProfilerConfig {
                s3_output_path: self.s3_output_path,
                profiling_interval_in_milliseconds: self.profiling_interval_in_milliseconds,
                profiling_parameters: self.profiling_parameters,
            }
        }
    }
}
impl ProfilerConfig {
    /// Creates a new builder-style object to manufacture [`ProfilerConfig`](crate::model::ProfilerConfig)
    pub fn builder() -> crate::model::profiler_config::Builder {
        crate::model::profiler_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DirectInternetAccess {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DirectInternetAccess {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => DirectInternetAccess::Disabled,
            "Enabled" => DirectInternetAccess::Enabled,
            other => DirectInternetAccess::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DirectInternetAccess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DirectInternetAccess::from(s))
    }
}
impl DirectInternetAccess {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DirectInternetAccess::Disabled => "Disabled",
            DirectInternetAccess::Enabled => "Enabled",
            DirectInternetAccess::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for DirectInternetAccess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The networking configuration for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringNetworkConfig {
    /// <p>Whether to encrypt all communications between the instances used for the monitoring jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.</p>
    pub enable_network_isolation: bool,
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl MonitoringNetworkConfig {
    /// <p>Whether to encrypt all communications between the instances used for the monitoring jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.</p>
    pub fn enable_inter_container_traffic_encryption(&self) -> bool {
        self.enable_inter_container_traffic_encryption
    }
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.</p>
    pub fn enable_network_isolation(&self) -> bool {
        self.enable_network_isolation
    }
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
impl std::fmt::Debug for MonitoringNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringNetworkConfig");
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
pub mod monitoring_network_config {

    /// A builder for [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>Whether to encrypt all communications between the instances used for the monitoring jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        /// <p>Whether to encrypt all communications between the instances used for the monitoring jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.</p>
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.</p>
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
        pub fn build(self) -> crate::model::MonitoringNetworkConfig {
            crate::model::MonitoringNetworkConfig {
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl MonitoringNetworkConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
    pub fn builder() -> crate::model::monitoring_network_config::Builder {
        crate::model::monitoring_network_config::Builder::default()
    }
}

/// <p>The input for the model quality monitoring job. Currently endponts are supported for input for model quality monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
    /// <p>The ground truth label provided for the model.</p>
    pub ground_truth_s3_input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
}
impl ModelQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub fn endpoint_input(&self) -> std::option::Option<&crate::model::EndpointInput> {
        self.endpoint_input.as_ref()
    }
    /// <p>The ground truth label provided for the model.</p>
    pub fn ground_truth_s3_input(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringGroundTruthS3Input> {
        self.ground_truth_s3_input.as_ref()
    }
}
impl std::fmt::Debug for ModelQualityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.field("ground_truth_s3_input", &self.ground_truth_s3_input);
        formatter.finish()
    }
}
/// See [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
pub mod model_quality_job_input {

    /// A builder for [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
        pub(crate) ground_truth_s3_input:
            std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        /// <p>Input object for the endpoint</p>
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// <p>The ground truth label provided for the model.</p>
        pub fn ground_truth_s3_input(
            mut self,
            input: crate::model::MonitoringGroundTruthS3Input,
        ) -> Self {
            self.ground_truth_s3_input = Some(input);
            self
        }
        /// <p>The ground truth label provided for the model.</p>
        pub fn set_ground_truth_s3_input(
            mut self,
            input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
        ) -> Self {
            self.ground_truth_s3_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
        pub fn build(self) -> crate::model::ModelQualityJobInput {
            crate::model::ModelQualityJobInput {
                endpoint_input: self.endpoint_input,
                ground_truth_s3_input: self.ground_truth_s3_input,
            }
        }
    }
}
impl ModelQualityJobInput {
    /// Creates a new builder-style object to manufacture [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
    pub fn builder() -> crate::model::model_quality_job_input::Builder {
        crate::model::model_quality_job_input::Builder::default()
    }
}

/// <p>The ground truth labels for the dataset used for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringGroundTruthS3Input {
    /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl MonitoringGroundTruthS3Input {
    /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for MonitoringGroundTruthS3Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringGroundTruthS3Input");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
pub mod monitoring_ground_truth_s3_input {

    /// A builder for [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
        pub fn build(self) -> crate::model::MonitoringGroundTruthS3Input {
            crate::model::MonitoringGroundTruthS3Input {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringGroundTruthS3Input {
    /// Creates a new builder-style object to manufacture [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
    pub fn builder() -> crate::model::monitoring_ground_truth_s3_input::Builder {
        crate::model::monitoring_ground_truth_s3_input::Builder::default()
    }
}

/// <p>Container image configuration object for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityAppSpecification {
    /// <p>The address of the container image that the monitoring job runs.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the entrypoint for a container that the monitoring job runs.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
    pub problem_type: std::option::Option<crate::model::MonitoringProblemType>,
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ModelQualityAppSpecification {
    /// <p>The address of the container image that the monitoring job runs.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>Specifies the entrypoint for a container that the monitoring job runs.</p>
    pub fn container_entrypoint(&self) -> std::option::Option<&[std::string::String]> {
        self.container_entrypoint.as_deref()
    }
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub fn container_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.container_arguments.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub fn record_preprocessor_source_uri(&self) -> std::option::Option<&str> {
        self.record_preprocessor_source_uri.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub fn post_analytics_processor_source_uri(&self) -> std::option::Option<&str> {
        self.post_analytics_processor_source_uri.as_deref()
    }
    /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
    pub fn problem_type(&self) -> std::option::Option<&crate::model::MonitoringProblemType> {
        self.problem_type.as_ref()
    }
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
}
impl std::fmt::Debug for ModelQualityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.field("problem_type", &self.problem_type);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
pub mod model_quality_app_specification {

    /// A builder for [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
        pub(crate) problem_type: std::option::Option<crate::model::MonitoringProblemType>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The address of the container image that the monitoring job runs.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The address of the container image that the monitoring job runs.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Appends an item to `container_entrypoint`.
        ///
        /// To override the contents of this collection use [`set_container_entrypoint`](Self::set_container_entrypoint).
        ///
        /// <p>Specifies the entrypoint for a container that the monitoring job runs.</p>
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        /// <p>Specifies the entrypoint for a container that the monitoring job runs.</p>
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        /// Appends an item to `container_arguments`.
        ///
        /// To override the contents of this collection use [`set_container_arguments`](Self::set_container_arguments).
        ///
        /// <p>An array of arguments for the container used to run the monitoring job.</p>
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        /// <p>An array of arguments for the container used to run the monitoring job.</p>
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
        pub fn problem_type(mut self, input: crate::model::MonitoringProblemType) -> Self {
            self.problem_type = Some(input);
            self
        }
        /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
        pub fn set_problem_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringProblemType>,
        ) -> Self {
            self.problem_type = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
        pub fn build(self) -> crate::model::ModelQualityAppSpecification {
            crate::model::ModelQualityAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
                problem_type: self.problem_type,
                environment: self.environment,
            }
        }
    }
}
impl ModelQualityAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
    pub fn builder() -> crate::model::model_quality_app_specification::Builder {
        crate::model::model_quality_app_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringProblemType {
    #[allow(missing_docs)] // documentation missing in model
    BinaryClassification,
    #[allow(missing_docs)] // documentation missing in model
    MulticlassClassification,
    #[allow(missing_docs)] // documentation missing in model
    Regression,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringProblemType {
    fn from(s: &str) -> Self {
        match s {
            "BinaryClassification" => MonitoringProblemType::BinaryClassification,
            "MulticlassClassification" => MonitoringProblemType::MulticlassClassification,
            "Regression" => MonitoringProblemType::Regression,
            other => MonitoringProblemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringProblemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringProblemType::from(s))
    }
}
impl MonitoringProblemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringProblemType::BinaryClassification => "BinaryClassification",
            MonitoringProblemType::MulticlassClassification => "MulticlassClassification",
            MonitoringProblemType::Regression => "Regression",
            MonitoringProblemType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BinaryClassification",
            "MulticlassClassification",
            "Regression",
        ]
    }
}
impl AsRef<str> for MonitoringProblemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl ModelQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub fn baselining_job_name(&self) -> std::option::Option<&str> {
        self.baselining_job_name.as_deref()
    }
    /// <p>The constraints resource for a monitoring job.</p>
    pub fn constraints_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConstraintsResource> {
        self.constraints_resource.as_ref()
    }
}
impl std::fmt::Debug for ModelQualityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
pub mod model_quality_baseline_config {

    /// A builder for [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
        pub fn build(self) -> crate::model::ModelQualityBaselineConfig {
            crate::model::ModelQualityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelQualityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
    pub fn builder() -> crate::model::model_quality_baseline_config::Builder {
        crate::model::model_quality_baseline_config::Builder::default()
    }
}

/// <p>Inputs for the model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl ModelExplainabilityJobInput {
    /// <p>Input object for the endpoint</p>
    pub fn endpoint_input(&self) -> std::option::Option<&crate::model::EndpointInput> {
        self.endpoint_input.as_ref()
    }
}
impl std::fmt::Debug for ModelExplainabilityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
pub mod model_explainability_job_input {

    /// A builder for [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        /// <p>Input object for the endpoint</p>
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
        pub fn build(self) -> crate::model::ModelExplainabilityJobInput {
            crate::model::ModelExplainabilityJobInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl ModelExplainabilityJobInput {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
    pub fn builder() -> crate::model::model_explainability_job_input::Builder {
        crate::model::model_explainability_job_input::Builder::default()
    }
}

/// <p>Docker container image configuration object for the model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityAppSpecification {
    /// <p>The container image to be run by the model explainability job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>JSON formatted S3 file that defines explainability parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model explainability parameters</a>.</p>
    pub config_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ModelExplainabilityAppSpecification {
    /// <p>The container image to be run by the model explainability job.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>JSON formatted S3 file that defines explainability parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model explainability parameters</a>.</p>
    pub fn config_uri(&self) -> std::option::Option<&str> {
        self.config_uri.as_deref()
    }
    /// <p>Sets the environment variables in the Docker container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
}
impl std::fmt::Debug for ModelExplainabilityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("config_uri", &self.config_uri);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
pub mod model_explainability_app_specification {

    /// A builder for [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) config_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image to be run by the model explainability job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The container image to be run by the model explainability job.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>JSON formatted S3 file that defines explainability parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model explainability parameters</a>.</p>
        pub fn config_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_uri = Some(input.into());
            self
        }
        /// <p>JSON formatted S3 file that defines explainability parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model explainability parameters</a>.</p>
        pub fn set_config_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_uri = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
        pub fn build(self) -> crate::model::ModelExplainabilityAppSpecification {
            crate::model::ModelExplainabilityAppSpecification {
                image_uri: self.image_uri,
                config_uri: self.config_uri,
                environment: self.environment,
            }
        }
    }
}
impl ModelExplainabilityAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
    pub fn builder() -> crate::model::model_explainability_app_specification::Builder {
        crate::model::model_explainability_app_specification::Builder::default()
    }
}

/// <p>The configuration for a baseline model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityBaselineConfig {
    /// <p>The name of the baseline model explainability job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl ModelExplainabilityBaselineConfig {
    /// <p>The name of the baseline model explainability job.</p>
    pub fn baselining_job_name(&self) -> std::option::Option<&str> {
        self.baselining_job_name.as_deref()
    }
    /// <p>The constraints resource for a monitoring job.</p>
    pub fn constraints_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConstraintsResource> {
        self.constraints_resource.as_ref()
    }
}
impl std::fmt::Debug for ModelExplainabilityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
pub mod model_explainability_baseline_config {

    /// A builder for [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the baseline model explainability job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        /// <p>The name of the baseline model explainability job.</p>
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
        pub fn build(self) -> crate::model::ModelExplainabilityBaselineConfig {
            crate::model::ModelExplainabilityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelExplainabilityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
    pub fn builder() -> crate::model::model_explainability_baseline_config::Builder {
        crate::model::model_explainability_baseline_config::Builder::default()
    }
}

/// <p>Inputs for the model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
    /// <p>Location of ground truth labels to use in model bias job.</p>
    pub ground_truth_s3_input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
}
impl ModelBiasJobInput {
    /// <p>Input object for the endpoint</p>
    pub fn endpoint_input(&self) -> std::option::Option<&crate::model::EndpointInput> {
        self.endpoint_input.as_ref()
    }
    /// <p>Location of ground truth labels to use in model bias job.</p>
    pub fn ground_truth_s3_input(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringGroundTruthS3Input> {
        self.ground_truth_s3_input.as_ref()
    }
}
impl std::fmt::Debug for ModelBiasJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.field("ground_truth_s3_input", &self.ground_truth_s3_input);
        formatter.finish()
    }
}
/// See [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
pub mod model_bias_job_input {

    /// A builder for [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
        pub(crate) ground_truth_s3_input:
            std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        /// <p>Input object for the endpoint</p>
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// <p>Location of ground truth labels to use in model bias job.</p>
        pub fn ground_truth_s3_input(
            mut self,
            input: crate::model::MonitoringGroundTruthS3Input,
        ) -> Self {
            self.ground_truth_s3_input = Some(input);
            self
        }
        /// <p>Location of ground truth labels to use in model bias job.</p>
        pub fn set_ground_truth_s3_input(
            mut self,
            input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
        ) -> Self {
            self.ground_truth_s3_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
        pub fn build(self) -> crate::model::ModelBiasJobInput {
            crate::model::ModelBiasJobInput {
                endpoint_input: self.endpoint_input,
                ground_truth_s3_input: self.ground_truth_s3_input,
            }
        }
    }
}
impl ModelBiasJobInput {
    /// Creates a new builder-style object to manufacture [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
    pub fn builder() -> crate::model::model_bias_job_input::Builder {
        crate::model::model_bias_job_input::Builder::default()
    }
}

/// <p>Docker container image configuration object for the model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasAppSpecification {
    /// <p>The container image to be run by the model bias job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias parameters</a>.</p>
    pub config_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ModelBiasAppSpecification {
    /// <p>The container image to be run by the model bias job.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias parameters</a>.</p>
    pub fn config_uri(&self) -> std::option::Option<&str> {
        self.config_uri.as_deref()
    }
    /// <p>Sets the environment variables in the Docker container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
}
impl std::fmt::Debug for ModelBiasAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("config_uri", &self.config_uri);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
pub mod model_bias_app_specification {

    /// A builder for [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) config_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image to be run by the model bias job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The container image to be run by the model bias job.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias parameters</a>.</p>
        pub fn config_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_uri = Some(input.into());
            self
        }
        /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias parameters</a>.</p>
        pub fn set_config_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_uri = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the Docker container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
        pub fn build(self) -> crate::model::ModelBiasAppSpecification {
            crate::model::ModelBiasAppSpecification {
                image_uri: self.image_uri,
                config_uri: self.config_uri,
                environment: self.environment,
            }
        }
    }
}
impl ModelBiasAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
    pub fn builder() -> crate::model::model_bias_app_specification::Builder {
        crate::model::model_bias_app_specification::Builder::default()
    }
}

/// <p>The configuration for a baseline model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasBaselineConfig {
    /// <p>The name of the baseline model bias job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl ModelBiasBaselineConfig {
    /// <p>The name of the baseline model bias job.</p>
    pub fn baselining_job_name(&self) -> std::option::Option<&str> {
        self.baselining_job_name.as_deref()
    }
    /// <p>The constraints resource for a monitoring job.</p>
    pub fn constraints_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConstraintsResource> {
        self.constraints_resource.as_ref()
    }
}
impl std::fmt::Debug for ModelBiasBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
pub mod model_bias_baseline_config {

    /// A builder for [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the baseline model bias job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        /// <p>The name of the baseline model bias job.</p>
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
        pub fn build(self) -> crate::model::ModelBiasBaselineConfig {
            crate::model::ModelBiasBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelBiasBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
    pub fn builder() -> crate::model::model_bias_baseline_config::Builder {
        crate::model::model_bias_baseline_config::Builder::default()
    }
}

/// <p>Specifies details about how containers in a multi-container endpoint are run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceExecutionConfig {
    /// <p>How containers in a multi-container are run. The following values are valid.</p>
    /// <ul>
    /// <li> <p> <code>SERIAL</code> - Containers run as a serial pipeline.</p> </li>
    /// <li> <p> <code>DIRECT</code> - Only the individual container that you specify is run.</p> </li>
    /// </ul>
    pub mode: std::option::Option<crate::model::InferenceExecutionMode>,
}
impl InferenceExecutionConfig {
    /// <p>How containers in a multi-container are run. The following values are valid.</p>
    /// <ul>
    /// <li> <p> <code>SERIAL</code> - Containers run as a serial pipeline.</p> </li>
    /// <li> <p> <code>DIRECT</code> - Only the individual container that you specify is run.</p> </li>
    /// </ul>
    pub fn mode(&self) -> std::option::Option<&crate::model::InferenceExecutionMode> {
        self.mode.as_ref()
    }
}
impl std::fmt::Debug for InferenceExecutionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceExecutionConfig");
        formatter.field("mode", &self.mode);
        formatter.finish()
    }
}
/// See [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
pub mod inference_execution_config {

    /// A builder for [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::InferenceExecutionMode>,
    }
    impl Builder {
        /// <p>How containers in a multi-container are run. The following values are valid.</p>
        /// <ul>
        /// <li> <p> <code>SERIAL</code> - Containers run as a serial pipeline.</p> </li>
        /// <li> <p> <code>DIRECT</code> - Only the individual container that you specify is run.</p> </li>
        /// </ul>
        pub fn mode(mut self, input: crate::model::InferenceExecutionMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>How containers in a multi-container are run. The following values are valid.</p>
        /// <ul>
        /// <li> <p> <code>SERIAL</code> - Containers run as a serial pipeline.</p> </li>
        /// <li> <p> <code>DIRECT</code> - Only the individual container that you specify is run.</p> </li>
        /// </ul>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::InferenceExecutionMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
        pub fn build(self) -> crate::model::InferenceExecutionConfig {
            crate::model::InferenceExecutionConfig { mode: self.mode }
        }
    }
}
impl InferenceExecutionConfig {
    /// Creates a new builder-style object to manufacture [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
    pub fn builder() -> crate::model::inference_execution_config::Builder {
        crate::model::inference_execution_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InferenceExecutionMode {
    #[allow(missing_docs)] // documentation missing in model
    Direct,
    #[allow(missing_docs)] // documentation missing in model
    Serial,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InferenceExecutionMode {
    fn from(s: &str) -> Self {
        match s {
            "Direct" => InferenceExecutionMode::Direct,
            "Serial" => InferenceExecutionMode::Serial,
            other => InferenceExecutionMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InferenceExecutionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InferenceExecutionMode::from(s))
    }
}
impl InferenceExecutionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InferenceExecutionMode::Direct => "Direct",
            InferenceExecutionMode::Serial => "Serial",
            InferenceExecutionMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Direct", "Serial"]
    }
}
impl AsRef<str> for InferenceExecutionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the container, as part of model definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainerDefinition {
    /// <p>This parameter is ignored for models that contain only a <code>PrimaryContainer</code>.</p>
    /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics to Monitor an Inference Pipeline</a>. If you don't specify a value for this parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline, a unique name is automatically assigned based on the position of the <code>ContainerDefinition</code> in the pipeline. If you specify a value for the <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part of an inference pipeline, you must specify a value for the <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code> in that pipeline.</p>
    pub container_hostname: std::option::Option<std::string::String>,
    /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a Docker registry that is accessible from the same VPC that you configure for your endpoint. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a> </p>
    pub image: std::option::Option<std::string::String>,
    /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a Private Docker Registry for Real-Time Inference Containers</a> </p>
    pub image_config: std::option::Option<crate::model::ImageConfig>,
    /// <p>Whether the container hosts a single model or multiple models.</p>
    pub mode: std::option::Option<crate::model::ContainerMode>,
    /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for SageMaker built-in algorithms, but not if you use your own algorithms. For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common Parameters</a>. </p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model or endpoint you are creating.</p>
    /// </note>
    /// <p>If you provide a value for this parameter, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User Guide</i>.</p> <important>
    /// <p>If you use a built-in algorithm to create a model, SageMaker requires that you provide a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
    /// </important>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map. </p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the model.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>The inference specification name in the model package version.</p>
    pub inference_specification_name: std::option::Option<std::string::String>,
    /// <p>Specifies additional configuration for multi-model endpoints.</p>
    pub multi_model_config: std::option::Option<crate::model::MultiModelConfig>,
}
impl ContainerDefinition {
    /// <p>This parameter is ignored for models that contain only a <code>PrimaryContainer</code>.</p>
    /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics to Monitor an Inference Pipeline</a>. If you don't specify a value for this parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline, a unique name is automatically assigned based on the position of the <code>ContainerDefinition</code> in the pipeline. If you specify a value for the <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part of an inference pipeline, you must specify a value for the <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code> in that pipeline.</p>
    pub fn container_hostname(&self) -> std::option::Option<&str> {
        self.container_hostname.as_deref()
    }
    /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a Docker registry that is accessible from the same VPC that you configure for your endpoint. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a> </p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a Private Docker Registry for Real-Time Inference Containers</a> </p>
    pub fn image_config(&self) -> std::option::Option<&crate::model::ImageConfig> {
        self.image_config.as_ref()
    }
    /// <p>Whether the container hosts a single model or multiple models.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::ContainerMode> {
        self.mode.as_ref()
    }
    /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for SageMaker built-in algorithms, but not if you use your own algorithms. For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common Parameters</a>. </p> <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model or endpoint you are creating.</p>
    /// </note>
    /// <p>If you provide a value for this parameter, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User Guide</i>.</p> <important>
    /// <p>If you use a built-in algorithm to create a model, SageMaker requires that you provide a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
    /// </important>
    pub fn model_data_url(&self) -> std::option::Option<&str> {
        self.model_data_url.as_deref()
    }
    /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map. </p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the model.</p>
    pub fn model_package_name(&self) -> std::option::Option<&str> {
        self.model_package_name.as_deref()
    }
    /// <p>The inference specification name in the model package version.</p>
    pub fn inference_specification_name(&self) -> std::option::Option<&str> {
        self.inference_specification_name.as_deref()
    }
    /// <p>Specifies additional configuration for multi-model endpoints.</p>
    pub fn multi_model_config(&self) -> std::option::Option<&crate::model::MultiModelConfig> {
        self.multi_model_config.as_ref()
    }
}
impl std::fmt::Debug for ContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainerDefinition");
        formatter.field("container_hostname", &self.container_hostname);
        formatter.field("image", &self.image);
        formatter.field("image_config", &self.image_config);
        formatter.field("mode", &self.mode);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("environment", &self.environment);
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field(
            "inference_specification_name",
            &self.inference_specification_name,
        );
        formatter.field("multi_model_config", &self.multi_model_config);
        formatter.finish()
    }
}
/// See [`ContainerDefinition`](crate::model::ContainerDefinition)
pub mod container_definition {

    /// A builder for [`ContainerDefinition`](crate::model::ContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_hostname: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) image_config: std::option::Option<crate::model::ImageConfig>,
        pub(crate) mode: std::option::Option<crate::model::ContainerMode>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) inference_specification_name: std::option::Option<std::string::String>,
        pub(crate) multi_model_config: std::option::Option<crate::model::MultiModelConfig>,
    }
    impl Builder {
        /// <p>This parameter is ignored for models that contain only a <code>PrimaryContainer</code>.</p>
        /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics to Monitor an Inference Pipeline</a>. If you don't specify a value for this parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline, a unique name is automatically assigned based on the position of the <code>ContainerDefinition</code> in the pipeline. If you specify a value for the <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part of an inference pipeline, you must specify a value for the <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code> in that pipeline.</p>
        pub fn container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_hostname = Some(input.into());
            self
        }
        /// <p>This parameter is ignored for models that contain only a <code>PrimaryContainer</code>.</p>
        /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics to Monitor an Inference Pipeline</a>. If you don't specify a value for this parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline, a unique name is automatically assigned based on the position of the <code>ContainerDefinition</code> in the pipeline. If you specify a value for the <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part of an inference pipeline, you must specify a value for the <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code> in that pipeline.</p>
        pub fn set_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_hostname = input;
            self
        }
        /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a Docker registry that is accessible from the same VPC that you configure for your endpoint. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a> </p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a Docker registry that is accessible from the same VPC that you configure for your endpoint. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a> </p>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a Private Docker Registry for Real-Time Inference Containers</a> </p>
        pub fn image_config(mut self, input: crate::model::ImageConfig) -> Self {
            self.image_config = Some(input);
            self
        }
        /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a Private Docker Registry for Real-Time Inference Containers</a> </p>
        pub fn set_image_config(
            mut self,
            input: std::option::Option<crate::model::ImageConfig>,
        ) -> Self {
            self.image_config = input;
            self
        }
        /// <p>Whether the container hosts a single model or multiple models.</p>
        pub fn mode(mut self, input: crate::model::ContainerMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Whether the container hosts a single model or multiple models.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ContainerMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for SageMaker built-in algorithms, but not if you use your own algorithms. For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common Parameters</a>. </p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model or endpoint you are creating.</p>
        /// </note>
        /// <p>If you provide a value for this parameter, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User Guide</i>.</p> <important>
        /// <p>If you use a built-in algorithm to create a model, SageMaker requires that you provide a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
        /// </important>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for SageMaker built-in algorithms, but not if you use your own algorithms. For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common Parameters</a>. </p> <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the model or endpoint you are creating.</p>
        /// </note>
        /// <p>If you provide a value for this parameter, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User Guide</i>.</p> <important>
        /// <p>If you use a built-in algorithm to create a model, SageMaker requires that you provide a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
        /// </important>
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map. </p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>The environment variables to set in the Docker container. Each key and value in the <code>Environment</code> string to string map can have length of up to 1024. We support up to 16 entries in the map. </p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the model.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the model.</p>
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>The inference specification name in the model package version.</p>
        pub fn inference_specification_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inference_specification_name = Some(input.into());
            self
        }
        /// <p>The inference specification name in the model package version.</p>
        pub fn set_inference_specification_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inference_specification_name = input;
            self
        }
        /// <p>Specifies additional configuration for multi-model endpoints.</p>
        pub fn multi_model_config(mut self, input: crate::model::MultiModelConfig) -> Self {
            self.multi_model_config = Some(input);
            self
        }
        /// <p>Specifies additional configuration for multi-model endpoints.</p>
        pub fn set_multi_model_config(
            mut self,
            input: std::option::Option<crate::model::MultiModelConfig>,
        ) -> Self {
            self.multi_model_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainerDefinition`](crate::model::ContainerDefinition)
        pub fn build(self) -> crate::model::ContainerDefinition {
            crate::model::ContainerDefinition {
                container_hostname: self.container_hostname,
                image: self.image,
                image_config: self.image_config,
                mode: self.mode,
                model_data_url: self.model_data_url,
                environment: self.environment,
                model_package_name: self.model_package_name,
                inference_specification_name: self.inference_specification_name,
                multi_model_config: self.multi_model_config,
            }
        }
    }
}
impl ContainerDefinition {
    /// Creates a new builder-style object to manufacture [`ContainerDefinition`](crate::model::ContainerDefinition)
    pub fn builder() -> crate::model::container_definition::Builder {
        crate::model::container_definition::Builder::default()
    }
}

/// <p>Specifies additional configuration for hosting multi-model endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultiModelConfig {
    /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints cache models so that a model does not have to be loaded into memory each time it is invoked. Some use cases do not benefit from model caching. For example, if an endpoint hosts a large number of models that are each invoked infrequently, the endpoint might perform better if you disable model caching. To disable model caching, set the value of this parameter to <code>Disabled</code>.</p>
    pub model_cache_setting: std::option::Option<crate::model::ModelCacheSetting>,
}
impl MultiModelConfig {
    /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints cache models so that a model does not have to be loaded into memory each time it is invoked. Some use cases do not benefit from model caching. For example, if an endpoint hosts a large number of models that are each invoked infrequently, the endpoint might perform better if you disable model caching. To disable model caching, set the value of this parameter to <code>Disabled</code>.</p>
    pub fn model_cache_setting(&self) -> std::option::Option<&crate::model::ModelCacheSetting> {
        self.model_cache_setting.as_ref()
    }
}
impl std::fmt::Debug for MultiModelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultiModelConfig");
        formatter.field("model_cache_setting", &self.model_cache_setting);
        formatter.finish()
    }
}
/// See [`MultiModelConfig`](crate::model::MultiModelConfig)
pub mod multi_model_config {

    /// A builder for [`MultiModelConfig`](crate::model::MultiModelConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_cache_setting: std::option::Option<crate::model::ModelCacheSetting>,
    }
    impl Builder {
        /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints cache models so that a model does not have to be loaded into memory each time it is invoked. Some use cases do not benefit from model caching. For example, if an endpoint hosts a large number of models that are each invoked infrequently, the endpoint might perform better if you disable model caching. To disable model caching, set the value of this parameter to <code>Disabled</code>.</p>
        pub fn model_cache_setting(mut self, input: crate::model::ModelCacheSetting) -> Self {
            self.model_cache_setting = Some(input);
            self
        }
        /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints cache models so that a model does not have to be loaded into memory each time it is invoked. Some use cases do not benefit from model caching. For example, if an endpoint hosts a large number of models that are each invoked infrequently, the endpoint might perform better if you disable model caching. To disable model caching, set the value of this parameter to <code>Disabled</code>.</p>
        pub fn set_model_cache_setting(
            mut self,
            input: std::option::Option<crate::model::ModelCacheSetting>,
        ) -> Self {
            self.model_cache_setting = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiModelConfig`](crate::model::MultiModelConfig)
        pub fn build(self) -> crate::model::MultiModelConfig {
            crate::model::MultiModelConfig {
                model_cache_setting: self.model_cache_setting,
            }
        }
    }
}
impl MultiModelConfig {
    /// Creates a new builder-style object to manufacture [`MultiModelConfig`](crate::model::MultiModelConfig)
    pub fn builder() -> crate::model::multi_model_config::Builder {
        crate::model::multi_model_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelCacheSetting {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelCacheSetting {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ModelCacheSetting::Disabled,
            "Enabled" => ModelCacheSetting::Enabled,
            other => ModelCacheSetting::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelCacheSetting {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelCacheSetting::from(s))
    }
}
impl ModelCacheSetting {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelCacheSetting::Disabled => "Disabled",
            ModelCacheSetting::Enabled => "Enabled",
            ModelCacheSetting::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ModelCacheSetting {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContainerMode {
    #[allow(missing_docs)] // documentation missing in model
    MultiModel,
    #[allow(missing_docs)] // documentation missing in model
    SingleModel,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContainerMode {
    fn from(s: &str) -> Self {
        match s {
            "MultiModel" => ContainerMode::MultiModel,
            "SingleModel" => ContainerMode::SingleModel,
            other => ContainerMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContainerMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContainerMode::from(s))
    }
}
impl ContainerMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContainerMode::MultiModel => "MultiModel",
            ContainerMode::SingleModel => "SingleModel",
            ContainerMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["MultiModel", "SingleModel"]
    }
}
impl AsRef<str> for ContainerMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageConfig {
    /// <p>Set this to one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>Platform</code> - The model image is hosted in Amazon ECR.</p> </li>
    /// <li> <p> <code>Vpc</code> - The model image is hosted in a private Docker registry in your VPC.</p> </li>
    /// </ul>
    pub repository_access_mode: std::option::Option<crate::model::RepositoryAccessMode>,
    /// <p>(Optional) Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field, and the private Docker registry where the model image is hosted requires authentication.</p>
    pub repository_auth_config: std::option::Option<crate::model::RepositoryAuthConfig>,
}
impl ImageConfig {
    /// <p>Set this to one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>Platform</code> - The model image is hosted in Amazon ECR.</p> </li>
    /// <li> <p> <code>Vpc</code> - The model image is hosted in a private Docker registry in your VPC.</p> </li>
    /// </ul>
    pub fn repository_access_mode(
        &self,
    ) -> std::option::Option<&crate::model::RepositoryAccessMode> {
        self.repository_access_mode.as_ref()
    }
    /// <p>(Optional) Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field, and the private Docker registry where the model image is hosted requires authentication.</p>
    pub fn repository_auth_config(
        &self,
    ) -> std::option::Option<&crate::model::RepositoryAuthConfig> {
        self.repository_auth_config.as_ref()
    }
}
impl std::fmt::Debug for ImageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageConfig");
        formatter.field("repository_access_mode", &self.repository_access_mode);
        formatter.field("repository_auth_config", &self.repository_auth_config);
        formatter.finish()
    }
}
/// See [`ImageConfig`](crate::model::ImageConfig)
pub mod image_config {

    /// A builder for [`ImageConfig`](crate::model::ImageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_access_mode: std::option::Option<crate::model::RepositoryAccessMode>,
        pub(crate) repository_auth_config: std::option::Option<crate::model::RepositoryAuthConfig>,
    }
    impl Builder {
        /// <p>Set this to one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>Platform</code> - The model image is hosted in Amazon ECR.</p> </li>
        /// <li> <p> <code>Vpc</code> - The model image is hosted in a private Docker registry in your VPC.</p> </li>
        /// </ul>
        pub fn repository_access_mode(mut self, input: crate::model::RepositoryAccessMode) -> Self {
            self.repository_access_mode = Some(input);
            self
        }
        /// <p>Set this to one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>Platform</code> - The model image is hosted in Amazon ECR.</p> </li>
        /// <li> <p> <code>Vpc</code> - The model image is hosted in a private Docker registry in your VPC.</p> </li>
        /// </ul>
        pub fn set_repository_access_mode(
            mut self,
            input: std::option::Option<crate::model::RepositoryAccessMode>,
        ) -> Self {
            self.repository_access_mode = input;
            self
        }
        /// <p>(Optional) Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field, and the private Docker registry where the model image is hosted requires authentication.</p>
        pub fn repository_auth_config(mut self, input: crate::model::RepositoryAuthConfig) -> Self {
            self.repository_auth_config = Some(input);
            self
        }
        /// <p>(Optional) Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field, and the private Docker registry where the model image is hosted requires authentication.</p>
        pub fn set_repository_auth_config(
            mut self,
            input: std::option::Option<crate::model::RepositoryAuthConfig>,
        ) -> Self {
            self.repository_auth_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfig`](crate::model::ImageConfig)
        pub fn build(self) -> crate::model::ImageConfig {
            crate::model::ImageConfig {
                repository_access_mode: self.repository_access_mode,
                repository_auth_config: self.repository_auth_config,
            }
        }
    }
}
impl ImageConfig {
    /// Creates a new builder-style object to manufacture [`ImageConfig`](crate::model::ImageConfig)
    pub fn builder() -> crate::model::image_config::Builder {
        crate::model::image_config::Builder::default()
    }
}

/// <p>Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field of the <code>ImageConfig</code> object that you passed to a call to <code>CreateModel</code> and the private Docker registry where the model image is hosted requires authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryAuthConfig {
    /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function with the console</a> in the <i>Amazon Web Services Lambda Developer Guide</i>.</p>
    pub repository_credentials_provider_arn: std::option::Option<std::string::String>,
}
impl RepositoryAuthConfig {
    /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function with the console</a> in the <i>Amazon Web Services Lambda Developer Guide</i>.</p>
    pub fn repository_credentials_provider_arn(&self) -> std::option::Option<&str> {
        self.repository_credentials_provider_arn.as_deref()
    }
}
impl std::fmt::Debug for RepositoryAuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryAuthConfig");
        formatter.field(
            "repository_credentials_provider_arn",
            &self.repository_credentials_provider_arn,
        );
        formatter.finish()
    }
}
/// See [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
pub mod repository_auth_config {

    /// A builder for [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_credentials_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function with the console</a> in the <i>Amazon Web Services Lambda Developer Guide</i>.</p>
        pub fn repository_credentials_provider_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.repository_credentials_provider_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function with the console</a> in the <i>Amazon Web Services Lambda Developer Guide</i>.</p>
        pub fn set_repository_credentials_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_credentials_provider_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
        pub fn build(self) -> crate::model::RepositoryAuthConfig {
            crate::model::RepositoryAuthConfig {
                repository_credentials_provider_arn: self.repository_credentials_provider_arn,
            }
        }
    }
}
impl RepositoryAuthConfig {
    /// Creates a new builder-style object to manufacture [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
    pub fn builder() -> crate::model::repository_auth_config::Builder {
        crate::model::repository_auth_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RepositoryAccessMode {
    #[allow(missing_docs)] // documentation missing in model
    Platform,
    #[allow(missing_docs)] // documentation missing in model
    Vpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RepositoryAccessMode {
    fn from(s: &str) -> Self {
        match s {
            "Platform" => RepositoryAccessMode::Platform,
            "Vpc" => RepositoryAccessMode::Vpc,
            other => RepositoryAccessMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RepositoryAccessMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RepositoryAccessMode::from(s))
    }
}
impl RepositoryAccessMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RepositoryAccessMode::Platform => "Platform",
            RepositoryAccessMode::Vpc => "Vpc",
            RepositoryAccessMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Platform", "Vpc"]
    }
}
impl AsRef<str> for RepositoryAccessMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information required for human workers to complete a labeling task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanTaskConfig {
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>Information about the user interface that workers use to complete the labeling task.</p>
    pub ui_config: std::option::Option<crate::model::UiConfig>,
    /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job.</p>
    /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
    /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Modalities</b> </p>
    /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks. See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types </a> to learn more. </p>
    /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p> <b>Bounding box verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding box adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud object detection adjustment</b> - Adjust 3D cuboids in a point cloud frame. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud object tracking adjustment</b> - Adjust 3D cuboids across a sequence of point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud semantic segmentation adjustment</b> - Adjust semantic segmentation masks in a 3D point cloud. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    pub pre_human_task_lambda_arn: std::option::Option<std::string::String>,
    /// <p>Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.</p>
    pub task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A title for the task for your human workers.</p>
    pub task_title: std::option::Option<std::string::String>,
    /// <p>A description of the task for your human workers.</p>
    pub task_description: std::option::Option<std::string::String>,
    /// <p>The number of human workers that will label an object. </p>
    pub number_of_human_workers_per_data_object: std::option::Option<i32>,
    /// <p>The amount of time that a worker has to complete a task. </p>
    /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours (28,800 seconds).</p>
    /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum for this parameter depends on the task type you use:</p>
    /// <ul>
    /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs, the maximum is 8 hours (28,800 seconds).</p> </li>
    /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs, the maximum is 30 days (2952,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
    /// </ul>
    pub task_time_limit_in_seconds: std::option::Option<i32>,
    /// <p>The length of time that a task remains available for labeling by human workers. The default and maximum values for this parameter depend on the type of workforce you use.</p>
    /// <ul>
    /// <li> <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds). The default is 6 hours (21,600 seconds).</p> </li>
    /// <li> <p>If you choose a private or vendor workforce, the default value is 30 days (2592,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
    /// </ul>
    pub task_availability_lifetime_in_seconds: std::option::Option<i32>,
    /// <p>Defines the maximum number of data objects that can be labeled by human workers at the same time. Also referred to as batch size. Each object may have more than one worker at one time. The default value is 1000 objects.</p>
    pub max_concurrent_task_count: std::option::Option<i32>,
    /// <p>Configures how labels are consolidated across human workers.</p>
    pub annotation_consolidation_config:
        std::option::Option<crate::model::AnnotationConsolidationConfig>,
    /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
    pub public_workforce_task_price: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
}
impl HumanTaskConfig {
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
    pub fn workteam_arn(&self) -> std::option::Option<&str> {
        self.workteam_arn.as_deref()
    }
    /// <p>Information about the user interface that workers use to complete the labeling task.</p>
    pub fn ui_config(&self) -> std::option::Option<&crate::model::UiConfig> {
        self.ui_config.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job.</p>
    /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
    /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Modalities</b> </p>
    /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks. See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types </a> to learn more. </p>
    /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p> <b>Bounding box verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding box adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud object detection adjustment</b> - Adjust 3D cuboids in a point cloud frame. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud object tracking adjustment</b> - Adjust 3D cuboids across a sequence of point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D point cloud semantic segmentation adjustment</b> - Adjust semantic segmentation masks in a 3D point cloud. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    pub fn pre_human_task_lambda_arn(&self) -> std::option::Option<&str> {
        self.pre_human_task_lambda_arn.as_deref()
    }
    /// <p>Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.</p>
    pub fn task_keywords(&self) -> std::option::Option<&[std::string::String]> {
        self.task_keywords.as_deref()
    }
    /// <p>A title for the task for your human workers.</p>
    pub fn task_title(&self) -> std::option::Option<&str> {
        self.task_title.as_deref()
    }
    /// <p>A description of the task for your human workers.</p>
    pub fn task_description(&self) -> std::option::Option<&str> {
        self.task_description.as_deref()
    }
    /// <p>The number of human workers that will label an object. </p>
    pub fn number_of_human_workers_per_data_object(&self) -> std::option::Option<i32> {
        self.number_of_human_workers_per_data_object
    }
    /// <p>The amount of time that a worker has to complete a task. </p>
    /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours (28,800 seconds).</p>
    /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum for this parameter depends on the task type you use:</p>
    /// <ul>
    /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs, the maximum is 8 hours (28,800 seconds).</p> </li>
    /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs, the maximum is 30 days (2952,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
    /// </ul>
    pub fn task_time_limit_in_seconds(&self) -> std::option::Option<i32> {
        self.task_time_limit_in_seconds
    }
    /// <p>The length of time that a task remains available for labeling by human workers. The default and maximum values for this parameter depend on the type of workforce you use.</p>
    /// <ul>
    /// <li> <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds). The default is 6 hours (21,600 seconds).</p> </li>
    /// <li> <p>If you choose a private or vendor workforce, the default value is 30 days (2592,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
    /// </ul>
    pub fn task_availability_lifetime_in_seconds(&self) -> std::option::Option<i32> {
        self.task_availability_lifetime_in_seconds
    }
    /// <p>Defines the maximum number of data objects that can be labeled by human workers at the same time. Also referred to as batch size. Each object may have more than one worker at one time. The default value is 1000 objects.</p>
    pub fn max_concurrent_task_count(&self) -> std::option::Option<i32> {
        self.max_concurrent_task_count
    }
    /// <p>Configures how labels are consolidated across human workers.</p>
    pub fn annotation_consolidation_config(
        &self,
    ) -> std::option::Option<&crate::model::AnnotationConsolidationConfig> {
        self.annotation_consolidation_config.as_ref()
    }
    /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
    pub fn public_workforce_task_price(
        &self,
    ) -> std::option::Option<&crate::model::PublicWorkforceTaskPrice> {
        self.public_workforce_task_price.as_ref()
    }
}
impl std::fmt::Debug for HumanTaskConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanTaskConfig");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("ui_config", &self.ui_config);
        formatter.field("pre_human_task_lambda_arn", &self.pre_human_task_lambda_arn);
        formatter.field("task_keywords", &self.task_keywords);
        formatter.field("task_title", &self.task_title);
        formatter.field("task_description", &self.task_description);
        formatter.field(
            "number_of_human_workers_per_data_object",
            &self.number_of_human_workers_per_data_object,
        );
        formatter.field(
            "task_time_limit_in_seconds",
            &self.task_time_limit_in_seconds,
        );
        formatter.field(
            "task_availability_lifetime_in_seconds",
            &self.task_availability_lifetime_in_seconds,
        );
        formatter.field("max_concurrent_task_count", &self.max_concurrent_task_count);
        formatter.field(
            "annotation_consolidation_config",
            &self.annotation_consolidation_config,
        );
        formatter.field(
            "public_workforce_task_price",
            &self.public_workforce_task_price,
        );
        formatter.finish()
    }
}
/// See [`HumanTaskConfig`](crate::model::HumanTaskConfig)
pub mod human_task_config {

    /// A builder for [`HumanTaskConfig`](crate::model::HumanTaskConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) ui_config: std::option::Option<crate::model::UiConfig>,
        pub(crate) pre_human_task_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) task_title: std::option::Option<std::string::String>,
        pub(crate) task_description: std::option::Option<std::string::String>,
        pub(crate) number_of_human_workers_per_data_object: std::option::Option<i32>,
        pub(crate) task_time_limit_in_seconds: std::option::Option<i32>,
        pub(crate) task_availability_lifetime_in_seconds: std::option::Option<i32>,
        pub(crate) max_concurrent_task_count: std::option::Option<i32>,
        pub(crate) annotation_consolidation_config:
            std::option::Option<crate::model::AnnotationConsolidationConfig>,
        pub(crate) public_workforce_task_price:
            std::option::Option<crate::model::PublicWorkforceTaskPrice>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>Information about the user interface that workers use to complete the labeling task.</p>
        pub fn ui_config(mut self, input: crate::model::UiConfig) -> Self {
            self.ui_config = Some(input);
            self
        }
        /// <p>Information about the user interface that workers use to complete the labeling task.</p>
        pub fn set_ui_config(mut self, input: std::option::Option<crate::model::UiConfig>) -> Self {
            self.ui_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job.</p>
        /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
        /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Modalities</b> </p>
        /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks. See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types </a> to learn more. </p>
        /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p> <b>Bounding box verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding box adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud object detection adjustment</b> - Adjust 3D cuboids in a point cloud frame. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud object tracking adjustment</b> - Adjust 3D cuboids across a sequence of point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud semantic segmentation adjustment</b> - Adjust semantic segmentation masks in a 3D point cloud. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        pub fn pre_human_task_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_human_task_lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job.</p>
        /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
        /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Modalities</b> </p>
        /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks. See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types </a> to learn more. </p>
        /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p> <b>Bounding box verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding box adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud object detection adjustment</b> - Adjust 3D cuboids in a point cloud frame. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud object tracking adjustment</b> - Adjust 3D cuboids across a sequence of point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D point cloud semantic segmentation adjustment</b> - Adjust semantic segmentation masks in a 3D point cloud. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        pub fn set_pre_human_task_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_human_task_lambda_arn = input;
            self
        }
        /// Appends an item to `task_keywords`.
        ///
        /// To override the contents of this collection use [`set_task_keywords`](Self::set_task_keywords).
        ///
        /// <p>Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.</p>
        pub fn task_keywords(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.task_keywords.unwrap_or_default();
            v.push(input.into());
            self.task_keywords = Some(v);
            self
        }
        /// <p>Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.</p>
        pub fn set_task_keywords(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.task_keywords = input;
            self
        }
        /// <p>A title for the task for your human workers.</p>
        pub fn task_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_title = Some(input.into());
            self
        }
        /// <p>A title for the task for your human workers.</p>
        pub fn set_task_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_title = input;
            self
        }
        /// <p>A description of the task for your human workers.</p>
        pub fn task_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_description = Some(input.into());
            self
        }
        /// <p>A description of the task for your human workers.</p>
        pub fn set_task_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_description = input;
            self
        }
        /// <p>The number of human workers that will label an object. </p>
        pub fn number_of_human_workers_per_data_object(mut self, input: i32) -> Self {
            self.number_of_human_workers_per_data_object = Some(input);
            self
        }
        /// <p>The number of human workers that will label an object. </p>
        pub fn set_number_of_human_workers_per_data_object(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_human_workers_per_data_object = input;
            self
        }
        /// <p>The amount of time that a worker has to complete a task. </p>
        /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours (28,800 seconds).</p>
        /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum for this parameter depends on the task type you use:</p>
        /// <ul>
        /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs, the maximum is 8 hours (28,800 seconds).</p> </li>
        /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs, the maximum is 30 days (2952,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
        /// </ul>
        pub fn task_time_limit_in_seconds(mut self, input: i32) -> Self {
            self.task_time_limit_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time that a worker has to complete a task. </p>
        /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours (28,800 seconds).</p>
        /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum for this parameter depends on the task type you use:</p>
        /// <ul>
        /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs, the maximum is 8 hours (28,800 seconds).</p> </li>
        /// <li> <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs, the maximum is 30 days (2952,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
        /// </ul>
        pub fn set_task_time_limit_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.task_time_limit_in_seconds = input;
            self
        }
        /// <p>The length of time that a task remains available for labeling by human workers. The default and maximum values for this parameter depend on the type of workforce you use.</p>
        /// <ul>
        /// <li> <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds). The default is 6 hours (21,600 seconds).</p> </li>
        /// <li> <p>If you choose a private or vendor workforce, the default value is 30 days (2592,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
        /// </ul>
        pub fn task_availability_lifetime_in_seconds(mut self, input: i32) -> Self {
            self.task_availability_lifetime_in_seconds = Some(input);
            self
        }
        /// <p>The length of time that a task remains available for labeling by human workers. The default and maximum values for this parameter depend on the type of workforce you use.</p>
        /// <ul>
        /// <li> <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds). The default is 6 hours (21,600 seconds).</p> </li>
        /// <li> <p>If you choose a private or vendor workforce, the default value is 30 days (2592,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.</p> </li>
        /// </ul>
        pub fn set_task_availability_lifetime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.task_availability_lifetime_in_seconds = input;
            self
        }
        /// <p>Defines the maximum number of data objects that can be labeled by human workers at the same time. Also referred to as batch size. Each object may have more than one worker at one time. The default value is 1000 objects.</p>
        pub fn max_concurrent_task_count(mut self, input: i32) -> Self {
            self.max_concurrent_task_count = Some(input);
            self
        }
        /// <p>Defines the maximum number of data objects that can be labeled by human workers at the same time. Also referred to as batch size. Each object may have more than one worker at one time. The default value is 1000 objects.</p>
        pub fn set_max_concurrent_task_count(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_task_count = input;
            self
        }
        /// <p>Configures how labels are consolidated across human workers.</p>
        pub fn annotation_consolidation_config(
            mut self,
            input: crate::model::AnnotationConsolidationConfig,
        ) -> Self {
            self.annotation_consolidation_config = Some(input);
            self
        }
        /// <p>Configures how labels are consolidated across human workers.</p>
        pub fn set_annotation_consolidation_config(
            mut self,
            input: std::option::Option<crate::model::AnnotationConsolidationConfig>,
        ) -> Self {
            self.annotation_consolidation_config = input;
            self
        }
        /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
        pub fn public_workforce_task_price(
            mut self,
            input: crate::model::PublicWorkforceTaskPrice,
        ) -> Self {
            self.public_workforce_task_price = Some(input);
            self
        }
        /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
        pub fn set_public_workforce_task_price(
            mut self,
            input: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
        ) -> Self {
            self.public_workforce_task_price = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanTaskConfig`](crate::model::HumanTaskConfig)
        pub fn build(self) -> crate::model::HumanTaskConfig {
            crate::model::HumanTaskConfig {
                workteam_arn: self.workteam_arn,
                ui_config: self.ui_config,
                pre_human_task_lambda_arn: self.pre_human_task_lambda_arn,
                task_keywords: self.task_keywords,
                task_title: self.task_title,
                task_description: self.task_description,
                number_of_human_workers_per_data_object: self
                    .number_of_human_workers_per_data_object,
                task_time_limit_in_seconds: self.task_time_limit_in_seconds,
                task_availability_lifetime_in_seconds: self.task_availability_lifetime_in_seconds,
                max_concurrent_task_count: self.max_concurrent_task_count,
                annotation_consolidation_config: self.annotation_consolidation_config,
                public_workforce_task_price: self.public_workforce_task_price,
            }
        }
    }
}
impl HumanTaskConfig {
    /// Creates a new builder-style object to manufacture [`HumanTaskConfig`](crate::model::HumanTaskConfig)
    pub fn builder() -> crate::model::human_task_config::Builder {
        crate::model::human_task_config::Builder::default()
    }
}

/// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
/// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and should be based on the complexity of the task; the longer it takes in your initial testing, the more you should offer.</p>
/// <ul>
/// <li> <p>0.036</p> </li>
/// <li> <p>0.048</p> </li>
/// <li> <p>0.060</p> </li>
/// <li> <p>0.072</p> </li>
/// <li> <p>0.120</p> </li>
/// <li> <p>0.240</p> </li>
/// <li> <p>0.360</p> </li>
/// <li> <p>0.480</p> </li>
/// <li> <p>0.600</p> </li>
/// <li> <p>0.720</p> </li>
/// <li> <p>0.840</p> </li>
/// <li> <p>0.960</p> </li>
/// <li> <p>1.080</p> </li>
/// <li> <p>1.200</p> </li>
/// </ul>
/// <p>Use one of the following prices for image classification, text classification, and custom tasks. Prices are in US dollars.</p>
/// <ul>
/// <li> <p>0.012</p> </li>
/// <li> <p>0.024</p> </li>
/// <li> <p>0.036</p> </li>
/// <li> <p>0.048</p> </li>
/// <li> <p>0.060</p> </li>
/// <li> <p>0.072</p> </li>
/// <li> <p>0.120</p> </li>
/// <li> <p>0.240</p> </li>
/// <li> <p>0.360</p> </li>
/// <li> <p>0.480</p> </li>
/// <li> <p>0.600</p> </li>
/// <li> <p>0.720</p> </li>
/// <li> <p>0.840</p> </li>
/// <li> <p>0.960</p> </li>
/// <li> <p>1.080</p> </li>
/// <li> <p>1.200</p> </li>
/// </ul>
/// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US dollars.</p>
/// <ul>
/// <li> <p>0.840</p> </li>
/// <li> <p>0.960</p> </li>
/// <li> <p>1.080</p> </li>
/// <li> <p>1.200</p> </li>
/// </ul>
/// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon Augmented AI review tasks. Prices are in US dollars.</p>
/// <ul>
/// <li> <p>2.400 </p> </li>
/// <li> <p>2.280 </p> </li>
/// <li> <p>2.160 </p> </li>
/// <li> <p>2.040 </p> </li>
/// <li> <p>1.920 </p> </li>
/// <li> <p>1.800 </p> </li>
/// <li> <p>1.680 </p> </li>
/// <li> <p>1.560 </p> </li>
/// <li> <p>1.440 </p> </li>
/// <li> <p>1.320 </p> </li>
/// <li> <p>1.200 </p> </li>
/// <li> <p>1.080 </p> </li>
/// <li> <p>0.960 </p> </li>
/// <li> <p>0.840 </p> </li>
/// <li> <p>0.720 </p> </li>
/// <li> <p>0.600 </p> </li>
/// <li> <p>0.480 </p> </li>
/// <li> <p>0.360 </p> </li>
/// <li> <p>0.240 </p> </li>
/// <li> <p>0.120 </p> </li>
/// <li> <p>0.072 </p> </li>
/// <li> <p>0.060 </p> </li>
/// <li> <p>0.048 </p> </li>
/// <li> <p>0.036 </p> </li>
/// <li> <p>0.024 </p> </li>
/// <li> <p>0.012 </p> </li>
/// </ul>
/// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon Augmented AI review tasks. Prices are in US dollars.</p>
/// <ul>
/// <li> <p>1.200 </p> </li>
/// <li> <p>1.080 </p> </li>
/// <li> <p>0.960 </p> </li>
/// <li> <p>0.840 </p> </li>
/// <li> <p>0.720 </p> </li>
/// <li> <p>0.600 </p> </li>
/// <li> <p>0.480 </p> </li>
/// <li> <p>0.360 </p> </li>
/// <li> <p>0.240 </p> </li>
/// <li> <p>0.120 </p> </li>
/// <li> <p>0.072 </p> </li>
/// <li> <p>0.060 </p> </li>
/// <li> <p>0.048 </p> </li>
/// <li> <p>0.036 </p> </li>
/// <li> <p>0.024 </p> </li>
/// <li> <p>0.012 </p> </li>
/// </ul>
/// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks. Prices are in US dollars.</p>
/// <ul>
/// <li> <p>1.200 </p> </li>
/// <li> <p>1.080 </p> </li>
/// <li> <p>0.960 </p> </li>
/// <li> <p>0.840 </p> </li>
/// <li> <p>0.720 </p> </li>
/// <li> <p>0.600 </p> </li>
/// <li> <p>0.480 </p> </li>
/// <li> <p>0.360 </p> </li>
/// <li> <p>0.240 </p> </li>
/// <li> <p>0.120 </p> </li>
/// <li> <p>0.072 </p> </li>
/// <li> <p>0.060 </p> </li>
/// <li> <p>0.048 </p> </li>
/// <li> <p>0.036 </p> </li>
/// <li> <p>0.024 </p> </li>
/// <li> <p>0.012 </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicWorkforceTaskPrice {
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
    pub amount_in_usd: std::option::Option<crate::model::Usd>,
}
impl PublicWorkforceTaskPrice {
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
    pub fn amount_in_usd(&self) -> std::option::Option<&crate::model::Usd> {
        self.amount_in_usd.as_ref()
    }
}
impl std::fmt::Debug for PublicWorkforceTaskPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicWorkforceTaskPrice");
        formatter.field("amount_in_usd", &self.amount_in_usd);
        formatter.finish()
    }
}
/// See [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
pub mod public_workforce_task_price {

    /// A builder for [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount_in_usd: std::option::Option<crate::model::Usd>,
    }
    impl Builder {
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
        pub fn amount_in_usd(mut self, input: crate::model::Usd) -> Self {
            self.amount_in_usd = Some(input);
            self
        }
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
        pub fn set_amount_in_usd(mut self, input: std::option::Option<crate::model::Usd>) -> Self {
            self.amount_in_usd = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
        pub fn build(self) -> crate::model::PublicWorkforceTaskPrice {
            crate::model::PublicWorkforceTaskPrice {
                amount_in_usd: self.amount_in_usd,
            }
        }
    }
}
impl PublicWorkforceTaskPrice {
    /// Creates a new builder-style object to manufacture [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
    pub fn builder() -> crate::model::public_workforce_task_price::Builder {
        crate::model::public_workforce_task_price::Builder::default()
    }
}

/// <p>Represents an amount of money in United States dollars.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Usd {
    /// <p>The whole number of dollars in the amount.</p>
    pub dollars: i32,
    /// <p>The fractional portion, in cents, of the amount. </p>
    pub cents: i32,
    /// <p>Fractions of a cent, in tenths.</p>
    pub tenth_fractions_of_a_cent: i32,
}
impl Usd {
    /// <p>The whole number of dollars in the amount.</p>
    pub fn dollars(&self) -> i32 {
        self.dollars
    }
    /// <p>The fractional portion, in cents, of the amount. </p>
    pub fn cents(&self) -> i32 {
        self.cents
    }
    /// <p>Fractions of a cent, in tenths.</p>
    pub fn tenth_fractions_of_a_cent(&self) -> i32 {
        self.tenth_fractions_of_a_cent
    }
}
impl std::fmt::Debug for Usd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Usd");
        formatter.field("dollars", &self.dollars);
        formatter.field("cents", &self.cents);
        formatter.field("tenth_fractions_of_a_cent", &self.tenth_fractions_of_a_cent);
        formatter.finish()
    }
}
/// See [`Usd`](crate::model::Usd)
pub mod usd {

    /// A builder for [`Usd`](crate::model::Usd)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dollars: std::option::Option<i32>,
        pub(crate) cents: std::option::Option<i32>,
        pub(crate) tenth_fractions_of_a_cent: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The whole number of dollars in the amount.</p>
        pub fn dollars(mut self, input: i32) -> Self {
            self.dollars = Some(input);
            self
        }
        /// <p>The whole number of dollars in the amount.</p>
        pub fn set_dollars(mut self, input: std::option::Option<i32>) -> Self {
            self.dollars = input;
            self
        }
        /// <p>The fractional portion, in cents, of the amount. </p>
        pub fn cents(mut self, input: i32) -> Self {
            self.cents = Some(input);
            self
        }
        /// <p>The fractional portion, in cents, of the amount. </p>
        pub fn set_cents(mut self, input: std::option::Option<i32>) -> Self {
            self.cents = input;
            self
        }
        /// <p>Fractions of a cent, in tenths.</p>
        pub fn tenth_fractions_of_a_cent(mut self, input: i32) -> Self {
            self.tenth_fractions_of_a_cent = Some(input);
            self
        }
        /// <p>Fractions of a cent, in tenths.</p>
        pub fn set_tenth_fractions_of_a_cent(mut self, input: std::option::Option<i32>) -> Self {
            self.tenth_fractions_of_a_cent = input;
            self
        }
        /// Consumes the builder and constructs a [`Usd`](crate::model::Usd)
        pub fn build(self) -> crate::model::Usd {
            crate::model::Usd {
                dollars: self.dollars.unwrap_or_default(),
                cents: self.cents.unwrap_or_default(),
                tenth_fractions_of_a_cent: self.tenth_fractions_of_a_cent.unwrap_or_default(),
            }
        }
    }
}
impl Usd {
    /// Creates a new builder-style object to manufacture [`Usd`](crate::model::Usd)
    pub fn builder() -> crate::model::usd::Builder {
        crate::model::usd::Builder::default()
    }
}

/// <p>Configures how labels are consolidated across human workers and processes output data. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnnotationConsolidationConfig {
    /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
    /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
    /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p> <b>Semantic Segmentation Adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic Segmentation Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding Box Adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding Box Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Detection Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects that appear in a sequence of 3D point cloud frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    pub annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
}
impl AnnotationConsolidationConfig {
    /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
    /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
    /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
    /// </ul>
    /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p> <b>Semantic Segmentation Adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Semantic Segmentation Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding Box Adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Bounding Box Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Detection Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Object Tracking Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects that appear in a sequence of 3D point cloud frames.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    pub fn annotation_consolidation_lambda_arn(&self) -> std::option::Option<&str> {
        self.annotation_consolidation_lambda_arn.as_deref()
    }
}
impl std::fmt::Debug for AnnotationConsolidationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnnotationConsolidationConfig");
        formatter.field(
            "annotation_consolidation_lambda_arn",
            &self.annotation_consolidation_lambda_arn,
        );
        formatter.finish()
    }
}
/// See [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
pub mod annotation_consolidation_config {

    /// A builder for [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
        /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
        /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p> <b>Semantic Segmentation Adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic Segmentation Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding Box Adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding Box Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Detection Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects that appear in a sequence of 3D point cloud frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        pub fn annotation_consolidation_lambda_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
        /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
        /// <p> <b>Bounding box</b> - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label image classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic segmentation</b> - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Multi-label text classification</b> - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code> </p> </li>
        /// </ul>
        /// <p> <b>Named entity recognition</b> - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Classification</b> - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection</b> - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking</b> - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Detection</b> - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking</b> - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation</b> - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Use the following ARNs for Label Verification and Adjustment Jobs</b> </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p> <b>Semantic Segmentation Adjustment</b> - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Semantic Segmentation Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding Box Adjustment</b> - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Bounding Box Verification</b> - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Detection Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame Object Tracking Adjustment</b> - Use this task type when you want workers to adjust bounding boxes that workers have added to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Detection Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Object Tracking Adjustment</b> - Use this task type when you want workers to adjust 3D cuboids around objects that appear in a sequence of 3D point cloud frames.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// <li> <p> <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        pub fn set_annotation_consolidation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
        pub fn build(self) -> crate::model::AnnotationConsolidationConfig {
            crate::model::AnnotationConsolidationConfig {
                annotation_consolidation_lambda_arn: self.annotation_consolidation_lambda_arn,
            }
        }
    }
}
impl AnnotationConsolidationConfig {
    /// Creates a new builder-style object to manufacture [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
    pub fn builder() -> crate::model::annotation_consolidation_config::Builder {
        crate::model::annotation_consolidation_config::Builder::default()
    }
}

/// <p>Provided configuration information for the worker UI for a labeling job. Provide either <code>HumanTaskUiArn</code> or <code>UiTemplateS3Uri</code>.</p>
/// <p>For named entity recognition, 3D point cloud and video frame labeling jobs, use <code>HumanTaskUiArn</code>.</p>
/// <p>For all other Ground Truth built-in task types and custom task types, use <code>UiTemplateS3Uri</code> to specify the location of a worker task template in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiConfig {
    /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the template used to render the worker UI and tools for labeling job tasks. For more information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom Labeling Task Template</a>.</p>
    pub ui_template_s3_uri: std::option::Option<std::string::String>,
    /// <p>The ARN of the worker task template used to render the worker UI and tools for labeling job tasks.</p>
    /// <p>Use this parameter when you are creating a labeling job for named entity recognition, 3D point cloud and video frame labeling jobs. Use your labeling job task type to select one of the following ARNs and use it with this parameter when you create a labeling job. Replace <code>aws-region</code> with the Amazon Web Services Region you are creating your labeling job in. For example, replace <code>aws-region</code> with <code>us-west-1</code> if you create a labeling job in US West (N. California).</p>
    /// <p> <b>Named Entity Recognition</b> </p>
    /// <p>Use the following <code>HumanTaskUiArn</code> for named entity recognition labeling jobs:</p>
    /// <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/NamedEntityRecognition</code> </p>
    /// <p> <b>3D Point Cloud HumanTaskUiArns</b> </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point cloud object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point cloud object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D point cloud semantic segmentation adjustment labeling jobs.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame HumanTaskUiArns</b> </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code> </p> </li>
    /// </ul>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
}
impl UiConfig {
    /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the template used to render the worker UI and tools for labeling job tasks. For more information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom Labeling Task Template</a>.</p>
    pub fn ui_template_s3_uri(&self) -> std::option::Option<&str> {
        self.ui_template_s3_uri.as_deref()
    }
    /// <p>The ARN of the worker task template used to render the worker UI and tools for labeling job tasks.</p>
    /// <p>Use this parameter when you are creating a labeling job for named entity recognition, 3D point cloud and video frame labeling jobs. Use your labeling job task type to select one of the following ARNs and use it with this parameter when you create a labeling job. Replace <code>aws-region</code> with the Amazon Web Services Region you are creating your labeling job in. For example, replace <code>aws-region</code> with <code>us-west-1</code> if you create a labeling job in US West (N. California).</p>
    /// <p> <b>Named Entity Recognition</b> </p>
    /// <p>Use the following <code>HumanTaskUiArn</code> for named entity recognition labeling jobs:</p>
    /// <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/NamedEntityRecognition</code> </p>
    /// <p> <b>3D Point Cloud HumanTaskUiArns</b> </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point cloud object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point cloud object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D point cloud semantic segmentation adjustment labeling jobs.</p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code> </p> </li>
    /// </ul>
    /// <p> <b>Video Frame HumanTaskUiArns</b> </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code> </p> </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code> </p> </li>
    /// </ul>
    pub fn human_task_ui_arn(&self) -> std::option::Option<&str> {
        self.human_task_ui_arn.as_deref()
    }
}
impl std::fmt::Debug for UiConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiConfig");
        formatter.field("ui_template_s3_uri", &self.ui_template_s3_uri);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.finish()
    }
}
/// See [`UiConfig`](crate::model::UiConfig)
pub mod ui_config {

    /// A builder for [`UiConfig`](crate::model::UiConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ui_template_s3_uri: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the template used to render the worker UI and tools for labeling job tasks. For more information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom Labeling Task Template</a>.</p>
        pub fn ui_template_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.ui_template_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the template used to render the worker UI and tools for labeling job tasks. For more information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom Labeling Task Template</a>.</p>
        pub fn set_ui_template_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ui_template_s3_uri = input;
            self
        }
        /// <p>The ARN of the worker task template used to render the worker UI and tools for labeling job tasks.</p>
        /// <p>Use this parameter when you are creating a labeling job for named entity recognition, 3D point cloud and video frame labeling jobs. Use your labeling job task type to select one of the following ARNs and use it with this parameter when you create a labeling job. Replace <code>aws-region</code> with the Amazon Web Services Region you are creating your labeling job in. For example, replace <code>aws-region</code> with <code>us-west-1</code> if you create a labeling job in US West (N. California).</p>
        /// <p> <b>Named Entity Recognition</b> </p>
        /// <p>Use the following <code>HumanTaskUiArn</code> for named entity recognition labeling jobs:</p>
        /// <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/NamedEntityRecognition</code> </p>
        /// <p> <b>3D Point Cloud HumanTaskUiArns</b> </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point cloud object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point cloud object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D point cloud semantic segmentation adjustment labeling jobs.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame HumanTaskUiArns</b> </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code> </p> </li>
        /// </ul>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the worker task template used to render the worker UI and tools for labeling job tasks.</p>
        /// <p>Use this parameter when you are creating a labeling job for named entity recognition, 3D point cloud and video frame labeling jobs. Use your labeling job task type to select one of the following ARNs and use it with this parameter when you create a labeling job. Replace <code>aws-region</code> with the Amazon Web Services Region you are creating your labeling job in. For example, replace <code>aws-region</code> with <code>us-west-1</code> if you create a labeling job in US West (N. California).</p>
        /// <p> <b>Named Entity Recognition</b> </p>
        /// <p>Use the following <code>HumanTaskUiArn</code> for named entity recognition labeling jobs:</p>
        /// <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/NamedEntityRecognition</code> </p>
        /// <p> <b>3D Point Cloud HumanTaskUiArns</b> </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point cloud object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point cloud object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D point cloud semantic segmentation adjustment labeling jobs.</p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code> </p> </li>
        /// </ul>
        /// <p> <b>Video Frame HumanTaskUiArns</b> </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code> </p> </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li> <p> <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code> </p> </li>
        /// </ul>
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UiConfig`](crate::model::UiConfig)
        pub fn build(self) -> crate::model::UiConfig {
            crate::model::UiConfig {
                ui_template_s3_uri: self.ui_template_s3_uri,
                human_task_ui_arn: self.human_task_ui_arn,
            }
        }
    }
}
impl UiConfig {
    /// Creates a new builder-style object to manufacture [`UiConfig`](crate::model::UiConfig)
    pub fn builder() -> crate::model::ui_config::Builder {
        crate::model::ui_config::Builder::default()
    }
}

/// <p>Provides configuration information for auto-labeling of your data objects. A <code>LabelingJobAlgorithmsConfig</code> object must be supplied in order to use auto-labeling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobAlgorithmsConfig {
    /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:</p>
    /// <ul>
    /// <li> <p> <i>Image classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code> </p> </li>
    /// <li> <p> <i>Text classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code> </p> </li>
    /// <li> <p> <i>Object detection</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code> </p> </li>
    /// <li> <p> <i>Semantic Segmentation</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code> </p> </li>
    /// </ul>
    pub labeling_job_algorithm_specification_arn: std::option::Option<std::string::String>,
    /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here. </p>
    pub initial_active_learning_model_arn: std::option::Option<std::string::String>,
    /// <p>Provides configuration information for a labeling job.</p>
    pub labeling_job_resource_config: std::option::Option<crate::model::LabelingJobResourceConfig>,
}
impl LabelingJobAlgorithmsConfig {
    /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:</p>
    /// <ul>
    /// <li> <p> <i>Image classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code> </p> </li>
    /// <li> <p> <i>Text classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code> </p> </li>
    /// <li> <p> <i>Object detection</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code> </p> </li>
    /// <li> <p> <i>Semantic Segmentation</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code> </p> </li>
    /// </ul>
    pub fn labeling_job_algorithm_specification_arn(&self) -> std::option::Option<&str> {
        self.labeling_job_algorithm_specification_arn.as_deref()
    }
    /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here. </p>
    pub fn initial_active_learning_model_arn(&self) -> std::option::Option<&str> {
        self.initial_active_learning_model_arn.as_deref()
    }
    /// <p>Provides configuration information for a labeling job.</p>
    pub fn labeling_job_resource_config(
        &self,
    ) -> std::option::Option<&crate::model::LabelingJobResourceConfig> {
        self.labeling_job_resource_config.as_ref()
    }
}
impl std::fmt::Debug for LabelingJobAlgorithmsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobAlgorithmsConfig");
        formatter.field(
            "labeling_job_algorithm_specification_arn",
            &self.labeling_job_algorithm_specification_arn,
        );
        formatter.field(
            "initial_active_learning_model_arn",
            &self.initial_active_learning_model_arn,
        );
        formatter.field(
            "labeling_job_resource_config",
            &self.labeling_job_resource_config,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
pub mod labeling_job_algorithms_config {

    /// A builder for [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_algorithm_specification_arn:
            std::option::Option<std::string::String>,
        pub(crate) initial_active_learning_model_arn: std::option::Option<std::string::String>,
        pub(crate) labeling_job_resource_config:
            std::option::Option<crate::model::LabelingJobResourceConfig>,
    }
    impl Builder {
        /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:</p>
        /// <ul>
        /// <li> <p> <i>Image classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code> </p> </li>
        /// <li> <p> <i>Text classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code> </p> </li>
        /// <li> <p> <i>Object detection</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code> </p> </li>
        /// <li> <p> <i>Semantic Segmentation</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code> </p> </li>
        /// </ul>
        pub fn labeling_job_algorithm_specification_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.labeling_job_algorithm_specification_arn = Some(input.into());
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:</p>
        /// <ul>
        /// <li> <p> <i>Image classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code> </p> </li>
        /// <li> <p> <i>Text classification</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code> </p> </li>
        /// <li> <p> <i>Object detection</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code> </p> </li>
        /// <li> <p> <i>Semantic Segmentation</i> </p> <p> <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code> </p> </li>
        /// </ul>
        pub fn set_labeling_job_algorithm_specification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_algorithm_specification_arn = input;
            self
        }
        /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here. </p>
        pub fn initial_active_learning_model_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.initial_active_learning_model_arn = Some(input.into());
            self
        }
        /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here. </p>
        pub fn set_initial_active_learning_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_active_learning_model_arn = input;
            self
        }
        /// <p>Provides configuration information for a labeling job.</p>
        pub fn labeling_job_resource_config(
            mut self,
            input: crate::model::LabelingJobResourceConfig,
        ) -> Self {
            self.labeling_job_resource_config = Some(input);
            self
        }
        /// <p>Provides configuration information for a labeling job.</p>
        pub fn set_labeling_job_resource_config(
            mut self,
            input: std::option::Option<crate::model::LabelingJobResourceConfig>,
        ) -> Self {
            self.labeling_job_resource_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
        pub fn build(self) -> crate::model::LabelingJobAlgorithmsConfig {
            crate::model::LabelingJobAlgorithmsConfig {
                labeling_job_algorithm_specification_arn: self
                    .labeling_job_algorithm_specification_arn,
                initial_active_learning_model_arn: self.initial_active_learning_model_arn,
                labeling_job_resource_config: self.labeling_job_resource_config,
            }
        }
    }
}
impl LabelingJobAlgorithmsConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
    pub fn builder() -> crate::model::labeling_job_algorithms_config::Builder {
        crate::model::labeling_job_algorithms_config::Builder::default()
    }
}

/// <p>Configure encryption on the storage volume attached to the ML compute instance used to run automated data labeling model training and inference. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobResourceConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training and inference jobs used for automated data labeling. </p>
    /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with automated data labeling enabled using the API operation <code>CreateLabelingJob</code>. You cannot specify an Amazon Web Services KMS key to encrypt the storage volume used for automated data labeling model training and inference when you create a labeling job using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume Encryption</a>.</p>
    /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl LabelingJobResourceConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training and inference jobs used for automated data labeling. </p>
    /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with automated data labeling enabled using the API operation <code>CreateLabelingJob</code>. You cannot specify an Amazon Web Services KMS key to encrypt the storage volume used for automated data labeling model training and inference when you create a labeling job using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume Encryption</a>.</p>
    /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobResourceConfig");
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
pub mod labeling_job_resource_config {

    /// A builder for [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training and inference jobs used for automated data labeling. </p>
        /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with automated data labeling enabled using the API operation <code>CreateLabelingJob</code>. You cannot specify an Amazon Web Services KMS key to encrypt the storage volume used for automated data labeling model training and inference when you create a labeling job using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume Encryption</a>.</p>
        /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training and inference jobs used for automated data labeling. </p>
        /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with automated data labeling enabled using the API operation <code>CreateLabelingJob</code>. You cannot specify an Amazon Web Services KMS key to encrypt the storage volume used for automated data labeling model training and inference when you create a labeling job using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume Encryption</a>.</p>
        /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
        pub fn build(self) -> crate::model::LabelingJobResourceConfig {
            crate::model::LabelingJobResourceConfig {
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl LabelingJobResourceConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
    pub fn builder() -> crate::model::labeling_job_resource_config::Builder {
        crate::model::labeling_job_resource_config::Builder::default()
    }
}

/// <p>A set of conditions for stopping a labeling job. If any of the conditions are met, the job is automatically stopped. You can use these conditions to control the cost of data labeling.</p> <note>
/// <p>Labeling jobs fail after 30 days with an appropriate client error message.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobStoppingConditions {
    /// <p>The maximum number of objects that can be labeled by human workers.</p>
    pub max_human_labeled_object_count: std::option::Option<i32>,
    /// <p>The maximum number of input data objects that should be labeled.</p>
    pub max_percentage_of_input_dataset_labeled: std::option::Option<i32>,
}
impl LabelingJobStoppingConditions {
    /// <p>The maximum number of objects that can be labeled by human workers.</p>
    pub fn max_human_labeled_object_count(&self) -> std::option::Option<i32> {
        self.max_human_labeled_object_count
    }
    /// <p>The maximum number of input data objects that should be labeled.</p>
    pub fn max_percentage_of_input_dataset_labeled(&self) -> std::option::Option<i32> {
        self.max_percentage_of_input_dataset_labeled
    }
}
impl std::fmt::Debug for LabelingJobStoppingConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobStoppingConditions");
        formatter.field(
            "max_human_labeled_object_count",
            &self.max_human_labeled_object_count,
        );
        formatter.field(
            "max_percentage_of_input_dataset_labeled",
            &self.max_percentage_of_input_dataset_labeled,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
pub mod labeling_job_stopping_conditions {

    /// A builder for [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_human_labeled_object_count: std::option::Option<i32>,
        pub(crate) max_percentage_of_input_dataset_labeled: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of objects that can be labeled by human workers.</p>
        pub fn max_human_labeled_object_count(mut self, input: i32) -> Self {
            self.max_human_labeled_object_count = Some(input);
            self
        }
        /// <p>The maximum number of objects that can be labeled by human workers.</p>
        pub fn set_max_human_labeled_object_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_human_labeled_object_count = input;
            self
        }
        /// <p>The maximum number of input data objects that should be labeled.</p>
        pub fn max_percentage_of_input_dataset_labeled(mut self, input: i32) -> Self {
            self.max_percentage_of_input_dataset_labeled = Some(input);
            self
        }
        /// <p>The maximum number of input data objects that should be labeled.</p>
        pub fn set_max_percentage_of_input_dataset_labeled(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_percentage_of_input_dataset_labeled = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
        pub fn build(self) -> crate::model::LabelingJobStoppingConditions {
            crate::model::LabelingJobStoppingConditions {
                max_human_labeled_object_count: self.max_human_labeled_object_count,
                max_percentage_of_input_dataset_labeled: self
                    .max_percentage_of_input_dataset_labeled,
            }
        }
    }
}
impl LabelingJobStoppingConditions {
    /// Creates a new builder-style object to manufacture [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
    pub fn builder() -> crate::model::labeling_job_stopping_conditions::Builder {
        crate::model::labeling_job_stopping_conditions::Builder::default()
    }
}

/// <p>Output configuration information for a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobOutputConfig {
    /// <p>The Amazon S3 location to write output data.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
    /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your role's account to encrypt your output data.</p>
    /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to do real time chaining to another streaming job and receive an Amazon SNS notifications each time a data object is submitted by a worker.</p>
    /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers complete labeling tasks, Ground Truth will send labeling task output data to the SNS output topic you specify here. </p>
    /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling Job</a>. </p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
}
impl LabelingJobOutputConfig {
    /// <p>The Amazon S3 location to write output data.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
    /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your role's account to encrypt your output data.</p>
    /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to do real time chaining to another streaming job and receive an Amazon SNS notifications each time a data object is submitted by a worker.</p>
    /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers complete labeling tasks, Ground Truth will send labeling task output data to the SNS output topic you specify here. </p>
    /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling Job</a>. </p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
}
impl std::fmt::Debug for LabelingJobOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobOutputConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.finish()
    }
}
/// See [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
pub mod labeling_job_output_config {

    /// A builder for [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location to write output data.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location to write output data.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
        /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your role's account to encrypt your output data.</p>
        /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
        /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your role's account to encrypt your output data.</p>
        /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to do real time chaining to another streaming job and receive an Amazon SNS notifications each time a data object is submitted by a worker.</p>
        /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers complete labeling tasks, Ground Truth will send labeling task output data to the SNS output topic you specify here. </p>
        /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling Job</a>. </p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to do real time chaining to another streaming job and receive an Amazon SNS notifications each time a data object is submitted by a worker.</p>
        /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers complete labeling tasks, Ground Truth will send labeling task output data to the SNS output topic you specify here. </p>
        /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling Job</a>. </p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
        pub fn build(self) -> crate::model::LabelingJobOutputConfig {
            crate::model::LabelingJobOutputConfig {
                s3_output_path: self.s3_output_path,
                kms_key_id: self.kms_key_id,
                sns_topic_arn: self.sns_topic_arn,
            }
        }
    }
}
impl LabelingJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
    pub fn builder() -> crate::model::labeling_job_output_config::Builder {
        crate::model::labeling_job_output_config::Builder::default()
    }
}

/// <p>A list of recommendations made by Amazon SageMaker Inference Recommender.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceRecommendation {
    /// <p>The metrics used to decide what recommendation to make.</p>
    pub metrics: std::option::Option<crate::model::RecommendationMetrics>,
    /// <p>Defines the endpoint configuration parameters.</p>
    pub endpoint_configuration: std::option::Option<crate::model::EndpointOutputConfiguration>,
    /// <p>Defines the model configuration.</p>
    pub model_configuration: std::option::Option<crate::model::ModelConfiguration>,
}
impl InferenceRecommendation {
    /// <p>The metrics used to decide what recommendation to make.</p>
    pub fn metrics(&self) -> std::option::Option<&crate::model::RecommendationMetrics> {
        self.metrics.as_ref()
    }
    /// <p>Defines the endpoint configuration parameters.</p>
    pub fn endpoint_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EndpointOutputConfiguration> {
        self.endpoint_configuration.as_ref()
    }
    /// <p>Defines the model configuration.</p>
    pub fn model_configuration(&self) -> std::option::Option<&crate::model::ModelConfiguration> {
        self.model_configuration.as_ref()
    }
}
impl std::fmt::Debug for InferenceRecommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceRecommendation");
        formatter.field("metrics", &self.metrics);
        formatter.field("endpoint_configuration", &self.endpoint_configuration);
        formatter.field("model_configuration", &self.model_configuration);
        formatter.finish()
    }
}
/// See [`InferenceRecommendation`](crate::model::InferenceRecommendation)
pub mod inference_recommendation {

    /// A builder for [`InferenceRecommendation`](crate::model::InferenceRecommendation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metrics: std::option::Option<crate::model::RecommendationMetrics>,
        pub(crate) endpoint_configuration:
            std::option::Option<crate::model::EndpointOutputConfiguration>,
        pub(crate) model_configuration: std::option::Option<crate::model::ModelConfiguration>,
    }
    impl Builder {
        /// <p>The metrics used to decide what recommendation to make.</p>
        pub fn metrics(mut self, input: crate::model::RecommendationMetrics) -> Self {
            self.metrics = Some(input);
            self
        }
        /// <p>The metrics used to decide what recommendation to make.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<crate::model::RecommendationMetrics>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Defines the endpoint configuration parameters.</p>
        pub fn endpoint_configuration(
            mut self,
            input: crate::model::EndpointOutputConfiguration,
        ) -> Self {
            self.endpoint_configuration = Some(input);
            self
        }
        /// <p>Defines the endpoint configuration parameters.</p>
        pub fn set_endpoint_configuration(
            mut self,
            input: std::option::Option<crate::model::EndpointOutputConfiguration>,
        ) -> Self {
            self.endpoint_configuration = input;
            self
        }
        /// <p>Defines the model configuration.</p>
        pub fn model_configuration(mut self, input: crate::model::ModelConfiguration) -> Self {
            self.model_configuration = Some(input);
            self
        }
        /// <p>Defines the model configuration.</p>
        pub fn set_model_configuration(
            mut self,
            input: std::option::Option<crate::model::ModelConfiguration>,
        ) -> Self {
            self.model_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceRecommendation`](crate::model::InferenceRecommendation)
        pub fn build(self) -> crate::model::InferenceRecommendation {
            crate::model::InferenceRecommendation {
                metrics: self.metrics,
                endpoint_configuration: self.endpoint_configuration,
                model_configuration: self.model_configuration,
            }
        }
    }
}
impl InferenceRecommendation {
    /// Creates a new builder-style object to manufacture [`InferenceRecommendation`](crate::model::InferenceRecommendation)
    pub fn builder() -> crate::model::inference_recommendation::Builder {
        crate::model::inference_recommendation::Builder::default()
    }
}

/// <p>Defines the model configuration. Includes the specification name and environment parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelConfiguration {
    /// <p>The inference specification name in the model package version.</p>
    pub inference_specification_name: std::option::Option<std::string::String>,
    /// <p>Defines the environment parameters that includes key, value types, and values.</p>
    pub environment_parameters:
        std::option::Option<std::vec::Vec<crate::model::EnvironmentParameter>>,
}
impl ModelConfiguration {
    /// <p>The inference specification name in the model package version.</p>
    pub fn inference_specification_name(&self) -> std::option::Option<&str> {
        self.inference_specification_name.as_deref()
    }
    /// <p>Defines the environment parameters that includes key, value types, and values.</p>
    pub fn environment_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::EnvironmentParameter]> {
        self.environment_parameters.as_deref()
    }
}
impl std::fmt::Debug for ModelConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelConfiguration");
        formatter.field(
            "inference_specification_name",
            &self.inference_specification_name,
        );
        formatter.field("environment_parameters", &self.environment_parameters);
        formatter.finish()
    }
}
/// See [`ModelConfiguration`](crate::model::ModelConfiguration)
pub mod model_configuration {

    /// A builder for [`ModelConfiguration`](crate::model::ModelConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inference_specification_name: std::option::Option<std::string::String>,
        pub(crate) environment_parameters:
            std::option::Option<std::vec::Vec<crate::model::EnvironmentParameter>>,
    }
    impl Builder {
        /// <p>The inference specification name in the model package version.</p>
        pub fn inference_specification_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inference_specification_name = Some(input.into());
            self
        }
        /// <p>The inference specification name in the model package version.</p>
        pub fn set_inference_specification_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inference_specification_name = input;
            self
        }
        /// Appends an item to `environment_parameters`.
        ///
        /// To override the contents of this collection use [`set_environment_parameters`](Self::set_environment_parameters).
        ///
        /// <p>Defines the environment parameters that includes key, value types, and values.</p>
        pub fn environment_parameters(mut self, input: crate::model::EnvironmentParameter) -> Self {
            let mut v = self.environment_parameters.unwrap_or_default();
            v.push(input);
            self.environment_parameters = Some(v);
            self
        }
        /// <p>Defines the environment parameters that includes key, value types, and values.</p>
        pub fn set_environment_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EnvironmentParameter>>,
        ) -> Self {
            self.environment_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelConfiguration`](crate::model::ModelConfiguration)
        pub fn build(self) -> crate::model::ModelConfiguration {
            crate::model::ModelConfiguration {
                inference_specification_name: self.inference_specification_name,
                environment_parameters: self.environment_parameters,
            }
        }
    }
}
impl ModelConfiguration {
    /// Creates a new builder-style object to manufacture [`ModelConfiguration`](crate::model::ModelConfiguration)
    pub fn builder() -> crate::model::model_configuration::Builder {
        crate::model::model_configuration::Builder::default()
    }
}

/// <p>A list of environment parameters suggested by the Amazon SageMaker Inference Recommender.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentParameter {
    /// <p>The environment key suggested by the Amazon SageMaker Inference Recommender.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value type suggested by the Amazon SageMaker Inference Recommender.</p>
    pub value_type: std::option::Option<std::string::String>,
    /// <p>The value suggested by the Amazon SageMaker Inference Recommender.</p>
    pub value: std::option::Option<std::string::String>,
}
impl EnvironmentParameter {
    /// <p>The environment key suggested by the Amazon SageMaker Inference Recommender.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value type suggested by the Amazon SageMaker Inference Recommender.</p>
    pub fn value_type(&self) -> std::option::Option<&str> {
        self.value_type.as_deref()
    }
    /// <p>The value suggested by the Amazon SageMaker Inference Recommender.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentParameter");
        formatter.field("key", &self.key);
        formatter.field("value_type", &self.value_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`EnvironmentParameter`](crate::model::EnvironmentParameter)
pub mod environment_parameter {

    /// A builder for [`EnvironmentParameter`](crate::model::EnvironmentParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value_type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The environment key suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The environment key suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value type suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn value_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.value_type = Some(input.into());
            self
        }
        /// <p>The value type suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn set_value_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value_type = input;
            self
        }
        /// <p>The value suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value suggested by the Amazon SageMaker Inference Recommender.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentParameter`](crate::model::EnvironmentParameter)
        pub fn build(self) -> crate::model::EnvironmentParameter {
            crate::model::EnvironmentParameter {
                key: self.key,
                value_type: self.value_type,
                value: self.value,
            }
        }
    }
}
impl EnvironmentParameter {
    /// Creates a new builder-style object to manufacture [`EnvironmentParameter`](crate::model::EnvironmentParameter)
    pub fn builder() -> crate::model::environment_parameter::Builder {
        crate::model::environment_parameter::Builder::default()
    }
}

/// <p>The endpoint configuration made by Inference Recommender during a recommendation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointOutputConfiguration {
    /// <p>The name of the endpoint made during a recommendation job.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The name of the production variant (deployed model) made during a recommendation job.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>The instance type recommended by Amazon SageMaker Inference Recommender.</p>
    pub instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
    /// <p>The number of instances recommended to launch initially.</p>
    pub initial_instance_count: i32,
}
impl EndpointOutputConfiguration {
    /// <p>The name of the endpoint made during a recommendation job.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The name of the production variant (deployed model) made during a recommendation job.</p>
    pub fn variant_name(&self) -> std::option::Option<&str> {
        self.variant_name.as_deref()
    }
    /// <p>The instance type recommended by Amazon SageMaker Inference Recommender.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The number of instances recommended to launch initially.</p>
    pub fn initial_instance_count(&self) -> i32 {
        self.initial_instance_count
    }
}
impl std::fmt::Debug for EndpointOutputConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointOutputConfiguration");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("variant_name", &self.variant_name);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("initial_instance_count", &self.initial_instance_count);
        formatter.finish()
    }
}
/// See [`EndpointOutputConfiguration`](crate::model::EndpointOutputConfiguration)
pub mod endpoint_output_configuration {

    /// A builder for [`EndpointOutputConfiguration`](crate::model::EndpointOutputConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
        pub(crate) initial_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the endpoint made during a recommendation job.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint made during a recommendation job.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The name of the production variant (deployed model) made during a recommendation job.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        /// <p>The name of the production variant (deployed model) made during a recommendation job.</p>
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// <p>The instance type recommended by Amazon SageMaker Inference Recommender.</p>
        pub fn instance_type(mut self, input: crate::model::ProductionVariantInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type recommended by Amazon SageMaker Inference Recommender.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of instances recommended to launch initially.</p>
        pub fn initial_instance_count(mut self, input: i32) -> Self {
            self.initial_instance_count = Some(input);
            self
        }
        /// <p>The number of instances recommended to launch initially.</p>
        pub fn set_initial_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointOutputConfiguration`](crate::model::EndpointOutputConfiguration)
        pub fn build(self) -> crate::model::EndpointOutputConfiguration {
            crate::model::EndpointOutputConfiguration {
                endpoint_name: self.endpoint_name,
                variant_name: self.variant_name,
                instance_type: self.instance_type,
                initial_instance_count: self.initial_instance_count.unwrap_or_default(),
            }
        }
    }
}
impl EndpointOutputConfiguration {
    /// Creates a new builder-style object to manufacture [`EndpointOutputConfiguration`](crate::model::EndpointOutputConfiguration)
    pub fn builder() -> crate::model::endpoint_output_configuration::Builder {
        crate::model::endpoint_output_configuration::Builder::default()
    }
}

/// <p>The metrics of recommendations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationMetrics {
    /// <p>Defines the cost per hour for the instance. </p>
    pub cost_per_hour: f32,
    /// <p>Defines the cost per inference for the instance .</p>
    pub cost_per_inference: f32,
    /// <p>The expected maximum number of requests per minute for the instance.</p>
    pub max_invocations: i32,
    /// <p>The expected model latency at maximum invocation per minute for the instance.</p>
    pub model_latency: i32,
}
impl RecommendationMetrics {
    /// <p>Defines the cost per hour for the instance. </p>
    pub fn cost_per_hour(&self) -> f32 {
        self.cost_per_hour
    }
    /// <p>Defines the cost per inference for the instance .</p>
    pub fn cost_per_inference(&self) -> f32 {
        self.cost_per_inference
    }
    /// <p>The expected maximum number of requests per minute for the instance.</p>
    pub fn max_invocations(&self) -> i32 {
        self.max_invocations
    }
    /// <p>The expected model latency at maximum invocation per minute for the instance.</p>
    pub fn model_latency(&self) -> i32 {
        self.model_latency
    }
}
impl std::fmt::Debug for RecommendationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationMetrics");
        formatter.field("cost_per_hour", &self.cost_per_hour);
        formatter.field("cost_per_inference", &self.cost_per_inference);
        formatter.field("max_invocations", &self.max_invocations);
        formatter.field("model_latency", &self.model_latency);
        formatter.finish()
    }
}
/// See [`RecommendationMetrics`](crate::model::RecommendationMetrics)
pub mod recommendation_metrics {

    /// A builder for [`RecommendationMetrics`](crate::model::RecommendationMetrics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_per_hour: std::option::Option<f32>,
        pub(crate) cost_per_inference: std::option::Option<f32>,
        pub(crate) max_invocations: std::option::Option<i32>,
        pub(crate) model_latency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Defines the cost per hour for the instance. </p>
        pub fn cost_per_hour(mut self, input: f32) -> Self {
            self.cost_per_hour = Some(input);
            self
        }
        /// <p>Defines the cost per hour for the instance. </p>
        pub fn set_cost_per_hour(mut self, input: std::option::Option<f32>) -> Self {
            self.cost_per_hour = input;
            self
        }
        /// <p>Defines the cost per inference for the instance .</p>
        pub fn cost_per_inference(mut self, input: f32) -> Self {
            self.cost_per_inference = Some(input);
            self
        }
        /// <p>Defines the cost per inference for the instance .</p>
        pub fn set_cost_per_inference(mut self, input: std::option::Option<f32>) -> Self {
            self.cost_per_inference = input;
            self
        }
        /// <p>The expected maximum number of requests per minute for the instance.</p>
        pub fn max_invocations(mut self, input: i32) -> Self {
            self.max_invocations = Some(input);
            self
        }
        /// <p>The expected maximum number of requests per minute for the instance.</p>
        pub fn set_max_invocations(mut self, input: std::option::Option<i32>) -> Self {
            self.max_invocations = input;
            self
        }
        /// <p>The expected model latency at maximum invocation per minute for the instance.</p>
        pub fn model_latency(mut self, input: i32) -> Self {
            self.model_latency = Some(input);
            self
        }
        /// <p>The expected model latency at maximum invocation per minute for the instance.</p>
        pub fn set_model_latency(mut self, input: std::option::Option<i32>) -> Self {
            self.model_latency = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationMetrics`](crate::model::RecommendationMetrics)
        pub fn build(self) -> crate::model::RecommendationMetrics {
            crate::model::RecommendationMetrics {
                cost_per_hour: self.cost_per_hour.unwrap_or_default(),
                cost_per_inference: self.cost_per_inference.unwrap_or_default(),
                max_invocations: self.max_invocations.unwrap_or_default(),
                model_latency: self.model_latency.unwrap_or_default(),
            }
        }
    }
}
impl RecommendationMetrics {
    /// Creates a new builder-style object to manufacture [`RecommendationMetrics`](crate::model::RecommendationMetrics)
    pub fn builder() -> crate::model::recommendation_metrics::Builder {
        crate::model::recommendation_metrics::Builder::default()
    }
}

/// <p>Specifies conditions for stopping a job. When a job reaches a stopping condition limit, SageMaker ends the job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationJobStoppingConditions {
    /// <p>The maximum number of requests per minute expected for the endpoint.</p>
    pub max_invocations: i32,
    /// <p>The interval of time taken by a model to respond as viewed from SageMaker. The interval includes the local communication time taken to send the request and to fetch the response from the container of a model and the time taken to complete the inference in the container.</p>
    pub model_latency_thresholds:
        std::option::Option<std::vec::Vec<crate::model::ModelLatencyThreshold>>,
}
impl RecommendationJobStoppingConditions {
    /// <p>The maximum number of requests per minute expected for the endpoint.</p>
    pub fn max_invocations(&self) -> i32 {
        self.max_invocations
    }
    /// <p>The interval of time taken by a model to respond as viewed from SageMaker. The interval includes the local communication time taken to send the request and to fetch the response from the container of a model and the time taken to complete the inference in the container.</p>
    pub fn model_latency_thresholds(
        &self,
    ) -> std::option::Option<&[crate::model::ModelLatencyThreshold]> {
        self.model_latency_thresholds.as_deref()
    }
}
impl std::fmt::Debug for RecommendationJobStoppingConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationJobStoppingConditions");
        formatter.field("max_invocations", &self.max_invocations);
        formatter.field("model_latency_thresholds", &self.model_latency_thresholds);
        formatter.finish()
    }
}
/// See [`RecommendationJobStoppingConditions`](crate::model::RecommendationJobStoppingConditions)
pub mod recommendation_job_stopping_conditions {

    /// A builder for [`RecommendationJobStoppingConditions`](crate::model::RecommendationJobStoppingConditions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_invocations: std::option::Option<i32>,
        pub(crate) model_latency_thresholds:
            std::option::Option<std::vec::Vec<crate::model::ModelLatencyThreshold>>,
    }
    impl Builder {
        /// <p>The maximum number of requests per minute expected for the endpoint.</p>
        pub fn max_invocations(mut self, input: i32) -> Self {
            self.max_invocations = Some(input);
            self
        }
        /// <p>The maximum number of requests per minute expected for the endpoint.</p>
        pub fn set_max_invocations(mut self, input: std::option::Option<i32>) -> Self {
            self.max_invocations = input;
            self
        }
        /// Appends an item to `model_latency_thresholds`.
        ///
        /// To override the contents of this collection use [`set_model_latency_thresholds`](Self::set_model_latency_thresholds).
        ///
        /// <p>The interval of time taken by a model to respond as viewed from SageMaker. The interval includes the local communication time taken to send the request and to fetch the response from the container of a model and the time taken to complete the inference in the container.</p>
        pub fn model_latency_thresholds(
            mut self,
            input: crate::model::ModelLatencyThreshold,
        ) -> Self {
            let mut v = self.model_latency_thresholds.unwrap_or_default();
            v.push(input);
            self.model_latency_thresholds = Some(v);
            self
        }
        /// <p>The interval of time taken by a model to respond as viewed from SageMaker. The interval includes the local communication time taken to send the request and to fetch the response from the container of a model and the time taken to complete the inference in the container.</p>
        pub fn set_model_latency_thresholds(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelLatencyThreshold>>,
        ) -> Self {
            self.model_latency_thresholds = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationJobStoppingConditions`](crate::model::RecommendationJobStoppingConditions)
        pub fn build(self) -> crate::model::RecommendationJobStoppingConditions {
            crate::model::RecommendationJobStoppingConditions {
                max_invocations: self.max_invocations.unwrap_or_default(),
                model_latency_thresholds: self.model_latency_thresholds,
            }
        }
    }
}
impl RecommendationJobStoppingConditions {
    /// Creates a new builder-style object to manufacture [`RecommendationJobStoppingConditions`](crate::model::RecommendationJobStoppingConditions)
    pub fn builder() -> crate::model::recommendation_job_stopping_conditions::Builder {
        crate::model::recommendation_job_stopping_conditions::Builder::default()
    }
}

/// <p>The model latency threshold.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelLatencyThreshold {
    /// <p>The model latency percentile threshold.</p>
    pub percentile: std::option::Option<std::string::String>,
    /// <p>The model latency percentile value in milliseconds.</p>
    pub value_in_milliseconds: i32,
}
impl ModelLatencyThreshold {
    /// <p>The model latency percentile threshold.</p>
    pub fn percentile(&self) -> std::option::Option<&str> {
        self.percentile.as_deref()
    }
    /// <p>The model latency percentile value in milliseconds.</p>
    pub fn value_in_milliseconds(&self) -> i32 {
        self.value_in_milliseconds
    }
}
impl std::fmt::Debug for ModelLatencyThreshold {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelLatencyThreshold");
        formatter.field("percentile", &self.percentile);
        formatter.field("value_in_milliseconds", &self.value_in_milliseconds);
        formatter.finish()
    }
}
/// See [`ModelLatencyThreshold`](crate::model::ModelLatencyThreshold)
pub mod model_latency_threshold {

    /// A builder for [`ModelLatencyThreshold`](crate::model::ModelLatencyThreshold)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentile: std::option::Option<std::string::String>,
        pub(crate) value_in_milliseconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The model latency percentile threshold.</p>
        pub fn percentile(mut self, input: impl Into<std::string::String>) -> Self {
            self.percentile = Some(input.into());
            self
        }
        /// <p>The model latency percentile threshold.</p>
        pub fn set_percentile(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.percentile = input;
            self
        }
        /// <p>The model latency percentile value in milliseconds.</p>
        pub fn value_in_milliseconds(mut self, input: i32) -> Self {
            self.value_in_milliseconds = Some(input);
            self
        }
        /// <p>The model latency percentile value in milliseconds.</p>
        pub fn set_value_in_milliseconds(mut self, input: std::option::Option<i32>) -> Self {
            self.value_in_milliseconds = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelLatencyThreshold`](crate::model::ModelLatencyThreshold)
        pub fn build(self) -> crate::model::ModelLatencyThreshold {
            crate::model::ModelLatencyThreshold {
                percentile: self.percentile,
                value_in_milliseconds: self.value_in_milliseconds.unwrap_or_default(),
            }
        }
    }
}
impl ModelLatencyThreshold {
    /// Creates a new builder-style object to manufacture [`ModelLatencyThreshold`](crate::model::ModelLatencyThreshold)
    pub fn builder() -> crate::model::model_latency_threshold::Builder {
        crate::model::model_latency_threshold::Builder::default()
    }
}

/// <p>The input configuration of the recommendation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationJobInputConfig {
    /// <p>The Amazon Resource Name (ARN) of a versioned model package.</p>
    pub model_package_version_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the maximum duration of the job, in seconds.&gt;</p>
    pub job_duration_in_seconds: std::option::Option<i32>,
    /// <p>Specifies the traffic pattern of the job.</p>
    pub traffic_pattern: std::option::Option<crate::model::TrafficPattern>,
    /// <p>Defines the resource limit of the job.</p>
    pub resource_limit: std::option::Option<crate::model::RecommendationJobResourceLimit>,
    /// <p>Specifies the endpoint configuration to use for a job.</p>
    pub endpoint_configurations:
        std::option::Option<std::vec::Vec<crate::model::EndpointInputConfiguration>>,
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. This key will be passed to SageMaker Hosting for endpoint creation. </p>
    /// <p>The SageMaker execution role must have <code>kms:CreateGrant</code> permission in order to encrypt data on the storage volume of the endpoints created for inference recommendation. The inference recommendation job will fail asynchronously during endpoint configuration creation if the role passed does not have <code>kms:CreateGrant</code> permission.</p>
    /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :key/
    /// <key-id-12ab-34cd-56ef-1234567890ab>
    /// "
    /// </key-id-12ab-34cd-56ef-1234567890ab>
    /// </account>
    /// </region></code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :alias/
    /// <examplealias>
    /// "
    /// </examplealias>
    /// </account>
    /// </region></code> </p> </li>
    /// </ul>
    /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl RecommendationJobInputConfig {
    /// <p>The Amazon Resource Name (ARN) of a versioned model package.</p>
    pub fn model_package_version_arn(&self) -> std::option::Option<&str> {
        self.model_package_version_arn.as_deref()
    }
    /// <p>Specifies the maximum duration of the job, in seconds.&gt;</p>
    pub fn job_duration_in_seconds(&self) -> std::option::Option<i32> {
        self.job_duration_in_seconds
    }
    /// <p>Specifies the traffic pattern of the job.</p>
    pub fn traffic_pattern(&self) -> std::option::Option<&crate::model::TrafficPattern> {
        self.traffic_pattern.as_ref()
    }
    /// <p>Defines the resource limit of the job.</p>
    pub fn resource_limit(
        &self,
    ) -> std::option::Option<&crate::model::RecommendationJobResourceLimit> {
        self.resource_limit.as_ref()
    }
    /// <p>Specifies the endpoint configuration to use for a job.</p>
    pub fn endpoint_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::EndpointInputConfiguration]> {
        self.endpoint_configurations.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. This key will be passed to SageMaker Hosting for endpoint creation. </p>
    /// <p>The SageMaker execution role must have <code>kms:CreateGrant</code> permission in order to encrypt data on the storage volume of the endpoints created for inference recommendation. The inference recommendation job will fail asynchronously during endpoint configuration creation if the role passed does not have <code>kms:CreateGrant</code> permission.</p>
    /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :key/
    /// <key-id-12ab-34cd-56ef-1234567890ab>
    /// "
    /// </key-id-12ab-34cd-56ef-1234567890ab>
    /// </account>
    /// </region></code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :alias/
    /// <examplealias>
    /// "
    /// </examplealias>
    /// </account>
    /// </region></code> </p> </li>
    /// </ul>
    /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for RecommendationJobInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationJobInputConfig");
        formatter.field("model_package_version_arn", &self.model_package_version_arn);
        formatter.field("job_duration_in_seconds", &self.job_duration_in_seconds);
        formatter.field("traffic_pattern", &self.traffic_pattern);
        formatter.field("resource_limit", &self.resource_limit);
        formatter.field("endpoint_configurations", &self.endpoint_configurations);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`RecommendationJobInputConfig`](crate::model::RecommendationJobInputConfig)
pub mod recommendation_job_input_config {

    /// A builder for [`RecommendationJobInputConfig`](crate::model::RecommendationJobInputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_version_arn: std::option::Option<std::string::String>,
        pub(crate) job_duration_in_seconds: std::option::Option<i32>,
        pub(crate) traffic_pattern: std::option::Option<crate::model::TrafficPattern>,
        pub(crate) resource_limit:
            std::option::Option<crate::model::RecommendationJobResourceLimit>,
        pub(crate) endpoint_configurations:
            std::option::Option<std::vec::Vec<crate::model::EndpointInputConfiguration>>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a versioned model package.</p>
        pub fn model_package_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a versioned model package.</p>
        pub fn set_model_package_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_version_arn = input;
            self
        }
        /// <p>Specifies the maximum duration of the job, in seconds.&gt;</p>
        pub fn job_duration_in_seconds(mut self, input: i32) -> Self {
            self.job_duration_in_seconds = Some(input);
            self
        }
        /// <p>Specifies the maximum duration of the job, in seconds.&gt;</p>
        pub fn set_job_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.job_duration_in_seconds = input;
            self
        }
        /// <p>Specifies the traffic pattern of the job.</p>
        pub fn traffic_pattern(mut self, input: crate::model::TrafficPattern) -> Self {
            self.traffic_pattern = Some(input);
            self
        }
        /// <p>Specifies the traffic pattern of the job.</p>
        pub fn set_traffic_pattern(
            mut self,
            input: std::option::Option<crate::model::TrafficPattern>,
        ) -> Self {
            self.traffic_pattern = input;
            self
        }
        /// <p>Defines the resource limit of the job.</p>
        pub fn resource_limit(
            mut self,
            input: crate::model::RecommendationJobResourceLimit,
        ) -> Self {
            self.resource_limit = Some(input);
            self
        }
        /// <p>Defines the resource limit of the job.</p>
        pub fn set_resource_limit(
            mut self,
            input: std::option::Option<crate::model::RecommendationJobResourceLimit>,
        ) -> Self {
            self.resource_limit = input;
            self
        }
        /// Appends an item to `endpoint_configurations`.
        ///
        /// To override the contents of this collection use [`set_endpoint_configurations`](Self::set_endpoint_configurations).
        ///
        /// <p>Specifies the endpoint configuration to use for a job.</p>
        pub fn endpoint_configurations(
            mut self,
            input: crate::model::EndpointInputConfiguration,
        ) -> Self {
            let mut v = self.endpoint_configurations.unwrap_or_default();
            v.push(input);
            self.endpoint_configurations = Some(v);
            self
        }
        /// <p>Specifies the endpoint configuration to use for a job.</p>
        pub fn set_endpoint_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointInputConfiguration>>,
        ) -> Self {
            self.endpoint_configurations = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. This key will be passed to SageMaker Hosting for endpoint creation. </p>
        /// <p>The SageMaker execution role must have <code>kms:CreateGrant</code> permission in order to encrypt data on the storage volume of the endpoints created for inference recommendation. The inference recommendation job will fail asynchronously during endpoint configuration creation if the role passed does not have <code>kms:CreateGrant</code> permission.</p>
        /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :key/
        /// <key-id-12ab-34cd-56ef-1234567890ab>
        /// "
        /// </key-id-12ab-34cd-56ef-1234567890ab>
        /// </account>
        /// </region></code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :alias/
        /// <examplealias>
        /// "
        /// </examplealias>
        /// </account>
        /// </region></code> </p> </li>
        /// </ul>
        /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. This key will be passed to SageMaker Hosting for endpoint creation. </p>
        /// <p>The SageMaker execution role must have <code>kms:CreateGrant</code> permission in order to encrypt data on the storage volume of the endpoints created for inference recommendation. The inference recommendation job will fail asynchronously during endpoint configuration creation if the role passed does not have <code>kms:CreateGrant</code> permission.</p>
        /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :key/
        /// <key-id-12ab-34cd-56ef-1234567890ab>
        /// "
        /// </key-id-12ab-34cd-56ef-1234567890ab>
        /// </account>
        /// </region></code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :alias/
        /// <examplealias>
        /// "
        /// </examplealias>
        /// </account>
        /// </region></code> </p> </li>
        /// </ul>
        /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationJobInputConfig`](crate::model::RecommendationJobInputConfig)
        pub fn build(self) -> crate::model::RecommendationJobInputConfig {
            crate::model::RecommendationJobInputConfig {
                model_package_version_arn: self.model_package_version_arn,
                job_duration_in_seconds: self.job_duration_in_seconds,
                traffic_pattern: self.traffic_pattern,
                resource_limit: self.resource_limit,
                endpoint_configurations: self.endpoint_configurations,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl RecommendationJobInputConfig {
    /// Creates a new builder-style object to manufacture [`RecommendationJobInputConfig`](crate::model::RecommendationJobInputConfig)
    pub fn builder() -> crate::model::recommendation_job_input_config::Builder {
        crate::model::recommendation_job_input_config::Builder::default()
    }
}

/// <p>The endpoint configuration for the load test.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointInputConfiguration {
    /// <p>The instance types to use for the load test.</p>
    pub instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
    /// <p>The inference specification name in the model package version.</p>
    pub inference_specification_name: std::option::Option<std::string::String>,
    /// <p> The parameter you want to benchmark against.</p>
    pub environment_parameter_ranges: std::option::Option<crate::model::EnvironmentParameterRanges>,
}
impl EndpointInputConfiguration {
    /// <p>The instance types to use for the load test.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The inference specification name in the model package version.</p>
    pub fn inference_specification_name(&self) -> std::option::Option<&str> {
        self.inference_specification_name.as_deref()
    }
    /// <p> The parameter you want to benchmark against.</p>
    pub fn environment_parameter_ranges(
        &self,
    ) -> std::option::Option<&crate::model::EnvironmentParameterRanges> {
        self.environment_parameter_ranges.as_ref()
    }
}
impl std::fmt::Debug for EndpointInputConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointInputConfiguration");
        formatter.field("instance_type", &self.instance_type);
        formatter.field(
            "inference_specification_name",
            &self.inference_specification_name,
        );
        formatter.field(
            "environment_parameter_ranges",
            &self.environment_parameter_ranges,
        );
        formatter.finish()
    }
}
/// See [`EndpointInputConfiguration`](crate::model::EndpointInputConfiguration)
pub mod endpoint_input_configuration {

    /// A builder for [`EndpointInputConfiguration`](crate::model::EndpointInputConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
        pub(crate) inference_specification_name: std::option::Option<std::string::String>,
        pub(crate) environment_parameter_ranges:
            std::option::Option<crate::model::EnvironmentParameterRanges>,
    }
    impl Builder {
        /// <p>The instance types to use for the load test.</p>
        pub fn instance_type(mut self, input: crate::model::ProductionVariantInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance types to use for the load test.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The inference specification name in the model package version.</p>
        pub fn inference_specification_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inference_specification_name = Some(input.into());
            self
        }
        /// <p>The inference specification name in the model package version.</p>
        pub fn set_inference_specification_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inference_specification_name = input;
            self
        }
        /// <p> The parameter you want to benchmark against.</p>
        pub fn environment_parameter_ranges(
            mut self,
            input: crate::model::EnvironmentParameterRanges,
        ) -> Self {
            self.environment_parameter_ranges = Some(input);
            self
        }
        /// <p> The parameter you want to benchmark against.</p>
        pub fn set_environment_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::EnvironmentParameterRanges>,
        ) -> Self {
            self.environment_parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointInputConfiguration`](crate::model::EndpointInputConfiguration)
        pub fn build(self) -> crate::model::EndpointInputConfiguration {
            crate::model::EndpointInputConfiguration {
                instance_type: self.instance_type,
                inference_specification_name: self.inference_specification_name,
                environment_parameter_ranges: self.environment_parameter_ranges,
            }
        }
    }
}
impl EndpointInputConfiguration {
    /// Creates a new builder-style object to manufacture [`EndpointInputConfiguration`](crate::model::EndpointInputConfiguration)
    pub fn builder() -> crate::model::endpoint_input_configuration::Builder {
        crate::model::endpoint_input_configuration::Builder::default()
    }
}

/// <p>Specifies the range of environment parameters</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentParameterRanges {
    /// <p>Specified a list of parameters for each category.</p>
    pub categorical_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::CategoricalParameter>>,
}
impl EnvironmentParameterRanges {
    /// <p>Specified a list of parameters for each category.</p>
    pub fn categorical_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::CategoricalParameter]> {
        self.categorical_parameter_ranges.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentParameterRanges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentParameterRanges");
        formatter.field(
            "categorical_parameter_ranges",
            &self.categorical_parameter_ranges,
        );
        formatter.finish()
    }
}
/// See [`EnvironmentParameterRanges`](crate::model::EnvironmentParameterRanges)
pub mod environment_parameter_ranges {

    /// A builder for [`EnvironmentParameterRanges`](crate::model::EnvironmentParameterRanges)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) categorical_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::CategoricalParameter>>,
    }
    impl Builder {
        /// Appends an item to `categorical_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_categorical_parameter_ranges`](Self::set_categorical_parameter_ranges).
        ///
        /// <p>Specified a list of parameters for each category.</p>
        pub fn categorical_parameter_ranges(
            mut self,
            input: crate::model::CategoricalParameter,
        ) -> Self {
            let mut v = self.categorical_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.categorical_parameter_ranges = Some(v);
            self
        }
        /// <p>Specified a list of parameters for each category.</p>
        pub fn set_categorical_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CategoricalParameter>>,
        ) -> Self {
            self.categorical_parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentParameterRanges`](crate::model::EnvironmentParameterRanges)
        pub fn build(self) -> crate::model::EnvironmentParameterRanges {
            crate::model::EnvironmentParameterRanges {
                categorical_parameter_ranges: self.categorical_parameter_ranges,
            }
        }
    }
}
impl EnvironmentParameterRanges {
    /// Creates a new builder-style object to manufacture [`EnvironmentParameterRanges`](crate::model::EnvironmentParameterRanges)
    pub fn builder() -> crate::model::environment_parameter_ranges::Builder {
        crate::model::environment_parameter_ranges::Builder::default()
    }
}

/// <p>Environment parameters you want to benchmark your load test against.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoricalParameter {
    /// <p>The Name of the environment variable.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The list of values you can pass.</p>
    pub value: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CategoricalParameter {
    /// <p>The Name of the environment variable.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The list of values you can pass.</p>
    pub fn value(&self) -> std::option::Option<&[std::string::String]> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for CategoricalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoricalParameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CategoricalParameter`](crate::model::CategoricalParameter)
pub mod categorical_parameter {

    /// A builder for [`CategoricalParameter`](crate::model::CategoricalParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Name of the environment variable.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The Name of the environment variable.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `value`.
        ///
        /// To override the contents of this collection use [`set_value`](Self::set_value).
        ///
        /// <p>The list of values you can pass.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value.unwrap_or_default();
            v.push(input.into());
            self.value = Some(v);
            self
        }
        /// <p>The list of values you can pass.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameter`](crate::model::CategoricalParameter)
        pub fn build(self) -> crate::model::CategoricalParameter {
            crate::model::CategoricalParameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl CategoricalParameter {
    /// Creates a new builder-style object to manufacture [`CategoricalParameter`](crate::model::CategoricalParameter)
    pub fn builder() -> crate::model::categorical_parameter::Builder {
        crate::model::categorical_parameter::Builder::default()
    }
}

/// <p>Specifies the maximum number of jobs that can run in parallel and the maximum number of jobs that can run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationJobResourceLimit {
    /// <p>Defines the maximum number of load tests.</p>
    pub max_number_of_tests: std::option::Option<i32>,
    /// <p>Defines the maximum number of parallel load tests.</p>
    pub max_parallel_of_tests: std::option::Option<i32>,
}
impl RecommendationJobResourceLimit {
    /// <p>Defines the maximum number of load tests.</p>
    pub fn max_number_of_tests(&self) -> std::option::Option<i32> {
        self.max_number_of_tests
    }
    /// <p>Defines the maximum number of parallel load tests.</p>
    pub fn max_parallel_of_tests(&self) -> std::option::Option<i32> {
        self.max_parallel_of_tests
    }
}
impl std::fmt::Debug for RecommendationJobResourceLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationJobResourceLimit");
        formatter.field("max_number_of_tests", &self.max_number_of_tests);
        formatter.field("max_parallel_of_tests", &self.max_parallel_of_tests);
        formatter.finish()
    }
}
/// See [`RecommendationJobResourceLimit`](crate::model::RecommendationJobResourceLimit)
pub mod recommendation_job_resource_limit {

    /// A builder for [`RecommendationJobResourceLimit`](crate::model::RecommendationJobResourceLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_number_of_tests: std::option::Option<i32>,
        pub(crate) max_parallel_of_tests: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Defines the maximum number of load tests.</p>
        pub fn max_number_of_tests(mut self, input: i32) -> Self {
            self.max_number_of_tests = Some(input);
            self
        }
        /// <p>Defines the maximum number of load tests.</p>
        pub fn set_max_number_of_tests(mut self, input: std::option::Option<i32>) -> Self {
            self.max_number_of_tests = input;
            self
        }
        /// <p>Defines the maximum number of parallel load tests.</p>
        pub fn max_parallel_of_tests(mut self, input: i32) -> Self {
            self.max_parallel_of_tests = Some(input);
            self
        }
        /// <p>Defines the maximum number of parallel load tests.</p>
        pub fn set_max_parallel_of_tests(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parallel_of_tests = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationJobResourceLimit`](crate::model::RecommendationJobResourceLimit)
        pub fn build(self) -> crate::model::RecommendationJobResourceLimit {
            crate::model::RecommendationJobResourceLimit {
                max_number_of_tests: self.max_number_of_tests,
                max_parallel_of_tests: self.max_parallel_of_tests,
            }
        }
    }
}
impl RecommendationJobResourceLimit {
    /// Creates a new builder-style object to manufacture [`RecommendationJobResourceLimit`](crate::model::RecommendationJobResourceLimit)
    pub fn builder() -> crate::model::recommendation_job_resource_limit::Builder {
        crate::model::recommendation_job_resource_limit::Builder::default()
    }
}

/// <p>Defines the traffic pattern of the load test.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficPattern {
    /// <p>Defines the traffic patterns.</p>
    pub traffic_type: std::option::Option<crate::model::TrafficType>,
    /// <p>Defines the phases traffic specification.</p>
    pub phases: std::option::Option<std::vec::Vec<crate::model::Phase>>,
}
impl TrafficPattern {
    /// <p>Defines the traffic patterns.</p>
    pub fn traffic_type(&self) -> std::option::Option<&crate::model::TrafficType> {
        self.traffic_type.as_ref()
    }
    /// <p>Defines the phases traffic specification.</p>
    pub fn phases(&self) -> std::option::Option<&[crate::model::Phase]> {
        self.phases.as_deref()
    }
}
impl std::fmt::Debug for TrafficPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficPattern");
        formatter.field("traffic_type", &self.traffic_type);
        formatter.field("phases", &self.phases);
        formatter.finish()
    }
}
/// See [`TrafficPattern`](crate::model::TrafficPattern)
pub mod traffic_pattern {

    /// A builder for [`TrafficPattern`](crate::model::TrafficPattern)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_type: std::option::Option<crate::model::TrafficType>,
        pub(crate) phases: std::option::Option<std::vec::Vec<crate::model::Phase>>,
    }
    impl Builder {
        /// <p>Defines the traffic patterns.</p>
        pub fn traffic_type(mut self, input: crate::model::TrafficType) -> Self {
            self.traffic_type = Some(input);
            self
        }
        /// <p>Defines the traffic patterns.</p>
        pub fn set_traffic_type(
            mut self,
            input: std::option::Option<crate::model::TrafficType>,
        ) -> Self {
            self.traffic_type = input;
            self
        }
        /// Appends an item to `phases`.
        ///
        /// To override the contents of this collection use [`set_phases`](Self::set_phases).
        ///
        /// <p>Defines the phases traffic specification.</p>
        pub fn phases(mut self, input: crate::model::Phase) -> Self {
            let mut v = self.phases.unwrap_or_default();
            v.push(input);
            self.phases = Some(v);
            self
        }
        /// <p>Defines the phases traffic specification.</p>
        pub fn set_phases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Phase>>,
        ) -> Self {
            self.phases = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficPattern`](crate::model::TrafficPattern)
        pub fn build(self) -> crate::model::TrafficPattern {
            crate::model::TrafficPattern {
                traffic_type: self.traffic_type,
                phases: self.phases,
            }
        }
    }
}
impl TrafficPattern {
    /// Creates a new builder-style object to manufacture [`TrafficPattern`](crate::model::TrafficPattern)
    pub fn builder() -> crate::model::traffic_pattern::Builder {
        crate::model::traffic_pattern::Builder::default()
    }
}

/// <p>Defines the traffic pattern.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase {
    /// <p>Specifies how many concurrent users to start with.</p>
    pub initial_number_of_users: std::option::Option<i32>,
    /// <p>Specified how many new users to spawn in a minute.</p>
    pub spawn_rate: std::option::Option<i32>,
    /// <p>Specifies how long traffic phase should be.</p>
    pub duration_in_seconds: std::option::Option<i32>,
}
impl Phase {
    /// <p>Specifies how many concurrent users to start with.</p>
    pub fn initial_number_of_users(&self) -> std::option::Option<i32> {
        self.initial_number_of_users
    }
    /// <p>Specified how many new users to spawn in a minute.</p>
    pub fn spawn_rate(&self) -> std::option::Option<i32> {
        self.spawn_rate
    }
    /// <p>Specifies how long traffic phase should be.</p>
    pub fn duration_in_seconds(&self) -> std::option::Option<i32> {
        self.duration_in_seconds
    }
}
impl std::fmt::Debug for Phase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase");
        formatter.field("initial_number_of_users", &self.initial_number_of_users);
        formatter.field("spawn_rate", &self.spawn_rate);
        formatter.field("duration_in_seconds", &self.duration_in_seconds);
        formatter.finish()
    }
}
/// See [`Phase`](crate::model::Phase)
pub mod phase {

    /// A builder for [`Phase`](crate::model::Phase)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_number_of_users: std::option::Option<i32>,
        pub(crate) spawn_rate: std::option::Option<i32>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies how many concurrent users to start with.</p>
        pub fn initial_number_of_users(mut self, input: i32) -> Self {
            self.initial_number_of_users = Some(input);
            self
        }
        /// <p>Specifies how many concurrent users to start with.</p>
        pub fn set_initial_number_of_users(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_number_of_users = input;
            self
        }
        /// <p>Specified how many new users to spawn in a minute.</p>
        pub fn spawn_rate(mut self, input: i32) -> Self {
            self.spawn_rate = Some(input);
            self
        }
        /// <p>Specified how many new users to spawn in a minute.</p>
        pub fn set_spawn_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.spawn_rate = input;
            self
        }
        /// <p>Specifies how long traffic phase should be.</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>Specifies how long traffic phase should be.</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase`](crate::model::Phase)
        pub fn build(self) -> crate::model::Phase {
            crate::model::Phase {
                initial_number_of_users: self.initial_number_of_users,
                spawn_rate: self.spawn_rate,
                duration_in_seconds: self.duration_in_seconds,
            }
        }
    }
}
impl Phase {
    /// Creates a new builder-style object to manufacture [`Phase`](crate::model::Phase)
    pub fn builder() -> crate::model::phase::Builder {
        crate::model::phase::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficType {
    #[allow(missing_docs)] // documentation missing in model
    Phases,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficType {
    fn from(s: &str) -> Self {
        match s {
            "PHASES" => TrafficType::Phases,
            other => TrafficType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficType::from(s))
    }
}
impl TrafficType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrafficType::Phases => "PHASES",
            TrafficType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PHASES"]
    }
}
impl AsRef<str> for TrafficType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the configuration for a hyperparameter tuning job that uses one or more previous hyperparameter tuning jobs as a starting point. The results of previous tuning jobs are used to inform which combinations of hyperparameters to search over in the new tuning job.</p>
/// <p>All training jobs launched by the new hyperparameter tuning job are evaluated by using the objective metric, and the training job that performs the best is compared to the best training jobs from the parent tuning jobs. From these, the training job that performs the best as measured by the objective metric is returned as the overall best training job.</p> <note>
/// <p>All training jobs launched by parent hyperparameter tuning jobs and the new hyperparameter tuning jobs count against the limit of training jobs for the tuning job.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobWarmStartConfig {
    /// <p>An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-warm-start.html">Using a Previous Hyperparameter Tuning Job as a Starting Point</a>.</p>
    /// <p>Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.</p>
    pub parent_hyper_parameter_tuning_jobs:
        std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
    /// <p>Specifies one of the following:</p>
    /// <dl>
    /// <dt>
    /// IDENTICAL_DATA_AND_ALGORITHM
    /// </dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
    /// </dd>
    /// <dt>
    /// TRANSFER_LEARNING
    /// </dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
    /// </dd>
    /// </dl>
    pub warm_start_type: std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
}
impl HyperParameterTuningJobWarmStartConfig {
    /// <p>An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-warm-start.html">Using a Previous Hyperparameter Tuning Job as a Starting Point</a>.</p>
    /// <p>Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.</p>
    pub fn parent_hyper_parameter_tuning_jobs(
        &self,
    ) -> std::option::Option<&[crate::model::ParentHyperParameterTuningJob]> {
        self.parent_hyper_parameter_tuning_jobs.as_deref()
    }
    /// <p>Specifies one of the following:</p>
    /// <dl>
    /// <dt>
    /// IDENTICAL_DATA_AND_ALGORITHM
    /// </dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
    /// </dd>
    /// <dt>
    /// TRANSFER_LEARNING
    /// </dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
    /// </dd>
    /// </dl>
    pub fn warm_start_type(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobWarmStartType> {
        self.warm_start_type.as_ref()
    }
}
impl std::fmt::Debug for HyperParameterTuningJobWarmStartConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobWarmStartConfig");
        formatter.field(
            "parent_hyper_parameter_tuning_jobs",
            &self.parent_hyper_parameter_tuning_jobs,
        );
        formatter.field("warm_start_type", &self.warm_start_type);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
pub mod hyper_parameter_tuning_job_warm_start_config {

    /// A builder for [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parent_hyper_parameter_tuning_jobs:
            std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
        pub(crate) warm_start_type:
            std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
    }
    impl Builder {
        /// Appends an item to `parent_hyper_parameter_tuning_jobs`.
        ///
        /// To override the contents of this collection use [`set_parent_hyper_parameter_tuning_jobs`](Self::set_parent_hyper_parameter_tuning_jobs).
        ///
        /// <p>An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-warm-start.html">Using a Previous Hyperparameter Tuning Job as a Starting Point</a>.</p>
        /// <p>Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.</p>
        pub fn parent_hyper_parameter_tuning_jobs(
            mut self,
            input: crate::model::ParentHyperParameterTuningJob,
        ) -> Self {
            let mut v = self.parent_hyper_parameter_tuning_jobs.unwrap_or_default();
            v.push(input);
            self.parent_hyper_parameter_tuning_jobs = Some(v);
            self
        }
        /// <p>An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-warm-start.html">Using a Previous Hyperparameter Tuning Job as a Starting Point</a>.</p>
        /// <p>Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.</p>
        pub fn set_parent_hyper_parameter_tuning_jobs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
        ) -> Self {
            self.parent_hyper_parameter_tuning_jobs = input;
            self
        }
        /// <p>Specifies one of the following:</p>
        /// <dl>
        /// <dt>
        /// IDENTICAL_DATA_AND_ALGORITHM
        /// </dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
        /// </dd>
        /// <dt>
        /// TRANSFER_LEARNING
        /// </dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
        /// </dd>
        /// </dl>
        pub fn warm_start_type(
            mut self,
            input: crate::model::HyperParameterTuningJobWarmStartType,
        ) -> Self {
            self.warm_start_type = Some(input);
            self
        }
        /// <p>Specifies one of the following:</p>
        /// <dl>
        /// <dt>
        /// IDENTICAL_DATA_AND_ALGORITHM
        /// </dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
        /// </dd>
        /// <dt>
        /// TRANSFER_LEARNING
        /// </dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.</p>
        /// </dd>
        /// </dl>
        pub fn set_warm_start_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
        ) -> Self {
            self.warm_start_type = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
        pub fn build(self) -> crate::model::HyperParameterTuningJobWarmStartConfig {
            crate::model::HyperParameterTuningJobWarmStartConfig {
                parent_hyper_parameter_tuning_jobs: self.parent_hyper_parameter_tuning_jobs,
                warm_start_type: self.warm_start_type,
            }
        }
    }
}
impl HyperParameterTuningJobWarmStartConfig {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_warm_start_config::Builder {
        crate::model::hyper_parameter_tuning_job_warm_start_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobWarmStartType {
    #[allow(missing_docs)] // documentation missing in model
    IdenticalDataAndAlgorithm,
    #[allow(missing_docs)] // documentation missing in model
    TransferLearning,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobWarmStartType {
    fn from(s: &str) -> Self {
        match s {
            "IdenticalDataAndAlgorithm" => {
                HyperParameterTuningJobWarmStartType::IdenticalDataAndAlgorithm
            }
            "TransferLearning" => HyperParameterTuningJobWarmStartType::TransferLearning,
            other => HyperParameterTuningJobWarmStartType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobWarmStartType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobWarmStartType::from(s))
    }
}
impl HyperParameterTuningJobWarmStartType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobWarmStartType::IdenticalDataAndAlgorithm => {
                "IdenticalDataAndAlgorithm"
            }
            HyperParameterTuningJobWarmStartType::TransferLearning => "TransferLearning",
            HyperParameterTuningJobWarmStartType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["IdenticalDataAndAlgorithm", "TransferLearning"]
    }
}
impl AsRef<str> for HyperParameterTuningJobWarmStartType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A previously completed or stopped hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentHyperParameterTuningJob {
    /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.</p>
    pub hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
}
impl ParentHyperParameterTuningJob {
    /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.</p>
    pub fn hyper_parameter_tuning_job_name(&self) -> std::option::Option<&str> {
        self.hyper_parameter_tuning_job_name.as_deref()
    }
}
impl std::fmt::Debug for ParentHyperParameterTuningJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentHyperParameterTuningJob");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.finish()
    }
}
/// See [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
pub mod parent_hyper_parameter_tuning_job {

    /// A builder for [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.</p>
        pub fn hyper_parameter_tuning_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = Some(input.into());
            self
        }
        /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.</p>
        pub fn set_hyper_parameter_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
        pub fn build(self) -> crate::model::ParentHyperParameterTuningJob {
            crate::model::ParentHyperParameterTuningJob {
                hyper_parameter_tuning_job_name: self.hyper_parameter_tuning_job_name,
            }
        }
    }
}
impl ParentHyperParameterTuningJob {
    /// Creates a new builder-style object to manufacture [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
    pub fn builder() -> crate::model::parent_hyper_parameter_tuning_job::Builder {
        crate::model::parent_hyper_parameter_tuning_job::Builder::default()
    }
}

/// <p>Defines the training jobs launched by a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTrainingJobDefinition {
    /// <p>The job definition name.</p>
    pub definition_name: std::option::Option<std::string::String>,
    /// <p>Defines the objective metric for a hyperparameter tuning job. Hyperparameter tuning uses the value of this metric to evaluate the training jobs it launches, and returns the training job that results in either the highest or lowest value for this metric, depending on the value you specify for the <code>Type</code> parameter.</p>
    pub tuning_objective: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
    /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs with hyperparameter values within these ranges to find the combination of values that result in the training job with the best performance as measured by the objective metric of the hyperparameter tuning job.</p> <note>
    /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job can search over. Every possible value of a categorical parameter range counts against this limit.</p>
    /// </note>
    pub hyper_parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
    /// <p>Specifies the values of hyperparameters that do not change for the tuning job.</p>
    pub static_hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The <code>HyperParameterAlgorithmSpecification</code> object that specifies the resource algorithm to use for the training jobs that the tuning job launches.</p>
    pub algorithm_specification:
        std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An array of <code>Channel</code> objects that specify the input for the training jobs that the tuning job launches.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>The <code>VpcConfig</code> object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches.</p>
    /// <p>Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want SageMaker to use the storage volume to store the training data, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.</p>
    pub enable_network_isolation: bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or not (<code>False</code>).</p>
    pub enable_managed_spot_training: bool,
    /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
    pub checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
    /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
    pub retry_strategy: std::option::Option<crate::model::RetryStrategy>,
}
impl HyperParameterTrainingJobDefinition {
    /// <p>The job definition name.</p>
    pub fn definition_name(&self) -> std::option::Option<&str> {
        self.definition_name.as_deref()
    }
    /// <p>Defines the objective metric for a hyperparameter tuning job. Hyperparameter tuning uses the value of this metric to evaluate the training jobs it launches, and returns the training job that results in either the highest or lowest value for this metric, depending on the value you specify for the <code>Type</code> parameter.</p>
    pub fn tuning_objective(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobObjective> {
        self.tuning_objective.as_ref()
    }
    /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs with hyperparameter values within these ranges to find the combination of values that result in the training job with the best performance as measured by the objective metric of the hyperparameter tuning job.</p> <note>
    /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job can search over. Every possible value of a categorical parameter range counts against this limit.</p>
    /// </note>
    pub fn hyper_parameter_ranges(&self) -> std::option::Option<&crate::model::ParameterRanges> {
        self.hyper_parameter_ranges.as_ref()
    }
    /// <p>Specifies the values of hyperparameters that do not change for the tuning job.</p>
    pub fn static_hyper_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.static_hyper_parameters.as_ref()
    }
    /// <p>The <code>HyperParameterAlgorithmSpecification</code> object that specifies the resource algorithm to use for the training jobs that the tuning job launches.</p>
    pub fn algorithm_specification(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterAlgorithmSpecification> {
        self.algorithm_specification.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>An array of <code>Channel</code> objects that specify the input for the training jobs that the tuning job launches.</p>
    pub fn input_data_config(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.input_data_config.as_deref()
    }
    /// <p>The <code>VpcConfig</code> object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches.</p>
    /// <p>Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want SageMaker to use the storage volume to store the training data, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.</p>
    pub fn resource_config(&self) -> std::option::Option<&crate::model::ResourceConfig> {
        self.resource_config.as_ref()
    }
    /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    pub fn stopping_condition(&self) -> std::option::Option<&crate::model::StoppingCondition> {
        self.stopping_condition.as_ref()
    }
    /// <p>Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.</p>
    pub fn enable_network_isolation(&self) -> bool {
        self.enable_network_isolation
    }
    /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
    pub fn enable_inter_container_traffic_encryption(&self) -> bool {
        self.enable_inter_container_traffic_encryption
    }
    /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or not (<code>False</code>).</p>
    pub fn enable_managed_spot_training(&self) -> bool {
        self.enable_managed_spot_training
    }
    /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
    pub fn checkpoint_config(&self) -> std::option::Option<&crate::model::CheckpointConfig> {
        self.checkpoint_config.as_ref()
    }
    /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
    pub fn retry_strategy(&self) -> std::option::Option<&crate::model::RetryStrategy> {
        self.retry_strategy.as_ref()
    }
}
impl std::fmt::Debug for HyperParameterTrainingJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTrainingJobDefinition");
        formatter.field("definition_name", &self.definition_name);
        formatter.field("tuning_objective", &self.tuning_objective);
        formatter.field("hyper_parameter_ranges", &self.hyper_parameter_ranges);
        formatter.field("static_hyper_parameters", &self.static_hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.finish()
    }
}
/// See [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
pub mod hyper_parameter_training_job_definition {

    /// A builder for [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition_name: std::option::Option<std::string::String>,
        pub(crate) tuning_objective:
            std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        pub(crate) hyper_parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
        pub(crate) static_hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) algorithm_specification:
            std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_managed_spot_training: std::option::Option<bool>,
        pub(crate) checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
        pub(crate) retry_strategy: std::option::Option<crate::model::RetryStrategy>,
    }
    impl Builder {
        /// <p>The job definition name.</p>
        pub fn definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.definition_name = Some(input.into());
            self
        }
        /// <p>The job definition name.</p>
        pub fn set_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.definition_name = input;
            self
        }
        /// <p>Defines the objective metric for a hyperparameter tuning job. Hyperparameter tuning uses the value of this metric to evaluate the training jobs it launches, and returns the training job that results in either the highest or lowest value for this metric, depending on the value you specify for the <code>Type</code> parameter.</p>
        pub fn tuning_objective(
            mut self,
            input: crate::model::HyperParameterTuningJobObjective,
        ) -> Self {
            self.tuning_objective = Some(input);
            self
        }
        /// <p>Defines the objective metric for a hyperparameter tuning job. Hyperparameter tuning uses the value of this metric to evaluate the training jobs it launches, and returns the training job that results in either the highest or lowest value for this metric, depending on the value you specify for the <code>Type</code> parameter.</p>
        pub fn set_tuning_objective(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        ) -> Self {
            self.tuning_objective = input;
            self
        }
        /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs with hyperparameter values within these ranges to find the combination of values that result in the training job with the best performance as measured by the objective metric of the hyperparameter tuning job.</p> <note>
        /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job can search over. Every possible value of a categorical parameter range counts against this limit.</p>
        /// </note>
        pub fn hyper_parameter_ranges(mut self, input: crate::model::ParameterRanges) -> Self {
            self.hyper_parameter_ranges = Some(input);
            self
        }
        /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs with hyperparameter values within these ranges to find the combination of values that result in the training job with the best performance as measured by the objective metric of the hyperparameter tuning job.</p> <note>
        /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job can search over. Every possible value of a categorical parameter range counts against this limit.</p>
        /// </note>
        pub fn set_hyper_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::ParameterRanges>,
        ) -> Self {
            self.hyper_parameter_ranges = input;
            self
        }
        /// Adds a key-value pair to `static_hyper_parameters`.
        ///
        /// To override the contents of this collection use [`set_static_hyper_parameters`](Self::set_static_hyper_parameters).
        ///
        /// <p>Specifies the values of hyperparameters that do not change for the tuning job.</p>
        pub fn static_hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.static_hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.static_hyper_parameters = Some(hash_map);
            self
        }
        /// <p>Specifies the values of hyperparameters that do not change for the tuning job.</p>
        pub fn set_static_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.static_hyper_parameters = input;
            self
        }
        /// <p>The <code>HyperParameterAlgorithmSpecification</code> object that specifies the resource algorithm to use for the training jobs that the tuning job launches.</p>
        pub fn algorithm_specification(
            mut self,
            input: crate::model::HyperParameterAlgorithmSpecification,
        ) -> Self {
            self.algorithm_specification = Some(input);
            self
        }
        /// <p>The <code>HyperParameterAlgorithmSpecification</code> object that specifies the resource algorithm to use for the training jobs that the tuning job launches.</p>
        pub fn set_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
        ) -> Self {
            self.algorithm_specification = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Appends an item to `input_data_config`.
        ///
        /// To override the contents of this collection use [`set_input_data_config`](Self::set_input_data_config).
        ///
        /// <p>An array of <code>Channel</code> objects that specify the input for the training jobs that the tuning job launches.</p>
        pub fn input_data_config(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input);
            self.input_data_config = Some(v);
            self
        }
        /// <p>An array of <code>Channel</code> objects that specify the input for the training jobs that the tuning job launches.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The <code>VpcConfig</code> object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>The <code>VpcConfig</code> object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches.</p>
        /// <p>Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want SageMaker to use the storage volume to store the training data, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        /// <p>The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches.</p>
        /// <p>Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want SageMaker to use the storage volume to store the training data, choose <code>File</code> as the <code>TrainingInputMode</code> in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.</p>
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        /// <p>Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.</p>
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training, choose <code>True</code>. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.</p>
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or not (<code>False</code>).</p>
        pub fn enable_managed_spot_training(mut self, input: bool) -> Self {
            self.enable_managed_spot_training = Some(input);
            self
        }
        /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or not (<code>False</code>).</p>
        pub fn set_enable_managed_spot_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_managed_spot_training = input;
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
        pub fn checkpoint_config(mut self, input: crate::model::CheckpointConfig) -> Self {
            self.checkpoint_config = Some(input);
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint data. </p>
        pub fn set_checkpoint_config(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfig>,
        ) -> Self {
            self.checkpoint_config = input;
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
        pub fn retry_strategy(mut self, input: crate::model::RetryStrategy) -> Self {
            self.retry_strategy = Some(input);
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an <code>InternalServerError</code>.</p>
        pub fn set_retry_strategy(
            mut self,
            input: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.retry_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
        pub fn build(self) -> crate::model::HyperParameterTrainingJobDefinition {
            crate::model::HyperParameterTrainingJobDefinition {
                definition_name: self.definition_name,
                tuning_objective: self.tuning_objective,
                hyper_parameter_ranges: self.hyper_parameter_ranges,
                static_hyper_parameters: self.static_hyper_parameters,
                algorithm_specification: self.algorithm_specification,
                role_arn: self.role_arn,
                input_data_config: self.input_data_config,
                vpc_config: self.vpc_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                stopping_condition: self.stopping_condition,
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_managed_spot_training: self.enable_managed_spot_training.unwrap_or_default(),
                checkpoint_config: self.checkpoint_config,
                retry_strategy: self.retry_strategy,
            }
        }
    }
}
impl HyperParameterTrainingJobDefinition {
    /// Creates a new builder-style object to manufacture [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
    pub fn builder() -> crate::model::hyper_parameter_training_job_definition::Builder {
        crate::model::hyper_parameter_training_job_definition::Builder::default()
    }
}

/// <p>Specifies which training algorithm to use for training jobs that a hyperparameter tuning job launches and the metrics to monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterAlgorithmSpecification {
    /// <p> The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms Provided by Amazon SageMaker: Common Parameters</a>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for <code>TrainingImage</code>.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>An array of <code>MetricDefinition</code> objects that specify the metrics that the algorithm emits.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
}
impl HyperParameterAlgorithmSpecification {
    /// <p> The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms Provided by Amazon SageMaker: Common Parameters</a>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
    pub fn training_image(&self) -> std::option::Option<&str> {
        self.training_image.as_deref()
    }
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub fn training_input_mode(&self) -> std::option::Option<&crate::model::TrainingInputMode> {
        self.training_input_mode.as_ref()
    }
    /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for <code>TrainingImage</code>.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&str> {
        self.algorithm_name.as_deref()
    }
    /// <p>An array of <code>MetricDefinition</code> objects that specify the metrics that the algorithm emits.</p>
    pub fn metric_definitions(&self) -> std::option::Option<&[crate::model::MetricDefinition]> {
        self.metric_definitions.as_deref()
    }
}
impl std::fmt::Debug for HyperParameterAlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterAlgorithmSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.finish()
    }
}
/// See [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
pub mod hyper_parameter_algorithm_specification {

    /// A builder for [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    }
    impl Builder {
        /// <p> The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms Provided by Amazon SageMaker: Common Parameters</a>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        /// <p> The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms Provided by Amazon SageMaker: Common Parameters</a>. SageMaker supports both <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code> image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon SageMaker</a>.</p>
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for <code>TrainingImage</code>.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for <code>TrainingImage</code>.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// Appends an item to `metric_definitions`.
        ///
        /// To override the contents of this collection use [`set_metric_definitions`](Self::set_metric_definitions).
        ///
        /// <p>An array of <code>MetricDefinition</code> objects that specify the metrics that the algorithm emits.</p>
        pub fn metric_definitions(mut self, input: crate::model::MetricDefinition) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input);
            self.metric_definitions = Some(v);
            self
        }
        /// <p>An array of <code>MetricDefinition</code> objects that specify the metrics that the algorithm emits.</p>
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
        pub fn build(self) -> crate::model::HyperParameterAlgorithmSpecification {
            crate::model::HyperParameterAlgorithmSpecification {
                training_image: self.training_image,
                training_input_mode: self.training_input_mode,
                algorithm_name: self.algorithm_name,
                metric_definitions: self.metric_definitions,
            }
        }
    }
}
impl HyperParameterAlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
    pub fn builder() -> crate::model::hyper_parameter_algorithm_specification::Builder {
        crate::model::hyper_parameter_algorithm_specification::Builder::default()
    }
}

/// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs with hyperparameter values within these ranges to find the combination of values that result in the training job with the best performance as measured by the objective metric of the hyperparameter tuning job.</p> <note>
/// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job can search over. Every possible value of a categorical parameter range counts against this limit.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterRanges {
    /// <p>The array of <code>IntegerParameterRange</code> objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.</p>
    pub integer_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
    /// <p>The array of <code>ContinuousParameterRange</code> objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.</p>
    pub continuous_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
    /// <p>The array of <code>CategoricalParameterRange</code> objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.</p>
    pub categorical_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
}
impl ParameterRanges {
    /// <p>The array of <code>IntegerParameterRange</code> objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.</p>
    pub fn integer_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::IntegerParameterRange]> {
        self.integer_parameter_ranges.as_deref()
    }
    /// <p>The array of <code>ContinuousParameterRange</code> objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.</p>
    pub fn continuous_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::ContinuousParameterRange]> {
        self.continuous_parameter_ranges.as_deref()
    }
    /// <p>The array of <code>CategoricalParameterRange</code> objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.</p>
    pub fn categorical_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::CategoricalParameterRange]> {
        self.categorical_parameter_ranges.as_deref()
    }
}
impl std::fmt::Debug for ParameterRanges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterRanges");
        formatter.field("integer_parameter_ranges", &self.integer_parameter_ranges);
        formatter.field(
            "continuous_parameter_ranges",
            &self.continuous_parameter_ranges,
        );
        formatter.field(
            "categorical_parameter_ranges",
            &self.categorical_parameter_ranges,
        );
        formatter.finish()
    }
}
/// See [`ParameterRanges`](crate::model::ParameterRanges)
pub mod parameter_ranges {

    /// A builder for [`ParameterRanges`](crate::model::ParameterRanges)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integer_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
        pub(crate) continuous_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        pub(crate) categorical_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
    }
    impl Builder {
        /// Appends an item to `integer_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_integer_parameter_ranges`](Self::set_integer_parameter_ranges).
        ///
        /// <p>The array of <code>IntegerParameterRange</code> objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn integer_parameter_ranges(
            mut self,
            input: crate::model::IntegerParameterRange,
        ) -> Self {
            let mut v = self.integer_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.integer_parameter_ranges = Some(v);
            self
        }
        /// <p>The array of <code>IntegerParameterRange</code> objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn set_integer_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
        ) -> Self {
            self.integer_parameter_ranges = input;
            self
        }
        /// Appends an item to `continuous_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_continuous_parameter_ranges`](Self::set_continuous_parameter_ranges).
        ///
        /// <p>The array of <code>ContinuousParameterRange</code> objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn continuous_parameter_ranges(
            mut self,
            input: crate::model::ContinuousParameterRange,
        ) -> Self {
            let mut v = self.continuous_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.continuous_parameter_ranges = Some(v);
            self
        }
        /// <p>The array of <code>ContinuousParameterRange</code> objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn set_continuous_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        ) -> Self {
            self.continuous_parameter_ranges = input;
            self
        }
        /// Appends an item to `categorical_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_categorical_parameter_ranges`](Self::set_categorical_parameter_ranges).
        ///
        /// <p>The array of <code>CategoricalParameterRange</code> objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn categorical_parameter_ranges(
            mut self,
            input: crate::model::CategoricalParameterRange,
        ) -> Self {
            let mut v = self.categorical_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.categorical_parameter_ranges = Some(v);
            self
        }
        /// <p>The array of <code>CategoricalParameterRange</code> objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.</p>
        pub fn set_categorical_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
        ) -> Self {
            self.categorical_parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterRanges`](crate::model::ParameterRanges)
        pub fn build(self) -> crate::model::ParameterRanges {
            crate::model::ParameterRanges {
                integer_parameter_ranges: self.integer_parameter_ranges,
                continuous_parameter_ranges: self.continuous_parameter_ranges,
                categorical_parameter_ranges: self.categorical_parameter_ranges,
            }
        }
    }
}
impl ParameterRanges {
    /// Creates a new builder-style object to manufacture [`ParameterRanges`](crate::model::ParameterRanges)
    pub fn builder() -> crate::model::parameter_ranges::Builder {
        crate::model::parameter_ranges::Builder::default()
    }
}

/// <p>A list of categorical hyperparameters to tune.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoricalParameterRange {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the categories for the hyperparameter.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CategoricalParameterRange {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the categories for the hyperparameter.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for CategoricalParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoricalParameterRange");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
pub mod categorical_parameter_range {

    /// A builder for [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the categorical hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the categorical hyperparameter to tune.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of the categories for the hyperparameter.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>A list of the categories for the hyperparameter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
        pub fn build(self) -> crate::model::CategoricalParameterRange {
            crate::model::CategoricalParameterRange {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl CategoricalParameterRange {
    /// Creates a new builder-style object to manufacture [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
    pub fn builder() -> crate::model::categorical_parameter_range::Builder {
        crate::model::categorical_parameter_range::Builder::default()
    }
}

/// <p>A list of continuous hyperparameters to tune.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousParameterRange {
    /// <p>The name of the continuous hyperparameter to tune.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and <code>MaxValue</code>for tuning.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values between <code>MinValue</code> value and this value for tuning.</p>
    pub max_value: std::option::Option<std::string::String>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0&lt;=x&lt;1.0.</p>
    /// </dd>
    /// </dl>
    pub scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
}
impl ContinuousParameterRange {
    /// <p>The name of the continuous hyperparameter to tune.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and <code>MaxValue</code>for tuning.</p>
    pub fn min_value(&self) -> std::option::Option<&str> {
        self.min_value.as_deref()
    }
    /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values between <code>MinValue</code> value and this value for tuning.</p>
    pub fn max_value(&self) -> std::option::Option<&str> {
        self.max_value.as_deref()
    }
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0&lt;=x&lt;1.0.</p>
    /// </dd>
    /// </dl>
    pub fn scaling_type(&self) -> std::option::Option<&crate::model::HyperParameterScalingType> {
        self.scaling_type.as_ref()
    }
}
impl std::fmt::Debug for ContinuousParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousParameterRange");
        formatter.field("name", &self.name);
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.field("scaling_type", &self.scaling_type);
        formatter.finish()
    }
}
/// See [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
pub mod continuous_parameter_range {

    /// A builder for [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
        pub(crate) scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
    }
    impl Builder {
        /// <p>The name of the continuous hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the continuous hyperparameter to tune.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and <code>MaxValue</code>for tuning.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        /// <p>The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and <code>MaxValue</code>for tuning.</p>
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values between <code>MinValue</code> value and this value for tuning.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values between <code>MinValue</code> value and this value for tuning.</p>
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0&lt;=x&lt;1.0.</p>
        /// </dd>
        /// </dl>
        pub fn scaling_type(mut self, input: crate::model::HyperParameterScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0&lt;=x&lt;1.0.</p>
        /// </dd>
        /// </dl>
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
        pub fn build(self) -> crate::model::ContinuousParameterRange {
            crate::model::ContinuousParameterRange {
                name: self.name,
                min_value: self.min_value,
                max_value: self.max_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl ContinuousParameterRange {
    /// Creates a new builder-style object to manufacture [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
    pub fn builder() -> crate::model::continuous_parameter_range::Builder {
        crate::model::continuous_parameter_range::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterScalingType {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    #[allow(missing_docs)] // documentation missing in model
    Logarithmic,
    #[allow(missing_docs)] // documentation missing in model
    ReverseLogarithmic,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterScalingType {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => HyperParameterScalingType::Auto,
            "Linear" => HyperParameterScalingType::Linear,
            "Logarithmic" => HyperParameterScalingType::Logarithmic,
            "ReverseLogarithmic" => HyperParameterScalingType::ReverseLogarithmic,
            other => HyperParameterScalingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterScalingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterScalingType::from(s))
    }
}
impl HyperParameterScalingType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterScalingType::Auto => "Auto",
            HyperParameterScalingType::Linear => "Linear",
            HyperParameterScalingType::Logarithmic => "Logarithmic",
            HyperParameterScalingType::ReverseLogarithmic => "ReverseLogarithmic",
            HyperParameterScalingType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Auto", "Linear", "Logarithmic", "ReverseLogarithmic"]
    }
}
impl AsRef<str> for HyperParameterScalingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>For a hyperparameter of the integer type, specifies the range that a hyperparameter tuning job searches.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegerParameterRange {
    /// <p>The name of the hyperparameter to search.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The minimum value of the hyperparameter to search.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum value of the hyperparameter to search.</p>
    pub max_value: std::option::Option<std::string::String>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
    /// </dd>
    /// </dl>
    pub scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
}
impl IntegerParameterRange {
    /// <p>The name of the hyperparameter to search.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The minimum value of the hyperparameter to search.</p>
    pub fn min_value(&self) -> std::option::Option<&str> {
        self.min_value.as_deref()
    }
    /// <p>The maximum value of the hyperparameter to search.</p>
    pub fn max_value(&self) -> std::option::Option<&str> {
        self.max_value.as_deref()
    }
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
    /// </dd>
    /// </dl>
    pub fn scaling_type(&self) -> std::option::Option<&crate::model::HyperParameterScalingType> {
        self.scaling_type.as_ref()
    }
}
impl std::fmt::Debug for IntegerParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegerParameterRange");
        formatter.field("name", &self.name);
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.field("scaling_type", &self.scaling_type);
        formatter.finish()
    }
}
/// See [`IntegerParameterRange`](crate::model::IntegerParameterRange)
pub mod integer_parameter_range {

    /// A builder for [`IntegerParameterRange`](crate::model::IntegerParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
        pub(crate) scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter to search.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hyperparameter to search.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The minimum value of the hyperparameter to search.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        /// <p>The minimum value of the hyperparameter to search.</p>
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum value of the hyperparameter to search.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        /// <p>The maximum value of the hyperparameter to search.</p>
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
        /// </dd>
        /// </dl>
        pub fn scaling_type(mut self, input: crate::model::HyperParameterScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater than 0.</p>
        /// </dd>
        /// </dl>
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterRange`](crate::model::IntegerParameterRange)
        pub fn build(self) -> crate::model::IntegerParameterRange {
            crate::model::IntegerParameterRange {
                name: self.name,
                min_value: self.min_value,
                max_value: self.max_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl IntegerParameterRange {
    /// Creates a new builder-style object to manufacture [`IntegerParameterRange`](crate::model::IntegerParameterRange)
    pub fn builder() -> crate::model::integer_parameter_range::Builder {
        crate::model::integer_parameter_range::Builder::default()
    }
}

/// <p>Defines the objective metric for a hyperparameter tuning job. Hyperparameter tuning uses the value of this metric to evaluate the training jobs it launches, and returns the training job that results in either the highest or lowest value for this metric, depending on the value you specify for the <code>Type</code> parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobObjective {
    /// <p>Whether to minimize or maximize the objective metric.</p>
    pub r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
    /// <p>The name of the metric to use for the objective metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl HyperParameterTuningJobObjective {
    /// <p>Whether to minimize or maximize the objective metric.</p>
    pub fn r#type(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobObjectiveType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the metric to use for the objective metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for HyperParameterTuningJobObjective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobObjective");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
pub mod hyper_parameter_tuning_job_objective {

    /// A builder for [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to minimize or maximize the objective metric.</p>
        pub fn r#type(mut self, input: crate::model::HyperParameterTuningJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Whether to minimize or maximize the objective metric.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the metric to use for the objective metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric to use for the objective metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
        pub fn build(self) -> crate::model::HyperParameterTuningJobObjective {
            crate::model::HyperParameterTuningJobObjective {
                r#type: self.r#type,
                metric_name: self.metric_name,
            }
        }
    }
}
impl HyperParameterTuningJobObjective {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_objective::Builder {
        crate::model::hyper_parameter_tuning_job_objective::Builder::default()
    }
}

/// <p>Configures a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobConfig {
    /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values to use for the training job it launches. To use the Bayesian search strategy, set this to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How Hyperparameter Tuning Works</a>.</p>
    pub strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
    /// <p>The <code>HyperParameterTuningJobObjective</code> object that specifies the objective metric for this tuning job.</p>
    pub hyper_parameter_tuning_job_objective:
        std::option::Option<crate::model::HyperParameterTuningJobObjective>,
    /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs for this tuning job.</p>
    pub resource_limits: std::option::Option<crate::model::ResourceLimits>,
    /// <p>The <code>ParameterRanges</code> object that specifies the ranges of hyperparameters that this tuning job searches.</p>
    pub parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
    /// <p>Specifies whether to use early stopping for training jobs launched by the hyperparameter tuning job. This can be one of the following values (the default value is <code>OFF</code>):</p>
    /// <dl>
    /// <dt>
    /// OFF
    /// </dt>
    /// <dd>
    /// <p>Training jobs launched by the hyperparameter tuning job do not use early stopping.</p>
    /// </dd>
    /// <dt>
    /// AUTO
    /// </dt>
    /// <dd>
    /// <p>SageMaker stops training jobs launched by the hyperparameter tuning job when they are unlikely to perform better than previously completed training jobs. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
    /// </dd>
    /// </dl>
    pub training_job_early_stopping_type:
        std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
    /// <p>The tuning job's completion criteria.</p>
    pub tuning_job_completion_criteria:
        std::option::Option<crate::model::TuningJobCompletionCriteria>,
}
impl HyperParameterTuningJobConfig {
    /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values to use for the training job it launches. To use the Bayesian search strategy, set this to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How Hyperparameter Tuning Works</a>.</p>
    pub fn strategy(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobStrategyType> {
        self.strategy.as_ref()
    }
    /// <p>The <code>HyperParameterTuningJobObjective</code> object that specifies the objective metric for this tuning job.</p>
    pub fn hyper_parameter_tuning_job_objective(
        &self,
    ) -> std::option::Option<&crate::model::HyperParameterTuningJobObjective> {
        self.hyper_parameter_tuning_job_objective.as_ref()
    }
    /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs for this tuning job.</p>
    pub fn resource_limits(&self) -> std::option::Option<&crate::model::ResourceLimits> {
        self.resource_limits.as_ref()
    }
    /// <p>The <code>ParameterRanges</code> object that specifies the ranges of hyperparameters that this tuning job searches.</p>
    pub fn parameter_ranges(&self) -> std::option::Option<&crate::model::ParameterRanges> {
        self.parameter_ranges.as_ref()
    }
    /// <p>Specifies whether to use early stopping for training jobs launched by the hyperparameter tuning job. This can be one of the following values (the default value is <code>OFF</code>):</p>
    /// <dl>
    /// <dt>
    /// OFF
    /// </dt>
    /// <dd>
    /// <p>Training jobs launched by the hyperparameter tuning job do not use early stopping.</p>
    /// </dd>
    /// <dt>
    /// AUTO
    /// </dt>
    /// <dd>
    /// <p>SageMaker stops training jobs launched by the hyperparameter tuning job when they are unlikely to perform better than previously completed training jobs. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
    /// </dd>
    /// </dl>
    pub fn training_job_early_stopping_type(
        &self,
    ) -> std::option::Option<&crate::model::TrainingJobEarlyStoppingType> {
        self.training_job_early_stopping_type.as_ref()
    }
    /// <p>The tuning job's completion criteria.</p>
    pub fn tuning_job_completion_criteria(
        &self,
    ) -> std::option::Option<&crate::model::TuningJobCompletionCriteria> {
        self.tuning_job_completion_criteria.as_ref()
    }
}
impl std::fmt::Debug for HyperParameterTuningJobConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobConfig");
        formatter.field("strategy", &self.strategy);
        formatter.field(
            "hyper_parameter_tuning_job_objective",
            &self.hyper_parameter_tuning_job_objective,
        );
        formatter.field("resource_limits", &self.resource_limits);
        formatter.field("parameter_ranges", &self.parameter_ranges);
        formatter.field(
            "training_job_early_stopping_type",
            &self.training_job_early_stopping_type,
        );
        formatter.field(
            "tuning_job_completion_criteria",
            &self.tuning_job_completion_criteria,
        );
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
pub mod hyper_parameter_tuning_job_config {

    /// A builder for [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        pub(crate) hyper_parameter_tuning_job_objective:
            std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        pub(crate) resource_limits: std::option::Option<crate::model::ResourceLimits>,
        pub(crate) parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
        pub(crate) training_job_early_stopping_type:
            std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
        pub(crate) tuning_job_completion_criteria:
            std::option::Option<crate::model::TuningJobCompletionCriteria>,
    }
    impl Builder {
        /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values to use for the training job it launches. To use the Bayesian search strategy, set this to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How Hyperparameter Tuning Works</a>.</p>
        pub fn strategy(
            mut self,
            input: crate::model::HyperParameterTuningJobStrategyType,
        ) -> Self {
            self.strategy = Some(input);
            self
        }
        /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values to use for the training job it launches. To use the Bayesian search strategy, set this to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How Hyperparameter Tuning Works</a>.</p>
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        ) -> Self {
            self.strategy = input;
            self
        }
        /// <p>The <code>HyperParameterTuningJobObjective</code> object that specifies the objective metric for this tuning job.</p>
        pub fn hyper_parameter_tuning_job_objective(
            mut self,
            input: crate::model::HyperParameterTuningJobObjective,
        ) -> Self {
            self.hyper_parameter_tuning_job_objective = Some(input);
            self
        }
        /// <p>The <code>HyperParameterTuningJobObjective</code> object that specifies the objective metric for this tuning job.</p>
        pub fn set_hyper_parameter_tuning_job_objective(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        ) -> Self {
            self.hyper_parameter_tuning_job_objective = input;
            self
        }
        /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs for this tuning job.</p>
        pub fn resource_limits(mut self, input: crate::model::ResourceLimits) -> Self {
            self.resource_limits = Some(input);
            self
        }
        /// <p>The <code>ResourceLimits</code> object that specifies the maximum number of training jobs and parallel training jobs for this tuning job.</p>
        pub fn set_resource_limits(
            mut self,
            input: std::option::Option<crate::model::ResourceLimits>,
        ) -> Self {
            self.resource_limits = input;
            self
        }
        /// <p>The <code>ParameterRanges</code> object that specifies the ranges of hyperparameters that this tuning job searches.</p>
        pub fn parameter_ranges(mut self, input: crate::model::ParameterRanges) -> Self {
            self.parameter_ranges = Some(input);
            self
        }
        /// <p>The <code>ParameterRanges</code> object that specifies the ranges of hyperparameters that this tuning job searches.</p>
        pub fn set_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::ParameterRanges>,
        ) -> Self {
            self.parameter_ranges = input;
            self
        }
        /// <p>Specifies whether to use early stopping for training jobs launched by the hyperparameter tuning job. This can be one of the following values (the default value is <code>OFF</code>):</p>
        /// <dl>
        /// <dt>
        /// OFF
        /// </dt>
        /// <dd>
        /// <p>Training jobs launched by the hyperparameter tuning job do not use early stopping.</p>
        /// </dd>
        /// <dt>
        /// AUTO
        /// </dt>
        /// <dd>
        /// <p>SageMaker stops training jobs launched by the hyperparameter tuning job when they are unlikely to perform better than previously completed training jobs. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
        /// </dd>
        /// </dl>
        pub fn training_job_early_stopping_type(
            mut self,
            input: crate::model::TrainingJobEarlyStoppingType,
        ) -> Self {
            self.training_job_early_stopping_type = Some(input);
            self
        }
        /// <p>Specifies whether to use early stopping for training jobs launched by the hyperparameter tuning job. This can be one of the following values (the default value is <code>OFF</code>):</p>
        /// <dl>
        /// <dt>
        /// OFF
        /// </dt>
        /// <dd>
        /// <p>Training jobs launched by the hyperparameter tuning job do not use early stopping.</p>
        /// </dd>
        /// <dt>
        /// AUTO
        /// </dt>
        /// <dd>
        /// <p>SageMaker stops training jobs launched by the hyperparameter tuning job when they are unlikely to perform better than previously completed training jobs. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
        /// </dd>
        /// </dl>
        pub fn set_training_job_early_stopping_type(
            mut self,
            input: std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
        ) -> Self {
            self.training_job_early_stopping_type = input;
            self
        }
        /// <p>The tuning job's completion criteria.</p>
        pub fn tuning_job_completion_criteria(
            mut self,
            input: crate::model::TuningJobCompletionCriteria,
        ) -> Self {
            self.tuning_job_completion_criteria = Some(input);
            self
        }
        /// <p>The tuning job's completion criteria.</p>
        pub fn set_tuning_job_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::TuningJobCompletionCriteria>,
        ) -> Self {
            self.tuning_job_completion_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
        pub fn build(self) -> crate::model::HyperParameterTuningJobConfig {
            crate::model::HyperParameterTuningJobConfig {
                strategy: self.strategy,
                hyper_parameter_tuning_job_objective: self.hyper_parameter_tuning_job_objective,
                resource_limits: self.resource_limits,
                parameter_ranges: self.parameter_ranges,
                training_job_early_stopping_type: self.training_job_early_stopping_type,
                tuning_job_completion_criteria: self.tuning_job_completion_criteria,
            }
        }
    }
}
impl HyperParameterTuningJobConfig {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_config::Builder {
        crate::model::hyper_parameter_tuning_job_config::Builder::default()
    }
}

/// <p>The job completion criteria.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TuningJobCompletionCriteria {
    /// <p>The value of the objective metric.</p>
    pub target_objective_metric_value: std::option::Option<f32>,
}
impl TuningJobCompletionCriteria {
    /// <p>The value of the objective metric.</p>
    pub fn target_objective_metric_value(&self) -> std::option::Option<f32> {
        self.target_objective_metric_value
    }
}
impl std::fmt::Debug for TuningJobCompletionCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TuningJobCompletionCriteria");
        formatter.field(
            "target_objective_metric_value",
            &self.target_objective_metric_value,
        );
        formatter.finish()
    }
}
/// See [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
pub mod tuning_job_completion_criteria {

    /// A builder for [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_objective_metric_value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The value of the objective metric.</p>
        pub fn target_objective_metric_value(mut self, input: f32) -> Self {
            self.target_objective_metric_value = Some(input);
            self
        }
        /// <p>The value of the objective metric.</p>
        pub fn set_target_objective_metric_value(
            mut self,
            input: std::option::Option<f32>,
        ) -> Self {
            self.target_objective_metric_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
        pub fn build(self) -> crate::model::TuningJobCompletionCriteria {
            crate::model::TuningJobCompletionCriteria {
                target_objective_metric_value: self.target_objective_metric_value,
            }
        }
    }
}
impl TuningJobCompletionCriteria {
    /// Creates a new builder-style object to manufacture [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
    pub fn builder() -> crate::model::tuning_job_completion_criteria::Builder {
        crate::model::tuning_job_completion_criteria::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobEarlyStoppingType {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobEarlyStoppingType {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => TrainingJobEarlyStoppingType::Auto,
            "Off" => TrainingJobEarlyStoppingType::Off,
            other => TrainingJobEarlyStoppingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobEarlyStoppingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobEarlyStoppingType::from(s))
    }
}
impl TrainingJobEarlyStoppingType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobEarlyStoppingType::Auto => "Auto",
            TrainingJobEarlyStoppingType::Off => "Off",
            TrainingJobEarlyStoppingType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Auto", "Off"]
    }
}
impl AsRef<str> for TrainingJobEarlyStoppingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for user interface template information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiTemplateInfo {
    /// <p>The URL for the user interface template.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The SHA-256 digest of the contents of the template.</p>
    pub content_sha256: std::option::Option<std::string::String>,
}
impl UiTemplateInfo {
    /// <p>The URL for the user interface template.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The SHA-256 digest of the contents of the template.</p>
    pub fn content_sha256(&self) -> std::option::Option<&str> {
        self.content_sha256.as_deref()
    }
}
impl std::fmt::Debug for UiTemplateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiTemplateInfo");
        formatter.field("url", &self.url);
        formatter.field("content_sha256", &self.content_sha256);
        formatter.finish()
    }
}
/// See [`UiTemplateInfo`](crate::model::UiTemplateInfo)
pub mod ui_template_info {

    /// A builder for [`UiTemplateInfo`](crate::model::UiTemplateInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) content_sha256: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the user interface template.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL for the user interface template.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The SHA-256 digest of the contents of the template.</p>
        pub fn content_sha256(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_sha256 = Some(input.into());
            self
        }
        /// <p>The SHA-256 digest of the contents of the template.</p>
        pub fn set_content_sha256(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_sha256 = input;
            self
        }
        /// Consumes the builder and constructs a [`UiTemplateInfo`](crate::model::UiTemplateInfo)
        pub fn build(self) -> crate::model::UiTemplateInfo {
            crate::model::UiTemplateInfo {
                url: self.url,
                content_sha256: self.content_sha256,
            }
        }
    }
}
impl UiTemplateInfo {
    /// Creates a new builder-style object to manufacture [`UiTemplateInfo`](crate::model::UiTemplateInfo)
    pub fn builder() -> crate::model::ui_template_info::Builder {
        crate::model::ui_template_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HumanTaskUiStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HumanTaskUiStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => HumanTaskUiStatus::Active,
            "Deleting" => HumanTaskUiStatus::Deleting,
            other => HumanTaskUiStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HumanTaskUiStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HumanTaskUiStatus::from(s))
    }
}
impl HumanTaskUiStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HumanTaskUiStatus::Active => "Active",
            HumanTaskUiStatus::Deleting => "Deleting",
            HumanTaskUiStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Deleting"]
    }
}
impl AsRef<str> for HumanTaskUiStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about where human output will be stored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlowDefinitionOutputConfig {
    /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
    /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I Output Data</a>.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl FlowDefinitionOutputConfig {
    /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
    /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I Output Data</a>.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for FlowDefinitionOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlowDefinitionOutputConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
pub mod flow_definition_output_config {

    /// A builder for [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
        /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I Output Data</a>.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
        /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I Output Data</a>.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
        pub fn build(self) -> crate::model::FlowDefinitionOutputConfig {
            crate::model::FlowDefinitionOutputConfig {
                s3_output_path: self.s3_output_path,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl FlowDefinitionOutputConfig {
    /// Creates a new builder-style object to manufacture [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
    pub fn builder() -> crate::model::flow_definition_output_config::Builder {
        crate::model::flow_definition_output_config::Builder::default()
    }
}

/// <p>Describes the work to be performed by human workers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopConfig {
    /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create and Manage Workforces</a>.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task template. You use this template to create a human task UI.</p>
    /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker Task Template</a>.</p>
    /// <p>To learn how to create a human task UI, which is a worker task template that can be used in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
    /// <p>A title for the human worker task.</p>
    pub task_title: std::option::Option<std::string::String>,
    /// <p>A description for the human worker task.</p>
    pub task_description: std::option::Option<std::string::String>,
    /// <p>The number of distinct workers who will perform the same task on each object. For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification labeling job, three workers will classify each input image. Increasing <code>TaskCount</code> can improve label accuracy.</p>
    pub task_count: std::option::Option<i32>,
    /// <p>The length of time that a task remains available for review by human workers.</p>
    pub task_availability_lifetime_in_seconds: std::option::Option<i32>,
    /// <p>The amount of time that a worker has to complete a task. The default value is 3,600 seconds (1 hour).</p>
    pub task_time_limit_in_seconds: std::option::Option<i32>,
    /// <p>Keywords used to describe the task so that workers can discover the task.</p>
    pub task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
    /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and should be based on the complexity of the task; the longer it takes in your initial testing, the more you should offer.</p>
    /// <ul>
    /// <li> <p>0.036</p> </li>
    /// <li> <p>0.048</p> </li>
    /// <li> <p>0.060</p> </li>
    /// <li> <p>0.072</p> </li>
    /// <li> <p>0.120</p> </li>
    /// <li> <p>0.240</p> </li>
    /// <li> <p>0.360</p> </li>
    /// <li> <p>0.480</p> </li>
    /// <li> <p>0.600</p> </li>
    /// <li> <p>0.720</p> </li>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for image classification, text classification, and custom tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>0.012</p> </li>
    /// <li> <p>0.024</p> </li>
    /// <li> <p>0.036</p> </li>
    /// <li> <p>0.048</p> </li>
    /// <li> <p>0.060</p> </li>
    /// <li> <p>0.072</p> </li>
    /// <li> <p>0.120</p> </li>
    /// <li> <p>0.240</p> </li>
    /// <li> <p>0.360</p> </li>
    /// <li> <p>0.480</p> </li>
    /// <li> <p>0.600</p> </li>
    /// <li> <p>0.720</p> </li>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>2.400 </p> </li>
    /// <li> <p>2.280 </p> </li>
    /// <li> <p>2.160 </p> </li>
    /// <li> <p>2.040 </p> </li>
    /// <li> <p>1.920 </p> </li>
    /// <li> <p>1.800 </p> </li>
    /// <li> <p>1.680 </p> </li>
    /// <li> <p>1.560 </p> </li>
    /// <li> <p>1.440 </p> </li>
    /// <li> <p>1.320 </p> </li>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    pub public_workforce_task_price: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
}
impl HumanLoopConfig {
    /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create and Manage Workforces</a>.</p>
    pub fn workteam_arn(&self) -> std::option::Option<&str> {
        self.workteam_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task template. You use this template to create a human task UI.</p>
    /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker Task Template</a>.</p>
    /// <p>To learn how to create a human task UI, which is a worker task template that can be used in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
    pub fn human_task_ui_arn(&self) -> std::option::Option<&str> {
        self.human_task_ui_arn.as_deref()
    }
    /// <p>A title for the human worker task.</p>
    pub fn task_title(&self) -> std::option::Option<&str> {
        self.task_title.as_deref()
    }
    /// <p>A description for the human worker task.</p>
    pub fn task_description(&self) -> std::option::Option<&str> {
        self.task_description.as_deref()
    }
    /// <p>The number of distinct workers who will perform the same task on each object. For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification labeling job, three workers will classify each input image. Increasing <code>TaskCount</code> can improve label accuracy.</p>
    pub fn task_count(&self) -> std::option::Option<i32> {
        self.task_count
    }
    /// <p>The length of time that a task remains available for review by human workers.</p>
    pub fn task_availability_lifetime_in_seconds(&self) -> std::option::Option<i32> {
        self.task_availability_lifetime_in_seconds
    }
    /// <p>The amount of time that a worker has to complete a task. The default value is 3,600 seconds (1 hour).</p>
    pub fn task_time_limit_in_seconds(&self) -> std::option::Option<i32> {
        self.task_time_limit_in_seconds
    }
    /// <p>Keywords used to describe the task so that workers can discover the task.</p>
    pub fn task_keywords(&self) -> std::option::Option<&[std::string::String]> {
        self.task_keywords.as_deref()
    }
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
    /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and should be based on the complexity of the task; the longer it takes in your initial testing, the more you should offer.</p>
    /// <ul>
    /// <li> <p>0.036</p> </li>
    /// <li> <p>0.048</p> </li>
    /// <li> <p>0.060</p> </li>
    /// <li> <p>0.072</p> </li>
    /// <li> <p>0.120</p> </li>
    /// <li> <p>0.240</p> </li>
    /// <li> <p>0.360</p> </li>
    /// <li> <p>0.480</p> </li>
    /// <li> <p>0.600</p> </li>
    /// <li> <p>0.720</p> </li>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for image classification, text classification, and custom tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>0.012</p> </li>
    /// <li> <p>0.024</p> </li>
    /// <li> <p>0.036</p> </li>
    /// <li> <p>0.048</p> </li>
    /// <li> <p>0.060</p> </li>
    /// <li> <p>0.072</p> </li>
    /// <li> <p>0.120</p> </li>
    /// <li> <p>0.240</p> </li>
    /// <li> <p>0.360</p> </li>
    /// <li> <p>0.480</p> </li>
    /// <li> <p>0.600</p> </li>
    /// <li> <p>0.720</p> </li>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>0.840</p> </li>
    /// <li> <p>0.960</p> </li>
    /// <li> <p>1.080</p> </li>
    /// <li> <p>1.200</p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>2.400 </p> </li>
    /// <li> <p>2.280 </p> </li>
    /// <li> <p>2.160 </p> </li>
    /// <li> <p>2.040 </p> </li>
    /// <li> <p>1.920 </p> </li>
    /// <li> <p>1.800 </p> </li>
    /// <li> <p>1.680 </p> </li>
    /// <li> <p>1.560 </p> </li>
    /// <li> <p>1.440 </p> </li>
    /// <li> <p>1.320 </p> </li>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li> <p>1.200 </p> </li>
    /// <li> <p>1.080 </p> </li>
    /// <li> <p>0.960 </p> </li>
    /// <li> <p>0.840 </p> </li>
    /// <li> <p>0.720 </p> </li>
    /// <li> <p>0.600 </p> </li>
    /// <li> <p>0.480 </p> </li>
    /// <li> <p>0.360 </p> </li>
    /// <li> <p>0.240 </p> </li>
    /// <li> <p>0.120 </p> </li>
    /// <li> <p>0.072 </p> </li>
    /// <li> <p>0.060 </p> </li>
    /// <li> <p>0.048 </p> </li>
    /// <li> <p>0.036 </p> </li>
    /// <li> <p>0.024 </p> </li>
    /// <li> <p>0.012 </p> </li>
    /// </ul>
    pub fn public_workforce_task_price(
        &self,
    ) -> std::option::Option<&crate::model::PublicWorkforceTaskPrice> {
        self.public_workforce_task_price.as_ref()
    }
}
impl std::fmt::Debug for HumanLoopConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopConfig");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.field("task_title", &self.task_title);
        formatter.field("task_description", &self.task_description);
        formatter.field("task_count", &self.task_count);
        formatter.field(
            "task_availability_lifetime_in_seconds",
            &self.task_availability_lifetime_in_seconds,
        );
        formatter.field(
            "task_time_limit_in_seconds",
            &self.task_time_limit_in_seconds,
        );
        formatter.field("task_keywords", &self.task_keywords);
        formatter.field(
            "public_workforce_task_price",
            &self.public_workforce_task_price,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopConfig`](crate::model::HumanLoopConfig)
pub mod human_loop_config {

    /// A builder for [`HumanLoopConfig`](crate::model::HumanLoopConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
        pub(crate) task_title: std::option::Option<std::string::String>,
        pub(crate) task_description: std::option::Option<std::string::String>,
        pub(crate) task_count: std::option::Option<i32>,
        pub(crate) task_availability_lifetime_in_seconds: std::option::Option<i32>,
        pub(crate) task_time_limit_in_seconds: std::option::Option<i32>,
        pub(crate) task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) public_workforce_task_price:
            std::option::Option<crate::model::PublicWorkforceTaskPrice>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create and Manage Workforces</a>.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create and Manage Workforces</a>.</p>
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task template. You use this template to create a human task UI.</p>
        /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker Task Template</a>.</p>
        /// <p>To learn how to create a human task UI, which is a worker task template that can be used in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task template. You use this template to create a human task UI.</p>
        /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker Task Template</a>.</p>
        /// <p>To learn how to create a human task UI, which is a worker task template that can be used in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// <p>A title for the human worker task.</p>
        pub fn task_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_title = Some(input.into());
            self
        }
        /// <p>A title for the human worker task.</p>
        pub fn set_task_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_title = input;
            self
        }
        /// <p>A description for the human worker task.</p>
        pub fn task_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_description = Some(input.into());
            self
        }
        /// <p>A description for the human worker task.</p>
        pub fn set_task_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_description = input;
            self
        }
        /// <p>The number of distinct workers who will perform the same task on each object. For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification labeling job, three workers will classify each input image. Increasing <code>TaskCount</code> can improve label accuracy.</p>
        pub fn task_count(mut self, input: i32) -> Self {
            self.task_count = Some(input);
            self
        }
        /// <p>The number of distinct workers who will perform the same task on each object. For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification labeling job, three workers will classify each input image. Increasing <code>TaskCount</code> can improve label accuracy.</p>
        pub fn set_task_count(mut self, input: std::option::Option<i32>) -> Self {
            self.task_count = input;
            self
        }
        /// <p>The length of time that a task remains available for review by human workers.</p>
        pub fn task_availability_lifetime_in_seconds(mut self, input: i32) -> Self {
            self.task_availability_lifetime_in_seconds = Some(input);
            self
        }
        /// <p>The length of time that a task remains available for review by human workers.</p>
        pub fn set_task_availability_lifetime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.task_availability_lifetime_in_seconds = input;
            self
        }
        /// <p>The amount of time that a worker has to complete a task. The default value is 3,600 seconds (1 hour).</p>
        pub fn task_time_limit_in_seconds(mut self, input: i32) -> Self {
            self.task_time_limit_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time that a worker has to complete a task. The default value is 3,600 seconds (1 hour).</p>
        pub fn set_task_time_limit_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.task_time_limit_in_seconds = input;
            self
        }
        /// Appends an item to `task_keywords`.
        ///
        /// To override the contents of this collection use [`set_task_keywords`](Self::set_task_keywords).
        ///
        /// <p>Keywords used to describe the task so that workers can discover the task.</p>
        pub fn task_keywords(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.task_keywords.unwrap_or_default();
            v.push(input.into());
            self.task_keywords = Some(v);
            self
        }
        /// <p>Keywords used to describe the task so that workers can discover the task.</p>
        pub fn set_task_keywords(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.task_keywords = input;
            self
        }
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
        /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and should be based on the complexity of the task; the longer it takes in your initial testing, the more you should offer.</p>
        /// <ul>
        /// <li> <p>0.036</p> </li>
        /// <li> <p>0.048</p> </li>
        /// <li> <p>0.060</p> </li>
        /// <li> <p>0.072</p> </li>
        /// <li> <p>0.120</p> </li>
        /// <li> <p>0.240</p> </li>
        /// <li> <p>0.360</p> </li>
        /// <li> <p>0.480</p> </li>
        /// <li> <p>0.600</p> </li>
        /// <li> <p>0.720</p> </li>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for image classification, text classification, and custom tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>0.012</p> </li>
        /// <li> <p>0.024</p> </li>
        /// <li> <p>0.036</p> </li>
        /// <li> <p>0.048</p> </li>
        /// <li> <p>0.060</p> </li>
        /// <li> <p>0.072</p> </li>
        /// <li> <p>0.120</p> </li>
        /// <li> <p>0.240</p> </li>
        /// <li> <p>0.360</p> </li>
        /// <li> <p>0.480</p> </li>
        /// <li> <p>0.600</p> </li>
        /// <li> <p>0.720</p> </li>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>2.400 </p> </li>
        /// <li> <p>2.280 </p> </li>
        /// <li> <p>2.160 </p> </li>
        /// <li> <p>2.040 </p> </li>
        /// <li> <p>1.920 </p> </li>
        /// <li> <p>1.800 </p> </li>
        /// <li> <p>1.680 </p> </li>
        /// <li> <p>1.560 </p> </li>
        /// <li> <p>1.440 </p> </li>
        /// <li> <p>1.320 </p> </li>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        pub fn public_workforce_task_price(
            mut self,
            input: crate::model::PublicWorkforceTaskPrice,
        ) -> Self {
            self.public_workforce_task_price = Some(input);
            self
        }
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
        /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and should be based on the complexity of the task; the longer it takes in your initial testing, the more you should offer.</p>
        /// <ul>
        /// <li> <p>0.036</p> </li>
        /// <li> <p>0.048</p> </li>
        /// <li> <p>0.060</p> </li>
        /// <li> <p>0.072</p> </li>
        /// <li> <p>0.120</p> </li>
        /// <li> <p>0.240</p> </li>
        /// <li> <p>0.360</p> </li>
        /// <li> <p>0.480</p> </li>
        /// <li> <p>0.600</p> </li>
        /// <li> <p>0.720</p> </li>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for image classification, text classification, and custom tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>0.012</p> </li>
        /// <li> <p>0.024</p> </li>
        /// <li> <p>0.036</p> </li>
        /// <li> <p>0.048</p> </li>
        /// <li> <p>0.060</p> </li>
        /// <li> <p>0.072</p> </li>
        /// <li> <p>0.120</p> </li>
        /// <li> <p>0.240</p> </li>
        /// <li> <p>0.360</p> </li>
        /// <li> <p>0.480</p> </li>
        /// <li> <p>0.600</p> </li>
        /// <li> <p>0.720</p> </li>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>0.840</p> </li>
        /// <li> <p>0.960</p> </li>
        /// <li> <p>1.080</p> </li>
        /// <li> <p>1.200</p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>2.400 </p> </li>
        /// <li> <p>2.280 </p> </li>
        /// <li> <p>2.160 </p> </li>
        /// <li> <p>2.040 </p> </li>
        /// <li> <p>1.920 </p> </li>
        /// <li> <p>1.800 </p> </li>
        /// <li> <p>1.680 </p> </li>
        /// <li> <p>1.560 </p> </li>
        /// <li> <p>1.440 </p> </li>
        /// <li> <p>1.320 </p> </li>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li> <p>1.200 </p> </li>
        /// <li> <p>1.080 </p> </li>
        /// <li> <p>0.960 </p> </li>
        /// <li> <p>0.840 </p> </li>
        /// <li> <p>0.720 </p> </li>
        /// <li> <p>0.600 </p> </li>
        /// <li> <p>0.480 </p> </li>
        /// <li> <p>0.360 </p> </li>
        /// <li> <p>0.240 </p> </li>
        /// <li> <p>0.120 </p> </li>
        /// <li> <p>0.072 </p> </li>
        /// <li> <p>0.060 </p> </li>
        /// <li> <p>0.048 </p> </li>
        /// <li> <p>0.036 </p> </li>
        /// <li> <p>0.024 </p> </li>
        /// <li> <p>0.012 </p> </li>
        /// </ul>
        pub fn set_public_workforce_task_price(
            mut self,
            input: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
        ) -> Self {
            self.public_workforce_task_price = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopConfig`](crate::model::HumanLoopConfig)
        pub fn build(self) -> crate::model::HumanLoopConfig {
            crate::model::HumanLoopConfig {
                workteam_arn: self.workteam_arn,
                human_task_ui_arn: self.human_task_ui_arn,
                task_title: self.task_title,
                task_description: self.task_description,
                task_count: self.task_count,
                task_availability_lifetime_in_seconds: self.task_availability_lifetime_in_seconds,
                task_time_limit_in_seconds: self.task_time_limit_in_seconds,
                task_keywords: self.task_keywords,
                public_workforce_task_price: self.public_workforce_task_price,
            }
        }
    }
}
impl HumanLoopConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopConfig`](crate::model::HumanLoopConfig)
    pub fn builder() -> crate::model::human_loop_config::Builder {
        crate::model::human_loop_config::Builder::default()
    }
}

/// <p>Provides information about how and under what conditions SageMaker creates a human loop. If <code>HumanLoopActivationConfig</code> is not given, then all requests go to humans.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopActivationConfig {
    /// <p>Container structure for defining under what conditions SageMaker creates a human loop.</p>
    pub human_loop_activation_conditions_config:
        std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
}
impl HumanLoopActivationConfig {
    /// <p>Container structure for defining under what conditions SageMaker creates a human loop.</p>
    pub fn human_loop_activation_conditions_config(
        &self,
    ) -> std::option::Option<&crate::model::HumanLoopActivationConditionsConfig> {
        self.human_loop_activation_conditions_config.as_ref()
    }
}
impl std::fmt::Debug for HumanLoopActivationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopActivationConfig");
        formatter.field(
            "human_loop_activation_conditions_config",
            &self.human_loop_activation_conditions_config,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
pub mod human_loop_activation_config {

    /// A builder for [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_loop_activation_conditions_config:
            std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
    }
    impl Builder {
        /// <p>Container structure for defining under what conditions SageMaker creates a human loop.</p>
        pub fn human_loop_activation_conditions_config(
            mut self,
            input: crate::model::HumanLoopActivationConditionsConfig,
        ) -> Self {
            self.human_loop_activation_conditions_config = Some(input);
            self
        }
        /// <p>Container structure for defining under what conditions SageMaker creates a human loop.</p>
        pub fn set_human_loop_activation_conditions_config(
            mut self,
            input: std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
        ) -> Self {
            self.human_loop_activation_conditions_config = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
        pub fn build(self) -> crate::model::HumanLoopActivationConfig {
            crate::model::HumanLoopActivationConfig {
                human_loop_activation_conditions_config: self
                    .human_loop_activation_conditions_config,
            }
        }
    }
}
impl HumanLoopActivationConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
    pub fn builder() -> crate::model::human_loop_activation_config::Builder {
        crate::model::human_loop_activation_config::Builder::default()
    }
}

/// <p>Defines under what conditions SageMaker creates a human loop. Used within . See for the required format of activation conditions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopActivationConditionsConfig {
    /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a> in the <i>Amazon SageMaker Developer Guide</i>.</p>
    pub human_loop_activation_conditions: std::option::Option<std::string::String>,
}
impl HumanLoopActivationConditionsConfig {
    /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a> in the <i>Amazon SageMaker Developer Guide</i>.</p>
    pub fn human_loop_activation_conditions(&self) -> std::option::Option<&str> {
        self.human_loop_activation_conditions.as_deref()
    }
}
impl std::fmt::Debug for HumanLoopActivationConditionsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopActivationConditionsConfig");
        formatter.field(
            "human_loop_activation_conditions",
            &self.human_loop_activation_conditions,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
pub mod human_loop_activation_conditions_config {

    /// A builder for [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_loop_activation_conditions: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a> in the <i>Amazon SageMaker Developer Guide</i>.</p>
        pub fn human_loop_activation_conditions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.human_loop_activation_conditions = Some(input.into());
            self
        }
        /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a> in the <i>Amazon SageMaker Developer Guide</i>.</p>
        pub fn set_human_loop_activation_conditions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_loop_activation_conditions = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
        pub fn build(self) -> crate::model::HumanLoopActivationConditionsConfig {
            crate::model::HumanLoopActivationConditionsConfig {
                human_loop_activation_conditions: self.human_loop_activation_conditions,
            }
        }
    }
}
impl HumanLoopActivationConditionsConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
    pub fn builder() -> crate::model::human_loop_activation_conditions_config::Builder {
        crate::model::human_loop_activation_conditions_config::Builder::default()
    }
}

/// <p>Container for configuring the source of human task requests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopRequestSource {
    /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
    pub aws_managed_human_loop_request_source:
        std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
}
impl HumanLoopRequestSource {
    /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
    pub fn aws_managed_human_loop_request_source(
        &self,
    ) -> std::option::Option<&crate::model::AwsManagedHumanLoopRequestSource> {
        self.aws_managed_human_loop_request_source.as_ref()
    }
}
impl std::fmt::Debug for HumanLoopRequestSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopRequestSource");
        formatter.field(
            "aws_managed_human_loop_request_source",
            &self.aws_managed_human_loop_request_source,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
pub mod human_loop_request_source {

    /// A builder for [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_managed_human_loop_request_source:
            std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
    }
    impl Builder {
        /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
        pub fn aws_managed_human_loop_request_source(
            mut self,
            input: crate::model::AwsManagedHumanLoopRequestSource,
        ) -> Self {
            self.aws_managed_human_loop_request_source = Some(input);
            self
        }
        /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
        pub fn set_aws_managed_human_loop_request_source(
            mut self,
            input: std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
        ) -> Self {
            self.aws_managed_human_loop_request_source = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
        pub fn build(self) -> crate::model::HumanLoopRequestSource {
            crate::model::HumanLoopRequestSource {
                aws_managed_human_loop_request_source: self.aws_managed_human_loop_request_source,
            }
        }
    }
}
impl HumanLoopRequestSource {
    /// Creates a new builder-style object to manufacture [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
    pub fn builder() -> crate::model::human_loop_request_source::Builder {
        crate::model::human_loop_request_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsManagedHumanLoopRequestSource {
    #[allow(missing_docs)] // documentation missing in model
    RekognitionDetectModerationLabelsImageV3,
    #[allow(missing_docs)] // documentation missing in model
    TextractAnalyzeDocumentFormsV1,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AwsManagedHumanLoopRequestSource {
    fn from(s: &str) -> Self {
        match s {
            "AWS/Rekognition/DetectModerationLabels/Image/V3" => {
                AwsManagedHumanLoopRequestSource::RekognitionDetectModerationLabelsImageV3
            }
            "AWS/Textract/AnalyzeDocument/Forms/V1" => {
                AwsManagedHumanLoopRequestSource::TextractAnalyzeDocumentFormsV1
            }
            other => AwsManagedHumanLoopRequestSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AwsManagedHumanLoopRequestSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsManagedHumanLoopRequestSource::from(s))
    }
}
impl AwsManagedHumanLoopRequestSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AwsManagedHumanLoopRequestSource::RekognitionDetectModerationLabelsImageV3 => {
                "AWS/Rekognition/DetectModerationLabels/Image/V3"
            }
            AwsManagedHumanLoopRequestSource::TextractAnalyzeDocumentFormsV1 => {
                "AWS/Textract/AnalyzeDocument/Forms/V1"
            }
            AwsManagedHumanLoopRequestSource::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS/Rekognition/DetectModerationLabels/Image/V3",
            "AWS/Textract/AnalyzeDocument/Forms/V1",
        ]
    }
}
impl AsRef<str> for AwsManagedHumanLoopRequestSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies configuration for how an endpoint performs asynchronous inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AsyncInferenceConfig {
    /// <p>Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.</p>
    pub client_config: std::option::Option<crate::model::AsyncInferenceClientConfig>,
    /// <p>Specifies the configuration for asynchronous inference invocation outputs.</p>
    pub output_config: std::option::Option<crate::model::AsyncInferenceOutputConfig>,
}
impl AsyncInferenceConfig {
    /// <p>Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.</p>
    pub fn client_config(&self) -> std::option::Option<&crate::model::AsyncInferenceClientConfig> {
        self.client_config.as_ref()
    }
    /// <p>Specifies the configuration for asynchronous inference invocation outputs.</p>
    pub fn output_config(&self) -> std::option::Option<&crate::model::AsyncInferenceOutputConfig> {
        self.output_config.as_ref()
    }
}
impl std::fmt::Debug for AsyncInferenceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AsyncInferenceConfig");
        formatter.field("client_config", &self.client_config);
        formatter.field("output_config", &self.output_config);
        formatter.finish()
    }
}
/// See [`AsyncInferenceConfig`](crate::model::AsyncInferenceConfig)
pub mod async_inference_config {

    /// A builder for [`AsyncInferenceConfig`](crate::model::AsyncInferenceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_config: std::option::Option<crate::model::AsyncInferenceClientConfig>,
        pub(crate) output_config: std::option::Option<crate::model::AsyncInferenceOutputConfig>,
    }
    impl Builder {
        /// <p>Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.</p>
        pub fn client_config(mut self, input: crate::model::AsyncInferenceClientConfig) -> Self {
            self.client_config = Some(input);
            self
        }
        /// <p>Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.</p>
        pub fn set_client_config(
            mut self,
            input: std::option::Option<crate::model::AsyncInferenceClientConfig>,
        ) -> Self {
            self.client_config = input;
            self
        }
        /// <p>Specifies the configuration for asynchronous inference invocation outputs.</p>
        pub fn output_config(mut self, input: crate::model::AsyncInferenceOutputConfig) -> Self {
            self.output_config = Some(input);
            self
        }
        /// <p>Specifies the configuration for asynchronous inference invocation outputs.</p>
        pub fn set_output_config(
            mut self,
            input: std::option::Option<crate::model::AsyncInferenceOutputConfig>,
        ) -> Self {
            self.output_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AsyncInferenceConfig`](crate::model::AsyncInferenceConfig)
        pub fn build(self) -> crate::model::AsyncInferenceConfig {
            crate::model::AsyncInferenceConfig {
                client_config: self.client_config,
                output_config: self.output_config,
            }
        }
    }
}
impl AsyncInferenceConfig {
    /// Creates a new builder-style object to manufacture [`AsyncInferenceConfig`](crate::model::AsyncInferenceConfig)
    pub fn builder() -> crate::model::async_inference_config::Builder {
        crate::model::async_inference_config::Builder::default()
    }
}

/// <p>Specifies the configuration for asynchronous inference invocation outputs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AsyncInferenceOutputConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the asynchronous inference output in Amazon S3.</p>
    /// <p></p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location to upload inference responses to.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>Specifies the configuration for notifications of inference results for asynchronous inference.</p>
    pub notification_config: std::option::Option<crate::model::AsyncInferenceNotificationConfig>,
}
impl AsyncInferenceOutputConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the asynchronous inference output in Amazon S3.</p>
    /// <p></p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The Amazon S3 location to upload inference responses to.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
    /// <p>Specifies the configuration for notifications of inference results for asynchronous inference.</p>
    pub fn notification_config(
        &self,
    ) -> std::option::Option<&crate::model::AsyncInferenceNotificationConfig> {
        self.notification_config.as_ref()
    }
}
impl std::fmt::Debug for AsyncInferenceOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AsyncInferenceOutputConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("notification_config", &self.notification_config);
        formatter.finish()
    }
}
/// See [`AsyncInferenceOutputConfig`](crate::model::AsyncInferenceOutputConfig)
pub mod async_inference_output_config {

    /// A builder for [`AsyncInferenceOutputConfig`](crate::model::AsyncInferenceOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) notification_config:
            std::option::Option<crate::model::AsyncInferenceNotificationConfig>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the asynchronous inference output in Amazon S3.</p>
        /// <p></p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the asynchronous inference output in Amazon S3.</p>
        /// <p></p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon S3 location to upload inference responses to.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location to upload inference responses to.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>Specifies the configuration for notifications of inference results for asynchronous inference.</p>
        pub fn notification_config(
            mut self,
            input: crate::model::AsyncInferenceNotificationConfig,
        ) -> Self {
            self.notification_config = Some(input);
            self
        }
        /// <p>Specifies the configuration for notifications of inference results for asynchronous inference.</p>
        pub fn set_notification_config(
            mut self,
            input: std::option::Option<crate::model::AsyncInferenceNotificationConfig>,
        ) -> Self {
            self.notification_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AsyncInferenceOutputConfig`](crate::model::AsyncInferenceOutputConfig)
        pub fn build(self) -> crate::model::AsyncInferenceOutputConfig {
            crate::model::AsyncInferenceOutputConfig {
                kms_key_id: self.kms_key_id,
                s3_output_path: self.s3_output_path,
                notification_config: self.notification_config,
            }
        }
    }
}
impl AsyncInferenceOutputConfig {
    /// Creates a new builder-style object to manufacture [`AsyncInferenceOutputConfig`](crate::model::AsyncInferenceOutputConfig)
    pub fn builder() -> crate::model::async_inference_output_config::Builder {
        crate::model::async_inference_output_config::Builder::default()
    }
}

/// <p>Specifies the configuration for notifications of inference results for asynchronous inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AsyncInferenceNotificationConfig {
    /// <p>Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.</p>
    pub success_topic: std::option::Option<std::string::String>,
    /// <p>Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.</p>
    pub error_topic: std::option::Option<std::string::String>,
}
impl AsyncInferenceNotificationConfig {
    /// <p>Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.</p>
    pub fn success_topic(&self) -> std::option::Option<&str> {
        self.success_topic.as_deref()
    }
    /// <p>Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.</p>
    pub fn error_topic(&self) -> std::option::Option<&str> {
        self.error_topic.as_deref()
    }
}
impl std::fmt::Debug for AsyncInferenceNotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AsyncInferenceNotificationConfig");
        formatter.field("success_topic", &self.success_topic);
        formatter.field("error_topic", &self.error_topic);
        formatter.finish()
    }
}
/// See [`AsyncInferenceNotificationConfig`](crate::model::AsyncInferenceNotificationConfig)
pub mod async_inference_notification_config {

    /// A builder for [`AsyncInferenceNotificationConfig`](crate::model::AsyncInferenceNotificationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) success_topic: std::option::Option<std::string::String>,
        pub(crate) error_topic: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.</p>
        pub fn success_topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.success_topic = Some(input.into());
            self
        }
        /// <p>Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.</p>
        pub fn set_success_topic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.success_topic = input;
            self
        }
        /// <p>Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.</p>
        pub fn error_topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_topic = Some(input.into());
            self
        }
        /// <p>Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.</p>
        pub fn set_error_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`AsyncInferenceNotificationConfig`](crate::model::AsyncInferenceNotificationConfig)
        pub fn build(self) -> crate::model::AsyncInferenceNotificationConfig {
            crate::model::AsyncInferenceNotificationConfig {
                success_topic: self.success_topic,
                error_topic: self.error_topic,
            }
        }
    }
}
impl AsyncInferenceNotificationConfig {
    /// Creates a new builder-style object to manufacture [`AsyncInferenceNotificationConfig`](crate::model::AsyncInferenceNotificationConfig)
    pub fn builder() -> crate::model::async_inference_notification_config::Builder {
        crate::model::async_inference_notification_config::Builder::default()
    }
}

/// <p>Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AsyncInferenceClientConfig {
    /// <p>The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, SageMaker chooses an optimal value.</p>
    pub max_concurrent_invocations_per_instance: std::option::Option<i32>,
}
impl AsyncInferenceClientConfig {
    /// <p>The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, SageMaker chooses an optimal value.</p>
    pub fn max_concurrent_invocations_per_instance(&self) -> std::option::Option<i32> {
        self.max_concurrent_invocations_per_instance
    }
}
impl std::fmt::Debug for AsyncInferenceClientConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AsyncInferenceClientConfig");
        formatter.field(
            "max_concurrent_invocations_per_instance",
            &self.max_concurrent_invocations_per_instance,
        );
        formatter.finish()
    }
}
/// See [`AsyncInferenceClientConfig`](crate::model::AsyncInferenceClientConfig)
pub mod async_inference_client_config {

    /// A builder for [`AsyncInferenceClientConfig`](crate::model::AsyncInferenceClientConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_concurrent_invocations_per_instance: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, SageMaker chooses an optimal value.</p>
        pub fn max_concurrent_invocations_per_instance(mut self, input: i32) -> Self {
            self.max_concurrent_invocations_per_instance = Some(input);
            self
        }
        /// <p>The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, SageMaker chooses an optimal value.</p>
        pub fn set_max_concurrent_invocations_per_instance(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_concurrent_invocations_per_instance = input;
            self
        }
        /// Consumes the builder and constructs a [`AsyncInferenceClientConfig`](crate::model::AsyncInferenceClientConfig)
        pub fn build(self) -> crate::model::AsyncInferenceClientConfig {
            crate::model::AsyncInferenceClientConfig {
                max_concurrent_invocations_per_instance: self
                    .max_concurrent_invocations_per_instance,
            }
        }
    }
}
impl AsyncInferenceClientConfig {
    /// Creates a new builder-style object to manufacture [`AsyncInferenceClientConfig`](crate::model::AsyncInferenceClientConfig)
    pub fn builder() -> crate::model::async_inference_client_config::Builder {
        crate::model::async_inference_client_config::Builder::default()
    }
}

/// <p>Configuration to control how SageMaker captures inference data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCaptureConfig {
    /// <p>Whether data capture should be enabled or disabled (defaults to enabled).</p>
    pub enable_capture: bool,
    /// <p>The percentage of requests SageMaker will capture. A lower value is recommended for Endpoints with high traffic.</p>
    pub initial_sampling_percentage: std::option::Option<i32>,
    /// <p>The Amazon S3 location used to capture the data.</p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.</p>
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies data Model Monitor will capture. You can configure whether to collect only input, only output, or both</p>
    pub capture_options: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
    /// <p>Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.</p>
    pub capture_content_type_header: std::option::Option<crate::model::CaptureContentTypeHeader>,
}
impl DataCaptureConfig {
    /// <p>Whether data capture should be enabled or disabled (defaults to enabled).</p>
    pub fn enable_capture(&self) -> bool {
        self.enable_capture
    }
    /// <p>The percentage of requests SageMaker will capture. A lower value is recommended for Endpoints with high traffic.</p>
    pub fn initial_sampling_percentage(&self) -> std::option::Option<i32> {
        self.initial_sampling_percentage
    }
    /// <p>The Amazon S3 location used to capture the data.</p>
    pub fn destination_s3_uri(&self) -> std::option::Option<&str> {
        self.destination_s3_uri.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.</p>
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Specifies data Model Monitor will capture. You can configure whether to collect only input, only output, or both</p>
    pub fn capture_options(&self) -> std::option::Option<&[crate::model::CaptureOption]> {
        self.capture_options.as_deref()
    }
    /// <p>Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.</p>
    pub fn capture_content_type_header(
        &self,
    ) -> std::option::Option<&crate::model::CaptureContentTypeHeader> {
        self.capture_content_type_header.as_ref()
    }
}
impl std::fmt::Debug for DataCaptureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCaptureConfig");
        formatter.field("enable_capture", &self.enable_capture);
        formatter.field(
            "initial_sampling_percentage",
            &self.initial_sampling_percentage,
        );
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("capture_options", &self.capture_options);
        formatter.field(
            "capture_content_type_header",
            &self.capture_content_type_header,
        );
        formatter.finish()
    }
}
/// See [`DataCaptureConfig`](crate::model::DataCaptureConfig)
pub mod data_capture_config {

    /// A builder for [`DataCaptureConfig`](crate::model::DataCaptureConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_capture: std::option::Option<bool>,
        pub(crate) initial_sampling_percentage: std::option::Option<i32>,
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) capture_options: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
        pub(crate) capture_content_type_header:
            std::option::Option<crate::model::CaptureContentTypeHeader>,
    }
    impl Builder {
        /// <p>Whether data capture should be enabled or disabled (defaults to enabled).</p>
        pub fn enable_capture(mut self, input: bool) -> Self {
            self.enable_capture = Some(input);
            self
        }
        /// <p>Whether data capture should be enabled or disabled (defaults to enabled).</p>
        pub fn set_enable_capture(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_capture = input;
            self
        }
        /// <p>The percentage of requests SageMaker will capture. A lower value is recommended for Endpoints with high traffic.</p>
        pub fn initial_sampling_percentage(mut self, input: i32) -> Self {
            self.initial_sampling_percentage = Some(input);
            self
        }
        /// <p>The percentage of requests SageMaker will capture. A lower value is recommended for Endpoints with high traffic.</p>
        pub fn set_initial_sampling_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_sampling_percentage = input;
            self
        }
        /// <p>The Amazon S3 location used to capture the data.</p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location used to capture the data.</p>
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.</p>
        /// <p>The KmsKeyId can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.</p>
        /// <p>The KmsKeyId can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Appends an item to `capture_options`.
        ///
        /// To override the contents of this collection use [`set_capture_options`](Self::set_capture_options).
        ///
        /// <p>Specifies data Model Monitor will capture. You can configure whether to collect only input, only output, or both</p>
        pub fn capture_options(mut self, input: crate::model::CaptureOption) -> Self {
            let mut v = self.capture_options.unwrap_or_default();
            v.push(input);
            self.capture_options = Some(v);
            self
        }
        /// <p>Specifies data Model Monitor will capture. You can configure whether to collect only input, only output, or both</p>
        pub fn set_capture_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
        ) -> Self {
            self.capture_options = input;
            self
        }
        /// <p>Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.</p>
        pub fn capture_content_type_header(
            mut self,
            input: crate::model::CaptureContentTypeHeader,
        ) -> Self {
            self.capture_content_type_header = Some(input);
            self
        }
        /// <p>Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.</p>
        pub fn set_capture_content_type_header(
            mut self,
            input: std::option::Option<crate::model::CaptureContentTypeHeader>,
        ) -> Self {
            self.capture_content_type_header = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCaptureConfig`](crate::model::DataCaptureConfig)
        pub fn build(self) -> crate::model::DataCaptureConfig {
            crate::model::DataCaptureConfig {
                enable_capture: self.enable_capture.unwrap_or_default(),
                initial_sampling_percentage: self.initial_sampling_percentage,
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
                capture_options: self.capture_options,
                capture_content_type_header: self.capture_content_type_header,
            }
        }
    }
}
impl DataCaptureConfig {
    /// Creates a new builder-style object to manufacture [`DataCaptureConfig`](crate::model::DataCaptureConfig)
    pub fn builder() -> crate::model::data_capture_config::Builder {
        crate::model::data_capture_config::Builder::default()
    }
}

/// <p>Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptureContentTypeHeader {
    /// <p>The list of all content type headers that SageMaker will treat as CSV and capture accordingly.</p>
    pub csv_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of all content type headers that SageMaker will treat as JSON and capture accordingly.</p>
    pub json_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CaptureContentTypeHeader {
    /// <p>The list of all content type headers that SageMaker will treat as CSV and capture accordingly.</p>
    pub fn csv_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.csv_content_types.as_deref()
    }
    /// <p>The list of all content type headers that SageMaker will treat as JSON and capture accordingly.</p>
    pub fn json_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.json_content_types.as_deref()
    }
}
impl std::fmt::Debug for CaptureContentTypeHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptureContentTypeHeader");
        formatter.field("csv_content_types", &self.csv_content_types);
        formatter.field("json_content_types", &self.json_content_types);
        formatter.finish()
    }
}
/// See [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
pub mod capture_content_type_header {

    /// A builder for [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) csv_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) json_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `csv_content_types`.
        ///
        /// To override the contents of this collection use [`set_csv_content_types`](Self::set_csv_content_types).
        ///
        /// <p>The list of all content type headers that SageMaker will treat as CSV and capture accordingly.</p>
        pub fn csv_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.csv_content_types.unwrap_or_default();
            v.push(input.into());
            self.csv_content_types = Some(v);
            self
        }
        /// <p>The list of all content type headers that SageMaker will treat as CSV and capture accordingly.</p>
        pub fn set_csv_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.csv_content_types = input;
            self
        }
        /// Appends an item to `json_content_types`.
        ///
        /// To override the contents of this collection use [`set_json_content_types`](Self::set_json_content_types).
        ///
        /// <p>The list of all content type headers that SageMaker will treat as JSON and capture accordingly.</p>
        pub fn json_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.json_content_types.unwrap_or_default();
            v.push(input.into());
            self.json_content_types = Some(v);
            self
        }
        /// <p>The list of all content type headers that SageMaker will treat as JSON and capture accordingly.</p>
        pub fn set_json_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.json_content_types = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
        pub fn build(self) -> crate::model::CaptureContentTypeHeader {
            crate::model::CaptureContentTypeHeader {
                csv_content_types: self.csv_content_types,
                json_content_types: self.json_content_types,
            }
        }
    }
}
impl CaptureContentTypeHeader {
    /// Creates a new builder-style object to manufacture [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
    pub fn builder() -> crate::model::capture_content_type_header::Builder {
        crate::model::capture_content_type_header::Builder::default()
    }
}

/// <p>Specifies data Model Monitor will capture.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptureOption {
    /// <p>Specify the boundary of data to capture.</p>
    pub capture_mode: std::option::Option<crate::model::CaptureMode>,
}
impl CaptureOption {
    /// <p>Specify the boundary of data to capture.</p>
    pub fn capture_mode(&self) -> std::option::Option<&crate::model::CaptureMode> {
        self.capture_mode.as_ref()
    }
}
impl std::fmt::Debug for CaptureOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptureOption");
        formatter.field("capture_mode", &self.capture_mode);
        formatter.finish()
    }
}
/// See [`CaptureOption`](crate::model::CaptureOption)
pub mod capture_option {

    /// A builder for [`CaptureOption`](crate::model::CaptureOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capture_mode: std::option::Option<crate::model::CaptureMode>,
    }
    impl Builder {
        /// <p>Specify the boundary of data to capture.</p>
        pub fn capture_mode(mut self, input: crate::model::CaptureMode) -> Self {
            self.capture_mode = Some(input);
            self
        }
        /// <p>Specify the boundary of data to capture.</p>
        pub fn set_capture_mode(
            mut self,
            input: std::option::Option<crate::model::CaptureMode>,
        ) -> Self {
            self.capture_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureOption`](crate::model::CaptureOption)
        pub fn build(self) -> crate::model::CaptureOption {
            crate::model::CaptureOption {
                capture_mode: self.capture_mode,
            }
        }
    }
}
impl CaptureOption {
    /// Creates a new builder-style object to manufacture [`CaptureOption`](crate::model::CaptureOption)
    pub fn builder() -> crate::model::capture_option::Builder {
        crate::model::capture_option::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CaptureMode {
    #[allow(missing_docs)] // documentation missing in model
    Input,
    #[allow(missing_docs)] // documentation missing in model
    Output,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CaptureMode {
    fn from(s: &str) -> Self {
        match s {
            "Input" => CaptureMode::Input,
            "Output" => CaptureMode::Output,
            other => CaptureMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CaptureMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CaptureMode::from(s))
    }
}
impl CaptureMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CaptureMode::Input => "Input",
            CaptureMode::Output => "Output",
            CaptureMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Input", "Output"]
    }
}
impl AsRef<str> for CaptureMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Identifies a model that you want to host and the resources chosen to deploy for hosting it. If you are deploying multiple models, tell SageMaker how to distribute traffic among the models by specifying variant weights. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariant {
    /// <p>The name of the production variant.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>The name of the model that you want to host. This is the name that you specified when creating the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>Number of instances to launch initially.</p>
    pub initial_instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type.</p>
    pub instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
    /// <p>Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code> values across all ProductionVariants. If unspecified, it defaults to 1.0. </p>
    pub initial_variant_weight: std::option::Option<f32>,
    /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
    pub accelerator_type: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
    /// <p>Specifies configuration for a core dump from the model container when the process crashes.</p>
    pub core_dump_config: std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
    /// <p>The serverless configuration for an endpoint. Specifies a serverless endpoint configuration instead of an instance-based endpoint configuration.</p>
    pub serverless_config: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
}
impl ProductionVariant {
    /// <p>The name of the production variant.</p>
    pub fn variant_name(&self) -> std::option::Option<&str> {
        self.variant_name.as_deref()
    }
    /// <p>The name of the model that you want to host. This is the name that you specified when creating the model.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>Number of instances to launch initially.</p>
    pub fn initial_instance_count(&self) -> std::option::Option<i32> {
        self.initial_instance_count
    }
    /// <p>The ML compute instance type.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code> values across all ProductionVariants. If unspecified, it defaults to 1.0. </p>
    pub fn initial_variant_weight(&self) -> std::option::Option<f32> {
        self.initial_variant_weight
    }
    /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
    pub fn accelerator_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantAcceleratorType> {
        self.accelerator_type.as_ref()
    }
    /// <p>Specifies configuration for a core dump from the model container when the process crashes.</p>
    pub fn core_dump_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantCoreDumpConfig> {
        self.core_dump_config.as_ref()
    }
    /// <p>The serverless configuration for an endpoint. Specifies a serverless endpoint configuration instead of an instance-based endpoint configuration.</p>
    pub fn serverless_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantServerlessConfig> {
        self.serverless_config.as_ref()
    }
}
impl std::fmt::Debug for ProductionVariant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariant");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("initial_instance_count", &self.initial_instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("initial_variant_weight", &self.initial_variant_weight);
        formatter.field("accelerator_type", &self.accelerator_type);
        formatter.field("core_dump_config", &self.core_dump_config);
        formatter.field("serverless_config", &self.serverless_config);
        formatter.finish()
    }
}
/// See [`ProductionVariant`](crate::model::ProductionVariant)
pub mod production_variant {

    /// A builder for [`ProductionVariant`](crate::model::ProductionVariant)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) initial_instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
        pub(crate) initial_variant_weight: std::option::Option<f32>,
        pub(crate) accelerator_type:
            std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        pub(crate) core_dump_config:
            std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
        pub(crate) serverless_config:
            std::option::Option<crate::model::ProductionVariantServerlessConfig>,
    }
    impl Builder {
        /// <p>The name of the production variant.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        /// <p>The name of the production variant.</p>
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// <p>The name of the model that you want to host. This is the name that you specified when creating the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model that you want to host. This is the name that you specified when creating the model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>Number of instances to launch initially.</p>
        pub fn initial_instance_count(mut self, input: i32) -> Self {
            self.initial_instance_count = Some(input);
            self
        }
        /// <p>Number of instances to launch initially.</p>
        pub fn set_initial_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_instance_count = input;
            self
        }
        /// <p>The ML compute instance type.</p>
        pub fn instance_type(mut self, input: crate::model::ProductionVariantInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The ML compute instance type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code> values across all ProductionVariants. If unspecified, it defaults to 1.0. </p>
        pub fn initial_variant_weight(mut self, input: f32) -> Self {
            self.initial_variant_weight = Some(input);
            self
        }
        /// <p>Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code> values across all ProductionVariants. If unspecified, it defaults to 1.0. </p>
        pub fn set_initial_variant_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.initial_variant_weight = input;
            self
        }
        /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
        pub fn accelerator_type(
            mut self,
            input: crate::model::ProductionVariantAcceleratorType,
        ) -> Self {
            self.accelerator_type = Some(input);
            self
        }
        /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
        pub fn set_accelerator_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        ) -> Self {
            self.accelerator_type = input;
            self
        }
        /// <p>Specifies configuration for a core dump from the model container when the process crashes.</p>
        pub fn core_dump_config(
            mut self,
            input: crate::model::ProductionVariantCoreDumpConfig,
        ) -> Self {
            self.core_dump_config = Some(input);
            self
        }
        /// <p>Specifies configuration for a core dump from the model container when the process crashes.</p>
        pub fn set_core_dump_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
        ) -> Self {
            self.core_dump_config = input;
            self
        }
        /// <p>The serverless configuration for an endpoint. Specifies a serverless endpoint configuration instead of an instance-based endpoint configuration.</p>
        pub fn serverless_config(
            mut self,
            input: crate::model::ProductionVariantServerlessConfig,
        ) -> Self {
            self.serverless_config = Some(input);
            self
        }
        /// <p>The serverless configuration for an endpoint. Specifies a serverless endpoint configuration instead of an instance-based endpoint configuration.</p>
        pub fn set_serverless_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        ) -> Self {
            self.serverless_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariant`](crate::model::ProductionVariant)
        pub fn build(self) -> crate::model::ProductionVariant {
            crate::model::ProductionVariant {
                variant_name: self.variant_name,
                model_name: self.model_name,
                initial_instance_count: self.initial_instance_count,
                instance_type: self.instance_type,
                initial_variant_weight: self.initial_variant_weight,
                accelerator_type: self.accelerator_type,
                core_dump_config: self.core_dump_config,
                serverless_config: self.serverless_config,
            }
        }
    }
}
impl ProductionVariant {
    /// Creates a new builder-style object to manufacture [`ProductionVariant`](crate::model::ProductionVariant)
    pub fn builder() -> crate::model::production_variant::Builder {
        crate::model::production_variant::Builder::default()
    }
}

/// <p>Specifies configuration for a core dump from the model container when the process crashes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantCoreDumpConfig {
    /// <p>The Amazon S3 bucket to send the core dump to.</p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl ProductionVariantCoreDumpConfig {
    /// <p>The Amazon S3 bucket to send the core dump to.</p>
    pub fn destination_s3_uri(&self) -> std::option::Option<&str> {
        self.destination_s3_uri.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for ProductionVariantCoreDumpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantCoreDumpConfig");
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
pub mod production_variant_core_dump_config {

    /// A builder for [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket to send the core dump to.</p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket to send the core dump to.</p>
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket policy with an <code>s3:PutObject</code> permission that only allows objects with server-side encryption, set the condition key of <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
        pub fn build(self) -> crate::model::ProductionVariantCoreDumpConfig {
            crate::model::ProductionVariantCoreDumpConfig {
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl ProductionVariantCoreDumpConfig {
    /// Creates a new builder-style object to manufacture [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
    pub fn builder() -> crate::model::production_variant_core_dump_config::Builder {
        crate::model::production_variant_core_dump_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductionVariantAcceleratorType {
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Large,
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlEia1Xlarge,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Large,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Medium,
    #[allow(missing_docs)] // documentation missing in model
    MlEia2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProductionVariantAcceleratorType {
    fn from(s: &str) -> Self {
        match s {
            "ml.eia1.large" => ProductionVariantAcceleratorType::MlEia1Large,
            "ml.eia1.medium" => ProductionVariantAcceleratorType::MlEia1Medium,
            "ml.eia1.xlarge" => ProductionVariantAcceleratorType::MlEia1Xlarge,
            "ml.eia2.large" => ProductionVariantAcceleratorType::MlEia2Large,
            "ml.eia2.medium" => ProductionVariantAcceleratorType::MlEia2Medium,
            "ml.eia2.xlarge" => ProductionVariantAcceleratorType::MlEia2Xlarge,
            other => ProductionVariantAcceleratorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProductionVariantAcceleratorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductionVariantAcceleratorType::from(s))
    }
}
impl ProductionVariantAcceleratorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductionVariantAcceleratorType::MlEia1Large => "ml.eia1.large",
            ProductionVariantAcceleratorType::MlEia1Medium => "ml.eia1.medium",
            ProductionVariantAcceleratorType::MlEia1Xlarge => "ml.eia1.xlarge",
            ProductionVariantAcceleratorType::MlEia2Large => "ml.eia2.large",
            ProductionVariantAcceleratorType::MlEia2Medium => "ml.eia2.medium",
            ProductionVariantAcceleratorType::MlEia2Xlarge => "ml.eia2.xlarge",
            ProductionVariantAcceleratorType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.eia1.large",
            "ml.eia1.medium",
            "ml.eia1.xlarge",
            "ml.eia2.large",
            "ml.eia2.medium",
            "ml.eia2.xlarge",
        ]
    }
}
impl AsRef<str> for ProductionVariantAcceleratorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of an in-progress deployment when an endpoint is creating or updating with a new endpoint configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PendingDeploymentSummary {
    /// <p>The name of the endpoint configuration used in the deployment. </p>
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>List of <code>PendingProductionVariantSummary</code> objects.</p>
    pub production_variants:
        std::option::Option<std::vec::Vec<crate::model::PendingProductionVariantSummary>>,
    /// <p>The start time of the deployment.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PendingDeploymentSummary {
    /// <p>The name of the endpoint configuration used in the deployment. </p>
    pub fn endpoint_config_name(&self) -> std::option::Option<&str> {
        self.endpoint_config_name.as_deref()
    }
    /// <p>List of <code>PendingProductionVariantSummary</code> objects.</p>
    pub fn production_variants(
        &self,
    ) -> std::option::Option<&[crate::model::PendingProductionVariantSummary]> {
        self.production_variants.as_deref()
    }
    /// <p>The start time of the deployment.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl std::fmt::Debug for PendingDeploymentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PendingDeploymentSummary");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`PendingDeploymentSummary`](crate::model::PendingDeploymentSummary)
pub mod pending_deployment_summary {

    /// A builder for [`PendingDeploymentSummary`](crate::model::PendingDeploymentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_config_name: std::option::Option<std::string::String>,
        pub(crate) production_variants:
            std::option::Option<std::vec::Vec<crate::model::PendingProductionVariantSummary>>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the endpoint configuration used in the deployment. </p>
        pub fn endpoint_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint configuration used in the deployment. </p>
        pub fn set_endpoint_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_name = input;
            self
        }
        /// Appends an item to `production_variants`.
        ///
        /// To override the contents of this collection use [`set_production_variants`](Self::set_production_variants).
        ///
        /// <p>List of <code>PendingProductionVariantSummary</code> objects.</p>
        pub fn production_variants(
            mut self,
            input: crate::model::PendingProductionVariantSummary,
        ) -> Self {
            let mut v = self.production_variants.unwrap_or_default();
            v.push(input);
            self.production_variants = Some(v);
            self
        }
        /// <p>List of <code>PendingProductionVariantSummary</code> objects.</p>
        pub fn set_production_variants(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::PendingProductionVariantSummary>,
            >,
        ) -> Self {
            self.production_variants = input;
            self
        }
        /// <p>The start time of the deployment.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the deployment.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingDeploymentSummary`](crate::model::PendingDeploymentSummary)
        pub fn build(self) -> crate::model::PendingDeploymentSummary {
            crate::model::PendingDeploymentSummary {
                endpoint_config_name: self.endpoint_config_name,
                production_variants: self.production_variants,
                start_time: self.start_time,
            }
        }
    }
}
impl PendingDeploymentSummary {
    /// Creates a new builder-style object to manufacture [`PendingDeploymentSummary`](crate::model::PendingDeploymentSummary)
    pub fn builder() -> crate::model::pending_deployment_summary::Builder {
        crate::model::pending_deployment_summary::Builder::default()
    }
}

/// <p>The production variant summary for a deployment when an endpoint is creating or updating with the <code> <code>CreateEndpoint</code> </code> or <code> <code>UpdateEndpoint</code> </code> operations. Describes the <code>VariantStatus </code>, weight and capacity for a production variant associated with an endpoint. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PendingProductionVariantSummary {
    /// <p>The name of the variant.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
    pub deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
    /// <p>The weight associated with the variant.</p>
    pub current_weight: std::option::Option<f32>,
    /// <p>The requested weight for the variant in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
    pub desired_weight: std::option::Option<f32>,
    /// <p>The number of instances associated with the variant.</p>
    pub current_instance_count: std::option::Option<i32>,
    /// <p>The number of instances requested in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
    pub desired_instance_count: std::option::Option<i32>,
    /// <p>The type of instances associated with the variant.</p>
    pub instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
    /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
    pub accelerator_type: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    pub variant_status: std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
    /// <p>The serverless configuration for the endpoint.</p>
    pub current_serverless_config:
        std::option::Option<crate::model::ProductionVariantServerlessConfig>,
    /// <p>The serverless configuration requested for this deployment, as specified in the endpoint configuration for the endpoint.</p>
    pub desired_serverless_config:
        std::option::Option<crate::model::ProductionVariantServerlessConfig>,
}
impl PendingProductionVariantSummary {
    /// <p>The name of the variant.</p>
    pub fn variant_name(&self) -> std::option::Option<&str> {
        self.variant_name.as_deref()
    }
    /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
    pub fn deployed_images(&self) -> std::option::Option<&[crate::model::DeployedImage]> {
        self.deployed_images.as_deref()
    }
    /// <p>The weight associated with the variant.</p>
    pub fn current_weight(&self) -> std::option::Option<f32> {
        self.current_weight
    }
    /// <p>The requested weight for the variant in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
    pub fn desired_weight(&self) -> std::option::Option<f32> {
        self.desired_weight
    }
    /// <p>The number of instances associated with the variant.</p>
    pub fn current_instance_count(&self) -> std::option::Option<i32> {
        self.current_instance_count
    }
    /// <p>The number of instances requested in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
    pub fn desired_instance_count(&self) -> std::option::Option<i32> {
        self.desired_instance_count
    }
    /// <p>The type of instances associated with the variant.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
    pub fn accelerator_type(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantAcceleratorType> {
        self.accelerator_type.as_ref()
    }
    /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
    pub fn variant_status(&self) -> std::option::Option<&[crate::model::ProductionVariantStatus]> {
        self.variant_status.as_deref()
    }
    /// <p>The serverless configuration for the endpoint.</p>
    pub fn current_serverless_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantServerlessConfig> {
        self.current_serverless_config.as_ref()
    }
    /// <p>The serverless configuration requested for this deployment, as specified in the endpoint configuration for the endpoint.</p>
    pub fn desired_serverless_config(
        &self,
    ) -> std::option::Option<&crate::model::ProductionVariantServerlessConfig> {
        self.desired_serverless_config.as_ref()
    }
}
impl std::fmt::Debug for PendingProductionVariantSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PendingProductionVariantSummary");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("deployed_images", &self.deployed_images);
        formatter.field("current_weight", &self.current_weight);
        formatter.field("desired_weight", &self.desired_weight);
        formatter.field("current_instance_count", &self.current_instance_count);
        formatter.field("desired_instance_count", &self.desired_instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("accelerator_type", &self.accelerator_type);
        formatter.field("variant_status", &self.variant_status);
        formatter.field("current_serverless_config", &self.current_serverless_config);
        formatter.field("desired_serverless_config", &self.desired_serverless_config);
        formatter.finish()
    }
}
/// See [`PendingProductionVariantSummary`](crate::model::PendingProductionVariantSummary)
pub mod pending_production_variant_summary {

    /// A builder for [`PendingProductionVariantSummary`](crate::model::PendingProductionVariantSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        pub(crate) current_weight: std::option::Option<f32>,
        pub(crate) desired_weight: std::option::Option<f32>,
        pub(crate) current_instance_count: std::option::Option<i32>,
        pub(crate) desired_instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
        pub(crate) accelerator_type:
            std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        pub(crate) variant_status:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
        pub(crate) current_serverless_config:
            std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        pub(crate) desired_serverless_config:
            std::option::Option<crate::model::ProductionVariantServerlessConfig>,
    }
    impl Builder {
        /// <p>The name of the variant.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        /// <p>The name of the variant.</p>
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// Appends an item to `deployed_images`.
        ///
        /// To override the contents of this collection use [`set_deployed_images`](Self::set_deployed_images).
        ///
        /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
        pub fn deployed_images(mut self, input: crate::model::DeployedImage) -> Self {
            let mut v = self.deployed_images.unwrap_or_default();
            v.push(input);
            self.deployed_images = Some(v);
            self
        }
        /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this <code>ProductionVariant</code>.</p>
        pub fn set_deployed_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        ) -> Self {
            self.deployed_images = input;
            self
        }
        /// <p>The weight associated with the variant.</p>
        pub fn current_weight(mut self, input: f32) -> Self {
            self.current_weight = Some(input);
            self
        }
        /// <p>The weight associated with the variant.</p>
        pub fn set_current_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.current_weight = input;
            self
        }
        /// <p>The requested weight for the variant in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
        pub fn desired_weight(mut self, input: f32) -> Self {
            self.desired_weight = Some(input);
            self
        }
        /// <p>The requested weight for the variant in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
        pub fn set_desired_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.desired_weight = input;
            self
        }
        /// <p>The number of instances associated with the variant.</p>
        pub fn current_instance_count(mut self, input: i32) -> Self {
            self.current_instance_count = Some(input);
            self
        }
        /// <p>The number of instances associated with the variant.</p>
        pub fn set_current_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.current_instance_count = input;
            self
        }
        /// <p>The number of instances requested in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
        pub fn desired_instance_count(mut self, input: i32) -> Self {
            self.desired_instance_count = Some(input);
            self
        }
        /// <p>The number of instances requested in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the <code> <code>CreateEndpointConfig</code> </code> operation.</p>
        pub fn set_desired_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_instance_count = input;
            self
        }
        /// <p>The type of instances associated with the variant.</p>
        pub fn instance_type(mut self, input: crate::model::ProductionVariantInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The type of instances associated with the variant.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
        pub fn accelerator_type(
            mut self,
            input: crate::model::ProductionVariantAcceleratorType,
        ) -> Self {
            self.accelerator_type = Some(input);
            self
        }
        /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
        pub fn set_accelerator_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        ) -> Self {
            self.accelerator_type = input;
            self
        }
        /// Appends an item to `variant_status`.
        ///
        /// To override the contents of this collection use [`set_variant_status`](Self::set_variant_status).
        ///
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        pub fn variant_status(mut self, input: crate::model::ProductionVariantStatus) -> Self {
            let mut v = self.variant_status.unwrap_or_default();
            v.push(input);
            self.variant_status = Some(v);
            self
        }
        /// <p>The endpoint variant status which describes the current deployment stage status or operational status.</p>
        pub fn set_variant_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantStatus>>,
        ) -> Self {
            self.variant_status = input;
            self
        }
        /// <p>The serverless configuration for the endpoint.</p>
        pub fn current_serverless_config(
            mut self,
            input: crate::model::ProductionVariantServerlessConfig,
        ) -> Self {
            self.current_serverless_config = Some(input);
            self
        }
        /// <p>The serverless configuration for the endpoint.</p>
        pub fn set_current_serverless_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        ) -> Self {
            self.current_serverless_config = input;
            self
        }
        /// <p>The serverless configuration requested for this deployment, as specified in the endpoint configuration for the endpoint.</p>
        pub fn desired_serverless_config(
            mut self,
            input: crate::model::ProductionVariantServerlessConfig,
        ) -> Self {
            self.desired_serverless_config = Some(input);
            self
        }
        /// <p>The serverless configuration requested for this deployment, as specified in the endpoint configuration for the endpoint.</p>
        pub fn set_desired_serverless_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantServerlessConfig>,
        ) -> Self {
            self.desired_serverless_config = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingProductionVariantSummary`](crate::model::PendingProductionVariantSummary)
        pub fn build(self) -> crate::model::PendingProductionVariantSummary {
            crate::model::PendingProductionVariantSummary {
                variant_name: self.variant_name,
                deployed_images: self.deployed_images,
                current_weight: self.current_weight,
                desired_weight: self.desired_weight,
                current_instance_count: self.current_instance_count,
                desired_instance_count: self.desired_instance_count,
                instance_type: self.instance_type,
                accelerator_type: self.accelerator_type,
                variant_status: self.variant_status,
                current_serverless_config: self.current_serverless_config,
                desired_serverless_config: self.desired_serverless_config,
            }
        }
    }
}
impl PendingProductionVariantSummary {
    /// Creates a new builder-style object to manufacture [`PendingProductionVariantSummary`](crate::model::PendingProductionVariantSummary)
    pub fn builder() -> crate::model::pending_production_variant_summary::Builder {
        crate::model::pending_production_variant_summary::Builder::default()
    }
}

/// <p>The output of a SageMaker Edge Manager deployable resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgePresetDeploymentOutput {
    /// <p>The deployment type created by SageMaker Edge Manager. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub r#type: std::option::Option<crate::model::EdgePresetDeploymentType>,
    /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
    pub artifact: std::option::Option<std::string::String>,
    /// <p>The status of the deployable resource.</p>
    pub status: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
    /// <p>Returns a message describing the status of the deployed resource.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl EdgePresetDeploymentOutput {
    /// <p>The deployment type created by SageMaker Edge Manager. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::EdgePresetDeploymentType> {
        self.r#type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
    pub fn artifact(&self) -> std::option::Option<&str> {
        self.artifact.as_deref()
    }
    /// <p>The status of the deployable resource.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EdgePresetDeploymentStatus> {
        self.status.as_ref()
    }
    /// <p>Returns a message describing the status of the deployed resource.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl std::fmt::Debug for EdgePresetDeploymentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgePresetDeploymentOutput");
        formatter.field("r#type", &self.r#type);
        formatter.field("artifact", &self.artifact);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
pub mod edge_preset_deployment_output {

    /// A builder for [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::EdgePresetDeploymentType>,
        pub(crate) artifact: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The deployment type created by SageMaker Edge Manager. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn r#type(mut self, input: crate::model::EdgePresetDeploymentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The deployment type created by SageMaker Edge Manager. Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
        pub fn artifact(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
        pub fn set_artifact(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.artifact = input;
            self
        }
        /// <p>The status of the deployable resource.</p>
        pub fn status(mut self, input: crate::model::EdgePresetDeploymentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the deployable resource.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Returns a message describing the status of the deployed resource.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Returns a message describing the status of the deployed resource.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
        pub fn build(self) -> crate::model::EdgePresetDeploymentOutput {
            crate::model::EdgePresetDeploymentOutput {
                r#type: self.r#type,
                artifact: self.artifact,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}
impl EdgePresetDeploymentOutput {
    /// Creates a new builder-style object to manufacture [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
    pub fn builder() -> crate::model::edge_preset_deployment_output::Builder {
        crate::model::edge_preset_deployment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePresetDeploymentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePresetDeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => EdgePresetDeploymentStatus::Completed,
            "FAILED" => EdgePresetDeploymentStatus::Failed,
            other => EdgePresetDeploymentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePresetDeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePresetDeploymentStatus::from(s))
    }
}
impl EdgePresetDeploymentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EdgePresetDeploymentStatus::Completed => "COMPLETED",
            EdgePresetDeploymentStatus::Failed => "FAILED",
            EdgePresetDeploymentStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED"]
    }
}
impl AsRef<str> for EdgePresetDeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppSecurityGroupManagement {
    #[allow(missing_docs)] // documentation missing in model
    Customer,
    #[allow(missing_docs)] // documentation missing in model
    Service,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppSecurityGroupManagement {
    fn from(s: &str) -> Self {
        match s {
            "Customer" => AppSecurityGroupManagement::Customer,
            "Service" => AppSecurityGroupManagement::Service,
            other => AppSecurityGroupManagement::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppSecurityGroupManagement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppSecurityGroupManagement::from(s))
    }
}
impl AppSecurityGroupManagement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppSecurityGroupManagement::Customer => "Customer",
            AppSecurityGroupManagement::Service => "Service",
            AppSecurityGroupManagement::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Customer", "Service"]
    }
}
impl AsRef<str> for AppSecurityGroupManagement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of settings that apply to the <code>SageMaker Domain</code>. These settings are specified through the <code>CreateDomain</code> API call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainSettings {
    /// <p>The security groups for the Amazon Virtual Private Cloud that the <code>Domain</code> uses for communication between Domain-level apps and user apps.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A collection of settings that configure the <code>RStudioServerPro</code> Domain-level app.</p>
    pub r_studio_server_pro_domain_settings:
        std::option::Option<crate::model::RStudioServerProDomainSettings>,
}
impl DomainSettings {
    /// <p>The security groups for the Amazon Virtual Private Cloud that the <code>Domain</code> uses for communication between Domain-level apps and user apps.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>A collection of settings that configure the <code>RStudioServerPro</code> Domain-level app.</p>
    pub fn r_studio_server_pro_domain_settings(
        &self,
    ) -> std::option::Option<&crate::model::RStudioServerProDomainSettings> {
        self.r_studio_server_pro_domain_settings.as_ref()
    }
}
impl std::fmt::Debug for DomainSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainSettings");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field(
            "r_studio_server_pro_domain_settings",
            &self.r_studio_server_pro_domain_settings,
        );
        formatter.finish()
    }
}
/// See [`DomainSettings`](crate::model::DomainSettings)
pub mod domain_settings {

    /// A builder for [`DomainSettings`](crate::model::DomainSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r_studio_server_pro_domain_settings:
            std::option::Option<crate::model::RStudioServerProDomainSettings>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The security groups for the Amazon Virtual Private Cloud that the <code>Domain</code> uses for communication between Domain-level apps and user apps.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The security groups for the Amazon Virtual Private Cloud that the <code>Domain</code> uses for communication between Domain-level apps and user apps.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>A collection of settings that configure the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn r_studio_server_pro_domain_settings(
            mut self,
            input: crate::model::RStudioServerProDomainSettings,
        ) -> Self {
            self.r_studio_server_pro_domain_settings = Some(input);
            self
        }
        /// <p>A collection of settings that configure the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn set_r_studio_server_pro_domain_settings(
            mut self,
            input: std::option::Option<crate::model::RStudioServerProDomainSettings>,
        ) -> Self {
            self.r_studio_server_pro_domain_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainSettings`](crate::model::DomainSettings)
        pub fn build(self) -> crate::model::DomainSettings {
            crate::model::DomainSettings {
                security_group_ids: self.security_group_ids,
                r_studio_server_pro_domain_settings: self.r_studio_server_pro_domain_settings,
            }
        }
    }
}
impl DomainSettings {
    /// Creates a new builder-style object to manufacture [`DomainSettings`](crate::model::DomainSettings)
    pub fn builder() -> crate::model::domain_settings::Builder {
        crate::model::domain_settings::Builder::default()
    }
}

/// <p>A collection of settings that configure the <code>RStudioServerPro</code> Domain-level app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RStudioServerProDomainSettings {
    /// <p>The ARN of the execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
    pub domain_execution_role_arn: std::option::Option<std::string::String>,
    /// <p>A URL pointing to an RStudio Connect server.</p>
    pub r_studio_connect_url: std::option::Option<std::string::String>,
    /// <p>A URL pointing to an RStudio Package Manager server.</p>
    pub r_studio_package_manager_url: std::option::Option<std::string::String>,
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl RStudioServerProDomainSettings {
    /// <p>The ARN of the execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
    pub fn domain_execution_role_arn(&self) -> std::option::Option<&str> {
        self.domain_execution_role_arn.as_deref()
    }
    /// <p>A URL pointing to an RStudio Connect server.</p>
    pub fn r_studio_connect_url(&self) -> std::option::Option<&str> {
        self.r_studio_connect_url.as_deref()
    }
    /// <p>A URL pointing to an RStudio Package Manager server.</p>
    pub fn r_studio_package_manager_url(&self) -> std::option::Option<&str> {
        self.r_studio_package_manager_url.as_deref()
    }
    /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
    pub fn default_resource_spec(&self) -> std::option::Option<&crate::model::ResourceSpec> {
        self.default_resource_spec.as_ref()
    }
}
impl std::fmt::Debug for RStudioServerProDomainSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RStudioServerProDomainSettings");
        formatter.field("domain_execution_role_arn", &self.domain_execution_role_arn);
        formatter.field("r_studio_connect_url", &self.r_studio_connect_url);
        formatter.field(
            "r_studio_package_manager_url",
            &self.r_studio_package_manager_url,
        );
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.finish()
    }
}
/// See [`RStudioServerProDomainSettings`](crate::model::RStudioServerProDomainSettings)
pub mod r_studio_server_pro_domain_settings {

    /// A builder for [`RStudioServerProDomainSettings`](crate::model::RStudioServerProDomainSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) r_studio_connect_url: std::option::Option<std::string::String>,
        pub(crate) r_studio_package_manager_url: std::option::Option<std::string::String>,
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    }
    impl Builder {
        /// <p>The ARN of the execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn domain_execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_execution_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the execution role for the <code>RStudioServerPro</code> Domain-level app.</p>
        pub fn set_domain_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_execution_role_arn = input;
            self
        }
        /// <p>A URL pointing to an RStudio Connect server.</p>
        pub fn r_studio_connect_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.r_studio_connect_url = Some(input.into());
            self
        }
        /// <p>A URL pointing to an RStudio Connect server.</p>
        pub fn set_r_studio_connect_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.r_studio_connect_url = input;
            self
        }
        /// <p>A URL pointing to an RStudio Package Manager server.</p>
        pub fn r_studio_package_manager_url(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.r_studio_package_manager_url = Some(input.into());
            self
        }
        /// <p>A URL pointing to an RStudio Package Manager server.</p>
        pub fn set_r_studio_package_manager_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.r_studio_package_manager_url = input;
            self
        }
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        /// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that the version runs on.</p>
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Consumes the builder and constructs a [`RStudioServerProDomainSettings`](crate::model::RStudioServerProDomainSettings)
        pub fn build(self) -> crate::model::RStudioServerProDomainSettings {
            crate::model::RStudioServerProDomainSettings {
                domain_execution_role_arn: self.domain_execution_role_arn,
                r_studio_connect_url: self.r_studio_connect_url,
                r_studio_package_manager_url: self.r_studio_package_manager_url,
                default_resource_spec: self.default_resource_spec,
            }
        }
    }
}
impl RStudioServerProDomainSettings {
    /// Creates a new builder-style object to manufacture [`RStudioServerProDomainSettings`](crate::model::RStudioServerProDomainSettings)
    pub fn builder() -> crate::model::r_studio_server_pro_domain_settings::Builder {
        crate::model::r_studio_server_pro_domain_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppNetworkAccessType {
    #[allow(missing_docs)] // documentation missing in model
    PublicInternetOnly,
    #[allow(missing_docs)] // documentation missing in model
    VpcOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppNetworkAccessType {
    fn from(s: &str) -> Self {
        match s {
            "PublicInternetOnly" => AppNetworkAccessType::PublicInternetOnly,
            "VpcOnly" => AppNetworkAccessType::VpcOnly,
            other => AppNetworkAccessType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppNetworkAccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppNetworkAccessType::from(s))
    }
}
impl AppNetworkAccessType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppNetworkAccessType::PublicInternetOnly => "PublicInternetOnly",
            AppNetworkAccessType::VpcOnly => "VpcOnly",
            AppNetworkAccessType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PublicInternetOnly", "VpcOnly"]
    }
}
impl AsRef<str> for AppNetworkAccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthMode {
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    Sso,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AuthMode {
    fn from(s: &str) -> Self {
        match s {
            "IAM" => AuthMode::Iam,
            "SSO" => AuthMode::Sso,
            other => AuthMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AuthMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthMode::from(s))
    }
}
impl AuthMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthMode::Iam => "IAM",
            AuthMode::Sso => "SSO",
            AuthMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["IAM", "SSO"]
    }
}
impl AsRef<str> for AuthMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The model on the edge device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModel {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The model version.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last data sample taken.</p>
    pub latest_sample_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of the last inference that was made.</p>
    pub latest_inference: std::option::Option<aws_smithy_types::DateTime>,
}
impl EdgeModel {
    /// <p>The name of the model.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
    /// <p>The model version.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The timestamp of the last data sample taken.</p>
    pub fn latest_sample_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_sample_time.as_ref()
    }
    /// <p>The timestamp of the last inference that was made.</p>
    pub fn latest_inference(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_inference.as_ref()
    }
}
impl std::fmt::Debug for EdgeModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModel");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("latest_sample_time", &self.latest_sample_time);
        formatter.field("latest_inference", &self.latest_inference);
        formatter.finish()
    }
}
/// See [`EdgeModel`](crate::model::EdgeModel)
pub mod edge_model {

    /// A builder for [`EdgeModel`](crate::model::EdgeModel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) latest_sample_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_inference: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The model version.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The model version.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The timestamp of the last data sample taken.</p>
        pub fn latest_sample_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_sample_time = Some(input);
            self
        }
        /// <p>The timestamp of the last data sample taken.</p>
        pub fn set_latest_sample_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_sample_time = input;
            self
        }
        /// <p>The timestamp of the last inference that was made.</p>
        pub fn latest_inference(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_inference = Some(input);
            self
        }
        /// <p>The timestamp of the last inference that was made.</p>
        pub fn set_latest_inference(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_inference = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModel`](crate::model::EdgeModel)
        pub fn build(self) -> crate::model::EdgeModel {
            crate::model::EdgeModel {
                model_name: self.model_name,
                model_version: self.model_version,
                latest_sample_time: self.latest_sample_time,
                latest_inference: self.latest_inference,
            }
        }
    }
}
impl EdgeModel {
    /// Creates a new builder-style object to manufacture [`EdgeModel`](crate::model::EdgeModel)
    pub fn builder() -> crate::model::edge_model::Builder {
        crate::model::edge_model::Builder::default()
    }
}

/// <p>The input for the data quality monitoring job. Currently endpoints are supported for input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl DataQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub fn endpoint_input(&self) -> std::option::Option<&crate::model::EndpointInput> {
        self.endpoint_input.as_ref()
    }
}
impl std::fmt::Debug for DataQualityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`DataQualityJobInput`](crate::model::DataQualityJobInput)
pub mod data_quality_job_input {

    /// A builder for [`DataQualityJobInput`](crate::model::DataQualityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        /// <p>Input object for the endpoint</p>
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityJobInput`](crate::model::DataQualityJobInput)
        pub fn build(self) -> crate::model::DataQualityJobInput {
            crate::model::DataQualityJobInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl DataQualityJobInput {
    /// Creates a new builder-style object to manufacture [`DataQualityJobInput`](crate::model::DataQualityJobInput)
    pub fn builder() -> crate::model::data_quality_job_input::Builder {
        crate::model::data_quality_job_input::Builder::default()
    }
}

/// <p>Information about the container that a data quality monitoring job runs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityAppSpecification {
    /// <p>The container image that the data quality monitoring job runs.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The entrypoint for a container used to run a monitoring job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The arguments to send to the container that the monitoring job runs.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DataQualityAppSpecification {
    /// <p>The container image that the data quality monitoring job runs.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The entrypoint for a container used to run a monitoring job.</p>
    pub fn container_entrypoint(&self) -> std::option::Option<&[std::string::String]> {
        self.container_entrypoint.as_deref()
    }
    /// <p>The arguments to send to the container that the monitoring job runs.</p>
    pub fn container_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.container_arguments.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
    pub fn record_preprocessor_source_uri(&self) -> std::option::Option<&str> {
        self.record_preprocessor_source_uri.as_deref()
    }
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
    pub fn post_analytics_processor_source_uri(&self) -> std::option::Option<&str> {
        self.post_analytics_processor_source_uri.as_deref()
    }
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment.as_ref()
    }
}
impl std::fmt::Debug for DataQualityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
pub mod data_quality_app_specification {

    /// A builder for [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image that the data quality monitoring job runs.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The container image that the data quality monitoring job runs.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Appends an item to `container_entrypoint`.
        ///
        /// To override the contents of this collection use [`set_container_entrypoint`](Self::set_container_entrypoint).
        ///
        /// <p>The entrypoint for a container used to run a monitoring job.</p>
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        /// <p>The entrypoint for a container used to run a monitoring job.</p>
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        /// Appends an item to `container_arguments`.
        ///
        /// To override the contents of this collection use [`set_container_arguments`](Self::set_container_arguments).
        ///
        /// <p>The arguments to send to the container that the monitoring job runs.</p>
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        /// <p>The arguments to send to the container that the monitoring job runs.</p>
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.</p>
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.</p>
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        /// Adds a key-value pair to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
        pub fn build(self) -> crate::model::DataQualityAppSpecification {
            crate::model::DataQualityAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
                environment: self.environment,
            }
        }
    }
}
impl DataQualityAppSpecification {
    /// Creates a new builder-style object to manufacture [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
    pub fn builder() -> crate::model::data_quality_app_specification::Builder {
        crate::model::data_quality_app_specification::Builder::default()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
    /// <p>The statistics resource for a monitoring job.</p>
    pub statistics_resource: std::option::Option<crate::model::MonitoringStatisticsResource>,
}
impl DataQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
    pub fn baselining_job_name(&self) -> std::option::Option<&str> {
        self.baselining_job_name.as_deref()
    }
    /// <p>The constraints resource for a monitoring job.</p>
    pub fn constraints_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConstraintsResource> {
        self.constraints_resource.as_ref()
    }
    /// <p>The statistics resource for a monitoring job.</p>
    pub fn statistics_resource(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringStatisticsResource> {
        self.statistics_resource.as_ref()
    }
}
impl std::fmt::Debug for DataQualityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.field("statistics_resource", &self.statistics_resource);
        formatter.finish()
    }
}
/// See [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
pub mod data_quality_baseline_config {

    /// A builder for [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
        pub(crate) statistics_resource:
            std::option::Option<crate::model::MonitoringStatisticsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// <p>The statistics resource for a monitoring job.</p>
        pub fn statistics_resource(
            mut self,
            input: crate::model::MonitoringStatisticsResource,
        ) -> Self {
            self.statistics_resource = Some(input);
            self
        }
        /// <p>The statistics resource for a monitoring job.</p>
        pub fn set_statistics_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringStatisticsResource>,
        ) -> Self {
            self.statistics_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
        pub fn build(self) -> crate::model::DataQualityBaselineConfig {
            crate::model::DataQualityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
                statistics_resource: self.statistics_resource,
            }
        }
    }
}
impl DataQualityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
    pub fn builder() -> crate::model::data_quality_baseline_config::Builder {
        crate::model::data_quality_baseline_config::Builder::default()
    }
}

/// <p>The <code>VpcConfig</code> configuration object that specifies the VPC that you want the compilation jobs to connect to. For more information on controlling access to your Amazon S3 buckets used for compilation job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-vpc.html">Give Amazon SageMaker Compilation Jobs Access to Resources in Your Amazon VPC</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NeoVpcConfig {
    /// <p>The VPC security group IDs. IDs have the form of <code>sg-xxxxxxxx</code>. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the subnets in the VPC that you want to connect the compilation job to for accessing the model in Amazon S3.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl NeoVpcConfig {
    /// <p>The VPC security group IDs. IDs have the form of <code>sg-xxxxxxxx</code>. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The ID of the subnets in the VPC that you want to connect the compilation job to for accessing the model in Amazon S3.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
}
impl std::fmt::Debug for NeoVpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NeoVpcConfig");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`NeoVpcConfig`](crate::model::NeoVpcConfig)
pub mod neo_vpc_config {

    /// A builder for [`NeoVpcConfig`](crate::model::NeoVpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The VPC security group IDs. IDs have the form of <code>sg-xxxxxxxx</code>. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The VPC security group IDs. IDs have the form of <code>sg-xxxxxxxx</code>. Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>The ID of the subnets in the VPC that you want to connect the compilation job to for accessing the model in Amazon S3.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>The ID of the subnets in the VPC that you want to connect the compilation job to for accessing the model in Amazon S3.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`NeoVpcConfig`](crate::model::NeoVpcConfig)
        pub fn build(self) -> crate::model::NeoVpcConfig {
            crate::model::NeoVpcConfig {
                security_group_ids: self.security_group_ids,
                subnets: self.subnets,
            }
        }
    }
}
impl NeoVpcConfig {
    /// Creates a new builder-style object to manufacture [`NeoVpcConfig`](crate::model::NeoVpcConfig)
    pub fn builder() -> crate::model::neo_vpc_config::Builder {
        crate::model::neo_vpc_config::Builder::default()
    }
}

/// <p>Contains information about the output location for the compiled model and the target device that the model runs on. <code>TargetDevice</code> and <code>TargetPlatform</code> are mutually exclusive, so you need to choose one between the two to specify your target device or platform. If you cannot find your device you want to use from the <code>TargetDevice</code> list, use <code>TargetPlatform</code> to describe the platform of your edge device and <code>CompilerOptions</code> if there are specific settings that are required or recommended to use for particular TargetPlatform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputConfig {
    /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub s3_output_location: std::option::Option<std::string::String>,
    /// <p>Identifies the target device or the machine learning instance that you want to run your model on after the compilation has completed. Alternatively, you can specify OS, architecture, and accelerator using <code>TargetPlatform</code> fields. It can be used instead of <code>TargetPlatform</code>.</p>
    pub target_device: std::option::Option<crate::model::TargetDevice>,
    /// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
    /// <p>The following examples show how to configure the <code>TargetPlatform</code> and <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
    /// <ul>
    /// <li> <p>Raspberry Pi 3 Model B+</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code> </p> <p> <code> "CompilerOptions": {'mattr': ['+neon']}</code> </p> </li>
    /// <li> <p>Jetson TX2</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1', 'cuda-ver': '10.0'}</code> </p> </li>
    /// <li> <p>EC2 m5.2xlarge instance OS</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p>RK3399</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "MALI"}</code> </p> </li>
    /// <li> <p>ARMv7 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr': ['+neon']}</code> </p> </li>
    /// <li> <p>ARMv8 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code> </p> </li>
    /// </ul>
    pub target_platform: std::option::Option<crate::model::TargetPlatform>,
    /// <p>Specifies additional parameters for compiler options in JSON format. The compiler options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators and highly recommended for CPU compilations. For any other cases, it is optional to specify <code>CompilerOptions.</code> </p>
    /// <ul>
    /// <li> <p> <code>DTYPE</code>: Specifies the data type for the input. When compiling for <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch framework, provide the data type (dtype) of the model's input. <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified. Options for data type are:</p>
    /// <ul>
    /// <li> <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p> </li>
    /// <li> <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p> </li>
    /// </ul> <p> For example, <code>{"dtype" : "float32"}</code>.</p> </li>
    /// <li> <p> <code>CPU</code>: Compilation for CPU supports the following compiler options.</p>
    /// <ul>
    /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>ARM</code>: Details of ARM CPU compilations.</p>
    /// <ul>
    /// <li> <p> <code>NEON</code>: NEON is an implementation of the Advanced SIMD extension used in ARMv7 processors.</p> <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler options if compiling for ARM 32-bit platform with the NEON support.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following compiler options.</p>
    /// <ul>
    /// <li> <p> <code>gpu_code</code>: Specifies the targeted architecture.</p> </li>
    /// <li> <p> <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z. format.</p> </li>
    /// <li> <p> <code>cuda-ver</code>: Specifies the CUDA version in x.y format.</p> </li>
    /// </ul> <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver': '10.1'}</code> </p> </li>
    /// <li> <p> <code>ANDROID</code>: Compilation for the Android OS supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>ANDROID_PLATFORM</code>: Specifies the Android API levels. Available levels range from 21 to 29. For example, <code>{'ANDROID_PLATFORM': 28}</code>.</p> </li>
    /// <li> <p> <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler options if compiling for ARM 32-bit platform with NEON support.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options passed in as a JSON string. For example, <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>. </p> <p>For information about supported compiler options, see <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md"> Neuron Compiler CLI</a>. </p> </li>
    /// <li> <p> <code>CoreML</code>: Compilation for the CoreML <code>OutputConfig$TargetDevice</code> supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>class_labels</code>: Specifies the classification labels file name inside input tar.gz file. For example, <code>{"class_labels": "imagenet_labels_1000.txt"}</code>. Labels inside the txt file should be separated by newlines.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values are <code>"FP16"</code> and <code>"FP32"</code>. Default is <code>"FP32"</code>.</p> </li>
    /// <li> <p> <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel format. Defaults is TensorFlow's default signature def key.</p> </li>
    /// <li> <p> <code>output_names</code>: Specifies a list of output tensor names for models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p> </li>
    /// </ul> <p>For example: <code>{"precision_mode": "FP32", "output_names": ["output:0"]}</code> </p> </li>
    /// </ul>
    pub compiler_options: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl OutputConfig {
    /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub fn s3_output_location(&self) -> std::option::Option<&str> {
        self.s3_output_location.as_deref()
    }
    /// <p>Identifies the target device or the machine learning instance that you want to run your model on after the compilation has completed. Alternatively, you can specify OS, architecture, and accelerator using <code>TargetPlatform</code> fields. It can be used instead of <code>TargetPlatform</code>.</p>
    pub fn target_device(&self) -> std::option::Option<&crate::model::TargetDevice> {
        self.target_device.as_ref()
    }
    /// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
    /// <p>The following examples show how to configure the <code>TargetPlatform</code> and <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
    /// <ul>
    /// <li> <p>Raspberry Pi 3 Model B+</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code> </p> <p> <code> "CompilerOptions": {'mattr': ['+neon']}</code> </p> </li>
    /// <li> <p>Jetson TX2</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1', 'cuda-ver': '10.0'}</code> </p> </li>
    /// <li> <p>EC2 m5.2xlarge instance OS</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p>RK3399</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "MALI"}</code> </p> </li>
    /// <li> <p>ARMv7 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr': ['+neon']}</code> </p> </li>
    /// <li> <p>ARMv8 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code> </p> </li>
    /// </ul>
    pub fn target_platform(&self) -> std::option::Option<&crate::model::TargetPlatform> {
        self.target_platform.as_ref()
    }
    /// <p>Specifies additional parameters for compiler options in JSON format. The compiler options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators and highly recommended for CPU compilations. For any other cases, it is optional to specify <code>CompilerOptions.</code> </p>
    /// <ul>
    /// <li> <p> <code>DTYPE</code>: Specifies the data type for the input. When compiling for <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch framework, provide the data type (dtype) of the model's input. <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified. Options for data type are:</p>
    /// <ul>
    /// <li> <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p> </li>
    /// <li> <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p> </li>
    /// </ul> <p> For example, <code>{"dtype" : "float32"}</code>.</p> </li>
    /// <li> <p> <code>CPU</code>: Compilation for CPU supports the following compiler options.</p>
    /// <ul>
    /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>ARM</code>: Details of ARM CPU compilations.</p>
    /// <ul>
    /// <li> <p> <code>NEON</code>: NEON is an implementation of the Advanced SIMD extension used in ARMv7 processors.</p> <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler options if compiling for ARM 32-bit platform with the NEON support.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following compiler options.</p>
    /// <ul>
    /// <li> <p> <code>gpu_code</code>: Specifies the targeted architecture.</p> </li>
    /// <li> <p> <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z. format.</p> </li>
    /// <li> <p> <code>cuda-ver</code>: Specifies the CUDA version in x.y format.</p> </li>
    /// </ul> <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver': '10.1'}</code> </p> </li>
    /// <li> <p> <code>ANDROID</code>: Compilation for the Android OS supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>ANDROID_PLATFORM</code>: Specifies the Android API levels. Available levels range from 21 to 29. For example, <code>{'ANDROID_PLATFORM': 28}</code>.</p> </li>
    /// <li> <p> <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler options if compiling for ARM 32-bit platform with NEON support.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options passed in as a JSON string. For example, <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>. </p> <p>For information about supported compiler options, see <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md"> Neuron Compiler CLI</a>. </p> </li>
    /// <li> <p> <code>CoreML</code>: Compilation for the CoreML <code>OutputConfig$TargetDevice</code> supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>class_labels</code>: Specifies the classification labels file name inside input tar.gz file. For example, <code>{"class_labels": "imagenet_labels_1000.txt"}</code>. Labels inside the txt file should be separated by newlines.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following compiler options:</p>
    /// <ul>
    /// <li> <p> <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values are <code>"FP16"</code> and <code>"FP32"</code>. Default is <code>"FP32"</code>.</p> </li>
    /// <li> <p> <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel format. Defaults is TensorFlow's default signature def key.</p> </li>
    /// <li> <p> <code>output_names</code>: Specifies a list of output tensor names for models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p> </li>
    /// </ul> <p>For example: <code>{"precision_mode": "FP32", "output_names": ["output:0"]}</code> </p> </li>
    /// </ul>
    pub fn compiler_options(&self) -> std::option::Option<&str> {
        self.compiler_options.as_deref()
    }
    /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
    /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
    /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputConfig");
        formatter.field("s3_output_location", &self.s3_output_location);
        formatter.field("target_device", &self.target_device);
        formatter.field("target_platform", &self.target_platform);
        formatter.field("compiler_options", &self.compiler_options);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`OutputConfig`](crate::model::OutputConfig)
pub mod output_config {

    /// A builder for [`OutputConfig`](crate::model::OutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_location: std::option::Option<std::string::String>,
        pub(crate) target_device: std::option::Option<crate::model::TargetDevice>,
        pub(crate) target_platform: std::option::Option<crate::model::TargetPlatform>,
        pub(crate) compiler_options: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn s3_output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_location = Some(input.into());
            self
        }
        /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn set_s3_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_location = input;
            self
        }
        /// <p>Identifies the target device or the machine learning instance that you want to run your model on after the compilation has completed. Alternatively, you can specify OS, architecture, and accelerator using <code>TargetPlatform</code> fields. It can be used instead of <code>TargetPlatform</code>.</p>
        pub fn target_device(mut self, input: crate::model::TargetDevice) -> Self {
            self.target_device = Some(input);
            self
        }
        /// <p>Identifies the target device or the machine learning instance that you want to run your model on after the compilation has completed. Alternatively, you can specify OS, architecture, and accelerator using <code>TargetPlatform</code> fields. It can be used instead of <code>TargetPlatform</code>.</p>
        pub fn set_target_device(
            mut self,
            input: std::option::Option<crate::model::TargetDevice>,
        ) -> Self {
            self.target_device = input;
            self
        }
        /// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
        /// <p>The following examples show how to configure the <code>TargetPlatform</code> and <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
        /// <ul>
        /// <li> <p>Raspberry Pi 3 Model B+</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code> </p> <p> <code> "CompilerOptions": {'mattr': ['+neon']}</code> </p> </li>
        /// <li> <p>Jetson TX2</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1', 'cuda-ver': '10.0'}</code> </p> </li>
        /// <li> <p>EC2 m5.2xlarge instance OS</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p>RK3399</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "MALI"}</code> </p> </li>
        /// <li> <p>ARMv7 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr': ['+neon']}</code> </p> </li>
        /// <li> <p>ARMv8 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code> </p> </li>
        /// </ul>
        pub fn target_platform(mut self, input: crate::model::TargetPlatform) -> Self {
            self.target_platform = Some(input);
            self
        }
        /// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
        /// <p>The following examples show how to configure the <code>TargetPlatform</code> and <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
        /// <ul>
        /// <li> <p>Raspberry Pi 3 Model B+</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code> </p> <p> <code> "CompilerOptions": {'mattr': ['+neon']}</code> </p> </li>
        /// <li> <p>Jetson TX2</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1', 'cuda-ver': '10.0'}</code> </p> </li>
        /// <li> <p>EC2 m5.2xlarge instance OS</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator": "NVIDIA"},</code> </p> <p> <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p>RK3399</p> <p> <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "MALI"}</code> </p> </li>
        /// <li> <p>ARMv7 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr': ['+neon']}</code> </p> </li>
        /// <li> <p>ARMv8 phone (CPU)</p> <p> <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code> </p> <p> <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code> </p> </li>
        /// </ul>
        pub fn set_target_platform(
            mut self,
            input: std::option::Option<crate::model::TargetPlatform>,
        ) -> Self {
            self.target_platform = input;
            self
        }
        /// <p>Specifies additional parameters for compiler options in JSON format. The compiler options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators and highly recommended for CPU compilations. For any other cases, it is optional to specify <code>CompilerOptions.</code> </p>
        /// <ul>
        /// <li> <p> <code>DTYPE</code>: Specifies the data type for the input. When compiling for <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch framework, provide the data type (dtype) of the model's input. <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified. Options for data type are:</p>
        /// <ul>
        /// <li> <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p> </li>
        /// <li> <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p> </li>
        /// </ul> <p> For example, <code>{"dtype" : "float32"}</code>.</p> </li>
        /// <li> <p> <code>CPU</code>: Compilation for CPU supports the following compiler options.</p>
        /// <ul>
        /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>ARM</code>: Details of ARM CPU compilations.</p>
        /// <ul>
        /// <li> <p> <code>NEON</code>: NEON is an implementation of the Advanced SIMD extension used in ARMv7 processors.</p> <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler options if compiling for ARM 32-bit platform with the NEON support.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following compiler options.</p>
        /// <ul>
        /// <li> <p> <code>gpu_code</code>: Specifies the targeted architecture.</p> </li>
        /// <li> <p> <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z. format.</p> </li>
        /// <li> <p> <code>cuda-ver</code>: Specifies the CUDA version in x.y format.</p> </li>
        /// </ul> <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver': '10.1'}</code> </p> </li>
        /// <li> <p> <code>ANDROID</code>: Compilation for the Android OS supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>ANDROID_PLATFORM</code>: Specifies the Android API levels. Available levels range from 21 to 29. For example, <code>{'ANDROID_PLATFORM': 28}</code>.</p> </li>
        /// <li> <p> <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler options if compiling for ARM 32-bit platform with NEON support.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options passed in as a JSON string. For example, <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>. </p> <p>For information about supported compiler options, see <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md"> Neuron Compiler CLI</a>. </p> </li>
        /// <li> <p> <code>CoreML</code>: Compilation for the CoreML <code>OutputConfig$TargetDevice</code> supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>class_labels</code>: Specifies the classification labels file name inside input tar.gz file. For example, <code>{"class_labels": "imagenet_labels_1000.txt"}</code>. Labels inside the txt file should be separated by newlines.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values are <code>"FP16"</code> and <code>"FP32"</code>. Default is <code>"FP32"</code>.</p> </li>
        /// <li> <p> <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel format. Defaults is TensorFlow's default signature def key.</p> </li>
        /// <li> <p> <code>output_names</code>: Specifies a list of output tensor names for models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p> </li>
        /// </ul> <p>For example: <code>{"precision_mode": "FP32", "output_names": ["output:0"]}</code> </p> </li>
        /// </ul>
        pub fn compiler_options(mut self, input: impl Into<std::string::String>) -> Self {
            self.compiler_options = Some(input.into());
            self
        }
        /// <p>Specifies additional parameters for compiler options in JSON format. The compiler options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators and highly recommended for CPU compilations. For any other cases, it is optional to specify <code>CompilerOptions.</code> </p>
        /// <ul>
        /// <li> <p> <code>DTYPE</code>: Specifies the data type for the input. When compiling for <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch framework, provide the data type (dtype) of the model's input. <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified. Options for data type are:</p>
        /// <ul>
        /// <li> <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p> </li>
        /// <li> <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p> </li>
        /// </ul> <p> For example, <code>{"dtype" : "float32"}</code>.</p> </li>
        /// <li> <p> <code>CPU</code>: Compilation for CPU supports the following compiler options.</p>
        /// <ul>
        /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>ARM</code>: Details of ARM CPU compilations.</p>
        /// <ul>
        /// <li> <p> <code>NEON</code>: NEON is an implementation of the Advanced SIMD extension used in ARMv7 processors.</p> <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler options if compiling for ARM 32-bit platform with the NEON support.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following compiler options.</p>
        /// <ul>
        /// <li> <p> <code>gpu_code</code>: Specifies the targeted architecture.</p> </li>
        /// <li> <p> <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z. format.</p> </li>
        /// <li> <p> <code>cuda-ver</code>: Specifies the CUDA version in x.y format.</p> </li>
        /// </ul> <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver': '10.1'}</code> </p> </li>
        /// <li> <p> <code>ANDROID</code>: Compilation for the Android OS supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>ANDROID_PLATFORM</code>: Specifies the Android API levels. Available levels range from 21 to 29. For example, <code>{'ANDROID_PLATFORM': 28}</code>.</p> </li>
        /// <li> <p> <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler options if compiling for ARM 32-bit platform with NEON support.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options passed in as a JSON string. For example, <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>. </p> <p>For information about supported compiler options, see <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md"> Neuron Compiler CLI</a>. </p> </li>
        /// <li> <p> <code>CoreML</code>: Compilation for the CoreML <code>OutputConfig$TargetDevice</code> supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>class_labels</code>: Specifies the classification labels file name inside input tar.gz file. For example, <code>{"class_labels": "imagenet_labels_1000.txt"}</code>. Labels inside the txt file should be separated by newlines.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following compiler options:</p>
        /// <ul>
        /// <li> <p> <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values are <code>"FP16"</code> and <code>"FP32"</code>. Default is <code>"FP32"</code>.</p> </li>
        /// <li> <p> <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel format. Defaults is TensorFlow's default signature def key.</p> </li>
        /// <li> <p> <code>output_names</code>: Specifies a list of output tensor names for models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p> </li>
        /// </ul> <p>For example: <code>{"precision_mode": "FP32", "output_names": ["output:0"]}</code> </p> </li>
        /// </ul>
        pub fn set_compiler_options(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compiler_options = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KmsKeyId can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i> </p>
        /// <p>The KmsKeyId can be any of the following formats: </p>
        /// <ul>
        /// <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Key ARN: <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li>
        /// <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li>
        /// <li> <p>Alias name ARN: <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputConfig`](crate::model::OutputConfig)
        pub fn build(self) -> crate::model::OutputConfig {
            crate::model::OutputConfig {
                s3_output_location: self.s3_output_location,
                target_device: self.target_device,
                target_platform: self.target_platform,
                compiler_options: self.compiler_options,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl OutputConfig {
    /// Creates a new builder-style object to manufacture [`OutputConfig`](crate::model::OutputConfig)
    pub fn builder() -> crate::model::output_config::Builder {
        crate::model::output_config::Builder::default()
    }
}

/// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetPlatform {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub os: std::option::Option<crate::model::TargetPlatformOs>,
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub arch: std::option::Option<crate::model::TargetPlatformArch>,
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
}
impl TargetPlatform {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub fn os(&self) -> std::option::Option<&crate::model::TargetPlatformOs> {
        self.os.as_ref()
    }
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub fn arch(&self) -> std::option::Option<&crate::model::TargetPlatformArch> {
        self.arch.as_ref()
    }
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub fn accelerator(&self) -> std::option::Option<&crate::model::TargetPlatformAccelerator> {
        self.accelerator.as_ref()
    }
}
impl std::fmt::Debug for TargetPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetPlatform");
        formatter.field("os", &self.os);
        formatter.field("arch", &self.arch);
        formatter.field("accelerator", &self.accelerator);
        formatter.finish()
    }
}
/// See [`TargetPlatform`](crate::model::TargetPlatform)
pub mod target_platform {

    /// A builder for [`TargetPlatform`](crate::model::TargetPlatform)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) os: std::option::Option<crate::model::TargetPlatformOs>,
        pub(crate) arch: std::option::Option<crate::model::TargetPlatformArch>,
        pub(crate) accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
    }
    impl Builder {
        /// <p>Specifies a target platform OS.</p>
        /// <ul>
        /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
        /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
        /// </ul>
        pub fn os(mut self, input: crate::model::TargetPlatformOs) -> Self {
            self.os = Some(input);
            self
        }
        /// <p>Specifies a target platform OS.</p>
        /// <ul>
        /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
        /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
        /// </ul>
        pub fn set_os(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformOs>,
        ) -> Self {
            self.os = input;
            self
        }
        /// <p>Specifies a target platform architecture.</p>
        /// <ul>
        /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
        /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
        /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
        /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
        /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
        /// </ul>
        pub fn arch(mut self, input: crate::model::TargetPlatformArch) -> Self {
            self.arch = Some(input);
            self
        }
        /// <p>Specifies a target platform architecture.</p>
        /// <ul>
        /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
        /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
        /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
        /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
        /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
        /// </ul>
        pub fn set_arch(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformArch>,
        ) -> Self {
            self.arch = input;
            self
        }
        /// <p>Specifies a target platform accelerator (optional).</p>
        /// <ul>
        /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
        /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
        /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
        /// </ul>
        pub fn accelerator(mut self, input: crate::model::TargetPlatformAccelerator) -> Self {
            self.accelerator = Some(input);
            self
        }
        /// <p>Specifies a target platform accelerator (optional).</p>
        /// <ul>
        /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
        /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
        /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
        /// </ul>
        pub fn set_accelerator(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformAccelerator>,
        ) -> Self {
            self.accelerator = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetPlatform`](crate::model::TargetPlatform)
        pub fn build(self) -> crate::model::TargetPlatform {
            crate::model::TargetPlatform {
                os: self.os,
                arch: self.arch,
                accelerator: self.accelerator,
            }
        }
    }
}
impl TargetPlatform {
    /// Creates a new builder-style object to manufacture [`TargetPlatform`](crate::model::TargetPlatform)
    pub fn builder() -> crate::model::target_platform::Builder {
        crate::model::target_platform::Builder::default()
    }
}

/// <p>Contains information about the location of input model artifacts, the name and shape of the expected data inputs, and the framework in which the model was trained.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputConfig {
    /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are <code>InputConfig$Framework</code> specific. </p>
    /// <ul>
    /// <li> <p> <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of the expected data inputs using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input":[1,1024,1024,3]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input\":[1,1024,1024,3]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"data1": [1,28,28,1], "data2":[1,28,28,1]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"data1\": [1,28,28,1], \"data2\":[1,28,28,1]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>KERAS</code>: You must specify the name and shape (NCHW format) of expected data inputs using a dictionary format for your trained model. Note that while Keras model artifacts should be uploaded in NHWC (channel-last) format, <code>DataInputConfig</code> should be specified in NCHW (channel-first) format. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input_1":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input_1\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input_1": [1,3,224,224], "input_2":[1,3,224,224]} </code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input_1\": [1,3,224,224], \"input_2\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of the expected data inputs in order using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"data":[1,3,1024,1024]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"data\":[1,3,1024,1024]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"var1": [1,1,28,28], "var2":[1,1,28,28]} </code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"var1\": [1,1,28,28], \"var2\":[1,1,28,28]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>PyTorch</code>: You can either specify the name and shape (NCHW format) of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format. The dictionary formats required for the console and CLI are different. The list formats for the console and CLI are the same.</p>
    /// <ul>
    /// <li> <p>Examples for one input in dictionary format:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input0":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Example for one input in list format: <code>[[1,3,224,224]]</code> </p> </li>
    /// <li> <p>Examples for two inputs in dictionary format:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input0":[1,3,224,224], "input1":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224], \"input1\":[1,3,224,224]} </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Example for two inputs in list format: <code>[[1,3,224,224], [1,3,224,224]]</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>XGBOOST</code>: input data name and shape are not needed.</p> </li>
    /// </ul>
    /// <p> <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code> <code>OutputConfig$TargetDevice</code> (ML Model format):</p>
    /// <ul>
    /// <li> <p> <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>. In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
    /// <ul>
    /// <li> <p>Range Dimension. You can use the Range Dimension feature if you know the input shape will be within some specific interval in that dimension, for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code> </p> </li>
    /// <li> <p>Enumerated shapes. Sometimes, the models are trained to work only on a select set of inputs. You can enumerate all supported input shapes, for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>default_shape</code>: Default input shape. You can set a default shape during conversion for both Range Dimension and Enumerated Shapes. For example <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code> </p> </li>
    /// <li> <p> <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>. By default, the converter generates an ML Model with inputs of type Tensor (MultiArray). User can set input type to be Image. Image input type requires additional input parameters such as <code>bias</code> and <code>scale</code>.</p> </li>
    /// <li> <p> <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p> </li>
    /// <li> <p> <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p> </li>
    /// </ul>
    /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using <code>OutputConfig$CompilerOptions</code>. CoreML converter supports Tensorflow and PyTorch models. CoreML conversion examples:</p>
    /// <ul>
    /// <li> <p>Tensor type input:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3]}}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Tensor type input without input name (PyTorch):</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224]}]</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Image type input:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Image type input without input name (PyTorch):</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for <code>ml_eia2</code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
    /// <ul>
    /// <li> <p>For TensorFlow models saved in the SavedModel format, specify the input names from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>. Specify the <code>signature_def_key</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a> if the model does not use TensorFlow's default signature def key. For example:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a>. For example:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    pub data_input_config: std::option::Option<std::string::String>,
    /// <p>Identifies the framework in which the model was trained. For example: TENSORFLOW.</p>
    pub framework: std::option::Option<crate::model::Framework>,
    /// <p>Specifies the framework version to use. This API field is only supported for the PyTorch and TensorFlow frameworks.</p>
    /// <p>For information about framework versions supported for cloud targets and edge devices, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-cloud.html">Cloud Supported Instance Types and Frameworks</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-devices-edge-frameworks.html">Edge Supported Frameworks</a>.</p>
    pub framework_version: std::option::Option<std::string::String>,
}
impl InputConfig {
    /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are <code>InputConfig$Framework</code> specific. </p>
    /// <ul>
    /// <li> <p> <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of the expected data inputs using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input":[1,1024,1024,3]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input\":[1,1024,1024,3]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"data1": [1,28,28,1], "data2":[1,28,28,1]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"data1\": [1,28,28,1], \"data2\":[1,28,28,1]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>KERAS</code>: You must specify the name and shape (NCHW format) of expected data inputs using a dictionary format for your trained model. Note that while Keras model artifacts should be uploaded in NHWC (channel-last) format, <code>DataInputConfig</code> should be specified in NCHW (channel-first) format. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input_1":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input_1\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input_1": [1,3,224,224], "input_2":[1,3,224,224]} </code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input_1\": [1,3,224,224], \"input_2\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of the expected data inputs in order using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li> <p>Examples for one input:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"data":[1,3,1024,1024]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"data\":[1,3,1024,1024]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Examples for two inputs:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"var1": [1,1,28,28], "var2":[1,1,28,28]} </code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"var1\": [1,1,28,28], \"var2\":[1,1,28,28]}</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p> <code>PyTorch</code>: You can either specify the name and shape (NCHW format) of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format. The dictionary formats required for the console and CLI are different. The list formats for the console and CLI are the same.</p>
    /// <ul>
    /// <li> <p>Examples for one input in dictionary format:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input0":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224]}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Example for one input in list format: <code>[[1,3,224,224]]</code> </p> </li>
    /// <li> <p>Examples for two inputs in dictionary format:</p>
    /// <ul>
    /// <li> <p>If using the console, <code>{"input0":[1,3,224,224], "input1":[1,3,224,224]}</code> </p> </li>
    /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224], \"input1\":[1,3,224,224]} </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Example for two inputs in list format: <code>[[1,3,224,224], [1,3,224,224]]</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>XGBOOST</code>: input data name and shape are not needed.</p> </li>
    /// </ul>
    /// <p> <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code> <code>OutputConfig$TargetDevice</code> (ML Model format):</p>
    /// <ul>
    /// <li> <p> <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>. In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
    /// <ul>
    /// <li> <p>Range Dimension. You can use the Range Dimension feature if you know the input shape will be within some specific interval in that dimension, for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code> </p> </li>
    /// <li> <p>Enumerated shapes. Sometimes, the models are trained to work only on a select set of inputs. You can enumerate all supported input shapes, for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p> <code>default_shape</code>: Default input shape. You can set a default shape during conversion for both Range Dimension and Enumerated Shapes. For example <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code> </p> </li>
    /// <li> <p> <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>. By default, the converter generates an ML Model with inputs of type Tensor (MultiArray). User can set input type to be Image. Image input type requires additional input parameters such as <code>bias</code> and <code>scale</code>.</p> </li>
    /// <li> <p> <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p> </li>
    /// <li> <p> <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p> </li>
    /// </ul>
    /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using <code>OutputConfig$CompilerOptions</code>. CoreML converter supports Tensorflow and PyTorch models. CoreML conversion examples:</p>
    /// <ul>
    /// <li> <p>Tensor type input:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3]}}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Tensor type input without input name (PyTorch):</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224]}]</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Image type input:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Image type input without input name (PyTorch):</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for <code>ml_eia2</code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
    /// <ul>
    /// <li> <p>For TensorFlow models saved in the SavedModel format, specify the input names from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>. Specify the <code>signature_def_key</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a> if the model does not use TensorFlow's default signature def key. For example:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a>. For example:</p>
    /// <ul>
    /// <li> <p> <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code> </p> </li>
    /// <li> <p> <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    pub fn data_input_config(&self) -> std::option::Option<&str> {
        self.data_input_config.as_deref()
    }
    /// <p>Identifies the framework in which the model was trained. For example: TENSORFLOW.</p>
    pub fn framework(&self) -> std::option::Option<&crate::model::Framework> {
        self.framework.as_ref()
    }
    /// <p>Specifies the framework version to use. This API field is only supported for the PyTorch and TensorFlow frameworks.</p>
    /// <p>For information about framework versions supported for cloud targets and edge devices, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-cloud.html">Cloud Supported Instance Types and Frameworks</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-devices-edge-frameworks.html">Edge Supported Frameworks</a>.</p>
    pub fn framework_version(&self) -> std::option::Option<&str> {
        self.framework_version.as_deref()
    }
}
impl std::fmt::Debug for InputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("data_input_config", &self.data_input_config);
        formatter.field("framework", &self.framework);
        formatter.field("framework_version", &self.framework_version);
        formatter.finish()
    }
}
/// See [`InputConfig`](crate::model::InputConfig)
pub mod input_config {

    /// A builder for [`InputConfig`](crate::model::InputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) data_input_config: std::option::Option<std::string::String>,
        pub(crate) framework: std::option::Option<crate::model::Framework>,
        pub(crate) framework_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are <code>InputConfig$Framework</code> specific. </p>
        /// <ul>
        /// <li> <p> <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of the expected data inputs using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input":[1,1024,1024,3]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input\":[1,1024,1024,3]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"data1": [1,28,28,1], "data2":[1,28,28,1]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"data1\": [1,28,28,1], \"data2\":[1,28,28,1]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>KERAS</code>: You must specify the name and shape (NCHW format) of expected data inputs using a dictionary format for your trained model. Note that while Keras model artifacts should be uploaded in NHWC (channel-last) format, <code>DataInputConfig</code> should be specified in NCHW (channel-first) format. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input_1":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input_1\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input_1": [1,3,224,224], "input_2":[1,3,224,224]} </code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input_1\": [1,3,224,224], \"input_2\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of the expected data inputs in order using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"data":[1,3,1024,1024]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"data\":[1,3,1024,1024]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"var1": [1,1,28,28], "var2":[1,1,28,28]} </code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"var1\": [1,1,28,28], \"var2\":[1,1,28,28]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>PyTorch</code>: You can either specify the name and shape (NCHW format) of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format. The dictionary formats required for the console and CLI are different. The list formats for the console and CLI are the same.</p>
        /// <ul>
        /// <li> <p>Examples for one input in dictionary format:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input0":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Example for one input in list format: <code>[[1,3,224,224]]</code> </p> </li>
        /// <li> <p>Examples for two inputs in dictionary format:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input0":[1,3,224,224], "input1":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224], \"input1\":[1,3,224,224]} </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Example for two inputs in list format: <code>[[1,3,224,224], [1,3,224,224]]</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>XGBOOST</code>: input data name and shape are not needed.</p> </li>
        /// </ul>
        /// <p> <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code> <code>OutputConfig$TargetDevice</code> (ML Model format):</p>
        /// <ul>
        /// <li> <p> <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>. In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
        /// <ul>
        /// <li> <p>Range Dimension. You can use the Range Dimension feature if you know the input shape will be within some specific interval in that dimension, for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code> </p> </li>
        /// <li> <p>Enumerated shapes. Sometimes, the models are trained to work only on a select set of inputs. You can enumerate all supported input shapes, for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>default_shape</code>: Default input shape. You can set a default shape during conversion for both Range Dimension and Enumerated Shapes. For example <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code> </p> </li>
        /// <li> <p> <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>. By default, the converter generates an ML Model with inputs of type Tensor (MultiArray). User can set input type to be Image. Image input type requires additional input parameters such as <code>bias</code> and <code>scale</code>.</p> </li>
        /// <li> <p> <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p> </li>
        /// <li> <p> <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p> </li>
        /// </ul>
        /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using <code>OutputConfig$CompilerOptions</code>. CoreML converter supports Tensorflow and PyTorch models. CoreML conversion examples:</p>
        /// <ul>
        /// <li> <p>Tensor type input:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3]}}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Tensor type input without input name (PyTorch):</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224]}]</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Image type input:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Image type input without input name (PyTorch):</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
        /// </ul> </li>
        /// </ul>
        /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for <code>ml_eia2</code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
        /// <ul>
        /// <li> <p>For TensorFlow models saved in the SavedModel format, specify the input names from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>. Specify the <code>signature_def_key</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a> if the model does not use TensorFlow's default signature def key. For example:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a>. For example:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code> </p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn data_input_config(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_input_config = Some(input.into());
            self
        }
        /// <p>Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are <code>InputConfig$Framework</code> specific. </p>
        /// <ul>
        /// <li> <p> <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of the expected data inputs using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input":[1,1024,1024,3]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input\":[1,1024,1024,3]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"data1": [1,28,28,1], "data2":[1,28,28,1]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"data1\": [1,28,28,1], \"data2\":[1,28,28,1]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>KERAS</code>: You must specify the name and shape (NCHW format) of expected data inputs using a dictionary format for your trained model. Note that while Keras model artifacts should be uploaded in NHWC (channel-last) format, <code>DataInputConfig</code> should be specified in NCHW (channel-first) format. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input_1":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input_1\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input_1": [1,3,224,224], "input_2":[1,3,224,224]} </code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input_1\": [1,3,224,224], \"input_2\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of the expected data inputs in order using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li> <p>Examples for one input:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"data":[1,3,1024,1024]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"data\":[1,3,1024,1024]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Examples for two inputs:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"var1": [1,1,28,28], "var2":[1,1,28,28]} </code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"var1\": [1,1,28,28], \"var2\":[1,1,28,28]}</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p> <code>PyTorch</code>: You can either specify the name and shape (NCHW format) of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format. The dictionary formats required for the console and CLI are different. The list formats for the console and CLI are the same.</p>
        /// <ul>
        /// <li> <p>Examples for one input in dictionary format:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input0":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224]}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Example for one input in list format: <code>[[1,3,224,224]]</code> </p> </li>
        /// <li> <p>Examples for two inputs in dictionary format:</p>
        /// <ul>
        /// <li> <p>If using the console, <code>{"input0":[1,3,224,224], "input1":[1,3,224,224]}</code> </p> </li>
        /// <li> <p>If using the CLI, <code>{\"input0\":[1,3,224,224], \"input1\":[1,3,224,224]} </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Example for two inputs in list format: <code>[[1,3,224,224], [1,3,224,224]]</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>XGBOOST</code>: input data name and shape are not needed.</p> </li>
        /// </ul>
        /// <p> <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code> <code>OutputConfig$TargetDevice</code> (ML Model format):</p>
        /// <ul>
        /// <li> <p> <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>. In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
        /// <ul>
        /// <li> <p>Range Dimension. You can use the Range Dimension feature if you know the input shape will be within some specific interval in that dimension, for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code> </p> </li>
        /// <li> <p>Enumerated shapes. Sometimes, the models are trained to work only on a select set of inputs. You can enumerate all supported input shapes, for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p> <code>default_shape</code>: Default input shape. You can set a default shape during conversion for both Range Dimension and Enumerated Shapes. For example <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code> </p> </li>
        /// <li> <p> <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>. By default, the converter generates an ML Model with inputs of type Tensor (MultiArray). User can set input type to be Image. Image input type requires additional input parameters such as <code>bias</code> and <code>scale</code>.</p> </li>
        /// <li> <p> <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p> </li>
        /// <li> <p> <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p> </li>
        /// </ul>
        /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using <code>OutputConfig$CompilerOptions</code>. CoreML converter supports Tensorflow and PyTorch models. CoreML conversion examples:</p>
        /// <ul>
        /// <li> <p>Tensor type input:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3]}}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Tensor type input without input name (PyTorch):</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224]}]</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Image type input:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>Image type input without input name (PyTorch):</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code> </p> </li>
        /// </ul> </li>
        /// </ul>
        /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for <code>ml_eia2</code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
        /// <ul>
        /// <li> <p>For TensorFlow models saved in the SavedModel format, specify the input names from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>. Specify the <code>signature_def_key</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a> if the model does not use TensorFlow's default signature def key. For example:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code> </p> </li>
        /// </ul> </li>
        /// <li> <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions"> <code>OutputConfig:CompilerOptions</code> </a>. For example:</p>
        /// <ul>
        /// <li> <p> <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code> </p> </li>
        /// <li> <p> <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code> </p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn set_data_input_config(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_input_config = input;
            self
        }
        /// <p>Identifies the framework in which the model was trained. For example: TENSORFLOW.</p>
        pub fn framework(mut self, input: crate::model::Framework) -> Self {
            self.framework = Some(input);
            self
        }
        /// <p>Identifies the framework in which the model was trained. For example: TENSORFLOW.</p>
        pub fn set_framework(
            mut self,
            input: std::option::Option<crate::model::Framework>,
        ) -> Self {
            self.framework = input;
            self
        }
        /// <p>Specifies the framework version to use. This API field is only supported for the PyTorch and TensorFlow frameworks.</p>
        /// <p>For information about framework versions supported for cloud targets and edge devices, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-cloud.html">Cloud Supported Instance Types and Frameworks</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-devices-edge-frameworks.html">Edge Supported Frameworks</a>.</p>
        pub fn framework_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_version = Some(input.into());
            self
        }
        /// <p>Specifies the framework version to use. This API field is only supported for the PyTorch and TensorFlow frameworks.</p>
        /// <p>For information about framework versions supported for cloud targets and edge devices, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-cloud.html">Cloud Supported Instance Types and Frameworks</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-supported-devices-edge-frameworks.html">Edge Supported Frameworks</a>.</p>
        pub fn set_framework_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.framework_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InputConfig`](crate::model::InputConfig)
        pub fn build(self) -> crate::model::InputConfig {
            crate::model::InputConfig {
                s3_uri: self.s3_uri,
                data_input_config: self.data_input_config,
                framework: self.framework,
                framework_version: self.framework_version,
            }
        }
    }
}
impl InputConfig {
    /// Creates a new builder-style object to manufacture [`InputConfig`](crate::model::InputConfig)
    pub fn builder() -> crate::model::input_config::Builder {
        crate::model::input_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Framework {
    #[allow(missing_docs)] // documentation missing in model
    Darknet,
    #[allow(missing_docs)] // documentation missing in model
    Keras,
    #[allow(missing_docs)] // documentation missing in model
    Mxnet,
    #[allow(missing_docs)] // documentation missing in model
    Onnx,
    #[allow(missing_docs)] // documentation missing in model
    Pytorch,
    #[allow(missing_docs)] // documentation missing in model
    Sklearn,
    #[allow(missing_docs)] // documentation missing in model
    Tensorflow,
    #[allow(missing_docs)] // documentation missing in model
    Tflite,
    #[allow(missing_docs)] // documentation missing in model
    Xgboost,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Framework {
    fn from(s: &str) -> Self {
        match s {
            "DARKNET" => Framework::Darknet,
            "KERAS" => Framework::Keras,
            "MXNET" => Framework::Mxnet,
            "ONNX" => Framework::Onnx,
            "PYTORCH" => Framework::Pytorch,
            "SKLEARN" => Framework::Sklearn,
            "TENSORFLOW" => Framework::Tensorflow,
            "TFLITE" => Framework::Tflite,
            "XGBOOST" => Framework::Xgboost,
            other => Framework::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Framework {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Framework::from(s))
    }
}
impl Framework {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Framework::Darknet => "DARKNET",
            Framework::Keras => "KERAS",
            Framework::Mxnet => "MXNET",
            Framework::Onnx => "ONNX",
            Framework::Pytorch => "PYTORCH",
            Framework::Sklearn => "SKLEARN",
            Framework::Tensorflow => "TENSORFLOW",
            Framework::Tflite => "TFLITE",
            Framework::Xgboost => "XGBOOST",
            Framework::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DARKNET",
            "KERAS",
            "MXNET",
            "ONNX",
            "PYTORCH",
            "SKLEARN",
            "TENSORFLOW",
            "TFLITE",
            "XGBOOST",
        ]
    }
}
impl AsRef<str> for Framework {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information to verify the integrity of stored model artifacts. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDigests {
    /// <p>Provides a hash value that uniquely identifies the stored model artifacts.</p>
    pub artifact_digest: std::option::Option<std::string::String>,
}
impl ModelDigests {
    /// <p>Provides a hash value that uniquely identifies the stored model artifacts.</p>
    pub fn artifact_digest(&self) -> std::option::Option<&str> {
        self.artifact_digest.as_deref()
    }
}
impl std::fmt::Debug for ModelDigests {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDigests");
        formatter.field("artifact_digest", &self.artifact_digest);
        formatter.finish()
    }
}
/// See [`ModelDigests`](crate::model::ModelDigests)
pub mod model_digests {

    /// A builder for [`ModelDigests`](crate::model::ModelDigests)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_digest: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides a hash value that uniquely identifies the stored model artifacts.</p>
        pub fn artifact_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_digest = Some(input.into());
            self
        }
        /// <p>Provides a hash value that uniquely identifies the stored model artifacts.</p>
        pub fn set_artifact_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_digest = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDigests`](crate::model::ModelDigests)
        pub fn build(self) -> crate::model::ModelDigests {
            crate::model::ModelDigests {
                artifact_digest: self.artifact_digest,
            }
        }
    }
}
impl ModelDigests {
    /// Creates a new builder-style object to manufacture [`ModelDigests`](crate::model::ModelDigests)
    pub fn builder() -> crate::model::model_digests::Builder {
        crate::model::model_digests::Builder::default()
    }
}

/// <p>Provides information about the endpoint of the model deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDeployResult {
    /// <p>The name of the endpoint to which the model has been deployed.</p> <note>
    /// <p>If model deployment fails, this field is omitted from the response.</p>
    /// </note>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl ModelDeployResult {
    /// <p>The name of the endpoint to which the model has been deployed.</p> <note>
    /// <p>If model deployment fails, this field is omitted from the response.</p>
    /// </note>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
}
impl std::fmt::Debug for ModelDeployResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDeployResult");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`ModelDeployResult`](crate::model::ModelDeployResult)
pub mod model_deploy_result {

    /// A builder for [`ModelDeployResult`](crate::model::ModelDeployResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the endpoint to which the model has been deployed.</p> <note>
        /// <p>If model deployment fails, this field is omitted from the response.</p>
        /// </note>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint to which the model has been deployed.</p> <note>
        /// <p>If model deployment fails, this field is omitted from the response.</p>
        /// </note>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDeployResult`](crate::model::ModelDeployResult)
        pub fn build(self) -> crate::model::ModelDeployResult {
            crate::model::ModelDeployResult {
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl ModelDeployResult {
    /// Creates a new builder-style object to manufacture [`ModelDeployResult`](crate::model::ModelDeployResult)
    pub fn builder() -> crate::model::model_deploy_result::Builder {
        crate::model::model_deploy_result::Builder::default()
    }
}

/// <p>Specifies how to generate the endpoint name for an automatic one-click Autopilot model deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDeployConfig {
    /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click Autopilot model deployment; set to <code>False</code> otherwise. The default value is <code>False</code>.</p> <note>
    /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
    /// </note>
    pub auto_generate_endpoint_name: bool,
    /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the endpoint name is not generated automatically.</p> <note>
    /// <p>Specify the <code>EndpointName</code> if and only if you set <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error is thrown.</p>
    /// </note>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl ModelDeployConfig {
    /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click Autopilot model deployment; set to <code>False</code> otherwise. The default value is <code>False</code>.</p> <note>
    /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
    /// </note>
    pub fn auto_generate_endpoint_name(&self) -> bool {
        self.auto_generate_endpoint_name
    }
    /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the endpoint name is not generated automatically.</p> <note>
    /// <p>Specify the <code>EndpointName</code> if and only if you set <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error is thrown.</p>
    /// </note>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
}
impl std::fmt::Debug for ModelDeployConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDeployConfig");
        formatter.field(
            "auto_generate_endpoint_name",
            &self.auto_generate_endpoint_name,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`ModelDeployConfig`](crate::model::ModelDeployConfig)
pub mod model_deploy_config {

    /// A builder for [`ModelDeployConfig`](crate::model::ModelDeployConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_generate_endpoint_name: std::option::Option<bool>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click Autopilot model deployment; set to <code>False</code> otherwise. The default value is <code>False</code>.</p> <note>
        /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
        /// </note>
        pub fn auto_generate_endpoint_name(mut self, input: bool) -> Self {
            self.auto_generate_endpoint_name = Some(input);
            self
        }
        /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click Autopilot model deployment; set to <code>False</code> otherwise. The default value is <code>False</code>.</p> <note>
        /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
        /// </note>
        pub fn set_auto_generate_endpoint_name(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_generate_endpoint_name = input;
            self
        }
        /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the endpoint name is not generated automatically.</p> <note>
        /// <p>Specify the <code>EndpointName</code> if and only if you set <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error is thrown.</p>
        /// </note>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the endpoint name is not generated automatically.</p> <note>
        /// <p>Specify the <code>EndpointName</code> if and only if you set <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error is thrown.</p>
        /// </note>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDeployConfig`](crate::model::ModelDeployConfig)
        pub fn build(self) -> crate::model::ModelDeployConfig {
            crate::model::ModelDeployConfig {
                auto_generate_endpoint_name: self.auto_generate_endpoint_name.unwrap_or_default(),
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl ModelDeployConfig {
    /// Creates a new builder-style object to manufacture [`ModelDeployConfig`](crate::model::ModelDeployConfig)
    pub fn builder() -> crate::model::model_deploy_config::Builder {
        crate::model::model_deploy_config::Builder::default()
    }
}

/// <p>The resolved attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResolvedAttributes {
    /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
    pub auto_ml_job_objective: std::option::Option<crate::model::AutoMlJobObjective>,
    /// <p>The problem type.</p>
    pub problem_type: std::option::Option<crate::model::ProblemType>,
    /// <p>How long a job is allowed to run, or how many candidates a job is allowed to generate.</p>
    pub completion_criteria: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
}
impl ResolvedAttributes {
    /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
    pub fn auto_ml_job_objective(&self) -> std::option::Option<&crate::model::AutoMlJobObjective> {
        self.auto_ml_job_objective.as_ref()
    }
    /// <p>The problem type.</p>
    pub fn problem_type(&self) -> std::option::Option<&crate::model::ProblemType> {
        self.problem_type.as_ref()
    }
    /// <p>How long a job is allowed to run, or how many candidates a job is allowed to generate.</p>
    pub fn completion_criteria(
        &self,
    ) -> std::option::Option<&crate::model::AutoMlJobCompletionCriteria> {
        self.completion_criteria.as_ref()
    }
}
impl std::fmt::Debug for ResolvedAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResolvedAttributes");
        formatter.field("auto_ml_job_objective", &self.auto_ml_job_objective);
        formatter.field("problem_type", &self.problem_type);
        formatter.field("completion_criteria", &self.completion_criteria);
        formatter.finish()
    }
}
/// See [`ResolvedAttributes`](crate::model::ResolvedAttributes)
pub mod resolved_attributes {

    /// A builder for [`ResolvedAttributes`](crate::model::ResolvedAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_ml_job_objective: std::option::Option<crate::model::AutoMlJobObjective>,
        pub(crate) problem_type: std::option::Option<crate::model::ProblemType>,
        pub(crate) completion_criteria:
            std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
    }
    impl Builder {
        /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
        pub fn auto_ml_job_objective(mut self, input: crate::model::AutoMlJobObjective) -> Self {
            self.auto_ml_job_objective = Some(input);
            self
        }
        /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
        pub fn set_auto_ml_job_objective(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobObjective>,
        ) -> Self {
            self.auto_ml_job_objective = input;
            self
        }
        /// <p>The problem type.</p>
        pub fn problem_type(mut self, input: crate::model::ProblemType) -> Self {
            self.problem_type = Some(input);
            self
        }
        /// <p>The problem type.</p>
        pub fn set_problem_type(
            mut self,
            input: std::option::Option<crate::model::ProblemType>,
        ) -> Self {
            self.problem_type = input;
            self
        }
        /// <p>How long a job is allowed to run, or how many candidates a job is allowed to generate.</p>
        pub fn completion_criteria(
            mut self,
            input: crate::model::AutoMlJobCompletionCriteria,
        ) -> Self {
            self.completion_criteria = Some(input);
            self
        }
        /// <p>How long a job is allowed to run, or how many candidates a job is allowed to generate.</p>
        pub fn set_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        ) -> Self {
            self.completion_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`ResolvedAttributes`](crate::model::ResolvedAttributes)
        pub fn build(self) -> crate::model::ResolvedAttributes {
            crate::model::ResolvedAttributes {
                auto_ml_job_objective: self.auto_ml_job_objective,
                problem_type: self.problem_type,
                completion_criteria: self.completion_criteria,
            }
        }
    }
}
impl ResolvedAttributes {
    /// Creates a new builder-style object to manufacture [`ResolvedAttributes`](crate::model::ResolvedAttributes)
    pub fn builder() -> crate::model::resolved_attributes::Builder {
        crate::model::resolved_attributes::Builder::default()
    }
}

/// <p>How long a job is allowed to run, or how many candidates a job is allowed to generate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobCompletionCriteria {
    /// <p>The maximum number of times a training job is allowed to run.</p>
    pub max_candidates: std::option::Option<i32>,
    /// <p>The maximum time, in seconds, that each training job is allowed to run as part of a hyperparameter tuning job. For more information, see the used by the action.</p>
    pub max_runtime_per_training_job_in_seconds: std::option::Option<i32>,
    /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
    /// <p>If an AutoML job exceeds the maximum runtime, the job is stopped automatically and its processing is ended gracefully. The AutoML job identifies the best model whose training was completed and marks it as the best-performing model. Any unfinished steps of the job, such as automatic one-click Autopilot model deployment, will not be completed. </p>
    pub max_auto_ml_job_runtime_in_seconds: std::option::Option<i32>,
}
impl AutoMlJobCompletionCriteria {
    /// <p>The maximum number of times a training job is allowed to run.</p>
    pub fn max_candidates(&self) -> std::option::Option<i32> {
        self.max_candidates
    }
    /// <p>The maximum time, in seconds, that each training job is allowed to run as part of a hyperparameter tuning job. For more information, see the used by the action.</p>
    pub fn max_runtime_per_training_job_in_seconds(&self) -> std::option::Option<i32> {
        self.max_runtime_per_training_job_in_seconds
    }
    /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
    /// <p>If an AutoML job exceeds the maximum runtime, the job is stopped automatically and its processing is ended gracefully. The AutoML job identifies the best model whose training was completed and marks it as the best-performing model. Any unfinished steps of the job, such as automatic one-click Autopilot model deployment, will not be completed. </p>
    pub fn max_auto_ml_job_runtime_in_seconds(&self) -> std::option::Option<i32> {
        self.max_auto_ml_job_runtime_in_seconds
    }
}
impl std::fmt::Debug for AutoMlJobCompletionCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobCompletionCriteria");
        formatter.field("max_candidates", &self.max_candidates);
        formatter.field(
            "max_runtime_per_training_job_in_seconds",
            &self.max_runtime_per_training_job_in_seconds,
        );
        formatter.field(
            "max_auto_ml_job_runtime_in_seconds",
            &self.max_auto_ml_job_runtime_in_seconds,
        );
        formatter.finish()
    }
}
/// See [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
pub mod auto_ml_job_completion_criteria {

    /// A builder for [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_candidates: std::option::Option<i32>,
        pub(crate) max_runtime_per_training_job_in_seconds: std::option::Option<i32>,
        pub(crate) max_auto_ml_job_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of times a training job is allowed to run.</p>
        pub fn max_candidates(mut self, input: i32) -> Self {
            self.max_candidates = Some(input);
            self
        }
        /// <p>The maximum number of times a training job is allowed to run.</p>
        pub fn set_max_candidates(mut self, input: std::option::Option<i32>) -> Self {
            self.max_candidates = input;
            self
        }
        /// <p>The maximum time, in seconds, that each training job is allowed to run as part of a hyperparameter tuning job. For more information, see the used by the action.</p>
        pub fn max_runtime_per_training_job_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_per_training_job_in_seconds = Some(input);
            self
        }
        /// <p>The maximum time, in seconds, that each training job is allowed to run as part of a hyperparameter tuning job. For more information, see the used by the action.</p>
        pub fn set_max_runtime_per_training_job_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_runtime_per_training_job_in_seconds = input;
            self
        }
        /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
        /// <p>If an AutoML job exceeds the maximum runtime, the job is stopped automatically and its processing is ended gracefully. The AutoML job identifies the best model whose training was completed and marks it as the best-performing model. Any unfinished steps of the job, such as automatic one-click Autopilot model deployment, will not be completed. </p>
        pub fn max_auto_ml_job_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_auto_ml_job_runtime_in_seconds = Some(input);
            self
        }
        /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
        /// <p>If an AutoML job exceeds the maximum runtime, the job is stopped automatically and its processing is ended gracefully. The AutoML job identifies the best model whose training was completed and marks it as the best-performing model. Any unfinished steps of the job, such as automatic one-click Autopilot model deployment, will not be completed. </p>
        pub fn set_max_auto_ml_job_runtime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_auto_ml_job_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
        pub fn build(self) -> crate::model::AutoMlJobCompletionCriteria {
            crate::model::AutoMlJobCompletionCriteria {
                max_candidates: self.max_candidates,
                max_runtime_per_training_job_in_seconds: self
                    .max_runtime_per_training_job_in_seconds,
                max_auto_ml_job_runtime_in_seconds: self.max_auto_ml_job_runtime_in_seconds,
            }
        }
    }
}
impl AutoMlJobCompletionCriteria {
    /// Creates a new builder-style object to manufacture [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
    pub fn builder() -> crate::model::auto_ml_job_completion_criteria::Builder {
        crate::model::auto_ml_job_completion_criteria::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProblemType {
    #[allow(missing_docs)] // documentation missing in model
    BinaryClassification,
    #[allow(missing_docs)] // documentation missing in model
    MulticlassClassification,
    #[allow(missing_docs)] // documentation missing in model
    Regression,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProblemType {
    fn from(s: &str) -> Self {
        match s {
            "BinaryClassification" => ProblemType::BinaryClassification,
            "MulticlassClassification" => ProblemType::MulticlassClassification,
            "Regression" => ProblemType::Regression,
            other => ProblemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProblemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProblemType::from(s))
    }
}
impl ProblemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProblemType::BinaryClassification => "BinaryClassification",
            ProblemType::MulticlassClassification => "MulticlassClassification",
            ProblemType::Regression => "Regression",
            ProblemType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BinaryClassification",
            "MulticlassClassification",
            "Regression",
        ]
    }
}
impl AsRef<str> for ProblemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobObjective {
    /// <p>The name of the objective metric used to measure the predictive quality of a machine learning system. This metric is optimized during training to provide the best estimate for model parameter values from data.</p>
    /// <p>Here are the options:</p>
    /// <ul>
    /// <li> <p> <code>MSE</code>: The mean squared error (MSE) is the average of the squared differences between the predicted and actual values. It is used for regression. MSE values are always positive: the better a model is at predicting the actual values, the smaller the MSE value is. When the data contains outliers, they tend to dominate the MSE, which might cause subpar prediction performance.</p> </li>
    /// <li> <p> <code>Accuracy</code>: The ratio of the number of correctly classified items to the total number of (correctly and incorrectly) classified items. It is used for binary and multiclass classification. It measures how close the predicted class values are to the actual values. Accuracy values vary between zero and one: one indicates perfect accuracy and zero indicates perfect inaccuracy.</p> </li>
    /// <li> <p> <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It is used for binary classification into classes traditionally referred to as positive and negative. Predictions are said to be true when they match their actual (correct) class and false when they do not. Precision is the ratio of the true positive predictions to all positive predictions (including the false positives) in a data set and measures the quality of the prediction when it predicts the positive class. Recall (or sensitivity) is the ratio of the true positive predictions to all actual positive instances and measures how completely a model predicts the actual class members in a data set. The standard F1 score weighs precision and recall equally. But which metric is paramount typically depends on specific aspects of a problem. F1 scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
    /// <li> <p> <code>AUC</code>: The area under the curve (AUC) metric is used to compare and evaluate binary classification by algorithms such as logistic regression that return probabilities. A threshold is needed to map the probabilities into classifications. The relevant curve is the receiver operating characteristic curve that plots the true positive rate (TPR) of predictions (or recall) against the false positive rate (FPR) as a function of the threshold value, above which a prediction is considered positive. Increasing the threshold results in fewer false positives but more false negatives. AUC is the area under this receiver operating characteristic curve and so provides an aggregated measure of the model performance across all possible classification thresholds. The AUC score can also be interpreted as the probability that a randomly selected positive data point is more likely to be predicted positive than a randomly selected negative example. AUC scores vary between zero and one: a score of one indicates perfect accuracy and a score of one half indicates that the prediction is not better than a random classifier. Values under one half predict less accurately than a random predictor. But such consistently bad predictors can simply be inverted to obtain better than random predictors.</p> </li>
    /// <li> <p> <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass classification. In this context, you have multiple classes to predict. You just calculate the precision and recall for each class as you did for the positive class in binary classification. Then, use these values to calculate the F1 score for each class and average them to obtain the F1macro score. F1macro scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
    /// </ul>
    /// <p>If you do not specify a metric explicitly, the default behavior is to automatically use:</p>
    /// <ul>
    /// <li> <p> <code>MSE</code>: for regression.</p> </li>
    /// <li> <p> <code>F1</code>: for binary classification</p> </li>
    /// <li> <p> <code>Accuracy</code>: for multiclass classification.</p> </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
}
impl AutoMlJobObjective {
    /// <p>The name of the objective metric used to measure the predictive quality of a machine learning system. This metric is optimized during training to provide the best estimate for model parameter values from data.</p>
    /// <p>Here are the options:</p>
    /// <ul>
    /// <li> <p> <code>MSE</code>: The mean squared error (MSE) is the average of the squared differences between the predicted and actual values. It is used for regression. MSE values are always positive: the better a model is at predicting the actual values, the smaller the MSE value is. When the data contains outliers, they tend to dominate the MSE, which might cause subpar prediction performance.</p> </li>
    /// <li> <p> <code>Accuracy</code>: The ratio of the number of correctly classified items to the total number of (correctly and incorrectly) classified items. It is used for binary and multiclass classification. It measures how close the predicted class values are to the actual values. Accuracy values vary between zero and one: one indicates perfect accuracy and zero indicates perfect inaccuracy.</p> </li>
    /// <li> <p> <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It is used for binary classification into classes traditionally referred to as positive and negative. Predictions are said to be true when they match their actual (correct) class and false when they do not. Precision is the ratio of the true positive predictions to all positive predictions (including the false positives) in a data set and measures the quality of the prediction when it predicts the positive class. Recall (or sensitivity) is the ratio of the true positive predictions to all actual positive instances and measures how completely a model predicts the actual class members in a data set. The standard F1 score weighs precision and recall equally. But which metric is paramount typically depends on specific aspects of a problem. F1 scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
    /// <li> <p> <code>AUC</code>: The area under the curve (AUC) metric is used to compare and evaluate binary classification by algorithms such as logistic regression that return probabilities. A threshold is needed to map the probabilities into classifications. The relevant curve is the receiver operating characteristic curve that plots the true positive rate (TPR) of predictions (or recall) against the false positive rate (FPR) as a function of the threshold value, above which a prediction is considered positive. Increasing the threshold results in fewer false positives but more false negatives. AUC is the area under this receiver operating characteristic curve and so provides an aggregated measure of the model performance across all possible classification thresholds. The AUC score can also be interpreted as the probability that a randomly selected positive data point is more likely to be predicted positive than a randomly selected negative example. AUC scores vary between zero and one: a score of one indicates perfect accuracy and a score of one half indicates that the prediction is not better than a random classifier. Values under one half predict less accurately than a random predictor. But such consistently bad predictors can simply be inverted to obtain better than random predictors.</p> </li>
    /// <li> <p> <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass classification. In this context, you have multiple classes to predict. You just calculate the precision and recall for each class as you did for the positive class in binary classification. Then, use these values to calculate the F1 score for each class and average them to obtain the F1macro score. F1macro scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
    /// </ul>
    /// <p>If you do not specify a metric explicitly, the default behavior is to automatically use:</p>
    /// <ul>
    /// <li> <p> <code>MSE</code>: for regression.</p> </li>
    /// <li> <p> <code>F1</code>: for binary classification</p> </li>
    /// <li> <p> <code>Accuracy</code>: for multiclass classification.</p> </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::AutoMlMetricEnum> {
        self.metric_name.as_ref()
    }
}
impl std::fmt::Debug for AutoMlJobObjective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobObjective");
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}
/// See [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
pub mod auto_ml_job_objective {

    /// A builder for [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
    }
    impl Builder {
        /// <p>The name of the objective metric used to measure the predictive quality of a machine learning system. This metric is optimized during training to provide the best estimate for model parameter values from data.</p>
        /// <p>Here are the options:</p>
        /// <ul>
        /// <li> <p> <code>MSE</code>: The mean squared error (MSE) is the average of the squared differences between the predicted and actual values. It is used for regression. MSE values are always positive: the better a model is at predicting the actual values, the smaller the MSE value is. When the data contains outliers, they tend to dominate the MSE, which might cause subpar prediction performance.</p> </li>
        /// <li> <p> <code>Accuracy</code>: The ratio of the number of correctly classified items to the total number of (correctly and incorrectly) classified items. It is used for binary and multiclass classification. It measures how close the predicted class values are to the actual values. Accuracy values vary between zero and one: one indicates perfect accuracy and zero indicates perfect inaccuracy.</p> </li>
        /// <li> <p> <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It is used for binary classification into classes traditionally referred to as positive and negative. Predictions are said to be true when they match their actual (correct) class and false when they do not. Precision is the ratio of the true positive predictions to all positive predictions (including the false positives) in a data set and measures the quality of the prediction when it predicts the positive class. Recall (or sensitivity) is the ratio of the true positive predictions to all actual positive instances and measures how completely a model predicts the actual class members in a data set. The standard F1 score weighs precision and recall equally. But which metric is paramount typically depends on specific aspects of a problem. F1 scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
        /// <li> <p> <code>AUC</code>: The area under the curve (AUC) metric is used to compare and evaluate binary classification by algorithms such as logistic regression that return probabilities. A threshold is needed to map the probabilities into classifications. The relevant curve is the receiver operating characteristic curve that plots the true positive rate (TPR) of predictions (or recall) against the false positive rate (FPR) as a function of the threshold value, above which a prediction is considered positive. Increasing the threshold results in fewer false positives but more false negatives. AUC is the area under this receiver operating characteristic curve and so provides an aggregated measure of the model performance across all possible classification thresholds. The AUC score can also be interpreted as the probability that a randomly selected positive data point is more likely to be predicted positive than a randomly selected negative example. AUC scores vary between zero and one: a score of one indicates perfect accuracy and a score of one half indicates that the prediction is not better than a random classifier. Values under one half predict less accurately than a random predictor. But such consistently bad predictors can simply be inverted to obtain better than random predictors.</p> </li>
        /// <li> <p> <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass classification. In this context, you have multiple classes to predict. You just calculate the precision and recall for each class as you did for the positive class in binary classification. Then, use these values to calculate the F1 score for each class and average them to obtain the F1macro score. F1macro scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
        /// </ul>
        /// <p>If you do not specify a metric explicitly, the default behavior is to automatically use:</p>
        /// <ul>
        /// <li> <p> <code>MSE</code>: for regression.</p> </li>
        /// <li> <p> <code>F1</code>: for binary classification</p> </li>
        /// <li> <p> <code>Accuracy</code>: for multiclass classification.</p> </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::AutoMlMetricEnum) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The name of the objective metric used to measure the predictive quality of a machine learning system. This metric is optimized during training to provide the best estimate for model parameter values from data.</p>
        /// <p>Here are the options:</p>
        /// <ul>
        /// <li> <p> <code>MSE</code>: The mean squared error (MSE) is the average of the squared differences between the predicted and actual values. It is used for regression. MSE values are always positive: the better a model is at predicting the actual values, the smaller the MSE value is. When the data contains outliers, they tend to dominate the MSE, which might cause subpar prediction performance.</p> </li>
        /// <li> <p> <code>Accuracy</code>: The ratio of the number of correctly classified items to the total number of (correctly and incorrectly) classified items. It is used for binary and multiclass classification. It measures how close the predicted class values are to the actual values. Accuracy values vary between zero and one: one indicates perfect accuracy and zero indicates perfect inaccuracy.</p> </li>
        /// <li> <p> <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It is used for binary classification into classes traditionally referred to as positive and negative. Predictions are said to be true when they match their actual (correct) class and false when they do not. Precision is the ratio of the true positive predictions to all positive predictions (including the false positives) in a data set and measures the quality of the prediction when it predicts the positive class. Recall (or sensitivity) is the ratio of the true positive predictions to all actual positive instances and measures how completely a model predicts the actual class members in a data set. The standard F1 score weighs precision and recall equally. But which metric is paramount typically depends on specific aspects of a problem. F1 scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
        /// <li> <p> <code>AUC</code>: The area under the curve (AUC) metric is used to compare and evaluate binary classification by algorithms such as logistic regression that return probabilities. A threshold is needed to map the probabilities into classifications. The relevant curve is the receiver operating characteristic curve that plots the true positive rate (TPR) of predictions (or recall) against the false positive rate (FPR) as a function of the threshold value, above which a prediction is considered positive. Increasing the threshold results in fewer false positives but more false negatives. AUC is the area under this receiver operating characteristic curve and so provides an aggregated measure of the model performance across all possible classification thresholds. The AUC score can also be interpreted as the probability that a randomly selected positive data point is more likely to be predicted positive than a randomly selected negative example. AUC scores vary between zero and one: a score of one indicates perfect accuracy and a score of one half indicates that the prediction is not better than a random classifier. Values under one half predict less accurately than a random predictor. But such consistently bad predictors can simply be inverted to obtain better than random predictors.</p> </li>
        /// <li> <p> <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass classification. In this context, you have multiple classes to predict. You just calculate the precision and recall for each class as you did for the positive class in binary classification. Then, use these values to calculate the F1 score for each class and average them to obtain the F1macro score. F1macro scores vary between zero and one: one indicates the best possible performance and zero the worst.</p> </li>
        /// </ul>
        /// <p>If you do not specify a metric explicitly, the default behavior is to automatically use:</p>
        /// <ul>
        /// <li> <p> <code>MSE</code>: for regression.</p> </li>
        /// <li> <p> <code>F1</code>: for binary classification</p> </li>
        /// <li> <p> <code>Accuracy</code>: for multiclass classification.</p> </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricEnum>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
        pub fn build(self) -> crate::model::AutoMlJobObjective {
            crate::model::AutoMlJobObjective {
                metric_name: self.metric_name,
            }
        }
    }
}
impl AutoMlJobObjective {
    /// Creates a new builder-style object to manufacture [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
    pub fn builder() -> crate::model::auto_ml_job_objective::Builder {
        crate::model::auto_ml_job_objective::Builder::default()
    }
}

/// <p>The artifacts that are generated during an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobArtifacts {
    /// <p>The URL of the notebook location.</p>
    pub candidate_definition_notebook_location: std::option::Option<std::string::String>,
    /// <p>The URL of the notebook location.</p>
    pub data_exploration_notebook_location: std::option::Option<std::string::String>,
}
impl AutoMlJobArtifacts {
    /// <p>The URL of the notebook location.</p>
    pub fn candidate_definition_notebook_location(&self) -> std::option::Option<&str> {
        self.candidate_definition_notebook_location.as_deref()
    }
    /// <p>The URL of the notebook location.</p>
    pub fn data_exploration_notebook_location(&self) -> std::option::Option<&str> {
        self.data_exploration_notebook_location.as_deref()
    }
}
impl std::fmt::Debug for AutoMlJobArtifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobArtifacts");
        formatter.field(
            "candidate_definition_notebook_location",
            &self.candidate_definition_notebook_location,
        );
        formatter.field(
            "data_exploration_notebook_location",
            &self.data_exploration_notebook_location,
        );
        formatter.finish()
    }
}
/// See [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
pub mod auto_ml_job_artifacts {

    /// A builder for [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_definition_notebook_location: std::option::Option<std::string::String>,
        pub(crate) data_exploration_notebook_location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL of the notebook location.</p>
        pub fn candidate_definition_notebook_location(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.candidate_definition_notebook_location = Some(input.into());
            self
        }
        /// <p>The URL of the notebook location.</p>
        pub fn set_candidate_definition_notebook_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_definition_notebook_location = input;
            self
        }
        /// <p>The URL of the notebook location.</p>
        pub fn data_exploration_notebook_location(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.data_exploration_notebook_location = Some(input.into());
            self
        }
        /// <p>The URL of the notebook location.</p>
        pub fn set_data_exploration_notebook_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_exploration_notebook_location = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
        pub fn build(self) -> crate::model::AutoMlJobArtifacts {
            crate::model::AutoMlJobArtifacts {
                candidate_definition_notebook_location: self.candidate_definition_notebook_location,
                data_exploration_notebook_location: self.data_exploration_notebook_location,
            }
        }
    }
}
impl AutoMlJobArtifacts {
    /// Creates a new builder-style object to manufacture [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
    pub fn builder() -> crate::model::auto_ml_job_artifacts::Builder {
        crate::model::auto_ml_job_artifacts::Builder::default()
    }
}

/// <p>A collection of settings used for an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobConfig {
    /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to generate.</p>
    pub completion_criteria: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
    /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
    pub security_config: std::option::Option<crate::model::AutoMlSecurityConfig>,
    /// <p>The configuration for splitting the input training dataset.</p>
    /// <p>Type: AutoMLDataSplitConfig</p>
    pub data_split_config: std::option::Option<crate::model::AutoMlDataSplitConfig>,
    /// <p>The configuration for generating a candidate for an AutoML job (optional). </p>
    pub candidate_generation_config:
        std::option::Option<crate::model::AutoMlCandidateGenerationConfig>,
}
impl AutoMlJobConfig {
    /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to generate.</p>
    pub fn completion_criteria(
        &self,
    ) -> std::option::Option<&crate::model::AutoMlJobCompletionCriteria> {
        self.completion_criteria.as_ref()
    }
    /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
    pub fn security_config(&self) -> std::option::Option<&crate::model::AutoMlSecurityConfig> {
        self.security_config.as_ref()
    }
    /// <p>The configuration for splitting the input training dataset.</p>
    /// <p>Type: AutoMLDataSplitConfig</p>
    pub fn data_split_config(&self) -> std::option::Option<&crate::model::AutoMlDataSplitConfig> {
        self.data_split_config.as_ref()
    }
    /// <p>The configuration for generating a candidate for an AutoML job (optional). </p>
    pub fn candidate_generation_config(
        &self,
    ) -> std::option::Option<&crate::model::AutoMlCandidateGenerationConfig> {
        self.candidate_generation_config.as_ref()
    }
}
impl std::fmt::Debug for AutoMlJobConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobConfig");
        formatter.field("completion_criteria", &self.completion_criteria);
        formatter.field("security_config", &self.security_config);
        formatter.field("data_split_config", &self.data_split_config);
        formatter.field(
            "candidate_generation_config",
            &self.candidate_generation_config,
        );
        formatter.finish()
    }
}
/// See [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
pub mod auto_ml_job_config {

    /// A builder for [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) completion_criteria:
            std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        pub(crate) security_config: std::option::Option<crate::model::AutoMlSecurityConfig>,
        pub(crate) data_split_config: std::option::Option<crate::model::AutoMlDataSplitConfig>,
        pub(crate) candidate_generation_config:
            std::option::Option<crate::model::AutoMlCandidateGenerationConfig>,
    }
    impl Builder {
        /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to generate.</p>
        pub fn completion_criteria(
            mut self,
            input: crate::model::AutoMlJobCompletionCriteria,
        ) -> Self {
            self.completion_criteria = Some(input);
            self
        }
        /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to generate.</p>
        pub fn set_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        ) -> Self {
            self.completion_criteria = input;
            self
        }
        /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
        pub fn security_config(mut self, input: crate::model::AutoMlSecurityConfig) -> Self {
            self.security_config = Some(input);
            self
        }
        /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
        pub fn set_security_config(
            mut self,
            input: std::option::Option<crate::model::AutoMlSecurityConfig>,
        ) -> Self {
            self.security_config = input;
            self
        }
        /// <p>The configuration for splitting the input training dataset.</p>
        /// <p>Type: AutoMLDataSplitConfig</p>
        pub fn data_split_config(mut self, input: crate::model::AutoMlDataSplitConfig) -> Self {
            self.data_split_config = Some(input);
            self
        }
        /// <p>The configuration for splitting the input training dataset.</p>
        /// <p>Type: AutoMLDataSplitConfig</p>
        pub fn set_data_split_config(
            mut self,
            input: std::option::Option<crate::model::AutoMlDataSplitConfig>,
        ) -> Self {
            self.data_split_config = input;
            self
        }
        /// <p>The configuration for generating a candidate for an AutoML job (optional). </p>
        pub fn candidate_generation_config(
            mut self,
            input: crate::model::AutoMlCandidateGenerationConfig,
        ) -> Self {
            self.candidate_generation_config = Some(input);
            self
        }
        /// <p>The configuration for generating a candidate for an AutoML job (optional). </p>
        pub fn set_candidate_generation_config(
            mut self,
            input: std::option::Option<crate::model::AutoMlCandidateGenerationConfig>,
        ) -> Self {
            self.candidate_generation_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
        pub fn build(self) -> crate::model::AutoMlJobConfig {
            crate::model::AutoMlJobConfig {
                completion_criteria: self.completion_criteria,
                security_config: self.security_config,
                data_split_config: self.data_split_config,
                candidate_generation_config: self.candidate_generation_config,
            }
        }
    }
}
impl AutoMlJobConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
    pub fn builder() -> crate::model::auto_ml_job_config::Builder {
        crate::model::auto_ml_job_config::Builder::default()
    }
}

/// <p>Stores the config information for how a candidate is generated (optional).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlCandidateGenerationConfig {
    /// <p>A URL to the Amazon S3 data source containing selected features from the input data source to run an Autopilot job (optional). This file should be in json format as shown below: </p>
    /// <p> <code>{ "FeatureAttributeNames":["col1", "col2", ...] }</code>.</p>
    /// <p>The key name <code>FeatureAttributeNames</code> is fixed. The values listed in <code>["col1", "col2", ...]</code> is case sensitive and should be a list of strings containing unique values that are a subset of the column names in the input data. The list of columns provided must not include the target column.</p>
    pub feature_specification_s3_uri: std::option::Option<std::string::String>,
}
impl AutoMlCandidateGenerationConfig {
    /// <p>A URL to the Amazon S3 data source containing selected features from the input data source to run an Autopilot job (optional). This file should be in json format as shown below: </p>
    /// <p> <code>{ "FeatureAttributeNames":["col1", "col2", ...] }</code>.</p>
    /// <p>The key name <code>FeatureAttributeNames</code> is fixed. The values listed in <code>["col1", "col2", ...]</code> is case sensitive and should be a list of strings containing unique values that are a subset of the column names in the input data. The list of columns provided must not include the target column.</p>
    pub fn feature_specification_s3_uri(&self) -> std::option::Option<&str> {
        self.feature_specification_s3_uri.as_deref()
    }
}
impl std::fmt::Debug for AutoMlCandidateGenerationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlCandidateGenerationConfig");
        formatter.field(
            "feature_specification_s3_uri",
            &self.feature_specification_s3_uri,
        );
        formatter.finish()
    }
}
/// See [`AutoMlCandidateGenerationConfig`](crate::model::AutoMlCandidateGenerationConfig)
pub mod auto_ml_candidate_generation_config {

    /// A builder for [`AutoMlCandidateGenerationConfig`](crate::model::AutoMlCandidateGenerationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_specification_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A URL to the Amazon S3 data source containing selected features from the input data source to run an Autopilot job (optional). This file should be in json format as shown below: </p>
        /// <p> <code>{ "FeatureAttributeNames":["col1", "col2", ...] }</code>.</p>
        /// <p>The key name <code>FeatureAttributeNames</code> is fixed. The values listed in <code>["col1", "col2", ...]</code> is case sensitive and should be a list of strings containing unique values that are a subset of the column names in the input data. The list of columns provided must not include the target column.</p>
        pub fn feature_specification_s3_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.feature_specification_s3_uri = Some(input.into());
            self
        }
        /// <p>A URL to the Amazon S3 data source containing selected features from the input data source to run an Autopilot job (optional). This file should be in json format as shown below: </p>
        /// <p> <code>{ "FeatureAttributeNames":["col1", "col2", ...] }</code>.</p>
        /// <p>The key name <code>FeatureAttributeNames</code> is fixed. The values listed in <code>["col1", "col2", ...]</code> is case sensitive and should be a list of strings containing unique values that are a subset of the column names in the input data. The list of columns provided must not include the target column.</p>
        pub fn set_feature_specification_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_specification_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlCandidateGenerationConfig`](crate::model::AutoMlCandidateGenerationConfig)
        pub fn build(self) -> crate::model::AutoMlCandidateGenerationConfig {
            crate::model::AutoMlCandidateGenerationConfig {
                feature_specification_s3_uri: self.feature_specification_s3_uri,
            }
        }
    }
}
impl AutoMlCandidateGenerationConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlCandidateGenerationConfig`](crate::model::AutoMlCandidateGenerationConfig)
    pub fn builder() -> crate::model::auto_ml_candidate_generation_config::Builder {
        crate::model::auto_ml_candidate_generation_config::Builder::default()
    }
}

/// <p>This structure specifies how to split the data into train and test datasets. The validation and training datasets must contain the same headers. The validation dataset must be less than 2 GB in size.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlDataSplitConfig {
    /// <p>The validation fraction (optional) is a float that specifies the portion of the training dataset to be used for validation. The default value is 0.2, and values must be greater than 0 and less than 1. We recommend setting this value to be less than 0.5.</p>
    pub validation_fraction: std::option::Option<f32>,
}
impl AutoMlDataSplitConfig {
    /// <p>The validation fraction (optional) is a float that specifies the portion of the training dataset to be used for validation. The default value is 0.2, and values must be greater than 0 and less than 1. We recommend setting this value to be less than 0.5.</p>
    pub fn validation_fraction(&self) -> std::option::Option<f32> {
        self.validation_fraction
    }
}
impl std::fmt::Debug for AutoMlDataSplitConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlDataSplitConfig");
        formatter.field("validation_fraction", &self.validation_fraction);
        formatter.finish()
    }
}
/// See [`AutoMlDataSplitConfig`](crate::model::AutoMlDataSplitConfig)
pub mod auto_ml_data_split_config {

    /// A builder for [`AutoMlDataSplitConfig`](crate::model::AutoMlDataSplitConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_fraction: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The validation fraction (optional) is a float that specifies the portion of the training dataset to be used for validation. The default value is 0.2, and values must be greater than 0 and less than 1. We recommend setting this value to be less than 0.5.</p>
        pub fn validation_fraction(mut self, input: f32) -> Self {
            self.validation_fraction = Some(input);
            self
        }
        /// <p>The validation fraction (optional) is a float that specifies the portion of the training dataset to be used for validation. The default value is 0.2, and values must be greater than 0 and less than 1. We recommend setting this value to be less than 0.5.</p>
        pub fn set_validation_fraction(mut self, input: std::option::Option<f32>) -> Self {
            self.validation_fraction = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlDataSplitConfig`](crate::model::AutoMlDataSplitConfig)
        pub fn build(self) -> crate::model::AutoMlDataSplitConfig {
            crate::model::AutoMlDataSplitConfig {
                validation_fraction: self.validation_fraction,
            }
        }
    }
}
impl AutoMlDataSplitConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlDataSplitConfig`](crate::model::AutoMlDataSplitConfig)
    pub fn builder() -> crate::model::auto_ml_data_split_config::Builder {
        crate::model::auto_ml_data_split_config::Builder::default()
    }
}

/// <p>Security options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlSecurityConfig {
    /// <p>The key used to encrypt stored data.</p>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p>Whether to use traffic encryption between the container layers.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>The VPC configuration.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl AutoMlSecurityConfig {
    /// <p>The key used to encrypt stored data.</p>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p>Whether to use traffic encryption between the container layers.</p>
    pub fn enable_inter_container_traffic_encryption(&self) -> bool {
        self.enable_inter_container_traffic_encryption
    }
    /// <p>The VPC configuration.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
impl std::fmt::Debug for AutoMlSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlSecurityConfig");
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
pub mod auto_ml_security_config {

    /// A builder for [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The key used to encrypt stored data.</p>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The key used to encrypt stored data.</p>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p>Whether to use traffic encryption between the container layers.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        /// <p>Whether to use traffic encryption between the container layers.</p>
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>The VPC configuration.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>The VPC configuration.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
        pub fn build(self) -> crate::model::AutoMlSecurityConfig {
            crate::model::AutoMlSecurityConfig {
                volume_kms_key_id: self.volume_kms_key_id,
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl AutoMlSecurityConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
    pub fn builder() -> crate::model::auto_ml_security_config::Builder {
        crate::model::auto_ml_security_config::Builder::default()
    }
}

/// <p>The output data configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlOutputDataConfig {
    /// <p>The Amazon Web Services KMS encryption key ID.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl AutoMlOutputDataConfig {
    /// <p>The Amazon Web Services KMS encryption key ID.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
    pub fn s3_output_path(&self) -> std::option::Option<&str> {
        self.s3_output_path.as_deref()
    }
}
impl std::fmt::Debug for AutoMlOutputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlOutputDataConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
pub mod auto_ml_output_data_config {

    /// A builder for [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services KMS encryption key ID.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services KMS encryption key ID.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
        pub fn build(self) -> crate::model::AutoMlOutputDataConfig {
            crate::model::AutoMlOutputDataConfig {
                kms_key_id: self.kms_key_id,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl AutoMlOutputDataConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
    pub fn builder() -> crate::model::auto_ml_output_data_config::Builder {
        crate::model::auto_ml_output_data_config::Builder::default()
    }
}

/// <p>A channel is a named input source that training algorithms can consume. The validation dataset size is limited to less than 2 GB. The training dataset size must be less than 100 GB. For more information, see .</p> <note>
/// <p>A validation dataset must contain the same headers as the training dataset.</p>
/// </note>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlChannel {
    /// <p>The data source for an AutoML channel.</p>
    pub data_source: std::option::Option<crate::model::AutoMlDataSource>,
    /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is <code>None</code>.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>The name of the target variable in supervised learning, usually represented by 'y'.</p>
    pub target_attribute_name: std::option::Option<std::string::String>,
    /// <p>The content type of the data from the input source. You can use <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The channel type (optional) is an <code>enum</code> string. The default value is <code>training</code>. Channels for training and validation must share the same <code>ContentType</code> and <code>TargetAttributeName</code>. For information on specifying training and validation channel types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-datasets-problem-types.html#autopilot-data-sources-training-or-validation"> <code>How to specify training and validation datasets</code> </a>.</p>
    pub channel_type: std::option::Option<crate::model::AutoMlChannelType>,
}
impl AutoMlChannel {
    /// <p>The data source for an AutoML channel.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::AutoMlDataSource> {
        self.data_source.as_ref()
    }
    /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is <code>None</code>.</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>The name of the target variable in supervised learning, usually represented by 'y'.</p>
    pub fn target_attribute_name(&self) -> std::option::Option<&str> {
        self.target_attribute_name.as_deref()
    }
    /// <p>The content type of the data from the input source. You can use <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The channel type (optional) is an <code>enum</code> string. The default value is <code>training</code>. Channels for training and validation must share the same <code>ContentType</code> and <code>TargetAttributeName</code>. For information on specifying training and validation channel types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-datasets-problem-types.html#autopilot-data-sources-training-or-validation"> <code>How to specify training and validation datasets</code> </a>.</p>
    pub fn channel_type(&self) -> std::option::Option<&crate::model::AutoMlChannelType> {
        self.channel_type.as_ref()
    }
}
impl std::fmt::Debug for AutoMlChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlChannel");
        formatter.field("data_source", &self.data_source);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("target_attribute_name", &self.target_attribute_name);
        formatter.field("content_type", &self.content_type);
        formatter.field("channel_type", &self.channel_type);
        formatter.finish()
    }
}
/// See [`AutoMlChannel`](crate::model::AutoMlChannel)
pub mod auto_ml_channel {

    /// A builder for [`AutoMlChannel`](crate::model::AutoMlChannel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::AutoMlDataSource>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) target_attribute_name: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) channel_type: std::option::Option<crate::model::AutoMlChannelType>,
    }
    impl Builder {
        /// <p>The data source for an AutoML channel.</p>
        pub fn data_source(mut self, input: crate::model::AutoMlDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The data source for an AutoML channel.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::AutoMlDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is <code>None</code>.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is <code>None</code>.</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p>The name of the target variable in supervised learning, usually represented by 'y'.</p>
        pub fn target_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the target variable in supervised learning, usually represented by 'y'.</p>
        pub fn set_target_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_attribute_name = input;
            self
        }
        /// <p>The content type of the data from the input source. You can use <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The content type of the data from the input source. You can use <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The channel type (optional) is an <code>enum</code> string. The default value is <code>training</code>. Channels for training and validation must share the same <code>ContentType</code> and <code>TargetAttributeName</code>. For information on specifying training and validation channel types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-datasets-problem-types.html#autopilot-data-sources-training-or-validation"> <code>How to specify training and validation datasets</code> </a>.</p>
        pub fn channel_type(mut self, input: crate::model::AutoMlChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel type (optional) is an <code>enum</code> string. The default value is <code>training</code>. Channels for training and validation must share the same <code>ContentType</code> and <code>TargetAttributeName</code>. For information on specifying training and validation channel types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-datasets-problem-types.html#autopilot-data-sources-training-or-validation"> <code>How to specify training and validation datasets</code> </a>.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::AutoMlChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlChannel`](crate::model::AutoMlChannel)
        pub fn build(self) -> crate::model::AutoMlChannel {
            crate::model::AutoMlChannel {
                data_source: self.data_source,
                compression_type: self.compression_type,
                target_attribute_name: self.target_attribute_name,
                content_type: self.content_type,
                channel_type: self.channel_type,
            }
        }
    }
}
impl AutoMlChannel {
    /// Creates a new builder-style object to manufacture [`AutoMlChannel`](crate::model::AutoMlChannel)
    pub fn builder() -> crate::model::auto_ml_channel::Builder {
        crate::model::auto_ml_channel::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlChannelType {
    #[allow(missing_docs)] // documentation missing in model
    Training,
    #[allow(missing_docs)] // documentation missing in model
    Validation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlChannelType {
    fn from(s: &str) -> Self {
        match s {
            "training" => AutoMlChannelType::Training,
            "validation" => AutoMlChannelType::Validation,
            other => AutoMlChannelType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlChannelType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlChannelType::from(s))
    }
}
impl AutoMlChannelType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlChannelType::Training => "training",
            AutoMlChannelType::Validation => "validation",
            AutoMlChannelType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["training", "validation"]
    }
}
impl AsRef<str> for AutoMlChannelType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data source for the Autopilot job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlDataSource {
    /// <p>The Amazon S3 location of the input data.</p> <note>
    /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
    /// </note>
    pub s3_data_source: std::option::Option<crate::model::AutoMls3DataSource>,
}
impl AutoMlDataSource {
    /// <p>The Amazon S3 location of the input data.</p> <note>
    /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
    /// </note>
    pub fn s3_data_source(&self) -> std::option::Option<&crate::model::AutoMls3DataSource> {
        self.s3_data_source.as_ref()
    }
}
impl std::fmt::Debug for AutoMlDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.finish()
    }
}
/// See [`AutoMlDataSource`](crate::model::AutoMlDataSource)
pub mod auto_ml_data_source {

    /// A builder for [`AutoMlDataSource`](crate::model::AutoMlDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::AutoMls3DataSource>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the input data.</p> <note>
        /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
        /// </note>
        pub fn s3_data_source(mut self, input: crate::model::AutoMls3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        /// <p>The Amazon S3 location of the input data.</p> <note>
        /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
        /// </note>
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::AutoMls3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlDataSource`](crate::model::AutoMlDataSource)
        pub fn build(self) -> crate::model::AutoMlDataSource {
            crate::model::AutoMlDataSource {
                s3_data_source: self.s3_data_source,
            }
        }
    }
}
impl AutoMlDataSource {
    /// Creates a new builder-style object to manufacture [`AutoMlDataSource`](crate::model::AutoMlDataSource)
    pub fn builder() -> crate::model::auto_ml_data_source::Builder {
        crate::model::auto_ml_data_source::Builder::default()
    }
}

/// <p>The Amazon S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMls3DataSource {
    /// <p>The data type.</p>
    pub s3_data_type: std::option::Option<crate::model::AutoMls3DataType>,
    /// <p>The URL to the Amazon S3 data source.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl AutoMls3DataSource {
    /// <p>The data type.</p>
    pub fn s3_data_type(&self) -> std::option::Option<&crate::model::AutoMls3DataType> {
        self.s3_data_type.as_ref()
    }
    /// <p>The URL to the Amazon S3 data source.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl std::fmt::Debug for AutoMls3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMls3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
pub mod auto_mls3_data_source {

    /// A builder for [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::AutoMls3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data type.</p>
        pub fn s3_data_type(mut self, input: crate::model::AutoMls3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        /// <p>The data type.</p>
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::AutoMls3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>The URL to the Amazon S3 data source.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The URL to the Amazon S3 data source.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
        pub fn build(self) -> crate::model::AutoMls3DataSource {
            crate::model::AutoMls3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl AutoMls3DataSource {
    /// Creates a new builder-style object to manufacture [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
    pub fn builder() -> crate::model::auto_mls3_data_source::Builder {
        crate::model::auto_mls3_data_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMls3DataType {
    #[allow(missing_docs)] // documentation missing in model
    ManifestFile,
    #[allow(missing_docs)] // documentation missing in model
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMls3DataType {
    fn from(s: &str) -> Self {
        match s {
            "ManifestFile" => AutoMls3DataType::ManifestFile,
            "S3Prefix" => AutoMls3DataType::S3Prefix,
            other => AutoMls3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMls3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMls3DataType::from(s))
    }
}
impl AutoMls3DataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMls3DataType::ManifestFile => "ManifestFile",
            AutoMls3DataType::S3Prefix => "S3Prefix",
            AutoMls3DataType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for AutoMls3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the validation and image scan statuses of the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmStatusDetails {
    /// <p>The status of algorithm validation.</p>
    pub validation_statuses: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
    /// <p>The status of the scan of the algorithm's Docker image container.</p>
    pub image_scan_statuses: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
}
impl AlgorithmStatusDetails {
    /// <p>The status of algorithm validation.</p>
    pub fn validation_statuses(&self) -> std::option::Option<&[crate::model::AlgorithmStatusItem]> {
        self.validation_statuses.as_deref()
    }
    /// <p>The status of the scan of the algorithm's Docker image container.</p>
    pub fn image_scan_statuses(&self) -> std::option::Option<&[crate::model::AlgorithmStatusItem]> {
        self.image_scan_statuses.as_deref()
    }
}
impl std::fmt::Debug for AlgorithmStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmStatusDetails");
        formatter.field("validation_statuses", &self.validation_statuses);
        formatter.field("image_scan_statuses", &self.image_scan_statuses);
        formatter.finish()
    }
}
/// See [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
pub mod algorithm_status_details {

    /// A builder for [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_statuses:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        pub(crate) image_scan_statuses:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
    }
    impl Builder {
        /// Appends an item to `validation_statuses`.
        ///
        /// To override the contents of this collection use [`set_validation_statuses`](Self::set_validation_statuses).
        ///
        /// <p>The status of algorithm validation.</p>
        pub fn validation_statuses(mut self, input: crate::model::AlgorithmStatusItem) -> Self {
            let mut v = self.validation_statuses.unwrap_or_default();
            v.push(input);
            self.validation_statuses = Some(v);
            self
        }
        /// <p>The status of algorithm validation.</p>
        pub fn set_validation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        ) -> Self {
            self.validation_statuses = input;
            self
        }
        /// Appends an item to `image_scan_statuses`.
        ///
        /// To override the contents of this collection use [`set_image_scan_statuses`](Self::set_image_scan_statuses).
        ///
        /// <p>The status of the scan of the algorithm's Docker image container.</p>
        pub fn image_scan_statuses(mut self, input: crate::model::AlgorithmStatusItem) -> Self {
            let mut v = self.image_scan_statuses.unwrap_or_default();
            v.push(input);
            self.image_scan_statuses = Some(v);
            self
        }
        /// <p>The status of the scan of the algorithm's Docker image container.</p>
        pub fn set_image_scan_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        ) -> Self {
            self.image_scan_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
        pub fn build(self) -> crate::model::AlgorithmStatusDetails {
            crate::model::AlgorithmStatusDetails {
                validation_statuses: self.validation_statuses,
                image_scan_statuses: self.image_scan_statuses,
            }
        }
    }
}
impl AlgorithmStatusDetails {
    /// Creates a new builder-style object to manufacture [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
    pub fn builder() -> crate::model::algorithm_status_details::Builder {
        crate::model::algorithm_status_details::Builder::default()
    }
}

/// <p>Represents the overall status of an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmStatusItem {
    /// <p>The name of the algorithm for which the overall status is being reported.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status.</p>
    pub status: std::option::Option<crate::model::DetailedAlgorithmStatus>,
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl AlgorithmStatusItem {
    /// <p>The name of the algorithm for which the overall status is being reported.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DetailedAlgorithmStatus> {
        self.status.as_ref()
    }
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for AlgorithmStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmStatusItem");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
pub mod algorithm_status_item {

    /// A builder for [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DetailedAlgorithmStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the algorithm for which the overall status is being reported.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the algorithm for which the overall status is being reported.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current status.</p>
        pub fn status(mut self, input: crate::model::DetailedAlgorithmStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DetailedAlgorithmStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
        pub fn build(self) -> crate::model::AlgorithmStatusItem {
            crate::model::AlgorithmStatusItem {
                name: self.name,
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl AlgorithmStatusItem {
    /// Creates a new builder-style object to manufacture [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
    pub fn builder() -> crate::model::algorithm_status_item::Builder {
        crate::model::algorithm_status_item::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetailedAlgorithmStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DetailedAlgorithmStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => DetailedAlgorithmStatus::Completed,
            "Failed" => DetailedAlgorithmStatus::Failed,
            "InProgress" => DetailedAlgorithmStatus::InProgress,
            "NotStarted" => DetailedAlgorithmStatus::NotStarted,
            other => DetailedAlgorithmStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DetailedAlgorithmStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetailedAlgorithmStatus::from(s))
    }
}
impl DetailedAlgorithmStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DetailedAlgorithmStatus::Completed => "Completed",
            DetailedAlgorithmStatus::Failed => "Failed",
            DetailedAlgorithmStatus::InProgress => "InProgress",
            DetailedAlgorithmStatus::NotStarted => "NotStarted",
            DetailedAlgorithmStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "NotStarted"]
    }
}
impl AsRef<str> for DetailedAlgorithmStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies configurations for one or more training jobs that SageMaker runs to test the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmValidationSpecification {
    /// <p>The IAM roles that SageMaker uses to run the training jobs.</p>
    pub validation_role: std::option::Option<std::string::String>,
    /// <p>An array of <code>AlgorithmValidationProfile</code> objects, each of which specifies a training job and batch transform job that SageMaker runs to validate your algorithm.</p>
    pub validation_profiles:
        std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
}
impl AlgorithmValidationSpecification {
    /// <p>The IAM roles that SageMaker uses to run the training jobs.</p>
    pub fn validation_role(&self) -> std::option::Option<&str> {
        self.validation_role.as_deref()
    }
    /// <p>An array of <code>AlgorithmValidationProfile</code> objects, each of which specifies a training job and batch transform job that SageMaker runs to validate your algorithm.</p>
    pub fn validation_profiles(
        &self,
    ) -> std::option::Option<&[crate::model::AlgorithmValidationProfile]> {
        self.validation_profiles.as_deref()
    }
}
impl std::fmt::Debug for AlgorithmValidationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmValidationSpecification");
        formatter.field("validation_role", &self.validation_role);
        formatter.field("validation_profiles", &self.validation_profiles);
        formatter.finish()
    }
}
/// See [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
pub mod algorithm_validation_specification {

    /// A builder for [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_role: std::option::Option<std::string::String>,
        pub(crate) validation_profiles:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
    }
    impl Builder {
        /// <p>The IAM roles that SageMaker uses to run the training jobs.</p>
        pub fn validation_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_role = Some(input.into());
            self
        }
        /// <p>The IAM roles that SageMaker uses to run the training jobs.</p>
        pub fn set_validation_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_role = input;
            self
        }
        /// Appends an item to `validation_profiles`.
        ///
        /// To override the contents of this collection use [`set_validation_profiles`](Self::set_validation_profiles).
        ///
        /// <p>An array of <code>AlgorithmValidationProfile</code> objects, each of which specifies a training job and batch transform job that SageMaker runs to validate your algorithm.</p>
        pub fn validation_profiles(
            mut self,
            input: crate::model::AlgorithmValidationProfile,
        ) -> Self {
            let mut v = self.validation_profiles.unwrap_or_default();
            v.push(input);
            self.validation_profiles = Some(v);
            self
        }
        /// <p>An array of <code>AlgorithmValidationProfile</code> objects, each of which specifies a training job and batch transform job that SageMaker runs to validate your algorithm.</p>
        pub fn set_validation_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
        ) -> Self {
            self.validation_profiles = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
        pub fn build(self) -> crate::model::AlgorithmValidationSpecification {
            crate::model::AlgorithmValidationSpecification {
                validation_role: self.validation_role,
                validation_profiles: self.validation_profiles,
            }
        }
    }
}
impl AlgorithmValidationSpecification {
    /// Creates a new builder-style object to manufacture [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
    pub fn builder() -> crate::model::algorithm_validation_specification::Builder {
        crate::model::algorithm_validation_specification::Builder::default()
    }
}

/// <p>Defines a training job and a batch transform job that SageMaker runs to validate your algorithm.</p>
/// <p>The data provided in the validation profile is made available to your buyers on Amazon Web Services Marketplace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmValidationProfile {
    /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub profile_name: std::option::Option<std::string::String>,
    /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that SageMaker runs to validate your algorithm.</p>
    pub training_job_definition: std::option::Option<crate::model::TrainingJobDefinition>,
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that SageMaker runs to validate your algorithm.</p>
    pub transform_job_definition: std::option::Option<crate::model::TransformJobDefinition>,
}
impl AlgorithmValidationProfile {
    /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub fn profile_name(&self) -> std::option::Option<&str> {
        self.profile_name.as_deref()
    }
    /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that SageMaker runs to validate your algorithm.</p>
    pub fn training_job_definition(
        &self,
    ) -> std::option::Option<&crate::model::TrainingJobDefinition> {
        self.training_job_definition.as_ref()
    }
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that SageMaker runs to validate your algorithm.</p>
    pub fn transform_job_definition(
        &self,
    ) -> std::option::Option<&crate::model::TransformJobDefinition> {
        self.transform_job_definition.as_ref()
    }
}
impl std::fmt::Debug for AlgorithmValidationProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmValidationProfile");
        formatter.field("profile_name", &self.profile_name);
        formatter.field("training_job_definition", &self.training_job_definition);
        formatter.field("transform_job_definition", &self.transform_job_definition);
        formatter.finish()
    }
}
/// See [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
pub mod algorithm_validation_profile {

    /// A builder for [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_name: std::option::Option<std::string::String>,
        pub(crate) training_job_definition:
            std::option::Option<crate::model::TrainingJobDefinition>,
        pub(crate) transform_job_definition:
            std::option::Option<crate::model::TransformJobDefinition>,
    }
    impl Builder {
        /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
        pub fn profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_name = Some(input.into());
            self
        }
        /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
        pub fn set_profile_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_name = input;
            self
        }
        /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that SageMaker runs to validate your algorithm.</p>
        pub fn training_job_definition(
            mut self,
            input: crate::model::TrainingJobDefinition,
        ) -> Self {
            self.training_job_definition = Some(input);
            self
        }
        /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that SageMaker runs to validate your algorithm.</p>
        pub fn set_training_job_definition(
            mut self,
            input: std::option::Option<crate::model::TrainingJobDefinition>,
        ) -> Self {
            self.training_job_definition = input;
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that SageMaker runs to validate your algorithm.</p>
        pub fn transform_job_definition(
            mut self,
            input: crate::model::TransformJobDefinition,
        ) -> Self {
            self.transform_job_definition = Some(input);
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that SageMaker runs to validate your algorithm.</p>
        pub fn set_transform_job_definition(
            mut self,
            input: std::option::Option<crate::model::TransformJobDefinition>,
        ) -> Self {
            self.transform_job_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
        pub fn build(self) -> crate::model::AlgorithmValidationProfile {
            crate::model::AlgorithmValidationProfile {
                profile_name: self.profile_name,
                training_job_definition: self.training_job_definition,
                transform_job_definition: self.transform_job_definition,
            }
        }
    }
}
impl AlgorithmValidationProfile {
    /// Creates a new builder-style object to manufacture [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
    pub fn builder() -> crate::model::algorithm_validation_profile::Builder {
        crate::model::algorithm_validation_profile::Builder::default()
    }
}

/// <p>Defines the input needed to run a training job using the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobDefinition {
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>The hyperparameters used for the training job.</p>
    pub hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An array of <code>Channel</code> objects, each of which specifies an input source.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>the path to the S3 bucket where you want to store model artifacts. SageMaker creates subfolders for the artifacts.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The resources, including the ML compute instances and ML storage volumes, to use for model training.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts.</p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
}
impl TrainingJobDefinition {
    /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p> <b>Pipe mode</b> </p>
    /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
    /// <p> <b>File mode</b> </p>
    /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
    /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
    /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
    /// <p> <b>FastFile mode</b> </p>
    /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
    /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
    pub fn training_input_mode(&self) -> std::option::Option<&crate::model::TrainingInputMode> {
        self.training_input_mode.as_ref()
    }
    /// <p>The hyperparameters used for the training job.</p>
    pub fn hyper_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.hyper_parameters.as_ref()
    }
    /// <p>An array of <code>Channel</code> objects, each of which specifies an input source.</p>
    pub fn input_data_config(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.input_data_config.as_deref()
    }
    /// <p>the path to the S3 bucket where you want to store model artifacts. SageMaker creates subfolders for the artifacts.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The resources, including the ML compute instances and ML storage volumes, to use for model training.</p>
    pub fn resource_config(&self) -> std::option::Option<&crate::model::ResourceConfig> {
        self.resource_config.as_ref()
    }
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts.</p>
    pub fn stopping_condition(&self) -> std::option::Option<&crate::model::StoppingCondition> {
        self.stopping_condition.as_ref()
    }
}
impl std::fmt::Debug for TrainingJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobDefinition");
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}
/// See [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
pub mod training_job_definition {

    /// A builder for [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    }
    impl Builder {
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        /// <p>The training input mode that the algorithm supports. For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p> <b>Pipe mode</b> </p>
        /// <p>If an algorithm supports <code>Pipe</code> mode, Amazon SageMaker streams data directly from Amazon S3 to the container.</p>
        /// <p> <b>File mode</b> </p>
        /// <p>If an algorithm supports <code>File</code> mode, SageMaker downloads the training data from S3 to the provisioned ML storage volume, and mounts the directory to the Docker volume for the training container.</p>
        /// <p>You must provision the ML storage volume with sufficient capacity to accommodate the data downloaded from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container uses the ML storage volume to also store intermediate information, if any.</p>
        /// <p>For distributed algorithms, training data is distributed uniformly. Your training duration is predictable if the input data objects sizes are approximately the same. SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed when one host in a training cluster is overloaded, thus becoming a bottleneck in training.</p>
        /// <p> <b>FastFile mode</b> </p>
        /// <p>If an algorithm supports <code>FastFile</code> mode, SageMaker streams data directly from S3 to the container with no code changes, and provides file system access to the data. Users can author their training script to interact with these files as if they were stored on disk.</p>
        /// <p> <code>FastFile</code> mode works best when the data is read sequentially. Augmented manifest files aren't supported. The startup time is lower when there are fewer files in the S3 bucket provided.</p>
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        /// Adds a key-value pair to `hyper_parameters`.
        ///
        /// To override the contents of this collection use [`set_hyper_parameters`](Self::set_hyper_parameters).
        ///
        /// <p>The hyperparameters used for the training job.</p>
        pub fn hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hyper_parameters = Some(hash_map);
            self
        }
        /// <p>The hyperparameters used for the training job.</p>
        pub fn set_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hyper_parameters = input;
            self
        }
        /// Appends an item to `input_data_config`.
        ///
        /// To override the contents of this collection use [`set_input_data_config`](Self::set_input_data_config).
        ///
        /// <p>An array of <code>Channel</code> objects, each of which specifies an input source.</p>
        pub fn input_data_config(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input);
            self.input_data_config = Some(v);
            self
        }
        /// <p>An array of <code>Channel</code> objects, each of which specifies an input source.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>the path to the S3 bucket where you want to store model artifacts. SageMaker creates subfolders for the artifacts.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>the path to the S3 bucket where you want to store model artifacts. SageMaker creates subfolders for the artifacts.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The resources, including the ML compute instances and ML storage volumes, to use for model training.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        /// <p>The resources, including the ML compute instances and ML storage volumes, to use for model training.</p>
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts.</p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts.</p>
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
        pub fn build(self) -> crate::model::TrainingJobDefinition {
            crate::model::TrainingJobDefinition {
                training_input_mode: self.training_input_mode,
                hyper_parameters: self.hyper_parameters,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                stopping_condition: self.stopping_condition,
            }
        }
    }
}
impl TrainingJobDefinition {
    /// Creates a new builder-style object to manufacture [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
    pub fn builder() -> crate::model::training_job_definition::Builder {
        crate::model::training_job_definition::Builder::default()
    }
}

/// <p>Defines how the algorithm is used for a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the training algorithm.</p>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
    pub training_image_digest: std::option::Option<std::string::String>,
    /// <p>A list of the <code>HyperParameterSpecification</code> objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.&gt;</p>
    pub supported_hyper_parameters:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
    /// <p>A list of the instance types that this algorithm can use for training.</p>
    pub supported_training_instance_types:
        std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
    /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers can't request more than one instance during training.</p>
    pub supports_distributed_training: bool,
    /// <p>A list of <code>MetricDefinition</code> objects, which are used for parsing metrics generated by the algorithm.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    /// <p>A list of <code>ChannelSpecification</code> objects, which specify the input sources to be used by the algorithm.</p>
    pub training_channels: std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
    /// <p>A list of the metrics that the algorithm emits that can be used as the objective metric in a hyperparameter tuning job.</p>
    pub supported_tuning_job_objective_metrics:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterTuningJobObjective>>,
}
impl TrainingSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the training algorithm.</p>
    pub fn training_image(&self) -> std::option::Option<&str> {
        self.training_image.as_deref()
    }
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
    pub fn training_image_digest(&self) -> std::option::Option<&str> {
        self.training_image_digest.as_deref()
    }
    /// <p>A list of the <code>HyperParameterSpecification</code> objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.&gt;</p>
    pub fn supported_hyper_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::HyperParameterSpecification]> {
        self.supported_hyper_parameters.as_deref()
    }
    /// <p>A list of the instance types that this algorithm can use for training.</p>
    pub fn supported_training_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::TrainingInstanceType]> {
        self.supported_training_instance_types.as_deref()
    }
    /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers can't request more than one instance during training.</p>
    pub fn supports_distributed_training(&self) -> bool {
        self.supports_distributed_training
    }
    /// <p>A list of <code>MetricDefinition</code> objects, which are used for parsing metrics generated by the algorithm.</p>
    pub fn metric_definitions(&self) -> std::option::Option<&[crate::model::MetricDefinition]> {
        self.metric_definitions.as_deref()
    }
    /// <p>A list of <code>ChannelSpecification</code> objects, which specify the input sources to be used by the algorithm.</p>
    pub fn training_channels(&self) -> std::option::Option<&[crate::model::ChannelSpecification]> {
        self.training_channels.as_deref()
    }
    /// <p>A list of the metrics that the algorithm emits that can be used as the objective metric in a hyperparameter tuning job.</p>
    pub fn supported_tuning_job_objective_metrics(
        &self,
    ) -> std::option::Option<&[crate::model::HyperParameterTuningJobObjective]> {
        self.supported_tuning_job_objective_metrics.as_deref()
    }
}
impl std::fmt::Debug for TrainingSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("training_image_digest", &self.training_image_digest);
        formatter.field(
            "supported_hyper_parameters",
            &self.supported_hyper_parameters,
        );
        formatter.field(
            "supported_training_instance_types",
            &self.supported_training_instance_types,
        );
        formatter.field(
            "supports_distributed_training",
            &self.supports_distributed_training,
        );
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.field("training_channels", &self.training_channels);
        formatter.field(
            "supported_tuning_job_objective_metrics",
            &self.supported_tuning_job_objective_metrics,
        );
        formatter.finish()
    }
}
/// See [`TrainingSpecification`](crate::model::TrainingSpecification)
pub mod training_specification {

    /// A builder for [`TrainingSpecification`](crate::model::TrainingSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) training_image_digest: std::option::Option<std::string::String>,
        pub(crate) supported_hyper_parameters:
            std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
        pub(crate) supported_training_instance_types:
            std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
        pub(crate) supports_distributed_training: std::option::Option<bool>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        pub(crate) training_channels:
            std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
        pub(crate) supported_tuning_job_objective_metrics:
            std::option::Option<std::vec::Vec<crate::model::HyperParameterTuningJobObjective>>,
    }
    impl Builder {
        /// <p>The Amazon ECR registry path of the Docker image that contains the training algorithm.</p>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        /// <p>The Amazon ECR registry path of the Docker image that contains the training algorithm.</p>
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
        pub fn training_image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image_digest = Some(input.into());
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for training.</p>
        pub fn set_training_image_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image_digest = input;
            self
        }
        /// Appends an item to `supported_hyper_parameters`.
        ///
        /// To override the contents of this collection use [`set_supported_hyper_parameters`](Self::set_supported_hyper_parameters).
        ///
        /// <p>A list of the <code>HyperParameterSpecification</code> objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.&gt;</p>
        pub fn supported_hyper_parameters(
            mut self,
            input: crate::model::HyperParameterSpecification,
        ) -> Self {
            let mut v = self.supported_hyper_parameters.unwrap_or_default();
            v.push(input);
            self.supported_hyper_parameters = Some(v);
            self
        }
        /// <p>A list of the <code>HyperParameterSpecification</code> objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.&gt;</p>
        pub fn set_supported_hyper_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
        ) -> Self {
            self.supported_hyper_parameters = input;
            self
        }
        /// Appends an item to `supported_training_instance_types`.
        ///
        /// To override the contents of this collection use [`set_supported_training_instance_types`](Self::set_supported_training_instance_types).
        ///
        /// <p>A list of the instance types that this algorithm can use for training.</p>
        pub fn supported_training_instance_types(
            mut self,
            input: crate::model::TrainingInstanceType,
        ) -> Self {
            let mut v = self.supported_training_instance_types.unwrap_or_default();
            v.push(input);
            self.supported_training_instance_types = Some(v);
            self
        }
        /// <p>A list of the instance types that this algorithm can use for training.</p>
        pub fn set_supported_training_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
        ) -> Self {
            self.supported_training_instance_types = input;
            self
        }
        /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers can't request more than one instance during training.</p>
        pub fn supports_distributed_training(mut self, input: bool) -> Self {
            self.supports_distributed_training = Some(input);
            self
        }
        /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers can't request more than one instance during training.</p>
        pub fn set_supports_distributed_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.supports_distributed_training = input;
            self
        }
        /// Appends an item to `metric_definitions`.
        ///
        /// To override the contents of this collection use [`set_metric_definitions`](Self::set_metric_definitions).
        ///
        /// <p>A list of <code>MetricDefinition</code> objects, which are used for parsing metrics generated by the algorithm.</p>
        pub fn metric_definitions(mut self, input: crate::model::MetricDefinition) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input);
            self.metric_definitions = Some(v);
            self
        }
        /// <p>A list of <code>MetricDefinition</code> objects, which are used for parsing metrics generated by the algorithm.</p>
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        /// Appends an item to `training_channels`.
        ///
        /// To override the contents of this collection use [`set_training_channels`](Self::set_training_channels).
        ///
        /// <p>A list of <code>ChannelSpecification</code> objects, which specify the input sources to be used by the algorithm.</p>
        pub fn training_channels(mut self, input: crate::model::ChannelSpecification) -> Self {
            let mut v = self.training_channels.unwrap_or_default();
            v.push(input);
            self.training_channels = Some(v);
            self
        }
        /// <p>A list of <code>ChannelSpecification</code> objects, which specify the input sources to be used by the algorithm.</p>
        pub fn set_training_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
        ) -> Self {
            self.training_channels = input;
            self
        }
        /// Appends an item to `supported_tuning_job_objective_metrics`.
        ///
        /// To override the contents of this collection use [`set_supported_tuning_job_objective_metrics`](Self::set_supported_tuning_job_objective_metrics).
        ///
        /// <p>A list of the metrics that the algorithm emits that can be used as the objective metric in a hyperparameter tuning job.</p>
        pub fn supported_tuning_job_objective_metrics(
            mut self,
            input: crate::model::HyperParameterTuningJobObjective,
        ) -> Self {
            let mut v = self
                .supported_tuning_job_objective_metrics
                .unwrap_or_default();
            v.push(input);
            self.supported_tuning_job_objective_metrics = Some(v);
            self
        }
        /// <p>A list of the metrics that the algorithm emits that can be used as the objective metric in a hyperparameter tuning job.</p>
        pub fn set_supported_tuning_job_objective_metrics(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HyperParameterTuningJobObjective>,
            >,
        ) -> Self {
            self.supported_tuning_job_objective_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingSpecification`](crate::model::TrainingSpecification)
        pub fn build(self) -> crate::model::TrainingSpecification {
            crate::model::TrainingSpecification {
                training_image: self.training_image,
                training_image_digest: self.training_image_digest,
                supported_hyper_parameters: self.supported_hyper_parameters,
                supported_training_instance_types: self.supported_training_instance_types,
                supports_distributed_training: self
                    .supports_distributed_training
                    .unwrap_or_default(),
                metric_definitions: self.metric_definitions,
                training_channels: self.training_channels,
                supported_tuning_job_objective_metrics: self.supported_tuning_job_objective_metrics,
            }
        }
    }
}
impl TrainingSpecification {
    /// Creates a new builder-style object to manufacture [`TrainingSpecification`](crate::model::TrainingSpecification)
    pub fn builder() -> crate::model::training_specification::Builder {
        crate::model::training_specification::Builder::default()
    }
}

/// <p>Defines a named input source, called a channel, to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelSpecification {
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the channel.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub is_required: bool,
    /// <p>The supported MIME types for the data.</p>
    pub supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The allowed compression types, if data compression is used.</p>
    pub supported_compression_types:
        std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub supported_input_modes: std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
}
impl ChannelSpecification {
    /// <p>The name of the channel.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the channel.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub fn is_required(&self) -> bool {
        self.is_required
    }
    /// <p>The supported MIME types for the data.</p>
    pub fn supported_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_content_types.as_deref()
    }
    /// <p>The allowed compression types, if data compression is used.</p>
    pub fn supported_compression_types(
        &self,
    ) -> std::option::Option<&[crate::model::CompressionType]> {
        self.supported_compression_types.as_deref()
    }
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub fn supported_input_modes(&self) -> std::option::Option<&[crate::model::TrainingInputMode]> {
        self.supported_input_modes.as_deref()
    }
}
impl std::fmt::Debug for ChannelSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelSpecification");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_required", &self.is_required);
        formatter.field("supported_content_types", &self.supported_content_types);
        formatter.field(
            "supported_compression_types",
            &self.supported_compression_types,
        );
        formatter.field("supported_input_modes", &self.supported_input_modes);
        formatter.finish()
    }
}
/// See [`ChannelSpecification`](crate::model::ChannelSpecification)
pub mod channel_specification {

    /// A builder for [`ChannelSpecification`](crate::model::ChannelSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_required: std::option::Option<bool>,
        pub(crate) supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supported_compression_types:
            std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
        pub(crate) supported_input_modes:
            std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
    }
    impl Builder {
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the channel.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the channel.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the channel is required by the algorithm.</p>
        pub fn is_required(mut self, input: bool) -> Self {
            self.is_required = Some(input);
            self
        }
        /// <p>Indicates whether the channel is required by the algorithm.</p>
        pub fn set_is_required(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required = input;
            self
        }
        /// Appends an item to `supported_content_types`.
        ///
        /// To override the contents of this collection use [`set_supported_content_types`](Self::set_supported_content_types).
        ///
        /// <p>The supported MIME types for the data.</p>
        pub fn supported_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supported_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_content_types = Some(v);
            self
        }
        /// <p>The supported MIME types for the data.</p>
        pub fn set_supported_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_content_types = input;
            self
        }
        /// Appends an item to `supported_compression_types`.
        ///
        /// To override the contents of this collection use [`set_supported_compression_types`](Self::set_supported_compression_types).
        ///
        /// <p>The allowed compression types, if data compression is used.</p>
        pub fn supported_compression_types(mut self, input: crate::model::CompressionType) -> Self {
            let mut v = self.supported_compression_types.unwrap_or_default();
            v.push(input);
            self.supported_compression_types = Some(v);
            self
        }
        /// <p>The allowed compression types, if data compression is used.</p>
        pub fn set_supported_compression_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
        ) -> Self {
            self.supported_compression_types = input;
            self
        }
        /// Appends an item to `supported_input_modes`.
        ///
        /// To override the contents of this collection use [`set_supported_input_modes`](Self::set_supported_input_modes).
        ///
        /// <p>The allowed input mode, either FILE or PIPE.</p>
        /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
        /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
        pub fn supported_input_modes(mut self, input: crate::model::TrainingInputMode) -> Self {
            let mut v = self.supported_input_modes.unwrap_or_default();
            v.push(input);
            self.supported_input_modes = Some(v);
            self
        }
        /// <p>The allowed input mode, either FILE or PIPE.</p>
        /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
        /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
        pub fn set_supported_input_modes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
        ) -> Self {
            self.supported_input_modes = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelSpecification`](crate::model::ChannelSpecification)
        pub fn build(self) -> crate::model::ChannelSpecification {
            crate::model::ChannelSpecification {
                name: self.name,
                description: self.description,
                is_required: self.is_required.unwrap_or_default(),
                supported_content_types: self.supported_content_types,
                supported_compression_types: self.supported_compression_types,
                supported_input_modes: self.supported_input_modes,
            }
        }
    }
}
impl ChannelSpecification {
    /// Creates a new builder-style object to manufacture [`ChannelSpecification`](crate::model::ChannelSpecification)
    pub fn builder() -> crate::model::channel_specification::Builder {
        crate::model::channel_specification::Builder::default()
    }
}

/// <p>Defines a hyperparameter to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterSpecification {
    /// <p>The name of this hyperparameter. The name must be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the hyperparameter.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>, <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
    pub r#type: std::option::Option<crate::model::ParameterType>,
    /// <p>The allowed range for this hyperparameter.</p>
    pub range: std::option::Option<crate::model::ParameterRange>,
    /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.</p>
    pub is_tunable: bool,
    /// <p>Indicates whether this hyperparameter is required.</p>
    pub is_required: bool,
    /// <p>The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.</p>
    pub default_value: std::option::Option<std::string::String>,
}
impl HyperParameterSpecification {
    /// <p>The name of this hyperparameter. The name must be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the hyperparameter.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>, <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ParameterType> {
        self.r#type.as_ref()
    }
    /// <p>The allowed range for this hyperparameter.</p>
    pub fn range(&self) -> std::option::Option<&crate::model::ParameterRange> {
        self.range.as_ref()
    }
    /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.</p>
    pub fn is_tunable(&self) -> bool {
        self.is_tunable
    }
    /// <p>Indicates whether this hyperparameter is required.</p>
    pub fn is_required(&self) -> bool {
        self.is_required
    }
    /// <p>The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
impl std::fmt::Debug for HyperParameterSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterSpecification");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("range", &self.range);
        formatter.field("is_tunable", &self.is_tunable);
        formatter.field("is_required", &self.is_required);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
pub mod hyper_parameter_specification {

    /// A builder for [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParameterType>,
        pub(crate) range: std::option::Option<crate::model::ParameterRange>,
        pub(crate) is_tunable: std::option::Option<bool>,
        pub(crate) is_required: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of this hyperparameter. The name must be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of this hyperparameter. The name must be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the hyperparameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the hyperparameter.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>, <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
        pub fn r#type(mut self, input: crate::model::ParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>, <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParameterType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The allowed range for this hyperparameter.</p>
        pub fn range(mut self, input: crate::model::ParameterRange) -> Self {
            self.range = Some(input);
            self
        }
        /// <p>The allowed range for this hyperparameter.</p>
        pub fn set_range(
            mut self,
            input: std::option::Option<crate::model::ParameterRange>,
        ) -> Self {
            self.range = input;
            self
        }
        /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.</p>
        pub fn is_tunable(mut self, input: bool) -> Self {
            self.is_tunable = Some(input);
            self
        }
        /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.</p>
        pub fn set_is_tunable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_tunable = input;
            self
        }
        /// <p>Indicates whether this hyperparameter is required.</p>
        pub fn is_required(mut self, input: bool) -> Self {
            self.is_required = Some(input);
            self
        }
        /// <p>Indicates whether this hyperparameter is required.</p>
        pub fn set_is_required(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required = input;
            self
        }
        /// <p>The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
        pub fn build(self) -> crate::model::HyperParameterSpecification {
            crate::model::HyperParameterSpecification {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                range: self.range,
                is_tunable: self.is_tunable.unwrap_or_default(),
                is_required: self.is_required.unwrap_or_default(),
                default_value: self.default_value,
            }
        }
    }
}
impl HyperParameterSpecification {
    /// Creates a new builder-style object to manufacture [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
    pub fn builder() -> crate::model::hyper_parameter_specification::Builder {
        crate::model::hyper_parameter_specification::Builder::default()
    }
}

/// <p>Defines the possible values for categorical, continuous, and integer hyperparameters to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterRange {
    /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible values for an integer hyperparameter.</p>
    pub integer_parameter_range_specification:
        std::option::Option<crate::model::IntegerParameterRangeSpecification>,
    /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible values for a continuous hyperparameter.</p>
    pub continuous_parameter_range_specification:
        std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
    /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible values for a categorical hyperparameter.</p>
    pub categorical_parameter_range_specification:
        std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
}
impl ParameterRange {
    /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible values for an integer hyperparameter.</p>
    pub fn integer_parameter_range_specification(
        &self,
    ) -> std::option::Option<&crate::model::IntegerParameterRangeSpecification> {
        self.integer_parameter_range_specification.as_ref()
    }
    /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible values for a continuous hyperparameter.</p>
    pub fn continuous_parameter_range_specification(
        &self,
    ) -> std::option::Option<&crate::model::ContinuousParameterRangeSpecification> {
        self.continuous_parameter_range_specification.as_ref()
    }
    /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible values for a categorical hyperparameter.</p>
    pub fn categorical_parameter_range_specification(
        &self,
    ) -> std::option::Option<&crate::model::CategoricalParameterRangeSpecification> {
        self.categorical_parameter_range_specification.as_ref()
    }
}
impl std::fmt::Debug for ParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterRange");
        formatter.field(
            "integer_parameter_range_specification",
            &self.integer_parameter_range_specification,
        );
        formatter.field(
            "continuous_parameter_range_specification",
            &self.continuous_parameter_range_specification,
        );
        formatter.field(
            "categorical_parameter_range_specification",
            &self.categorical_parameter_range_specification,
        );
        formatter.finish()
    }
}
/// See [`ParameterRange`](crate::model::ParameterRange)
pub mod parameter_range {

    /// A builder for [`ParameterRange`](crate::model::ParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integer_parameter_range_specification:
            std::option::Option<crate::model::IntegerParameterRangeSpecification>,
        pub(crate) continuous_parameter_range_specification:
            std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
        pub(crate) categorical_parameter_range_specification:
            std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
    }
    impl Builder {
        /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible values for an integer hyperparameter.</p>
        pub fn integer_parameter_range_specification(
            mut self,
            input: crate::model::IntegerParameterRangeSpecification,
        ) -> Self {
            self.integer_parameter_range_specification = Some(input);
            self
        }
        /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible values for an integer hyperparameter.</p>
        pub fn set_integer_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::IntegerParameterRangeSpecification>,
        ) -> Self {
            self.integer_parameter_range_specification = input;
            self
        }
        /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible values for a continuous hyperparameter.</p>
        pub fn continuous_parameter_range_specification(
            mut self,
            input: crate::model::ContinuousParameterRangeSpecification,
        ) -> Self {
            self.continuous_parameter_range_specification = Some(input);
            self
        }
        /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible values for a continuous hyperparameter.</p>
        pub fn set_continuous_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
        ) -> Self {
            self.continuous_parameter_range_specification = input;
            self
        }
        /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible values for a categorical hyperparameter.</p>
        pub fn categorical_parameter_range_specification(
            mut self,
            input: crate::model::CategoricalParameterRangeSpecification,
        ) -> Self {
            self.categorical_parameter_range_specification = Some(input);
            self
        }
        /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible values for a categorical hyperparameter.</p>
        pub fn set_categorical_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
        ) -> Self {
            self.categorical_parameter_range_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterRange`](crate::model::ParameterRange)
        pub fn build(self) -> crate::model::ParameterRange {
            crate::model::ParameterRange {
                integer_parameter_range_specification: self.integer_parameter_range_specification,
                continuous_parameter_range_specification: self
                    .continuous_parameter_range_specification,
                categorical_parameter_range_specification: self
                    .categorical_parameter_range_specification,
            }
        }
    }
}
impl ParameterRange {
    /// Creates a new builder-style object to manufacture [`ParameterRange`](crate::model::ParameterRange)
    pub fn builder() -> crate::model::parameter_range::Builder {
        crate::model::parameter_range::Builder::default()
    }
}

/// <p>Defines the possible values for a categorical hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoricalParameterRangeSpecification {
    /// <p>The allowed categories for the hyperparameter.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CategoricalParameterRangeSpecification {
    /// <p>The allowed categories for the hyperparameter.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for CategoricalParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoricalParameterRangeSpecification");
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
pub mod categorical_parameter_range_specification {

    /// A builder for [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The allowed categories for the hyperparameter.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The allowed categories for the hyperparameter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
        pub fn build(self) -> crate::model::CategoricalParameterRangeSpecification {
            crate::model::CategoricalParameterRangeSpecification {
                values: self.values,
            }
        }
    }
}
impl CategoricalParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
    pub fn builder() -> crate::model::categorical_parameter_range_specification::Builder {
        crate::model::categorical_parameter_range_specification::Builder::default()
    }
}

/// <p>Defines the possible values for a continuous hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousParameterRangeSpecification {
    /// <p>The minimum floating-point value allowed.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum floating-point value allowed.</p>
    pub max_value: std::option::Option<std::string::String>,
}
impl ContinuousParameterRangeSpecification {
    /// <p>The minimum floating-point value allowed.</p>
    pub fn min_value(&self) -> std::option::Option<&str> {
        self.min_value.as_deref()
    }
    /// <p>The maximum floating-point value allowed.</p>
    pub fn max_value(&self) -> std::option::Option<&str> {
        self.max_value.as_deref()
    }
}
impl std::fmt::Debug for ContinuousParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousParameterRangeSpecification");
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.finish()
    }
}
/// See [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
pub mod continuous_parameter_range_specification {

    /// A builder for [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The minimum floating-point value allowed.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        /// <p>The minimum floating-point value allowed.</p>
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum floating-point value allowed.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        /// <p>The maximum floating-point value allowed.</p>
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
        pub fn build(self) -> crate::model::ContinuousParameterRangeSpecification {
            crate::model::ContinuousParameterRangeSpecification {
                min_value: self.min_value,
                max_value: self.max_value,
            }
        }
    }
}
impl ContinuousParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
    pub fn builder() -> crate::model::continuous_parameter_range_specification::Builder {
        crate::model::continuous_parameter_range_specification::Builder::default()
    }
}

/// <p>Defines the possible values for an integer hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegerParameterRangeSpecification {
    /// <p>The minimum integer value allowed.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum integer value allowed.</p>
    pub max_value: std::option::Option<std::string::String>,
}
impl IntegerParameterRangeSpecification {
    /// <p>The minimum integer value allowed.</p>
    pub fn min_value(&self) -> std::option::Option<&str> {
        self.min_value.as_deref()
    }
    /// <p>The maximum integer value allowed.</p>
    pub fn max_value(&self) -> std::option::Option<&str> {
        self.max_value.as_deref()
    }
}
impl std::fmt::Debug for IntegerParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegerParameterRangeSpecification");
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.finish()
    }
}
/// See [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
pub mod integer_parameter_range_specification {

    /// A builder for [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The minimum integer value allowed.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        /// <p>The minimum integer value allowed.</p>
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum integer value allowed.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        /// <p>The maximum integer value allowed.</p>
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
        pub fn build(self) -> crate::model::IntegerParameterRangeSpecification {
            crate::model::IntegerParameterRangeSpecification {
                min_value: self.min_value,
                max_value: self.max_value,
            }
        }
    }
}
impl IntegerParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
    pub fn builder() -> crate::model::integer_parameter_range_specification::Builder {
        crate::model::integer_parameter_range_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterType {
    #[allow(missing_docs)] // documentation missing in model
    Categorical,
    #[allow(missing_docs)] // documentation missing in model
    Continuous,
    #[allow(missing_docs)] // documentation missing in model
    FreeText,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterType {
    fn from(s: &str) -> Self {
        match s {
            "Categorical" => ParameterType::Categorical,
            "Continuous" => ParameterType::Continuous,
            "FreeText" => ParameterType::FreeText,
            "Integer" => ParameterType::Integer,
            other => ParameterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParameterType::from(s))
    }
}
impl ParameterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParameterType::Categorical => "Categorical",
            ParameterType::Continuous => "Continuous",
            ParameterType::FreeText => "FreeText",
            ParameterType::Integer => "Integer",
            ParameterType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Categorical", "Continuous", "FreeText", "Integer"]
    }
}
impl AsRef<str> for ParameterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The retention policy for data stored on an Amazon Elastic File System (EFS) volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RetentionPolicy {
    /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
    /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
    pub home_efs_file_system: std::option::Option<crate::model::RetentionType>,
}
impl RetentionPolicy {
    /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
    /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
    pub fn home_efs_file_system(&self) -> std::option::Option<&crate::model::RetentionType> {
        self.home_efs_file_system.as_ref()
    }
}
impl std::fmt::Debug for RetentionPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RetentionPolicy");
        formatter.field("home_efs_file_system", &self.home_efs_file_system);
        formatter.finish()
    }
}
/// See [`RetentionPolicy`](crate::model::RetentionPolicy)
pub mod retention_policy {

    /// A builder for [`RetentionPolicy`](crate::model::RetentionPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) home_efs_file_system: std::option::Option<crate::model::RetentionType>,
    }
    impl Builder {
        /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
        /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
        pub fn home_efs_file_system(mut self, input: crate::model::RetentionType) -> Self {
            self.home_efs_file_system = Some(input);
            self
        }
        /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
        /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
        pub fn set_home_efs_file_system(
            mut self,
            input: std::option::Option<crate::model::RetentionType>,
        ) -> Self {
            self.home_efs_file_system = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionPolicy`](crate::model::RetentionPolicy)
        pub fn build(self) -> crate::model::RetentionPolicy {
            crate::model::RetentionPolicy {
                home_efs_file_system: self.home_efs_file_system,
            }
        }
    }
}
impl RetentionPolicy {
    /// Creates a new builder-style object to manufacture [`RetentionPolicy`](crate::model::RetentionPolicy)
    pub fn builder() -> crate::model::retention_policy::Builder {
        crate::model::retention_policy::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RetentionType {
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Retain,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RetentionType {
    fn from(s: &str) -> Self {
        match s {
            "Delete" => RetentionType::Delete,
            "Retain" => RetentionType::Retain,
            other => RetentionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RetentionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RetentionType::from(s))
    }
}
impl RetentionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RetentionType::Delete => "Delete",
            RetentionType::Retain => "Retain",
            RetentionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Delete", "Retain"]
    }
}
impl AsRef<str> for RetentionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the output configuration for the compiled model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt your output artifacts with Amazon S3 server-side encryption. The SageMaker execution role must have <code>kms:GenerateDataKey</code> permission.</p>
    /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :key/
    /// <key-id-12ab-34cd-56ef-1234567890ab>
    /// "
    /// </key-id-12ab-34cd-56ef-1234567890ab>
    /// </account>
    /// </region></code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :alias/
    /// <examplealias>
    /// "
    /// </examplealias>
    /// </account>
    /// </region></code> </p> </li>
    /// </ul>
    /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Provides information about the output configuration for the compiled model.</p>
    pub compiled_output_config:
        std::option::Option<crate::model::RecommendationJobCompiledOutputConfig>,
}
impl RecommendationJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt your output artifacts with Amazon S3 server-side encryption. The SageMaker execution role must have <code>kms:GenerateDataKey</code> permission.</p>
    /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :key/
    /// <key-id-12ab-34cd-56ef-1234567890ab>
    /// "
    /// </key-id-12ab-34cd-56ef-1234567890ab>
    /// </account>
    /// </region></code> </p> </li>
    /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
    /// <region>
    /// :
    /// <account>
    /// :alias/
    /// <examplealias>
    /// "
    /// </examplealias>
    /// </account>
    /// </region></code> </p> </li>
    /// </ul>
    /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Provides information about the output configuration for the compiled model.</p>
    pub fn compiled_output_config(
        &self,
    ) -> std::option::Option<&crate::model::RecommendationJobCompiledOutputConfig> {
        self.compiled_output_config.as_ref()
    }
}
impl std::fmt::Debug for RecommendationJobOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationJobOutputConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("compiled_output_config", &self.compiled_output_config);
        formatter.finish()
    }
}
/// See [`RecommendationJobOutputConfig`](crate::model::RecommendationJobOutputConfig)
pub mod recommendation_job_output_config {

    /// A builder for [`RecommendationJobOutputConfig`](crate::model::RecommendationJobOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) compiled_output_config:
            std::option::Option<crate::model::RecommendationJobCompiledOutputConfig>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt your output artifacts with Amazon S3 server-side encryption. The SageMaker execution role must have <code>kms:GenerateDataKey</code> permission.</p>
        /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :key/
        /// <key-id-12ab-34cd-56ef-1234567890ab>
        /// "
        /// </key-id-12ab-34cd-56ef-1234567890ab>
        /// </account>
        /// </region></code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :alias/
        /// <examplealias>
        /// "
        /// </examplealias>
        /// </account>
        /// </region></code> </p> </li>
        /// </ul>
        /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt your output artifacts with Amazon S3 server-side encryption. The SageMaker execution role must have <code>kms:GenerateDataKey</code> permission.</p>
        /// <p>The <code>KmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li> <p>// KMS Key ID</p> <p> <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :key/
        /// <key-id-12ab-34cd-56ef-1234567890ab>
        /// "
        /// </key-id-12ab-34cd-56ef-1234567890ab>
        /// </account>
        /// </region></code> </p> </li>
        /// <li> <p>// KMS Key Alias</p> <p> <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p> <p> <code>"arn:aws:kms:
        /// <region>
        /// :
        /// <account>
        /// :alias/
        /// <examplealias>
        /// "
        /// </examplealias>
        /// </account>
        /// </region></code> </p> </li>
        /// </ul>
        /// <p>For more information about key identifiers, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id">Key identifiers (KeyID)</a> in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Provides information about the output configuration for the compiled model.</p>
        pub fn compiled_output_config(
            mut self,
            input: crate::model::RecommendationJobCompiledOutputConfig,
        ) -> Self {
            self.compiled_output_config = Some(input);
            self
        }
        /// <p>Provides information about the output configuration for the compiled model.</p>
        pub fn set_compiled_output_config(
            mut self,
            input: std::option::Option<crate::model::RecommendationJobCompiledOutputConfig>,
        ) -> Self {
            self.compiled_output_config = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationJobOutputConfig`](crate::model::RecommendationJobOutputConfig)
        pub fn build(self) -> crate::model::RecommendationJobOutputConfig {
            crate::model::RecommendationJobOutputConfig {
                kms_key_id: self.kms_key_id,
                compiled_output_config: self.compiled_output_config,
            }
        }
    }
}
impl RecommendationJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`RecommendationJobOutputConfig`](crate::model::RecommendationJobOutputConfig)
    pub fn builder() -> crate::model::recommendation_job_output_config::Builder {
        crate::model::recommendation_job_output_config::Builder::default()
    }
}

/// <p>Provides information about the output configuration for the compiled model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationJobCompiledOutputConfig {
    /// <p>Identifies the Amazon S3 bucket where you want SageMaker to store the compiled model artifacts.</p>
    pub s3_output_uri: std::option::Option<std::string::String>,
}
impl RecommendationJobCompiledOutputConfig {
    /// <p>Identifies the Amazon S3 bucket where you want SageMaker to store the compiled model artifacts.</p>
    pub fn s3_output_uri(&self) -> std::option::Option<&str> {
        self.s3_output_uri.as_deref()
    }
}
impl std::fmt::Debug for RecommendationJobCompiledOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationJobCompiledOutputConfig");
        formatter.field("s3_output_uri", &self.s3_output_uri);
        formatter.finish()
    }
}
/// See [`RecommendationJobCompiledOutputConfig`](crate::model::RecommendationJobCompiledOutputConfig)
pub mod recommendation_job_compiled_output_config {

    /// A builder for [`RecommendationJobCompiledOutputConfig`](crate::model::RecommendationJobCompiledOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the Amazon S3 bucket where you want SageMaker to store the compiled model artifacts.</p>
        pub fn s3_output_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_uri = Some(input.into());
            self
        }
        /// <p>Identifies the Amazon S3 bucket where you want SageMaker to store the compiled model artifacts.</p>
        pub fn set_s3_output_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationJobCompiledOutputConfig`](crate::model::RecommendationJobCompiledOutputConfig)
        pub fn build(self) -> crate::model::RecommendationJobCompiledOutputConfig {
            crate::model::RecommendationJobCompiledOutputConfig {
                s3_output_uri: self.s3_output_uri,
            }
        }
    }
}
impl RecommendationJobCompiledOutputConfig {
    /// Creates a new builder-style object to manufacture [`RecommendationJobCompiledOutputConfig`](crate::model::RecommendationJobCompiledOutputConfig)
    pub fn builder() -> crate::model::recommendation_job_compiled_output_config::Builder {
        crate::model::recommendation_job_compiled_output_config::Builder::default()
    }
}

/// <p>The error code and error description associated with the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDescribeModelPackageError {
    /// <p></p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p></p>
    pub error_response: std::option::Option<std::string::String>,
}
impl BatchDescribeModelPackageError {
    /// <p></p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p></p>
    pub fn error_response(&self) -> std::option::Option<&str> {
        self.error_response.as_deref()
    }
}
impl std::fmt::Debug for BatchDescribeModelPackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDescribeModelPackageError");
        formatter.field("error_code", &self.error_code);
        formatter.field("error_response", &self.error_response);
        formatter.finish()
    }
}
/// See [`BatchDescribeModelPackageError`](crate::model::BatchDescribeModelPackageError)
pub mod batch_describe_model_package_error {

    /// A builder for [`BatchDescribeModelPackageError`](crate::model::BatchDescribeModelPackageError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_response: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p></p>
        pub fn error_response(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_response = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_error_response(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_response = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDescribeModelPackageError`](crate::model::BatchDescribeModelPackageError)
        pub fn build(self) -> crate::model::BatchDescribeModelPackageError {
            crate::model::BatchDescribeModelPackageError {
                error_code: self.error_code,
                error_response: self.error_response,
            }
        }
    }
}
impl BatchDescribeModelPackageError {
    /// Creates a new builder-style object to manufacture [`BatchDescribeModelPackageError`](crate::model::BatchDescribeModelPackageError)
    pub fn builder() -> crate::model::batch_describe_model_package_error::Builder {
        crate::model::batch_describe_model_package_error::Builder::default()
    }
}

/// <p>Provides summary information about the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDescribeModelPackageSummary {
    /// <p>The group name for the model package</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The version number of a versioned model.</p>
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>The description of the model package.</p>
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>The creation time of the mortgage package summary.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Defines how to perform inference generation after a training job is run.</p>
    pub inference_specification: std::option::Option<crate::model::InferenceSpecification>,
    /// <p>The status of the mortgage package.</p>
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>The approval status of the model.</p>
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
}
impl BatchDescribeModelPackageSummary {
    /// <p>The group name for the model package</p>
    pub fn model_package_group_name(&self) -> std::option::Option<&str> {
        self.model_package_group_name.as_deref()
    }
    /// <p>The version number of a versioned model.</p>
    pub fn model_package_version(&self) -> std::option::Option<i32> {
        self.model_package_version
    }
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub fn model_package_arn(&self) -> std::option::Option<&str> {
        self.model_package_arn.as_deref()
    }
    /// <p>The description of the model package.</p>
    pub fn model_package_description(&self) -> std::option::Option<&str> {
        self.model_package_description.as_deref()
    }
    /// <p>The creation time of the mortgage package summary.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Defines how to perform inference generation after a training job is run.</p>
    pub fn inference_specification(
        &self,
    ) -> std::option::Option<&crate::model::InferenceSpecification> {
        self.inference_specification.as_ref()
    }
    /// <p>The status of the mortgage package.</p>
    pub fn model_package_status(&self) -> std::option::Option<&crate::model::ModelPackageStatus> {
        self.model_package_status.as_ref()
    }
    /// <p>The approval status of the model.</p>
    pub fn model_approval_status(&self) -> std::option::Option<&crate::model::ModelApprovalStatus> {
        self.model_approval_status.as_ref()
    }
}
impl std::fmt::Debug for BatchDescribeModelPackageSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDescribeModelPackageSummary");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.finish()
    }
}
/// See [`BatchDescribeModelPackageSummary`](crate::model::BatchDescribeModelPackageSummary)
pub mod batch_describe_model_package_summary {

    /// A builder for [`BatchDescribeModelPackageSummary`](crate::model::BatchDescribeModelPackageSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_version: std::option::Option<i32>,
        pub(crate) model_package_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) inference_specification:
            std::option::Option<crate::model::InferenceSpecification>,
        pub(crate) model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
        pub(crate) model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    }
    impl Builder {
        /// <p>The group name for the model package</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        /// <p>The group name for the model package</p>
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The version number of a versioned model.</p>
        pub fn model_package_version(mut self, input: i32) -> Self {
            self.model_package_version = Some(input);
            self
        }
        /// <p>The version number of a versioned model.</p>
        pub fn set_model_package_version(mut self, input: std::option::Option<i32>) -> Self {
            self.model_package_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn model_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn set_model_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_arn = input;
            self
        }
        /// <p>The description of the model package.</p>
        pub fn model_package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_description = Some(input.into());
            self
        }
        /// <p>The description of the model package.</p>
        pub fn set_model_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_description = input;
            self
        }
        /// <p>The creation time of the mortgage package summary.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the mortgage package summary.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Defines how to perform inference generation after a training job is run.</p>
        pub fn inference_specification(
            mut self,
            input: crate::model::InferenceSpecification,
        ) -> Self {
            self.inference_specification = Some(input);
            self
        }
        /// <p>Defines how to perform inference generation after a training job is run.</p>
        pub fn set_inference_specification(
            mut self,
            input: std::option::Option<crate::model::InferenceSpecification>,
        ) -> Self {
            self.inference_specification = input;
            self
        }
        /// <p>The status of the mortgage package.</p>
        pub fn model_package_status(mut self, input: crate::model::ModelPackageStatus) -> Self {
            self.model_package_status = Some(input);
            self
        }
        /// <p>The status of the mortgage package.</p>
        pub fn set_model_package_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatus>,
        ) -> Self {
            self.model_package_status = input;
            self
        }
        /// <p>The approval status of the model.</p>
        pub fn model_approval_status(mut self, input: crate::model::ModelApprovalStatus) -> Self {
            self.model_approval_status = Some(input);
            self
        }
        /// <p>The approval status of the model.</p>
        pub fn set_model_approval_status(
            mut self,
            input: std::option::Option<crate::model::ModelApprovalStatus>,
        ) -> Self {
            self.model_approval_status = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDescribeModelPackageSummary`](crate::model::BatchDescribeModelPackageSummary)
        pub fn build(self) -> crate::model::BatchDescribeModelPackageSummary {
            crate::model::BatchDescribeModelPackageSummary {
                model_package_group_name: self.model_package_group_name,
                model_package_version: self.model_package_version,
                model_package_arn: self.model_package_arn,
                model_package_description: self.model_package_description,
                creation_time: self.creation_time,
                inference_specification: self.inference_specification,
                model_package_status: self.model_package_status,
                model_approval_status: self.model_approval_status,
            }
        }
    }
}
impl BatchDescribeModelPackageSummary {
    /// Creates a new builder-style object to manufacture [`BatchDescribeModelPackageSummary`](crate::model::BatchDescribeModelPackageSummary)
    pub fn builder() -> crate::model::batch_describe_model_package_summary::Builder {
        crate::model::batch_describe_model_package_summary::Builder::default()
    }
}
