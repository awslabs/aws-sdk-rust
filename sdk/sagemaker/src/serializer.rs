// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddAssociationInputBody<'a> {
    /// <p>The ARN of the source.</p>
    pub source_arn: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub destination_arn: &'a std::option::Option<std::string::String>,
    /// <p>The type of association. The following are suggested uses for each type. Amazon SageMaker
    /// places no restrictions on their use.</p>
    /// <ul>
    /// <li>
    /// <p>ContributedTo - The source contributed to the destination or had a part in
    /// enabling the destination. For example, the training data contributed to the training
    /// job.</p>
    /// </li>
    /// <li>
    /// <p>AssociatedWith - The source is connected to the destination. For example, an
    /// approval workflow is associated with a model deployment.</p>
    /// </li>
    /// <li>
    /// <p>DerivedFrom - The destination is a modification of the source. For example, a digest
    /// output of a channel input for a processing job is derived from the original inputs.</p>
    /// </li>
    /// <li>
    /// <p>Produced - The source generated the destination. For example, a training job
    /// produced a model artifact.</p>
    /// </li>
    /// </ul>
    pub association_type: &'a std::option::Option<crate::model::AssociationEdgeType>,
}
impl<'a> std::fmt::Debug for AddAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddAssociationInputBody");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("association_type", &self.association_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddTagsInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to tag.</p>
    pub resource_arn: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for AddTagsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddTagsInputBody");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateTrialComponentInputBody<'a> {
    /// <p>The name of the component to associated with the trial.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the trial to associate with.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AssociateTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateActionInputBody<'a> {
    /// <p>The name of the action. Must be unique to your account in an AWS Region.</p>
    pub action_name: &'a std::option::Option<std::string::String>,
    /// <p>The source type, ID, and URI.</p>
    pub source: &'a std::option::Option<crate::model::ActionSource>,
    /// <p>The action type.</p>
    pub action_type: &'a std::option::Option<std::string::String>,
    /// <p>The description of the action.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    pub status: &'a std::option::Option<crate::model::ActionStatus>,
    /// <p>A list of properties to add to the action.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: &'a std::option::Option<crate::model::MetadataProperties>,
    /// <p>A list of tags to apply to the action.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateActionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateActionInputBody");
        formatter.field("action_name", &self.action_name);
        formatter.field("source", &self.source);
        formatter.field("action_type", &self.action_type);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("properties", &self.properties);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAlgorithmInputBody<'a> {
    /// <p>The name of the algorithm.</p>
    pub algorithm_name: &'a std::option::Option<std::string::String>,
    /// <p>A description of the algorithm.</p>
    pub algorithm_description: &'a std::option::Option<std::string::String>,
    /// <p>Specifies details about training jobs run by this algorithm, including the
    /// following:</p>
    /// <ul>
    /// <li>
    /// <p>The Amazon ECR path of the container and the version digest of the
    /// algorithm.</p>
    /// </li>
    /// <li>
    /// <p>The hyperparameters that the algorithm supports.</p>
    /// </li>
    /// <li>
    /// <p>The instance types that the algorithm supports for training.</p>
    /// </li>
    /// <li>
    /// <p>Whether the algorithm supports distributed training.</p>
    /// </li>
    /// <li>
    /// <p>The metrics that the algorithm emits to Amazon CloudWatch.</p>
    /// </li>
    /// <li>
    /// <p>Which metrics that the algorithm emits can be used as the objective metric for
    /// hyperparameter tuning jobs.</p>
    /// </li>
    /// <li>
    /// <p>The input channels that the algorithm supports for training data. For example,
    /// an algorithm might support <code>train</code>, <code>validation</code>, and
    /// <code>test</code> channels.</p>
    /// </li>
    /// </ul>
    pub training_specification: &'a std::option::Option<crate::model::TrainingSpecification>,
    /// <p>Specifies details about inference jobs that the algorithm runs, including the
    /// following:</p>
    /// <ul>
    /// <li>
    /// <p>The Amazon ECR paths of containers that contain the inference code and model
    /// artifacts.</p>
    /// </li>
    /// <li>
    /// <p>The instance types that the algorithm supports for transform jobs and
    /// real-time endpoints used for inference.</p>
    /// </li>
    /// <li>
    /// <p>The input and output content formats that the algorithm supports for
    /// inference.</p>
    /// </li>
    /// </ul>
    pub inference_specification: &'a std::option::Option<crate::model::InferenceSpecification>,
    /// <p>Specifies configurations for one or more training jobs and that Amazon SageMaker runs to test the
    /// algorithm's training code and, optionally, one or more batch transform jobs that Amazon SageMaker
    /// runs to test the algorithm's inference code.</p>
    pub validation_specification:
        &'a std::option::Option<crate::model::AlgorithmValidationSpecification>,
    /// <p>Whether to certify the algorithm so that it can be listed in AWS Marketplace.</p>
    pub certify_for_marketplace: &'a bool,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateAlgorithmInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAlgorithmInputBody");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("algorithm_description", &self.algorithm_description);
        formatter.field("training_specification", &self.training_specification);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of app. Supported apps are <code>JupyterServer</code> and
    /// <code>KernelGateway</code>. <code>TensorBoard</code> is not supported.</p>
    pub app_type: &'a std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    pub app_name: &'a std::option::Option<std::string::String>,
    /// <p>Each tag consists of a key and an optional value.
    /// Tag keys must be unique per resource.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
    pub resource_spec: &'a std::option::Option<crate::model::ResourceSpec>,
}
impl<'a> std::fmt::Debug for CreateAppInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.field("tags", &self.tags);
        formatter.field("resource_spec", &self.resource_spec);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppImageConfigInputBody<'a> {
    /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
    pub app_image_config_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of tags to apply to the AppImageConfig.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The KernelGatewayImageConfig.</p>
    pub kernel_gateway_image_config:
        &'a std::option::Option<crate::model::KernelGatewayImageConfig>,
}
impl<'a> std::fmt::Debug for CreateAppImageConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppImageConfigInputBody");
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.field("tags", &self.tags);
        formatter.field(
            "kernel_gateway_image_config",
            &self.kernel_gateway_image_config,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateArtifactInputBody<'a> {
    /// <p>The name of the artifact. Must be unique to your account in an AWS Region.</p>
    pub artifact_name: &'a std::option::Option<std::string::String>,
    /// <p>The ID, ID type, and URI of the source.</p>
    pub source: &'a std::option::Option<crate::model::ArtifactSource>,
    /// <p>The artifact type.</p>
    pub artifact_type: &'a std::option::Option<std::string::String>,
    /// <p>A list of properties to add to the artifact.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: &'a std::option::Option<crate::model::MetadataProperties>,
    /// <p>A list of tags to apply to the artifact.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateArtifactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateArtifactInputBody");
        formatter.field("artifact_name", &self.artifact_name);
        formatter.field("source", &self.source);
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("properties", &self.properties);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAutoMLJobInputBody<'a> {
    /// <p>Identifies an Autopilot job. The name must be unique to your account and is
    /// case-insensitive.</p>
    pub auto_ml_job_name: &'a std::option::Option<std::string::String>,
    /// <p>An array of channel objects that describes the input data and its location. Each channel
    /// is a named input source. Similar to <code>InputDataConfig</code> supported by . Format(s) supported: CSV. Minimum
    /// of 500 rows.</p>
    pub input_data_config: &'a std::option::Option<std::vec::Vec<crate::model::AutoMLChannel>>,
    /// <p>Provides information about encryption and the Amazon S3 output path needed to store
    /// artifacts from an AutoML job. Format(s) supported: CSV.</p>
    pub output_data_config: &'a std::option::Option<crate::model::AutoMLOutputDataConfig>,
    /// <p>Defines the type of supervised learning available for the candidates. Options include:
    /// <code>BinaryClassification</code>, <code>MulticlassClassification</code>, and
    /// <code>Regression</code>. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-automate-model-development-problem-types.html">
    /// Amazon SageMaker Autopilot problem types and algorithm support</a>.</p>
    pub problem_type: &'a std::option::Option<crate::model::ProblemType>,
    /// <p>Defines the objective metric used to measure the predictive quality of an AutoML job.
    /// You provide an <a>AutoMLJobObjective$MetricName</a> and Autopilot infers whether to
    /// minimize or maximize it.</p>
    pub auto_ml_job_objective: &'a std::option::Option<crate::model::AutoMLJobObjective>,
    /// <p>Contains <code>CompletionCriteria</code> and <code>SecurityConfig</code> settings for
    /// the AutoML job.</p>
    pub auto_ml_job_config: &'a std::option::Option<crate::model::AutoMLJobConfig>,
    /// <p>The ARN of the role that is used to access the data.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>Generates possible candidates without training the models. A candidate is a combination
    /// of data preprocessors, algorithms, and algorithm parameter settings.</p>
    pub generate_candidate_definitions_only: &'a bool,
    /// <p>Each tag consists of a key and an optional value. Tag keys must be unique per
    /// resource.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specifies how to generate the endpoint name for an automatic one-click Autopilot model
    /// deployment.</p>
    pub model_deploy_config: &'a std::option::Option<crate::model::ModelDeployConfig>,
}
impl<'a> std::fmt::Debug for CreateAutoMLJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAutoMLJobInputBody");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("problem_type", &self.problem_type);
        formatter.field("auto_ml_job_objective", &self.auto_ml_job_objective);
        formatter.field("auto_ml_job_config", &self.auto_ml_job_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "generate_candidate_definitions_only",
            &self.generate_candidate_definitions_only,
        );
        formatter.field("tags", &self.tags);
        formatter.field("model_deploy_config", &self.model_deploy_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCodeRepositoryInputBody<'a> {
    /// <p>The name of the Git repository. The name must have 1 to 63 characters. Valid
    /// characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub code_repository_name: &'a std::option::Option<std::string::String>,
    /// <p>Specifies details about the repository, including the URL where the repository is
    /// located, the default branch, and credentials to use to access the repository.</p>
    pub git_config: &'a std::option::Option<crate::model::GitConfig>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateCodeRepositoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCodeRepositoryInputBody");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.field("git_config", &self.git_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCompilationJobInputBody<'a> {
    /// <p>A name for the model compilation job. The name must be unique within the AWS Region
    /// and within your AWS account. </p>
    pub compilation_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on
    /// your behalf. </p>
    /// <p>During model compilation, Amazon SageMaker needs your permission to:</p>
    /// <ul>
    /// <li>
    /// <p>Read input data from an S3 bucket</p>
    /// </li>
    /// <li>
    /// <p>Write model artifacts to an S3 bucket</p>
    /// </li>
    /// <li>
    /// <p>Write logs to Amazon CloudWatch Logs</p>
    /// </li>
    /// <li>
    /// <p>Publish metrics to Amazon CloudWatch</p>
    /// </li>
    /// </ul>
    /// <p>You grant permissions for all of these tasks to an IAM role. To pass this role to
    /// Amazon SageMaker, the caller of this API must have the <code>iam:PassRole</code> permission. For
    /// more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-roles.html">Amazon SageMaker
    /// Roles.</a>
    /// </p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>Provides information about the location of input model artifacts, the name and shape
    /// of the expected data inputs, and the framework in which the model was trained.</p>
    pub input_config: &'a std::option::Option<crate::model::InputConfig>,
    /// <p>Provides information about the output location for the compiled model and the target
    /// device the model runs on.</p>
    pub output_config: &'a std::option::Option<crate::model::OutputConfig>,
    /// <p>Specifies a limit to how long a model compilation job can run. When the job reaches
    /// the time limit, Amazon SageMaker ends the compilation job. Use this API to cap model training
    /// costs.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::StoppingCondition>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateCompilationJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCompilationJobInputBody");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_config", &self.input_config);
        formatter.field("output_config", &self.output_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContextInputBody<'a> {
    /// <p>The name of the context. Must be unique to your account in an AWS Region.</p>
    pub context_name: &'a std::option::Option<std::string::String>,
    /// <p>The source type, ID, and URI.</p>
    pub source: &'a std::option::Option<crate::model::ContextSource>,
    /// <p>The context type.</p>
    pub context_type: &'a std::option::Option<std::string::String>,
    /// <p>The description of the context.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>A list of properties to add to the context.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of tags to apply to the context.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateContextInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContextInputBody");
        formatter.field("context_name", &self.context_name);
        formatter.field("source", &self.source);
        formatter.field("context_type", &self.context_type);
        formatter.field("description", &self.description);
        formatter.field("properties", &self.properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDataQualityJobDefinitionInputBody<'a> {
    /// <p>The name for the monitoring job definition.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>Configures the constraints and baselines for the monitoring job.</p>
    pub data_quality_baseline_config:
        &'a std::option::Option<crate::model::DataQualityBaselineConfig>,
    /// <p>Specifies the container that runs the monitoring job.</p>
    pub data_quality_app_specification:
        &'a std::option::Option<crate::model::DataQualityAppSpecification>,
    /// <p>A list of inputs for the monitoring job. Currently endpoints are supported as monitoring
    /// inputs.</p>
    pub data_quality_job_input: &'a std::option::Option<crate::model::DataQualityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    pub data_quality_job_output_config:
        &'a std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    pub job_resources: &'a std::option::Option<crate::model::MonitoringResources>,
    /// <p>Specifies networking configuration for the monitoring job.</p>
    pub network_config: &'a std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateDataQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDataQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field(
            "data_quality_baseline_config",
            &self.data_quality_baseline_config,
        );
        formatter.field(
            "data_quality_app_specification",
            &self.data_quality_app_specification,
        );
        formatter.field("data_quality_job_input", &self.data_quality_job_input);
        formatter.field(
            "data_quality_job_output_config",
            &self.data_quality_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDeviceFleetInputBody<'a> {
    /// <p>The name of the fleet that the device belongs to.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that has access to AWS Internet of Things (IoT).</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A description of the fleet.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The output configuration for storing sample data collected by the fleet.</p>
    pub output_config: &'a std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>Creates tags for the specified fleet.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Whether to create an AWS IoT Role Alias during device fleet creation.
    /// The name of the role alias generated will match this pattern:
    /// "SageMakerEdge-{DeviceFleetName}".</p>
    /// <p>For example, if your device fleet is called "demo-fleet", the name of
    /// the role alias will be "SageMakerEdge-demo-fleet".</p>
    pub enable_iot_role_alias: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for CreateDeviceFleetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDeviceFleetInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("description", &self.description);
        formatter.field("output_config", &self.output_config);
        formatter.field("tags", &self.tags);
        formatter.field("enable_iot_role_alias", &self.enable_iot_role_alias);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainInputBody<'a> {
    /// <p>A name for the domain.</p>
    pub domain_name: &'a std::option::Option<std::string::String>,
    /// <p>The mode of authentication that members use to access the domain.</p>
    pub auth_mode: &'a std::option::Option<crate::model::AuthMode>,
    /// <p>The default settings to use to create a user profile when <code>UserSettings</code> isn't specified
    /// in the call to the <code>CreateUserProfile</code> API.</p>
    /// <p>
    /// <code>SecurityGroups</code> is aggregated when specified in both calls. For all other
    /// settings in <code>UserSettings</code>, the values specified in <code>CreateUserProfile</code>
    /// take precedence over those specified in <code>CreateDomain</code>.</p>
    pub default_user_settings: &'a std::option::Option<crate::model::UserSettings>,
    /// <p>The VPC subnets that Studio uses for communication.</p>
    pub subnet_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
    pub vpc_id: &'a std::option::Option<std::string::String>,
    /// <p>Tags to associated with the Domain. Each tag consists of a key and an optional value.
    /// Tag keys must be unique per resource. Tags are searchable using the
    /// <code>Search</code> API.</p>
    /// <p>Tags that you specify for the Domain are also added to all Apps that the
    /// Domain launches.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specifies the VPC used for non-EFS traffic. The default value is
    /// <code>PublicInternetOnly</code>.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PublicInternetOnly</code> - Non-EFS traffic is through a VPC managed by
    /// Amazon SageMaker, which allows direct internet access</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>VpcOnly</code> - All Studio traffic is through the specified VPC and subnets</p>
    /// </li>
    /// </ul>
    pub app_network_access_type: &'a std::option::Option<crate::model::AppNetworkAccessType>,
    /// <p>This member is deprecated and replaced with <code>KmsKeyId</code>.</p>
    pub home_efs_file_system_kms_key_id: &'a std::option::Option<std::string::String>,
    /// <p>SageMaker uses AWS KMS to encrypt the EFS volume attached to the domain with an AWS managed
    /// customer master key (CMK) by default. For more control, specify a customer managed CMK.</p>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateDomainInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainInputBody");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("auth_mode", &self.auth_mode);
        formatter.field("default_user_settings", &self.default_user_settings);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("tags", &self.tags);
        formatter.field("app_network_access_type", &self.app_network_access_type);
        formatter.field(
            "home_efs_file_system_kms_key_id",
            &self.home_efs_file_system_kms_key_id,
        );
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEdgePackagingJobInputBody<'a> {
    /// <p>The name of the edge packaging job.</p>
    pub edge_packaging_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the SageMaker Neo compilation job that will be used to locate model artifacts for packaging.</p>
    pub compilation_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the model.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the model.</p>
    pub model_version: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to download and upload the model, and to contact SageMaker Neo.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>Provides information about the output location for the packaged model.</p>
    pub output_config: &'a std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>The CMK to use when encrypting the EBS volume the edge packaging job runs on.</p>
    pub resource_key: &'a std::option::Option<std::string::String>,
    /// <p>Creates tags for the packaging job.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateEdgePackagingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEdgePackagingJobInputBody");
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("output_config", &self.output_config);
        formatter.field("resource_key", &self.resource_key);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointInputBody<'a> {
    /// <p>The name of the endpoint.The name must be unique within an AWS Region in your AWS
    /// account. The name is case-insensitive in <code>CreateEndpoint</code>, but the case is
    /// preserved and must be matched in .</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of an endpoint configuration. For more information, see <a>CreateEndpointConfig</a>. </p>
    pub endpoint_config_name: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointConfigInputBody<'a> {
    /// <p>The name of the endpoint configuration. You specify this name in a <a>CreateEndpoint</a> request. </p>
    pub endpoint_config_name: &'a std::option::Option<std::string::String>,
    /// <p>An list of <code>ProductionVariant</code> objects, one for each model that you want
    /// to host at this endpoint.</p>
    pub production_variants:
        &'a std::option::Option<std::vec::Vec<crate::model::ProductionVariant>>,
    /// <p></p>
    pub data_capture_config: &'a std::option::Option<crate::model::DataCaptureConfig>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt data on
    /// the storage volume attached to the ML compute instance that hosts the endpoint.</p>
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li>
    /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Key ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name: <code>alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
    /// <code>CreateEndpoint</code>, <code>UpdateEndpoint</code> requests. For more
    /// information, refer to the AWS Key Management Service section<a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html"> Using Key
    /// Policies in AWS KMS </a>
    /// </p>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance
    /// type. Local storage volumes are encrypted using a hardware module on the instance.
    /// You can't request a <code>KmsKeyId</code> when using an instance type with local
    /// storage. If any of the models that you specify in the
    /// <code>ProductionVariants</code> parameter use nitro-based instances with local
    /// storage, do not specify a value for the <code>KmsKeyId</code> parameter. If you
    /// specify a value for <code>KmsKeyId</code> when using any nitro-based instances with
    /// local storage, the call to <code>CreateEndpointConfig</code> fails.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
    /// Instance Store Volumes</a>.</p>
    /// </note>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateEndpointConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointConfigInputBody");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("data_capture_config", &self.data_capture_config);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateExperimentInputBody<'a> {
    /// <p>The name of the experiment. The name must be unique in your AWS account and is not
    /// case-sensitive.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. The name doesn't need to be unique. If you don't
    /// specify <code>DisplayName</code>, the value in <code>ExperimentName</code> is
    /// displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The description of the experiment.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>A list of tags to associate with the experiment. You can use <a>Search</a> API
    /// to search on the tags.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateExperimentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateExperimentInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFeatureGroupInputBody<'a> {
    /// <p>The name of the <code>FeatureGroup</code>. The name must be unique within an AWS Region
    /// in an AWS account. The name:</p>
    /// <ul>
    /// <li>
    /// <p>Must start and end with an alphanumeric character.</p>
    /// </li>
    /// <li>
    /// <p>Can only contain alphanumeric character and hyphens. Spaces are not allowed.
    /// </p>
    /// </li>
    /// </ul>
    pub feature_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the <code>Feature</code> whose value uniquely identifies a
    /// <code>Record</code> defined in the <code>FeatureStore</code>. Only the latest record per
    /// identifier value will be stored in the <code>OnlineStore</code>.
    /// <code>RecordIdentifierFeatureName</code> must be one of feature definitions'
    /// names.</p>
    /// <p>You use the <code>RecordIdentifierFeatureName</code> to access data in a
    /// <code>FeatureStore</code>.</p>
    /// <p>This name:</p>
    /// <ul>
    /// <li>
    /// <p>Must start and end with an alphanumeric character.</p>
    /// </li>
    /// <li>
    /// <p>Can only contains alphanumeric characters, hyphens, underscores. Spaces are not
    /// allowed. </p>
    /// </li>
    /// </ul>
    pub record_identifier_feature_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the feature that stores the <code>EventTime</code> of a <code>Record</code>
    /// in a <code>FeatureGroup</code>.</p>
    /// <p>An <code>EventTime</code> is a point in time when a new event occurs that corresponds to
    /// the creation or update of a <code>Record</code> in a <code>FeatureGroup</code>. All
    /// <code>Records</code> in the <code>FeatureGroup</code> must have a corresponding
    /// <code>EventTime</code>.</p>
    /// <p>An <code>EventTime</code> can be a <code>String</code> or <code>Fractional</code>. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Fractional</code>: <code>EventTime</code> feature values must be a Unix
    /// timestamp in seconds.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>String</code>: <code>EventTime</code> feature values must be an ISO-8601
    /// string in the format. The following formats are supported
    /// <code>yyyy-MM-dd'T'HH:mm:ssZ</code> and <code>yyyy-MM-dd'T'HH:mm:ss.SSSZ</code>
    /// where <code>yyyy</code>, <code>MM</code>, and <code>dd</code> represent the year,
    /// month, and day respectively and <code>HH</code>, <code>mm</code>, <code>ss</code>,
    /// and if applicable, <code>SSS</code> represent the hour, month, second and
    /// milliseconds respsectively. <code>'T'</code> and <code>Z</code> are constants.</p>
    /// </li>
    /// </ul>
    pub event_time_feature_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of <code>Feature</code> names and types. <code>Name</code> and <code>Type</code>
    /// is compulsory per <code>Feature</code>. </p>
    /// <p>Valid feature <code>FeatureType</code>s are <code>Integral</code>,
    /// <code>Fractional</code> and <code>String</code>.</p>
    /// <p>
    /// <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>,
    /// <code>write_time</code>, <code>api_invocation_time</code>
    /// </p>
    /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per
    /// <code>FeatureGroup</code>.</p>
    pub feature_definitions:
        &'a std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
    /// <p>You can turn the <code>OnlineStore</code> on or off by specifying <code>True</code> for
    /// the <code>EnableOnlineStore</code> flag in <code>OnlineStoreConfig</code>; the default
    /// value is <code>False</code>.</p>
    /// <p>You can also include an AWS KMS key ID (<code>KMSKeyId</code>) for at-rest encryption of
    /// the <code>OnlineStore</code>.</p>
    pub online_store_config: &'a std::option::Option<crate::model::OnlineStoreConfig>,
    /// <p>Use this to configure an <code>OfflineFeatureStore</code>. This parameter allows you to
    /// specify:</p>
    /// <ul>
    /// <li>
    /// <p>The Amazon Simple Storage Service (Amazon S3) location of an
    /// <code>OfflineStore</code>.</p>
    /// </li>
    /// <li>
    /// <p>A configuration for an AWS Glue or AWS Hive data cataolgue. </p>
    /// </li>
    /// <li>
    /// <p>An KMS encryption key to encrypt the Amazon S3 location used for
    /// <code>OfflineStore</code>.</p>
    /// </li>
    /// </ul>
    /// <p>To learn more about this parameter, see <a>OfflineStoreConfig</a>.</p>
    pub offline_store_config: &'a std::option::Option<crate::model::OfflineStoreConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to persist data into the
    /// <code>OfflineStore</code> if an <code>OfflineStoreConfig</code> is provided.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A free-form description of a <code>FeatureGroup</code>.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Tags used to identify <code>Features</code> in each <code>FeatureGroup</code>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateFeatureGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFeatureGroupInputBody");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field(
            "record_identifier_feature_name",
            &self.record_identifier_feature_name,
        );
        formatter.field("event_time_feature_name", &self.event_time_feature_name);
        formatter.field("feature_definitions", &self.feature_definitions);
        formatter.field("online_store_config", &self.online_store_config);
        formatter.field("offline_store_config", &self.offline_store_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFlowDefinitionInputBody<'a> {
    /// <p>The name of your flow definition.</p>
    pub flow_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>Container for configuring the source of human task requests. Use to specify if
    /// Amazon Rekognition or Amazon Textract is used as an integration source.</p>
    pub human_loop_request_source: &'a std::option::Option<crate::model::HumanLoopRequestSource>,
    /// <p>An object containing information about the events that trigger a human workflow.</p>
    pub human_loop_activation_config:
        &'a std::option::Option<crate::model::HumanLoopActivationConfig>,
    /// <p>An object containing information about the tasks the human reviewers will perform.</p>
    pub human_loop_config: &'a std::option::Option<crate::model::HumanLoopConfig>,
    /// <p>An object containing information about where the human review results will be uploaded.</p>
    pub output_config: &'a std::option::Option<crate::model::FlowDefinitionOutputConfig>,
    /// <p>The Amazon Resource Name (ARN) of the role needed to call other services on your behalf. For example, <code>arn:aws:iam::1234567890:role/service-role/AmazonSageMaker-ExecutionRole-20180111T151298</code>.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs that contain metadata to help you categorize and organize a flow definition. Each tag consists of a key and a value, both of which you define.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateFlowDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFlowDefinitionInputBody");
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.field("human_loop_request_source", &self.human_loop_request_source);
        formatter.field(
            "human_loop_activation_config",
            &self.human_loop_activation_config,
        );
        formatter.field("human_loop_config", &self.human_loop_config);
        formatter.field("output_config", &self.output_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHumanTaskUiInputBody<'a> {
    /// <p>The name of the user interface you are creating.</p>
    pub human_task_ui_name: &'a std::option::Option<std::string::String>,
    /// <p>The Liquid template for the worker user interface.</p>
    pub ui_template: &'a std::option::Option<crate::model::UiTemplate>,
    /// <p>An array of key-value pairs that contain metadata to help you categorize and organize a human review workflow user interface. Each tag consists of a key and a value, both of which you define.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateHumanTaskUiInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHumanTaskUiInputBody");
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.field("ui_template", &self.ui_template);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHyperParameterTuningJobInputBody<'a> {
    /// <p>The name of the tuning job. This name is the prefix for the names of all training jobs
    /// that this tuning job launches. The name must be unique within the same AWS account and
    /// AWS Region. The name must have 1 to 32 characters. Valid characters are a-z, A-Z, 0-9,
    /// and : + = @ _ % - (hyphen). The name is not case sensitive.</p>
    pub hyper_parameter_tuning_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The <a>HyperParameterTuningJobConfig</a> object that describes the tuning
    /// job, including the search strategy, the objective metric used to evaluate training jobs,
    /// ranges of parameters to search, and resource limits for the tuning job. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How
    /// Hyperparameter Tuning Works</a>.</p>
    pub hyper_parameter_tuning_job_config:
        &'a std::option::Option<crate::model::HyperParameterTuningJobConfig>,
    /// <p>The <a>HyperParameterTrainingJobDefinition</a> object that describes the
    /// training jobs that this tuning job launches,
    /// including
    /// static hyperparameters, input data configuration, output data configuration, resource
    /// configuration, and stopping condition.</p>
    pub training_job_definition:
        &'a std::option::Option<crate::model::HyperParameterTrainingJobDefinition>,
    /// <p>A list of the <a>HyperParameterTrainingJobDefinition</a> objects launched
    /// for this tuning job.</p>
    pub training_job_definitions:
        &'a std::option::Option<std::vec::Vec<crate::model::HyperParameterTrainingJobDefinition>>,
    /// <p>Specifies the configuration for starting the hyperparameter tuning job using one or
    /// more previous tuning jobs as a starting point. The results of previous tuning jobs are
    /// used to inform which combinations of hyperparameters to search over in the new tuning
    /// job.</p>
    /// <p>All training jobs launched by the new hyperparameter tuning job are evaluated by using
    /// the objective metric. If you specify <code>IDENTICAL_DATA_AND_ALGORITHM</code> as the
    /// <code>WarmStartType</code> value for the warm start configuration, the training job
    /// that performs the best in the new tuning job is compared to the best training jobs from
    /// the parent tuning jobs. From these, the training job that performs the best as measured
    /// by the objective metric is returned as the overall best training job.</p>
    /// <note>
    /// <p>All training jobs launched by parent hyperparameter tuning jobs and the new
    /// hyperparameter tuning jobs count against the limit of training jobs for the tuning
    /// job.</p>
    /// </note>
    pub warm_start_config:
        &'a std::option::Option<crate::model::HyperParameterTuningJobWarmStartConfig>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    /// <p>Tags that you specify for the tuning job are also added to all training jobs that the
    /// tuning job launches.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateHyperParameterTuningJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHyperParameterTuningJobInputBody");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.field(
            "hyper_parameter_tuning_job_config",
            &self.hyper_parameter_tuning_job_config,
        );
        formatter.field("training_job_definition", &self.training_job_definition);
        formatter.field("training_job_definitions", &self.training_job_definitions);
        formatter.field("warm_start_config", &self.warm_start_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImageInputBody<'a> {
    /// <p>The description of the image.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The display name of the image. If not provided, <code>ImageName</code> is displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the image. Must be unique to your account.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A list of tags to apply to the image.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateImageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImageInputBody");
        formatter.field("description", &self.description);
        formatter.field("display_name", &self.display_name);
        formatter.field("image_name", &self.image_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImageVersionInputBody<'a> {
    /// <p>The registry path of the container image to use as the starting point for this
    /// version. The path is an Amazon Container Registry (ECR) URI in the following format:</p>
    /// <p>
    /// <code><acct-id>.dkr.ecr.<region>.amazonaws.com/<repo-name[:tag] or [@digest]></code>
    /// </p>
    pub base_image: &'a std::option::Option<std::string::String>,
    /// <p>A unique ID. If not specified, the AWS CLI and AWS SDKs, such as the SDK for Python
    /// (Boto3), add a unique value to the call.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
    /// <p>The <code>ImageName</code> of the <code>Image</code> to create a version of.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateImageVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImageVersionInputBody");
        formatter.field("base_image", &self.base_image);
        formatter.field("client_token", &self.client_token);
        formatter.field("image_name", &self.image_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLabelingJobInputBody<'a> {
    /// <p>The name of the labeling job. This name is used to identify the job in a list of
    /// labeling jobs. Labeling job names must be unique within an AWS account and region.
    /// <code>LabelingJobName</code> is not case sensitive. For example, Example-job and
    /// example-job are considered the same labeling job name by Ground Truth.</p>
    pub labeling_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The attribute name to use for the label in the output manifest file. This is the key
    /// for the key/value pair formed with the label that a worker assigns to the object. The
    /// <code>LabelAttributeName</code> must meet the following requirements.</p>
    /// <ul>
    /// <li>
    /// <p>The name can't end with "-metadata". </p>
    /// </li>
    /// <li>
    /// <p>If you are using one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>,
    /// the attribute name <i>must</i> end with "-ref". If the task type
    /// you are using is not listed below, the attribute name <i>must
    /// not</i> end with "-ref".</p>
    /// <ul>
    /// <li>
    /// <p>Image semantic segmentation (<code>SemanticSegmentation)</code>, and
    /// adjustment (<code>AdjustmentSemanticSegmentation</code>) and
    /// verification (<code>VerificationSemanticSegmentation</code>) labeling
    /// jobs for this task type.</p>
    /// </li>
    /// <li>
    /// <p>Video frame object detection (<code>VideoObjectDetection</code>), and
    /// adjustment and verification
    /// (<code>AdjustmentVideoObjectDetection</code>) labeling jobs for this
    /// task type.</p>
    /// </li>
    /// <li>
    /// <p>Video frame object tracking (<code>VideoObjectTracking</code>), and
    /// adjustment and verification (<code>AdjustmentVideoObjectTracking</code>)
    /// labeling jobs for this task type.</p>
    /// </li>
    /// <li>
    /// <p>3D point cloud semantic segmentation
    /// (<code>3DPointCloudSemanticSegmentation</code>), and adjustment and
    /// verification (<code>Adjustment3DPointCloudSemanticSegmentation</code>)
    /// labeling jobs for this task type. </p>
    /// </li>
    /// <li>
    /// <p>3D point cloud object tracking
    /// (<code>3DPointCloudObjectTracking</code>), and adjustment and
    /// verification (<code>Adjustment3DPointCloudObjectTracking</code>)
    /// labeling jobs for this task type. </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    /// <p></p>
    /// <important>
    /// <p>If you are creating an adjustment or verification labeling job, you must use a
    /// <i>different</i>
    /// <code>LabelAttributeName</code> than the one used in the original labeling job. The
    /// original labeling job is the Ground Truth labeling job that produced the labels that you
    /// want verified or adjusted. To learn more about adjustment and verification labeling
    /// jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust
    /// Labels</a>.</p>
    /// </important>
    pub label_attribute_name: &'a std::option::Option<std::string::String>,
    /// <p>Input data for the labeling job, such as the Amazon S3 location of the data objects and the
    /// location of the manifest file that describes the data objects.</p>
    /// <p>You must specify at least one of the following: <code>S3DataSource</code> or
    /// <code>SnsDataSource</code>. </p>
    /// <ul>
    /// <li>
    /// <p>Use <code>SnsDataSource</code> to specify an SNS input topic for a streaming
    /// labeling job. If you do not specify and SNS input topic ARN, Ground Truth will
    /// create a one-time labeling job that stops after all data objects in the input
    /// manifest file have been labeled.</p>
    /// </li>
    /// <li>
    /// <p>Use <code>S3DataSource</code> to specify an input manifest file for both
    /// streaming and one-time labeling jobs. Adding an <code>S3DataSource</code> is
    /// optional if you use <code>SnsDataSource</code> to create a streaming labeling
    /// job.</p>
    /// </li>
    /// </ul>
    /// <p>If you use the Amazon Mechanical Turk workforce, your input data should not include
    /// confidential information, personal information or protected health information. Use
    /// <code>ContentClassifiers</code> to specify that your data is free of personally
    /// identifiable information and adult content.</p>
    pub input_config: &'a std::option::Option<crate::model::LabelingJobInputConfig>,
    /// <p>The location of the output data and the AWS Key Management Service key ID for the key used to encrypt
    /// the output data, if any.</p>
    pub output_config: &'a std::option::Option<crate::model::LabelingJobOutputConfig>,
    /// <p>The Amazon Resource Number (ARN) that Amazon SageMaker assumes to perform tasks on your behalf
    /// during data labeling. You must grant this role the necessary permissions so that Amazon SageMaker
    /// can successfully complete data labeling.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The S3 URI of the file, referred to as a <i>label category configuration
    /// file</i>, that defines the categories used to label the data objects.</p>
    /// <p>For 3D point cloud and video frame task types, you can add label category attributes
    /// and frame attributes to your label category configuration file. To learn how, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-label-category-config.html">Create a
    /// Labeling Category Configuration File for 3D Point Cloud Labeling Jobs</a>. </p>
    /// <p>For all other <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates.html">custom
    /// tasks</a>, your label category configuration file must be a JSON file in the
    /// following format. Identify the labels you want to use by replacing <code>label_1</code>,
    /// <code>label_2</code>,<code>...</code>,<code>label_n</code> with your label
    /// categories.</p>
    /// <p>
    /// <code>{ </code>
    /// </p>
    /// <p>
    /// <code>"document-version": "2018-11-28",</code>
    /// </p>
    /// <p>
    /// <code>"labels": [{"label": "label_1"},{"label": "label_2"},...{"label":
    /// "label_n"}]</code>
    /// </p>
    /// <p>
    /// <code>}</code>
    /// </p>
    /// <p>Note the following about the label category configuration file:</p>
    /// <ul>
    /// <li>
    /// <p>For image classification and text classification (single and multi-label) you
    /// must specify at least two label categories. For all other task types, the
    /// minimum number of label categories required is one. </p>
    /// </li>
    /// <li>
    /// <p>Each label category must be unique, you cannot specify duplicate label
    /// categories.</p>
    /// </li>
    /// <li>
    /// <p>If you create a 3D point cloud or video frame adjustment or verification
    /// labeling job, you must include <code>auditLabelAttributeName</code> in the label
    /// category configuration. Use this parameter to enter the <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateLabelingJob.html#sagemaker-CreateLabelingJob-request-LabelAttributeName">
    /// <code>LabelAttributeName</code>
    /// </a> of the labeling job you want to
    /// adjust or verify annotations of.</p>
    /// </li>
    /// </ul>
    pub label_category_config_s3_uri: &'a std::option::Option<std::string::String>,
    /// <p>A set of conditions for stopping the labeling job. If any of the conditions are met,
    /// the job is automatically stopped. You can use these conditions to control the cost of
    /// data labeling.</p>
    pub stopping_conditions: &'a std::option::Option<crate::model::LabelingJobStoppingConditions>,
    /// <p>Configures the information required to perform automated data labeling.</p>
    pub labeling_job_algorithms_config:
        &'a std::option::Option<crate::model::LabelingJobAlgorithmsConfig>,
    /// <p>Configures the labeling task and how it is presented to workers; including, but not limited to price, keywords, and batch size (task count).</p>
    pub human_task_config: &'a std::option::Option<crate::model::HumanTaskConfig>,
    /// <p>An array of key/value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-what">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateLabelingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLabelingJobInputBody");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("label_attribute_name", &self.label_attribute_name);
        formatter.field("input_config", &self.input_config);
        formatter.field("output_config", &self.output_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "label_category_config_s3_uri",
            &self.label_category_config_s3_uri,
        );
        formatter.field("stopping_conditions", &self.stopping_conditions);
        formatter.field(
            "labeling_job_algorithms_config",
            &self.labeling_job_algorithms_config,
        );
        formatter.field("human_task_config", &self.human_task_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelInputBody<'a> {
    /// <p>The name of the new model.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
    /// <p>The location of the primary docker image containing inference code, associated
    /// artifacts, and custom environment map that the inference code uses when the model is
    /// deployed for predictions. </p>
    pub primary_container: &'a std::option::Option<crate::model::ContainerDefinition>,
    /// <p>Specifies the containers in the inference pipeline.</p>
    pub containers: &'a std::option::Option<std::vec::Vec<crate::model::ContainerDefinition>>,
    /// <p>Specifies details of how containers in a multi-container endpoint are called.</p>
    pub inference_execution_config: &'a std::option::Option<crate::model::InferenceExecutionConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that Amazon SageMaker can assume to access model
    /// artifacts and docker image for deployment on ML compute instances or for batch transform
    /// jobs. Deploying on ML compute instances is part of model hosting. For more information,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-roles.html">Amazon SageMaker
    /// Roles</a>. </p>
    /// <note>
    /// <p>To be able to pass this role to Amazon SageMaker, the caller of this API must have the
    /// <code>iam:PassRole</code> permission.</p>
    /// </note>
    pub execution_role_arn: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A <a>VpcConfig</a> object that specifies the VPC that you want your model
    /// to connect to. Control access to and from your model container by configuring the VPC.
    /// <code>VpcConfig</code> is used in hosting services and in batch transform. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-vpc.html">Protect Data in Batch
    /// Transform Jobs by Using an Amazon Virtual Private Cloud</a>.</p>
    pub vpc_config: &'a std::option::Option<crate::model::VpcConfig>,
    /// <p>Isolates the model container. No inbound or outbound network calls can be made to or
    /// from the model container.</p>
    pub enable_network_isolation: &'a bool,
}
impl<'a> std::fmt::Debug for CreateModelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelInputBody");
        formatter.field("model_name", &self.model_name);
        formatter.field("primary_container", &self.primary_container);
        formatter.field("containers", &self.containers);
        formatter.field(
            "inference_execution_config",
            &self.inference_execution_config,
        );
        formatter.field("execution_role_arn", &self.execution_role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelBiasJobDefinitionInputBody<'a> {
    /// <p>The name of the bias job definition. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>The baseline configuration for a model bias job.</p>
    pub model_bias_baseline_config: &'a std::option::Option<crate::model::ModelBiasBaselineConfig>,
    /// <p>Configures the model bias job to run a specified Docker container image.</p>
    pub model_bias_app_specification:
        &'a std::option::Option<crate::model::ModelBiasAppSpecification>,
    /// <p>Inputs for the model bias job.</p>
    pub model_bias_job_input: &'a std::option::Option<crate::model::ModelBiasJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    pub model_bias_job_output_config: &'a std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    pub job_resources: &'a std::option::Option<crate::model::MonitoringResources>,
    /// <p>Networking options for a model bias job.</p>
    pub network_config: &'a std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateModelBiasJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelBiasJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field(
            "model_bias_baseline_config",
            &self.model_bias_baseline_config,
        );
        formatter.field(
            "model_bias_app_specification",
            &self.model_bias_app_specification,
        );
        formatter.field("model_bias_job_input", &self.model_bias_job_input);
        formatter.field(
            "model_bias_job_output_config",
            &self.model_bias_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelExplainabilityJobDefinitionInputBody<'a> {
    /// <p> The name of the model explainability job definition. The name must be unique within an
    /// AWS Region in the AWS account.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>The baseline configuration for a model explainability job.</p>
    pub model_explainability_baseline_config:
        &'a std::option::Option<crate::model::ModelExplainabilityBaselineConfig>,
    /// <p>Configures the model explainability job to run a specified Docker container
    /// image.</p>
    pub model_explainability_app_specification:
        &'a std::option::Option<crate::model::ModelExplainabilityAppSpecification>,
    /// <p>Inputs for the model explainability job.</p>
    pub model_explainability_job_input:
        &'a std::option::Option<crate::model::ModelExplainabilityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    pub model_explainability_job_output_config:
        &'a std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    pub job_resources: &'a std::option::Option<crate::model::MonitoringResources>,
    /// <p>Networking options for a model explainability job.</p>
    pub network_config: &'a std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateModelExplainabilityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelExplainabilityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field(
            "model_explainability_baseline_config",
            &self.model_explainability_baseline_config,
        );
        formatter.field(
            "model_explainability_app_specification",
            &self.model_explainability_app_specification,
        );
        formatter.field(
            "model_explainability_job_input",
            &self.model_explainability_job_input,
        );
        formatter.field(
            "model_explainability_job_output_config",
            &self.model_explainability_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelPackageInputBody<'a> {
    /// <p>The name of the model package. The name must have 1 to 63 characters. Valid characters
    /// are a-z, A-Z, 0-9, and - (hyphen).</p>
    /// <p>This parameter is required for unversioned models. It is not applicable to versioned
    /// models.</p>
    pub model_package_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the model group that this model version belongs to.</p>
    /// <p>This parameter is required for versioned models, and does not apply to unversioned
    /// models.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A description of the model package.</p>
    pub model_package_description: &'a std::option::Option<std::string::String>,
    /// <p>Specifies details about inference jobs that can be run with models based on this model
    /// package, including the following:</p>
    /// <ul>
    /// <li>
    /// <p>The Amazon ECR paths of containers that contain the inference code and model
    /// artifacts.</p>
    /// </li>
    /// <li>
    /// <p>The instance types that the model package supports for transform jobs and
    /// real-time endpoints used for inference.</p>
    /// </li>
    /// <li>
    /// <p>The input and output content formats that the model package supports for
    /// inference.</p>
    /// </li>
    /// </ul>
    pub inference_specification: &'a std::option::Option<crate::model::InferenceSpecification>,
    /// <p>Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the
    /// model package.</p>
    pub validation_specification:
        &'a std::option::Option<crate::model::ModelPackageValidationSpecification>,
    /// <p>Details about the algorithm that was used to create the model package.</p>
    pub source_algorithm_specification:
        &'a std::option::Option<crate::model::SourceAlgorithmSpecification>,
    /// <p>Whether to certify the model package for listing on AWS Marketplace.</p>
    /// <p>This parameter is optional for unversioned models, and does not apply to versioned
    /// models.</p>
    pub certify_for_marketplace: &'a bool,
    /// <p>A list of key value pairs associated with the model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// resources</a> in the <i>AWS General Reference Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Whether the model is approved for deployment.</p>
    /// <p>This parameter is optional for versioned models, and does not apply to unversioned
    /// models.</p>
    /// <p>For versioned models, the value of this parameter must be set to <code>Approved</code>
    /// to deploy the model.</p>
    pub model_approval_status: &'a std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: &'a std::option::Option<crate::model::MetadataProperties>,
    /// <p>A structure that contains model metrics reports.</p>
    pub model_metrics: &'a std::option::Option<crate::model::ModelMetrics>,
    /// <p>A unique token that guarantees that the call to this API is idempotent.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateModelPackageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelPackageInputBody");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field(
            "source_algorithm_specification",
            &self.source_algorithm_specification,
        );
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.field("tags", &self.tags);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("model_metrics", &self.model_metrics);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelPackageGroupInputBody<'a> {
    /// <p>The name of the model group.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A description for the model group.</p>
    pub model_package_group_description: &'a std::option::Option<std::string::String>,
    /// <p>A list of key value pairs associated with the model group. For more information, see
    /// <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// resources</a> in the <i>AWS General Reference Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateModelPackageGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelPackageGroupInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelQualityJobDefinitionInputBody<'a> {
    /// <p>The name of the monitoring job definition.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>Specifies the constraints and baselines for the monitoring job.</p>
    pub model_quality_baseline_config:
        &'a std::option::Option<crate::model::ModelQualityBaselineConfig>,
    /// <p>The container that runs the monitoring job.</p>
    pub model_quality_app_specification:
        &'a std::option::Option<crate::model::ModelQualityAppSpecification>,
    /// <p>A list of the inputs that are monitored. Currently endpoints are supported.</p>
    pub model_quality_job_input: &'a std::option::Option<crate::model::ModelQualityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    pub model_quality_job_output_config:
        &'a std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    pub job_resources: &'a std::option::Option<crate::model::MonitoringResources>,
    /// <p>Specifies the network configuration for the monitoring job.</p>
    pub network_config: &'a std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateModelQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field(
            "model_quality_baseline_config",
            &self.model_quality_baseline_config,
        );
        formatter.field(
            "model_quality_app_specification",
            &self.model_quality_app_specification,
        );
        formatter.field("model_quality_job_input", &self.model_quality_job_input);
        formatter.field(
            "model_quality_job_output_config",
            &self.model_quality_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMonitoringScheduleInputBody<'a> {
    /// <p>The name of the monitoring schedule. The name must be unique within an AWS Region within
    /// an AWS account.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
    /// <p>The configuration object that specifies the monitoring schedule and defines the
    /// monitoring job.</p>
    pub monitoring_schedule_config: &'a std::option::Option<crate::model::MonitoringScheduleConfig>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href=" https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field(
            "monitoring_schedule_config",
            &self.monitoring_schedule_config,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateNotebookInstanceInputBody<'a> {
    /// <p>The name of the new notebook instance.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of ML compute instance to launch for the notebook instance.</p>
    pub instance_type: &'a std::option::Option<crate::model::InstanceType>,
    /// <p>The ID of the subnet in a VPC to which you would like to have a connectivity from
    /// your ML compute instance. </p>
    pub subnet_id: &'a std::option::Option<std::string::String>,
    /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. The security groups must be
    /// for the same VPC as specified in the subnet. </p>
    pub security_group_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> When you send any requests to AWS resources from the notebook instance, Amazon SageMaker
    /// assumes this role to perform tasks on your behalf. You must grant this role necessary
    /// permissions so Amazon SageMaker can perform these tasks. The policy must allow the Amazon SageMaker service
    /// principal (sagemaker.amazonaws.com) permissions to assume this role. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-roles.html">Amazon SageMaker Roles</a>. </p>
    /// <note>
    /// <p>To be able to pass this role to Amazon SageMaker, the caller of this API must have the
    /// <code>iam:PassRole</code> permission.</p>
    /// </note>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt data on
    /// the storage volume attached to your notebook instance. The KMS key you provide must be
    /// enabled. For information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/enabling-keys.html">Enabling and Disabling
    /// Keys</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The name of a lifecycle configuration to associate with the notebook instance. For
    /// information about lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional)
    /// Customize a Notebook Instance</a>.</p>
    pub lifecycle_config_name: &'a std::option::Option<std::string::String>,
    /// <p>Sets whether Amazon SageMaker provides internet access to the notebook instance. If you set this
    /// to <code>Disabled</code> this notebook instance is able to access resources only in your
    /// VPC, and is not be able to connect to Amazon SageMaker training and endpoint services unless you
    /// configure a NAT Gateway in your VPC.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/appendix-additional-considerations.html#appendix-notebook-and-internet-access">Notebook Instances Are Internet-Enabled by Default</a>. You can set the value
    /// of this parameter to <code>Disabled</code> only if you set a value for the
    /// <code>SubnetId</code> parameter.</p>
    pub direct_internet_access: &'a std::option::Option<crate::model::DirectInternetAccess>,
    /// <p>The size, in GB, of the ML storage volume to attach to the notebook instance. The
    /// default value is 5 GB.</p>
    pub volume_size_in_gb: &'a std::option::Option<i32>,
    /// <p>A list of Elastic Inference (EI) instance types to associate with this notebook
    /// instance. Currently, only one instance type can be associated with a notebook instance.
    /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon SageMaker</a>.</p>
    pub accelerator_types:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceAcceleratorType>>,
    /// <p>A Git repository to associate with the notebook instance as its default code
    /// repository. This can be either the name of a Git repository stored as a resource in your
    /// account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. When you open a notebook instance, it opens in the directory that
    /// contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with Amazon SageMaker
    /// Notebook Instances</a>.</p>
    pub default_code_repository: &'a std::option::Option<std::string::String>,
    /// <p>An array of up to three Git repositories to associate with the notebook instance.
    /// These can be either the names of Git repositories stored as resources in your account,
    /// or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. These repositories are cloned at the same level as the default
    /// repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git
    /// Repositories with Amazon SageMaker Notebook Instances</a>.</p>
    pub additional_code_repositories: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether root access is enabled or disabled for users of the notebook instance. The
    /// default value is <code>Enabled</code>.</p>
    /// <note>
    /// <p>Lifecycle configurations need root access to be able to set up a notebook
    /// instance. Because of this, lifecycle configurations associated with a notebook
    /// instance always run with root access even if you disable root access for
    /// users.</p>
    /// </note>
    pub root_access: &'a std::option::Option<crate::model::RootAccess>,
}
impl<'a> std::fmt::Debug for CreateNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("tags", &self.tags);
        formatter.field("lifecycle_config_name", &self.lifecycle_config_name);
        formatter.field("direct_internet_access", &self.direct_internet_access);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("accelerator_types", &self.accelerator_types);
        formatter.field("default_code_repository", &self.default_code_repository);
        formatter.field(
            "additional_code_repositories",
            &self.additional_code_repositories,
        );
        formatter.field("root_access", &self.root_access);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateNotebookInstanceLifecycleConfigInputBody<'a> {
    /// <p>The name of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_name: &'a std::option::Option<std::string::String>,
    /// <p>A shell script that runs only once, when you create a notebook instance. The shell
    /// script must be a base64-encoded string.</p>
    pub on_create:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
    /// <p>A shell script that runs every time you start a notebook instance, including when you
    /// create the notebook instance. The shell script must be a base64-encoded string.</p>
    pub on_start:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
}
impl<'a> std::fmt::Debug for CreateNotebookInstanceLifecycleConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateNotebookInstanceLifecycleConfigInputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("on_create", &self.on_create);
        formatter.field("on_start", &self.on_start);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePipelineInputBody<'a> {
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: &'a std::option::Option<std::string::String>,
    /// <p>The JSON pipeline definition of the pipeline.</p>
    pub pipeline_definition: &'a std::option::Option<std::string::String>,
    /// <p>A description of the pipeline.</p>
    pub pipeline_description: &'a std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the role used by the pipeline to access and create resources.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>A list of tags to apply to the created pipeline.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreatePipelineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePipelineInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_definition", &self.pipeline_definition);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePresignedDomainUrlInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the UserProfile to sign-in as.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>The session expiration duration in seconds. This value defaults to 43200.</p>
    pub session_expiration_duration_in_seconds: &'a std::option::Option<i32>,
    /// <p>The number of seconds until the pre-signed URL expires. This value defaults to
    /// 300.</p>
    pub expires_in_seconds: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for CreatePresignedDomainUrlInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePresignedDomainUrlInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field(
            "session_expiration_duration_in_seconds",
            &self.session_expiration_duration_in_seconds,
        );
        formatter.field("expires_in_seconds", &self.expires_in_seconds);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePresignedNotebookInstanceUrlInputBody<'a> {
    /// <p>The name of the notebook instance.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
    /// <p>The duration of the session, in seconds. The default is 12 hours.</p>
    pub session_expiration_duration_in_seconds: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for CreatePresignedNotebookInstanceUrlInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePresignedNotebookInstanceUrlInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field(
            "session_expiration_duration_in_seconds",
            &self.session_expiration_duration_in_seconds,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProcessingJobInputBody<'a> {
    /// <p>An array of inputs configuring the data to download into the
    /// processing container.</p>
    pub processing_inputs: &'a std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
    /// <p>Output configuration for the processing job.</p>
    pub processing_output_config: &'a std::option::Option<crate::model::ProcessingOutputConfig>,
    /// <p> The name of the processing job. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    pub processing_job_name: &'a std::option::Option<std::string::String>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
    /// processing job. In distributed training, you specify more than one instance.</p>
    pub processing_resources: &'a std::option::Option<crate::model::ProcessingResources>,
    /// <p>The time limit for how long the processing job is allowed to run.</p>
    pub stopping_condition: &'a std::option::Option<crate::model::ProcessingStoppingCondition>,
    /// <p>Configures the processing job to run a specified Docker container image.</p>
    pub app_specification: &'a std::option::Option<crate::model::AppSpecification>,
    /// <p>The environment variables to set in the Docker container. Up to
    /// 100 key and values entries in the map are supported.</p>
    pub environment: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>Networking options for a processing job, such as whether to allow inbound and
    /// outbound network calls to and from processing containers, and the VPC subnets and
    /// security groups to use for VPC-enabled processing jobs.</p>
    pub network_config: &'a std::option::Option<crate::model::NetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on
    /// your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: &'a std::option::Option<crate::model::ExperimentConfig>,
}
impl<'a> std::fmt::Debug for CreateProcessingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProcessingJobInputBody");
        formatter.field("processing_inputs", &self.processing_inputs);
        formatter.field("processing_output_config", &self.processing_output_config);
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_resources", &self.processing_resources);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("app_specification", &self.app_specification);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProjectInputBody<'a> {
    /// <p>The name of the project.</p>
    pub project_name: &'a std::option::Option<std::string::String>,
    /// <p>A description for the project.</p>
    pub project_description: &'a std::option::Option<std::string::String>,
    /// <p>The product ID and provisioning artifact ID to provision a service catalog. For
    /// information, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is AWS Service
    /// Catalog</a>.</p>
    pub service_catalog_provisioning_details:
        &'a std::option::Option<crate::model::ServiceCatalogProvisioningDetails>,
    /// <p>An array of key-value pairs that you want to use to organize and track your AWS
    /// resource costs. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a> in the <i>AWS General Reference Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateProjectInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProjectInputBody");
        formatter.field("project_name", &self.project_name);
        formatter.field("project_description", &self.project_description);
        formatter.field(
            "service_catalog_provisioning_details",
            &self.service_catalog_provisioning_details,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrainingJobInputBody<'a> {
    /// <p>The name of the training job. The name must be unique within an AWS Region in an
    /// AWS account. </p>
    pub training_job_name: &'a std::option::Option<std::string::String>,
    /// <p>Algorithm-specific parameters that influence the quality of the model. You set
    /// hyperparameters before you start the learning process. For a list of hyperparameters for
    /// each training algorithm provided by Amazon SageMaker, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. </p>
    /// <p>You can specify a maximum of 100 hyperparameters. Each hyperparameter is a
    /// key-value pair. Each key and value is limited to 256 characters, as specified by the
    /// <code>Length Constraint</code>. </p>
    pub hyper_parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>The registry path of the Docker image that contains the training algorithm and
    /// algorithm-specific metadata, including the input mode. For more information about
    /// algorithms provided by Amazon SageMaker, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. For information about
    /// providing your own algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
    /// SageMaker</a>. </p>
    pub algorithm_specification: &'a std::option::Option<crate::model::AlgorithmSpecification>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform
    /// tasks on your behalf. </p>
    /// <p>During model training, Amazon SageMaker needs your permission to read input data from an S3
    /// bucket, download a Docker image that contains training code, write model artifacts to an
    /// S3 bucket, write logs to Amazon CloudWatch Logs, and publish metrics to Amazon CloudWatch. You grant
    /// permissions for all of these tasks to an IAM role. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-roles.html">Amazon SageMaker
    /// Roles</a>. </p>
    /// <note>
    /// <p>To be able to pass this role to Amazon SageMaker, the caller of this API must have the
    /// <code>iam:PassRole</code> permission.</p>
    /// </note>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>An array of <code>Channel</code> objects. Each channel is a named input source.
    /// <code>InputDataConfig</code>
    /// describes the input data and its location. </p>
    /// <p>Algorithms can accept input data from one or more channels. For example, an
    /// algorithm might have two channels of input data, <code>training_data</code> and
    /// <code>validation_data</code>. The configuration for each channel provides the S3,
    /// EFS, or FSx location where the input data is stored. It also provides information about
    /// the stored data: the MIME type, compression method, and whether the data is wrapped in
    /// RecordIO format. </p>
    /// <p>Depending on the input mode that the algorithm supports, Amazon SageMaker either copies input
    /// data files from an S3 bucket to a local directory in the Docker container, or makes it
    /// available as input streams. For example, if you specify an EFS location, input data
    /// files will be made available as input streams. They do not need to be
    /// downloaded.</p>
    pub input_data_config: &'a std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>Specifies the path to the S3 location where you want to store model artifacts. Amazon SageMaker
    /// creates subfolders for the artifacts. </p>
    pub output_data_config: &'a std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The resources, including the ML compute instances and ML storage volumes, to use
    /// for model training. </p>
    /// <p>ML storage volumes store model artifacts and incremental states. Training
    /// algorithms might also use ML storage volumes for scratch space. If you want Amazon SageMaker to use
    /// the ML storage volume to store the training data, choose <code>File</code> as the
    /// <code>TrainingInputMode</code> in the algorithm specification. For distributed
    /// training algorithms, specify an instance count greater than 1.</p>
    pub resource_config: &'a std::option::Option<crate::model::ResourceConfig>,
    /// <p>A <a>VpcConfig</a> object that specifies the VPC that you want your
    /// training job to connect to. Control access to and from your training container by
    /// configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon
    /// Virtual Private Cloud</a>.</p>
    pub vpc_config: &'a std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
    /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
    /// ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, Amazon SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays
    /// job termination for 120 seconds. Algorithms can use this 120-second window to save the
    /// model artifacts, so the results of training are not lost. </p>
    pub stopping_condition: &'a std::option::Option<crate::model::StoppingCondition>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Isolates the training container. No inbound or outbound network calls can be made,
    /// except for calls between peers within a training cluster for distributed training. If
    /// you enable network isolation for training jobs that are configured to use a VPC, Amazon SageMaker
    /// downloads and uploads customer data and model artifacts through the specified VPC, but
    /// the training container does not have network access.</p>
    pub enable_network_isolation: &'a bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training,
    /// choose <code>True</code>. Encryption provides greater security for distributed training,
    /// but training might take longer. How long it takes depends on the amount of communication
    /// between compute instances, especially if you use a deep learning algorithm in
    /// distributed training. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-encrypt.html">Protect Communications Between ML
    /// Compute Instances in a Distributed Training Job</a>.</p>
    pub enable_inter_container_traffic_encryption: &'a bool,
    /// <p>To train models using managed spot training, choose <code>True</code>. Managed spot
    /// training provides a fully managed and scalable infrastructure for training machine
    /// learning models. this option is useful when training jobs can be interrupted and when
    /// there is flexibility when the training job is run. </p>
    /// <p>The complete and intermediate results of jobs are stored in an Amazon S3 bucket, and can be
    /// used as a starting point to train models incrementally. Amazon SageMaker provides metrics and
    /// logs in CloudWatch. They can be used to see when managed spot training jobs are running,
    /// interrupted, resumed, or completed. </p>
    pub enable_managed_spot_training: &'a bool,
    /// <p>Contains information about the output location for managed spot training checkpoint
    /// data.</p>
    pub checkpoint_config: &'a std::option::Option<crate::model::CheckpointConfig>,
    /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and
    /// storage paths. To learn more about
    /// how to configure the <code>DebugHookConfig</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
    pub debug_hook_config: &'a std::option::Option<crate::model::DebugHookConfig>,
    /// <p>Configuration information for Debugger rules for debugging output tensors.</p>
    pub debug_rule_configurations:
        &'a std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
    /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
    pub tensor_board_output_config: &'a std::option::Option<crate::model::TensorBoardOutputConfig>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: &'a std::option::Option<crate::model::ExperimentConfig>,
    /// <p>Configuration information for Debugger system monitoring, framework profiling, and
    /// storage paths.</p>
    pub profiler_config: &'a std::option::Option<crate::model::ProfilerConfig>,
    /// <p>Configuration information for Debugger rules for profiling system and framework
    /// metrics.</p>
    pub profiler_rule_configurations:
        &'a std::option::Option<std::vec::Vec<crate::model::ProfilerRuleConfiguration>>,
    /// <p>The environment variables to set in the Docker container.</p>
    pub environment: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>The number of times to retry the job when the job fails due to an
    /// <code>InternalServerError</code>.</p>
    pub retry_strategy: &'a std::option::Option<crate::model::RetryStrategy>,
}
impl<'a> std::fmt::Debug for CreateTrainingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrainingJobInputBody");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("tags", &self.tags);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("debug_hook_config", &self.debug_hook_config);
        formatter.field("debug_rule_configurations", &self.debug_rule_configurations);
        formatter.field(
            "tensor_board_output_config",
            &self.tensor_board_output_config,
        );
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("profiler_config", &self.profiler_config);
        formatter.field(
            "profiler_rule_configurations",
            &self.profiler_rule_configurations,
        );
        formatter.field("environment", &self.environment);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTransformJobInputBody<'a> {
    /// <p>The name of the transform job. The name must be unique within an AWS Region in an
    /// AWS account. </p>
    pub transform_job_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the model that you want to use for the transform job.
    /// <code>ModelName</code> must be the name of an existing Amazon SageMaker model within an AWS
    /// Region in an AWS account.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of parallel requests that can be sent to each instance in a
    /// transform job. If <code>MaxConcurrentTransforms</code> is set to <code>0</code> or left
    /// unset, Amazon SageMaker checks the optional execution-parameters to determine the settings for your
    /// chosen algorithm. If the execution-parameters endpoint is not enabled, the default value
    /// is <code>1</code>. For more information on execution-parameters, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-batch-code.html#your-algorithms-batch-code-how-containe-serves-requests">How Containers Serve Requests</a>. For built-in algorithms, you don't need to
    /// set a value for <code>MaxConcurrentTransforms</code>.</p>
    pub max_concurrent_transforms: &'a std::option::Option<i32>,
    /// <p>Configures the timeout and maximum number of retries for processing a transform job
    /// invocation.</p>
    pub model_client_config: &'a std::option::Option<crate::model::ModelClientConfig>,
    /// <p>The maximum allowed size of the payload, in MB. A <i>payload</i> is the
    /// data portion of a record (without metadata). The value in <code>MaxPayloadInMB</code>
    /// must be greater than, or equal to, the size of a single record. To estimate the size of
    /// a record in MB, divide the size of your dataset by the number of records. To ensure that
    /// the records fit within the maximum payload size, we recommend using a slightly larger
    /// value. The default value is <code>6</code> MB.
    /// </p>
    /// <p>For cases where the payload might be arbitrarily large and is transmitted using HTTP
    /// chunked encoding, set the value to <code>0</code>.
    /// This
    /// feature works only in supported algorithms. Currently, Amazon SageMaker built-in
    /// algorithms do not support HTTP chunked encoding.</p>
    pub max_payload_in_mb: &'a std::option::Option<i32>,
    /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference
    /// request. A <i>record</i>
    /// <i></i> is a single unit of input data that
    /// inference can be made on. For example, a single line in a CSV file is a record. </p>
    /// <p>To enable the batch strategy, you must set the <code>SplitType</code> property to
    /// <code>Line</code>, <code>RecordIO</code>, or <code>TFRecord</code>.</p>
    /// <p>To use only one record when making an HTTP invocation request to a container, set
    /// <code>BatchStrategy</code> to <code>SingleRecord</code> and <code>SplitType</code>
    /// to <code>Line</code>.</p>
    /// <p>To fit as many records in a mini-batch as can fit within the
    /// <code>MaxPayloadInMB</code> limit, set <code>BatchStrategy</code> to
    /// <code>MultiRecord</code> and <code>SplitType</code> to <code>Line</code>.</p>
    pub batch_strategy: &'a std::option::Option<crate::model::BatchStrategy>,
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and
    /// values entries in the map.</p>
    pub environment: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>Describes the input source and
    /// the
    /// way the transform job consumes it.</p>
    pub transform_input: &'a std::option::Option<crate::model::TransformInput>,
    /// <p>Describes the results of the transform job.</p>
    pub transform_output: &'a std::option::Option<crate::model::TransformOutput>,
    /// <p>Describes the resources, including
    /// ML
    /// instance types and ML instance count, to use for the transform
    /// job.</p>
    pub transform_resources: &'a std::option::Option<crate::model::TransformResources>,
    /// <p>The data structure used to specify the data to be used for inference in a batch
    /// transform job and to associate the data that is relevant to the prediction results in
    /// the output. The input filter provided allows you to exclude input data that is not
    /// needed for inference in a batch transform job. The output filter provided allows you to
    /// include input data relevant to interpreting the predictions in the output from the job.
    /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction
    /// Results with their Corresponding Input Records</a>.</p>
    pub data_processing: &'a std::option::Option<crate::model::DataProcessing>,
    /// <p>(Optional)
    /// An
    /// array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-what">Using
    /// Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management User
    /// Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: &'a std::option::Option<crate::model::ExperimentConfig>,
}
impl<'a> std::fmt::Debug for CreateTransformJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTransformJobInputBody");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("model_client_config", &self.model_client_config);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.field("data_processing", &self.data_processing);
        formatter.field("tags", &self.tags);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrialInputBody<'a> {
    /// <p>The name of the trial. The name must be unique in your AWS account and is not
    /// case-sensitive.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. The name doesn't need to be unique. If
    /// <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the experiment to associate the trial with.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: &'a std::option::Option<crate::model::MetadataProperties>,
    /// <p>A list of tags to associate with the trial. You can use <a>Search</a> API to
    /// search on the tags.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateTrialInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrialInputBody");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrialComponentInputBody<'a> {
    /// <p>The name of the component. The name must be unique in your AWS account and is not
    /// case-sensitive.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. The name doesn't need to be unique. If
    /// <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is
    /// displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The status of the component. States include:</p>
    /// <ul>
    /// <li>
    /// <p>InProgress</p>
    /// </li>
    /// <li>
    /// <p>Completed</p>
    /// </li>
    /// <li>
    /// <p>Failed</p>
    /// </li>
    /// </ul>
    pub status: &'a std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>When the component ended.</p>
    pub end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The hyperparameters for the component.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    >,
    /// <p>The input artifacts for the component. Examples of input artifacts are datasets,
    /// algorithms, hyperparameters, source code, and instance types.</p>
    pub input_artifacts: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The output artifacts for the component. Examples of output artifacts are metrics,
    /// snapshots, logs, and images.</p>
    pub output_artifacts: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: &'a std::option::Option<crate::model::MetadataProperties>,
    /// <p>A list of tags to associate with the component. You can use <a>Search</a> API
    /// to search on the tags.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("parameters", &self.parameters);
        formatter.field("input_artifacts", &self.input_artifacts);
        formatter.field("output_artifacts", &self.output_artifacts);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateUserProfileInputBody<'a> {
    /// <p>The ID of the associated Domain.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>A name for the UserProfile. This value is not case sensitive.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>A specifier for the type of value specified in SingleSignOnUserValue.  Currently, the only supported value is "UserName".
    /// If the Domain's AuthMode is SSO, this field is required.  If the Domain's AuthMode is not SSO, this field cannot be specified.
    /// </p>
    pub single_sign_on_user_identifier: &'a std::option::Option<std::string::String>,
    /// <p>The username of the associated AWS Single Sign-On User for this UserProfile.  If the Domain's AuthMode is SSO, this field is
    /// required, and must match a valid username of a user in your directory.  If the Domain's AuthMode is not SSO, this field cannot be specified.
    /// </p>
    pub single_sign_on_user_value: &'a std::option::Option<std::string::String>,
    /// <p>Each tag consists of a key and an optional value.
    /// Tag keys must be unique per resource.</p>
    /// <p>Tags that you specify for the User Profile are also added to all Apps that the
    /// User Profile launches.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A collection of settings.</p>
    pub user_settings: &'a std::option::Option<crate::model::UserSettings>,
}
impl<'a> std::fmt::Debug for CreateUserProfileInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateUserProfileInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field(
            "single_sign_on_user_identifier",
            &self.single_sign_on_user_identifier,
        );
        formatter.field("single_sign_on_user_value", &self.single_sign_on_user_value);
        formatter.field("tags", &self.tags);
        formatter.field("user_settings", &self.user_settings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkforceInputBody<'a> {
    /// <p>Use this parameter to configure an Amazon Cognito private workforce.
    /// A single Cognito workforce is created using and corresponds to a single
    /// <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
    /// Amazon Cognito user pool</a>.</p>
    /// <p>Do not use <code>OidcConfig</code> if you specify values for
    /// <code>CognitoConfig</code>.</p>
    pub cognito_config: &'a std::option::Option<crate::model::CognitoConfig>,
    /// <p>Use this parameter to configure a private workforce using your own OIDC Identity Provider.</p>
    /// <p>Do not use <code>CognitoConfig</code> if you specify values for
    /// <code>OidcConfig</code>.</p>
    pub oidc_config: &'a std::option::Option<crate::model::OidcConfig>,
    /// <p>A list of IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>). Used to create an allow
    /// list of IP addresses for a private workforce. Workers will only be able to login to their worker portal from an
    /// IP address within this range. By default, a workforce isn't restricted to specific IP addresses.</p>
    pub source_ip_config: &'a std::option::Option<crate::model::SourceIpConfig>,
    /// <p>The name of the private workforce.</p>
    pub workforce_name: &'a std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs that contain metadata to help you categorize and
    /// organize our workforce. Each tag consists of a key and a value,
    /// both of which you define.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateWorkforceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkforceInputBody");
        formatter.field("cognito_config", &self.cognito_config);
        formatter.field("oidc_config", &self.oidc_config);
        formatter.field("source_ip_config", &self.source_ip_config);
        formatter.field("workforce_name", &self.workforce_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkteamInputBody<'a> {
    /// <p>The name of the work team. Use this name to identify the work team.</p>
    pub workteam_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the workforce.</p>
    pub workforce_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify
    /// the workers that make up the work team. </p>
    /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For
    /// private workforces created using Amazon Cognito use <code>CognitoMemberDefinition</code>. For
    /// workforces created using your own OIDC identity provider (IdP) use
    /// <code>OidcMemberDefinition</code>. Do not provide input for both of these parameters
    /// in a single request.</p>
    /// <p>For workforces created using Amazon Cognito, private work teams correspond to Amazon Cognito
    /// <i>user groups</i> within the user pool used to create a workforce. All of the
    /// <code>CognitoMemberDefinition</code> objects that make up the member definition must
    /// have the same <code>ClientId</code> and <code>UserPool</code> values. To add a Amazon
    /// Cognito user group to an existing worker pool, see <a href="">Adding groups to a User
    /// Pool</a>. For more information about user pools, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">Amazon Cognito User
    /// Pools</a>.</p>
    /// <p>For workforces created using your own OIDC IdP, specify the user groups that you want to
    /// include in your private work team in <code>OidcMemberDefinition</code> by listing those groups
    /// in <code>Groups</code>.</p>
    pub member_definitions: &'a std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
    /// <p>A description of the work team.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Configures notification of workers regarding available or expiring work items.</p>
    pub notification_configuration:
        &'a std::option::Option<crate::model::NotificationConfiguration>,
    /// <p>An array of key-value pairs.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html">Resource
    /// Tag</a> and <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-what">Using
    /// Cost Allocation Tags</a> in the <i> AWS Billing and Cost Management User
    /// Guide</i>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkteamInputBody");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.field("workforce_name", &self.workforce_name);
        formatter.field("member_definitions", &self.member_definitions);
        formatter.field("description", &self.description);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteActionInputBody<'a> {
    /// <p>The name of the action to delete.</p>
    pub action_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteActionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteActionInputBody");
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAlgorithmInputBody<'a> {
    /// <p>The name of the algorithm to delete.</p>
    pub algorithm_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteAlgorithmInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAlgorithmInputBody");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of app.</p>
    pub app_type: &'a std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    pub app_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteAppInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppImageConfigInputBody<'a> {
    /// <p>The name of the AppImageConfig to delete.</p>
    pub app_image_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteAppImageConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppImageConfigInputBody");
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteArtifactInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the artifact to delete.</p>
    pub artifact_arn: &'a std::option::Option<std::string::String>,
    /// <p>The URI of the source.</p>
    pub source: &'a std::option::Option<crate::model::ArtifactSource>,
}
impl<'a> std::fmt::Debug for DeleteArtifactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteArtifactInputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.field("source", &self.source);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAssociationInputBody<'a> {
    /// <p>The ARN of the source.</p>
    pub source_arn: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub destination_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAssociationInputBody");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCodeRepositoryInputBody<'a> {
    /// <p>The name of the Git repository to delete.</p>
    pub code_repository_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteCodeRepositoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCodeRepositoryInputBody");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteContextInputBody<'a> {
    /// <p>The name of the context to delete.</p>
    pub context_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteContextInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteContextInputBody");
        formatter.field("context_name", &self.context_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDataQualityJobDefinitionInputBody<'a> {
    /// <p>The name of the data quality monitoring job definition to delete.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteDataQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDataQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDeviceFleetInputBody<'a> {
    /// <p>The name of the fleet to delete.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteDeviceFleetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDeviceFleetInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDomainInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The retention policy for this domain, which specifies whether resources will be retained after the Domain is deleted.
    /// By default, all resources are retained (not automatically deleted).
    /// </p>
    pub retention_policy: &'a std::option::Option<crate::model::RetentionPolicy>,
}
impl<'a> std::fmt::Debug for DeleteDomainInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDomainInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("retention_policy", &self.retention_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEndpointInputBody<'a> {
    /// <p>The name of the endpoint that you want to delete.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEndpointInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEndpointConfigInputBody<'a> {
    /// <p>The name of the endpoint configuration that you want to delete.</p>
    pub endpoint_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteEndpointConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEndpointConfigInputBody");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteExperimentInputBody<'a> {
    /// <p>The name of the experiment to delete.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteExperimentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteExperimentInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFeatureGroupInputBody<'a> {
    /// <p>The name of the <code>FeatureGroup</code> you want to delete. The name must be unique
    /// within an AWS Region in an AWS account. </p>
    pub feature_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteFeatureGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFeatureGroupInputBody");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFlowDefinitionInputBody<'a> {
    /// <p>The name of the flow definition you are deleting.</p>
    pub flow_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteFlowDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFlowDefinitionInputBody");
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteHumanTaskUiInputBody<'a> {
    /// <p>The name of the human task user interface (work task template) you want to delete.</p>
    pub human_task_ui_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteHumanTaskUiInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteHumanTaskUiInputBody");
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteImageInputBody<'a> {
    /// <p>The name of the image to delete.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteImageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteImageInputBody");
        formatter.field("image_name", &self.image_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteImageVersionInputBody<'a> {
    /// <p>The name of the image.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
    /// <p>The version to delete.</p>
    pub version: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DeleteImageVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteImageVersionInputBody");
        formatter.field("image_name", &self.image_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelInputBody<'a> {
    /// <p>The name of the model to delete.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelInputBody");
        formatter.field("model_name", &self.model_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelBiasJobDefinitionInputBody<'a> {
    /// <p>The name of the model bias job definition to delete.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelBiasJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelBiasJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelExplainabilityJobDefinitionInputBody<'a> {
    /// <p>The name of the model explainability job definition to delete.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelExplainabilityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelExplainabilityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelPackageInputBody<'a> {
    /// <p>The name or Amazon Resource Name (ARN) of the model package to delete.</p>
    /// <p>When you specify a name, the name must have 1 to 63 characters. Valid
    /// characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub model_package_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelPackageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelPackageInputBody");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelPackageGroupInputBody<'a> {
    /// <p>The name of the model group to delete.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelPackageGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelPackageGroupInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelPackageGroupPolicyInputBody<'a> {
    /// <p>The name of the model group for which to delete the policy.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelPackageGroupPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelPackageGroupPolicyInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteModelQualityJobDefinitionInputBody<'a> {
    /// <p>The name of the model quality monitoring job definition to delete.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteModelQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteModelQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMonitoringScheduleInputBody<'a> {
    /// <p>The name of the monitoring schedule to delete.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteNotebookInstanceInputBody<'a> {
    /// <p>The name of the Amazon SageMaker notebook instance to delete.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteNotebookInstanceLifecycleConfigInputBody<'a> {
    /// <p>The name of the lifecycle configuration to delete.</p>
    pub notebook_instance_lifecycle_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteNotebookInstanceLifecycleConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteNotebookInstanceLifecycleConfigInputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePipelineInputBody<'a> {
    /// <p>The name of the pipeline to delete.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeletePipelineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePipelineInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProjectInputBody<'a> {
    /// <p>The name of the project to delete.</p>
    pub project_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteProjectInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProjectInputBody");
        formatter.field("project_name", &self.project_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTagsInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to
    /// delete.</p>
    pub resource_arn: &'a std::option::Option<std::string::String>,
    /// <p>An array or one or more tag keys to delete.</p>
    pub tag_keys: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for DeleteTagsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTagsInputBody");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTrialInputBody<'a> {
    /// <p>The name of the trial to delete.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteTrialInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTrialInputBody");
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTrialComponentInputBody<'a> {
    /// <p>The name of the component to delete.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteUserProfileInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteUserProfileInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteUserProfileInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkforceInputBody<'a> {
    /// <p>The name of the workforce.</p>
    pub workforce_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteWorkforceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkforceInputBody");
        formatter.field("workforce_name", &self.workforce_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkteamInputBody<'a> {
    /// <p>The name of the work team to delete.</p>
    pub workteam_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkteamInputBody");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterDevicesInputBody<'a> {
    /// <p>The name of the fleet the devices belong to.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
    /// <p>The unique IDs of the devices.</p>
    pub device_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for DeregisterDevicesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterDevicesInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("device_names", &self.device_names);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActionInputBody<'a> {
    /// <p>The name of the action to describe.</p>
    pub action_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeActionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActionInputBody");
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAlgorithmInputBody<'a> {
    /// <p>The name of the algorithm to describe.</p>
    pub algorithm_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAlgorithmInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAlgorithmInputBody");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of app.</p>
    pub app_type: &'a std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    pub app_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAppInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppImageConfigInputBody<'a> {
    /// <p>The name of the AppImageConfig to describe.</p>
    pub app_image_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAppImageConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppImageConfigInputBody");
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeArtifactInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the artifact to describe.</p>
    pub artifact_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeArtifactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeArtifactInputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutoMLJobInputBody<'a> {
    /// <p>Requests information about an AutoML job using its unique name.</p>
    pub auto_ml_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAutoMLJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutoMLJobInputBody");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCodeRepositoryInputBody<'a> {
    /// <p>The name of the Git repository to describe.</p>
    pub code_repository_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeCodeRepositoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCodeRepositoryInputBody");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCompilationJobInputBody<'a> {
    /// <p>The name of the model compilation job that you want information about.</p>
    pub compilation_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeCompilationJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCompilationJobInputBody");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeContextInputBody<'a> {
    /// <p>The name of the context to describe.</p>
    pub context_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeContextInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeContextInputBody");
        formatter.field("context_name", &self.context_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDataQualityJobDefinitionInputBody<'a> {
    /// <p>The name of the data quality monitoring job definition to describe.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDataQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDataQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDeviceInputBody<'a> {
    /// <p>Next token of device description.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The unique ID of the device.</p>
    pub device_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the fleet the devices belong to.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDeviceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDeviceInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("device_name", &self.device_name);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDeviceFleetInputBody<'a> {
    /// <p>The name of the fleet.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDeviceFleetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDeviceFleetInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDomainInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDomainInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDomainInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEdgePackagingJobInputBody<'a> {
    /// <p>The name of the edge packaging job.</p>
    pub edge_packaging_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeEdgePackagingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEdgePackagingJobInputBody");
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointInputBody<'a> {
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointConfigInputBody<'a> {
    /// <p>The name of the endpoint configuration.</p>
    pub endpoint_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeEndpointConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointConfigInputBody");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeExperimentInputBody<'a> {
    /// <p>The name of the experiment to describe.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeExperimentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeExperimentInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFeatureGroupInputBody<'a> {
    /// <p>The name of the <code>FeatureGroup</code> you want described. </p>
    pub feature_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A token to resume pagination of the list of <code>Features</code>
    /// (<code>FeatureDefinitions</code>). 2,500 <code>Features</code> are returned by
    /// default.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeFeatureGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFeatureGroupInputBody");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFlowDefinitionInputBody<'a> {
    /// <p>The name of the flow definition.</p>
    pub flow_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeFlowDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFlowDefinitionInputBody");
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeHumanTaskUiInputBody<'a> {
    /// <p>The name of the human task user interface
    /// (worker task template) you want information about.</p>
    pub human_task_ui_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeHumanTaskUiInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeHumanTaskUiInputBody");
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeHyperParameterTuningJobInputBody<'a> {
    /// <p>The name of the tuning job.</p>
    pub hyper_parameter_tuning_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeHyperParameterTuningJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeHyperParameterTuningJobInputBody");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeImageInputBody<'a> {
    /// <p>The name of the image to describe.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeImageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeImageInputBody");
        formatter.field("image_name", &self.image_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeImageVersionInputBody<'a> {
    /// <p>The name of the image.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the image. If not specified, the latest version is described.</p>
    pub version: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeImageVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeImageVersionInputBody");
        formatter.field("image_name", &self.image_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLabelingJobInputBody<'a> {
    /// <p>The name of the labeling job to return information for.</p>
    pub labeling_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeLabelingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLabelingJobInputBody");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelInputBody<'a> {
    /// <p>The name of the model.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelInputBody");
        formatter.field("model_name", &self.model_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelBiasJobDefinitionInputBody<'a> {
    /// <p>The name of the model bias job definition. The name must be unique within an AWS Region
    /// in the AWS account.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelBiasJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelBiasJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelExplainabilityJobDefinitionInputBody<'a> {
    /// <p>The name of the model explainability job definition. The name must be unique within an
    /// AWS Region in the AWS account.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelExplainabilityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelExplainabilityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelPackageInputBody<'a> {
    /// <p>The name or Amazon Resource Name (ARN) of the model package to describe.</p>
    /// <p>When you specify a name, the name must have 1 to 63 characters. Valid
    /// characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub model_package_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelPackageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelPackageInputBody");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelPackageGroupInputBody<'a> {
    /// <p>The name of the model group to describe.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelPackageGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelPackageGroupInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelQualityJobDefinitionInputBody<'a> {
    /// <p>The name of the model quality job. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeModelQualityJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelQualityJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMonitoringScheduleInputBody<'a> {
    /// <p>Name of a previously created monitoring schedule.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeNotebookInstanceInputBody<'a> {
    /// <p>The name of the notebook instance that you want information about.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeNotebookInstanceLifecycleConfigInputBody<'a> {
    /// <p>The name of the lifecycle configuration to describe.</p>
    pub notebook_instance_lifecycle_config_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeNotebookInstanceLifecycleConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotebookInstanceLifecycleConfigInputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineInputBody<'a> {
    /// <p>The name of the pipeline to describe.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePipelineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineDefinitionForExecutionInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePipelineDefinitionForExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineDefinitionForExecutionInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineExecutionInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePipelineExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineExecutionInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProcessingJobInputBody<'a> {
    /// <p>The name of the processing job. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    pub processing_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeProcessingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProcessingJobInputBody");
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProjectInputBody<'a> {
    /// <p>The name of the project to describe.</p>
    pub project_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeProjectInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProjectInputBody");
        formatter.field("project_name", &self.project_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscribedWorkteamInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the subscribed work team to describe.</p>
    pub workteam_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeSubscribedWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscribedWorkteamInputBody");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrainingJobInputBody<'a> {
    /// <p>The name of the training job.</p>
    pub training_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeTrainingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrainingJobInputBody");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTransformJobInputBody<'a> {
    /// <p>The name of the transform job that you want to view details of.</p>
    pub transform_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeTransformJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTransformJobInputBody");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrialInputBody<'a> {
    /// <p>The name of the trial to describe.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeTrialInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrialInputBody");
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrialComponentInputBody<'a> {
    /// <p>The name of the trial component to describe.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeUserProfileInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name. This value is not case sensitive.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeUserProfileInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeUserProfileInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkforceInputBody<'a> {
    /// <p>The name of the private workforce whose access you want to restrict.
    /// <code>WorkforceName</code> is automatically set to <code>default</code> when a
    /// workforce is created and cannot be modified. </p>
    pub workforce_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeWorkforceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkforceInputBody");
        formatter.field("workforce_name", &self.workforce_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkteamInputBody<'a> {
    /// <p>The name of the work team to return a description of.</p>
    pub workteam_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkteamInputBody");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateTrialComponentInputBody<'a> {
    /// <p>The name of the component to disassociate from the trial.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the trial to disassociate from.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DisassociateTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeviceFleetReportInputBody<'a> {
    /// <p>The name of the fleet.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetDeviceFleetReportInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeviceFleetReportInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetModelPackageGroupPolicyInputBody<'a> {
    /// <p>The name of the model group for which to get the resource policy.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetModelPackageGroupPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetModelPackageGroupPolicyInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSearchSuggestionsInputBody<'a> {
    /// <p>The name of the Amazon SageMaker resource to search for.</p>
    pub resource: &'a std::option::Option<crate::model::ResourceType>,
    /// <p>Limits the property names that are included in the response.</p>
    pub suggestion_query: &'a std::option::Option<crate::model::SuggestionQuery>,
}
impl<'a> std::fmt::Debug for GetSearchSuggestionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSearchSuggestionsInputBody");
        formatter.field("resource", &self.resource);
        formatter.field("suggestion_query", &self.suggestion_query);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListActionsInputBody<'a> {
    /// <p>A filter that returns only actions with the specified source URI.</p>
    pub source_uri: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only actions of the specified type.</p>
    pub action_type: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only actions created on or after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only actions created on or before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortActionsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the previous call to <code>ListActions</code> didn't return the full set of actions,
    /// the call returns a token for getting the next set of actions.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of actions to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListActionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListActionsInputBody");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("action_type", &self.action_type);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAlgorithmsInputBody<'a> {
    /// <p>A filter that returns only algorithms created after the specified time
    /// (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only algorithms created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of algorithms to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the algorithm name. This filter returns only algorithms whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the response to a previous <code>ListAlgorithms</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To retrieve the next set of algorithms, use
    /// the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The parameter by which to sort the results. The default is
    /// <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::AlgorithmSortBy>,
    /// <p>The sort order for the results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListAlgorithmsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAlgorithmsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppImageConfigsInputBody<'a> {
    /// <p>The maximum number of AppImageConfigs to return in the response. The default value is
    /// 10. </p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous call to <code>ListImages</code> didn't return the full set of
    /// AppImageConfigs, the call returns a token for getting the next set of AppImageConfigs.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only AppImageConfigs whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only AppImageConfigs created on or before the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only AppImageConfigs created on or after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only AppImageConfigs modified on or before the specified time.</p>
    pub modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only AppImageConfigs modified on or after the specified time.</p>
    pub modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::AppImageConfigSortKey>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListAppImageConfigsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppImageConfigsInputBody");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("modified_time_before", &self.modified_time_before);
        formatter.field("modified_time_after", &self.modified_time_after);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppsInputBody<'a> {
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Returns a list up to a specified limit.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The sort order for the results. The default is Ascending.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The parameter by which to sort the results. The default is CreationTime.</p>
    pub sort_by: &'a std::option::Option<crate::model::AppSortKey>,
    /// <p>A parameter to search for the domain ID.</p>
    pub domain_id_equals: &'a std::option::Option<std::string::String>,
    /// <p>A parameter to search by user profile name.</p>
    pub user_profile_name_equals: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListAppsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("domain_id_equals", &self.domain_id_equals);
        formatter.field("user_profile_name_equals", &self.user_profile_name_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListArtifactsInputBody<'a> {
    /// <p>A filter that returns only artifacts with the specified source URI.</p>
    pub source_uri: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only artifacts of the specified type.</p>
    pub artifact_type: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only artifacts created on or after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only artifacts created on or before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortArtifactsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the previous call to <code>ListArtifacts</code> didn't return the full set of artifacts,
    /// the call returns a token for getting the next set of artifacts.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of artifacts to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListArtifactsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListArtifactsInputBody");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationsInputBody<'a> {
    /// <p>A filter that returns only associations with the specified source ARN.</p>
    pub source_arn: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only associations with the specified destination Amazon Resource Name (ARN).</p>
    pub destination_arn: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only associations with the specified source type.</p>
    pub source_type: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only associations with the specified destination type.</p>
    pub destination_type: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only associations of the specified type.</p>
    pub association_type: &'a std::option::Option<crate::model::AssociationEdgeType>,
    /// <p>A filter that returns only associations created on or after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only associations created on or before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortAssociationsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the previous call to <code>ListAssociations</code> didn't return the full set of associations,
    /// the call returns a token for getting the next set of associations.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of associations to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListAssociationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationsInputBody");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("source_type", &self.source_type);
        formatter.field("destination_type", &self.destination_type);
        formatter.field("association_type", &self.association_type);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAutoMLJobsInputBody<'a> {
    /// <p>Request a list of jobs, using a filter for time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Request a list of jobs, using a filter for time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Request a list of jobs, using a filter for time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Request a list of jobs, using a filter for time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Request a list of jobs, using a search filter for name.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>Request a list of jobs, using a filter for status.</p>
    pub status_equals: &'a std::option::Option<crate::model::AutoMlJobStatus>,
    /// <p>The sort order for the results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::AutoMlSortOrder>,
    /// <p>The parameter by which to sort the results. The default is <code>Name</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::AutoMlSortBy>,
    /// <p>Request a list of jobs up to a specified limit.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous response was truncated, you receive this token. Use it in your next
    /// request to receive the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListAutoMLJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAutoMLJobsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCandidatesForAutoMLJobInputBody<'a> {
    /// <p>List the candidates created for the job by providing the job's name.</p>
    pub auto_ml_job_name: &'a std::option::Option<std::string::String>,
    /// <p>List the candidates for the job and filter by status.</p>
    pub status_equals: &'a std::option::Option<crate::model::CandidateStatus>,
    /// <p>List the candidates for the job and filter by candidate name.</p>
    pub candidate_name_equals: &'a std::option::Option<std::string::String>,
    /// <p>The sort order for the results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::AutoMlSortOrder>,
    /// <p>The parameter by which to sort the results. The default is
    /// <code>Descending</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::CandidateSortBy>,
    /// <p>List the job's candidates up to a specified limit.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous response was truncated, you receive this token. Use it in your next
    /// request to receive the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListCandidatesForAutoMLJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCandidatesForAutoMLJobInputBody");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("candidate_name_equals", &self.candidate_name_equals);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCodeRepositoriesInputBody<'a> {
    /// <p>A filter that returns only Git repositories that were created after the specified
    /// time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only Git repositories that were created before the specified
    /// time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only Git repositories that were last modified after the
    /// specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only Git repositories that were last modified before the
    /// specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of Git repositories to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the Git repositories name. This filter returns only repositories whose
    /// name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the result of a <code>ListCodeRepositoriesOutput</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To get the next set of Git repositories, use
    /// the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>Name</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::CodeRepositorySortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::CodeRepositorySortOrder>,
}
impl<'a> std::fmt::Debug for ListCodeRepositoriesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCodeRepositoriesInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCompilationJobsInputBody<'a> {
    /// <p>If the result of the previous <code>ListCompilationJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of model
    /// compilation jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of model compilation jobs to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A filter that returns the model compilation jobs that were created after a specified
    /// time. </p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the model compilation jobs that were created before a specified
    /// time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the model compilation jobs that were modified after a specified
    /// time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the model compilation jobs that were modified before a specified
    /// time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the model compilation jobs whose name contains a specified
    /// string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that retrieves model compilation jobs with a specific <a>DescribeCompilationJobResponse$CompilationJobStatus</a> status.</p>
    pub status_equals: &'a std::option::Option<crate::model::CompilationJobStatus>,
    /// <p>The field by which to sort results. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListCompilationJobsSortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListCompilationJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCompilationJobsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListContextsInputBody<'a> {
    /// <p>A filter that returns only contexts with the specified source URI.</p>
    pub source_uri: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only contexts of the specified type.</p>
    pub context_type: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only contexts created on or after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only contexts created on or before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortContextsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the previous call to <code>ListContexts</code> didn't return the full set of contexts,
    /// the call returns a token for getting the next set of contexts.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of contexts to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListContextsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListContextsInputBody");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("context_type", &self.context_type);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDataQualityJobDefinitionsInputBody<'a> {
    /// <p>A filter that lists the data quality job definitions associated with the specified
    /// endpoint.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringJobDefinitionSortKey>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListDataQualityJobDefinitions</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// transform jobs, use the token in the next request.></p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of data quality monitoring job definitions to return in the
    /// response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the data quality monitoring job definition name. This filter returns only
    /// data quality monitoring job definitions whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only data quality monitoring job definitions created before the
    /// specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only data quality monitoring job definitions created after the
    /// specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListDataQualityJobDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDataQualityJobDefinitionsInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDeviceFleetsInputBody<'a> {
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of results to select.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Filter fleets where packaging job was created after specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Filter fleets where the edge packaging job was created before specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Select fleets where the job was updated after X</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Select fleets where the job was updated before X</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Filter for fleets containing this name in their fleet device name.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>The column to sort by.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListDeviceFleetsSortBy>,
    /// <p>What direction to sort in.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListDeviceFleetsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDeviceFleetsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDevicesInputBody<'a> {
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Maximum number of results to select.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Select fleets where the job was updated after X</p>
    pub latest_heartbeat_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that searches devices that contains this name in any of their models.</p>
    pub model_name: &'a std::option::Option<std::string::String>,
    /// <p>Filter for fleets containing this name in their device fleet name.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListDevicesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDevicesInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("latest_heartbeat_after", &self.latest_heartbeat_after);
        formatter.field("model_name", &self.model_name);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainsInputBody<'a> {
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Returns a list up to a specified limit.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListDomainsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEdgePackagingJobsInputBody<'a> {
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Maximum number of results to select.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Select jobs where the job was created after specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Select jobs where the job was created before specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Select jobs where the job was updated after specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Select jobs where the job was updated before specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Filter for jobs containing this name in their packaging job name.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>Filter for jobs where the model name contains this string.</p>
    pub model_name_contains: &'a std::option::Option<std::string::String>,
    /// <p>The job status to filter for.</p>
    pub status_equals: &'a std::option::Option<crate::model::EdgePackagingJobStatus>,
    /// <p>Use to specify what column to sort by.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListEdgePackagingJobsSortBy>,
    /// <p>What direction to sort by.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListEdgePackagingJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEdgePackagingJobsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("model_name_contains", &self.model_name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointConfigsInputBody<'a> {
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::EndpointConfigSortKey>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::OrderKey>,
    /// <p>If the result of the previous <code>ListEndpointConfig</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// endpoint configurations, use the token in the next request. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of training jobs to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the endpoint configuration name. This filter returns only endpoint
    /// configurations whose name contains the specified string. </p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only endpoint configurations created before the specified
    /// time (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only endpoint configurations with a creation time greater
    /// than or equal to the specified time (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListEndpointConfigsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointConfigsInputBody");
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointsInputBody<'a> {
    /// <p>Sorts the list of results. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::EndpointSortKey>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::OrderKey>,
    /// <p>If the result of a <code>ListEndpoints</code> request was truncated, the response
    /// includes a <code>NextToken</code>. To retrieve the next set of endpoints, use the token
    /// in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of endpoints to return in the response. This value defaults to
    /// 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in endpoint names. This filter returns only endpoints whose name contains
    /// the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only endpoints that were created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only endpoints with a creation time greater than or equal to
    /// the specified time (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p> A filter that returns only endpoints that were modified before the specified
    /// timestamp. </p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p> A filter that returns only endpoints that were modified after the specified
    /// timestamp. </p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p> A filter that returns only endpoints with the specified status.</p>
    pub status_equals: &'a std::option::Option<crate::model::EndpointStatus>,
}
impl<'a> std::fmt::Debug for ListEndpointsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointsInputBody");
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("status_equals", &self.status_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListExperimentsInputBody<'a> {
    /// <p>A filter that returns only experiments created after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only experiments created before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortExperimentsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the previous call to <code>ListExperiments</code> didn't return the full set of
    /// experiments, the call returns a token for getting the next set of experiments.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of experiments to return in the response. The default value is
    /// 10.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListExperimentsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListExperimentsInputBody");
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFeatureGroupsInputBody<'a> {
    /// <p>A string that partially matches one or more <code>FeatureGroup</code>s names. Filters
    /// <code>FeatureGroup</code>s by name. </p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A <code>FeatureGroup</code> status. Filters by <code>FeatureGroup</code> status. </p>
    pub feature_group_status_equals: &'a std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>An <code>OfflineStore</code> status. Filters by <code>OfflineStore</code> status. </p>
    pub offline_store_status_equals: &'a std::option::Option<crate::model::OfflineStoreStatusValue>,
    /// <p>Use this parameter to search for <code>FeatureGroups</code>s created after a specific
    /// date and time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Use this parameter to search for <code>FeatureGroups</code>s created before a specific
    /// date and time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The order in which feature groups are listed.</p>
    pub sort_order: &'a std::option::Option<crate::model::FeatureGroupSortOrder>,
    /// <p>The value on which the feature group list is sorted.</p>
    pub sort_by: &'a std::option::Option<crate::model::FeatureGroupSortBy>,
    /// <p>The maximum number of results returned by <code>ListFeatureGroups</code>.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to resume pagination of <code>ListFeatureGroups</code> results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListFeatureGroupsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFeatureGroupsInputBody");
        formatter.field("name_contains", &self.name_contains);
        formatter.field(
            "feature_group_status_equals",
            &self.feature_group_status_equals,
        );
        formatter.field(
            "offline_store_status_equals",
            &self.offline_store_status_equals,
        );
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFlowDefinitionsInputBody<'a> {
    /// <p>A filter that returns only flow definitions with a creation time greater than or equal to the specified timestamp.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only flow definitions that were created before the specified timestamp.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>An optional value that specifies whether you want the results sorted in <code>Ascending</code> or <code>Descending</code> order.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A token to resume pagination.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The total number of items to return. If the total number of available items is more than the value specified in <code>MaxResults</code>, then a <code>NextToken</code> will be provided in the output that you can use to resume pagination.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListFlowDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFlowDefinitionsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHumanTaskUisInputBody<'a> {
    /// <p>A filter that returns only human task user interfaces with a creation time greater than or equal to the specified timestamp.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only human task user interfaces that were created before the specified timestamp.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>An optional value that specifies whether you want the results sorted in <code>Ascending</code> or <code>Descending</code> order.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A token to resume pagination.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The total number of items to return. If the total number of available items is more than the value specified in <code>MaxResults</code>, then a <code>NextToken</code> will be provided in the output that you can use to resume pagination.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListHumanTaskUisInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHumanTaskUisInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHyperParameterTuningJobsInputBody<'a> {
    /// <p>If the result of the previous <code>ListHyperParameterTuningJobs</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// tuning jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The
    /// maximum number of tuning jobs to return. The default value is
    /// 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The
    /// field
    /// to sort results by. The default is <code>Name</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::HyperParameterTuningJobSortByOptions>,
    /// <p>The sort
    /// order
    /// for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A string in the tuning job name. This filter returns only tuning jobs whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only tuning jobs that were created after the
    /// specified
    /// time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only tuning jobs that were created before the
    /// specified
    /// time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only tuning jobs that were modified after the specified
    /// time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only tuning jobs that were modified before the specified
    /// time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only tuning jobs with the
    /// specified
    /// status.</p>
    pub status_equals: &'a std::option::Option<crate::model::HyperParameterTuningJobStatus>,
}
impl<'a> std::fmt::Debug for ListHyperParameterTuningJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHyperParameterTuningJobsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("status_equals", &self.status_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImagesInputBody<'a> {
    /// <p>A filter that returns only images created on or after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only images created on or before the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only images modified on or after the specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only images modified on or before the specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of images to return in the response. The default value is 10. </p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A filter that returns only images whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the previous call to <code>ListImages</code> didn't return the full set of images,
    /// the call returns a token for getting the next set of images.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The property used to sort results. The default value is <code>CREATION_TIME</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ImageSortBy>,
    /// <p>The sort order. The default value is <code>DESCENDING</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::ImageSortOrder>,
}
impl<'a> std::fmt::Debug for ListImagesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImagesInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImageVersionsInputBody<'a> {
    /// <p>A filter that returns only versions created on or after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only versions created on or before the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The name of the image to list the versions of.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only versions modified on or after the specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only versions modified on or before the specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of versions to return in the response. The default value is 10. </p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous call to <code>ListImageVersions</code> didn't return the full set of
    /// versions, the call returns a token for getting the next set of versions.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The property used to sort results. The default value is <code>CREATION_TIME</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ImageVersionSortBy>,
    /// <p>The sort order. The default value is <code>DESCENDING</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::ImageVersionSortOrder>,
}
impl<'a> std::fmt::Debug for ListImageVersionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImageVersionsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("image_name", &self.image_name);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLabelingJobsInputBody<'a> {
    /// <p>A filter that returns only labeling jobs created after the specified time
    /// (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only labeling jobs created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only labeling jobs modified after the specified time
    /// (timestamp).</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only labeling jobs modified before the specified time
    /// (timestamp).</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of labeling jobs to return in each page of the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the result of the previous <code>ListLabelingJobs</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To retrieve the next set of labeling jobs,
    /// use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>A string in the labeling job name. This filter returns only labeling jobs whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A filter that retrieves only labeling jobs with a specific status.</p>
    pub status_equals: &'a std::option::Option<crate::model::LabelingJobStatus>,
}
impl<'a> std::fmt::Debug for ListLabelingJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLabelingJobsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("status_equals", &self.status_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLabelingJobsForWorkteamInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the work team for which you want to see labeling
    /// jobs for.</p>
    pub workteam_arn: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of labeling jobs to return in each page of the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the result of the previous <code>ListLabelingJobsForWorkteam</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// labeling jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only labeling jobs created after the specified time
    /// (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only labeling jobs created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter the limits jobs to only the ones whose job reference code contains the
    /// specified string.</p>
    pub job_reference_code_contains: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListLabelingJobsForWorkteamSortByOptions>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListLabelingJobsForWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLabelingJobsForWorkteamInputBody");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field(
            "job_reference_code_contains",
            &self.job_reference_code_contains,
        );
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelBiasJobDefinitionsInputBody<'a> {
    /// <p>Name of the endpoint to monitor for model bias.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>Whether to sort results by the <code>Name</code> or <code>CreationTime</code> field. The
    /// default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringJobDefinitionSortKey>,
    /// <p>Whether to sort the results in <code>Ascending</code> or <code>Descending</code> order.
    /// The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The token returned if the response is truncated. To retrieve the next set of job
    /// executions, use it in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of model bias jobs to return in the response. The default value is
    /// 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Filter for model bias jobs whose name contains a specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only model bias jobs created before a specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only model bias jobs created after a specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListModelBiasJobDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelBiasJobDefinitionsInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelExplainabilityJobDefinitionsInputBody<'a> {
    /// <p>Name of the endpoint to monitor for model explainability.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>Whether to sort results by the <code>Name</code> or <code>CreationTime</code> field. The
    /// default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringJobDefinitionSortKey>,
    /// <p>Whether to sort the results in <code>Ascending</code> or <code>Descending</code> order.
    /// The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The token returned if the response is truncated. To retrieve the next set of job
    /// executions, use it in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of jobs to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Filter for model explainability jobs whose name contains a specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only model explainability jobs created before a specified
    /// time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only model explainability jobs created after a specified
    /// time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListModelExplainabilityJobDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelExplainabilityJobDefinitionsInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelPackageGroupsInputBody<'a> {
    /// <p>A filter that returns only model groups created after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only model groups created before the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of results to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the model group name. This filter returns only model groups whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListModelPackageGroups</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// model groups, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ModelPackageGroupSortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListModelPackageGroupsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelPackageGroupsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelPackagesInputBody<'a> {
    /// <p>A filter that returns only model packages created after the specified time
    /// (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only model packages created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of model packages to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the model package name. This filter returns only model packages whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only the model packages with the specified approval
    /// status.</p>
    pub model_approval_status: &'a std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>A filter that returns only model versions that belong to the specified model group.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns onlyl the model packages of the specified type. This can be one
    /// of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>VERSIONED</code> - List only versioned models.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNVERSIONED</code> - List only unversioined models.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BOTH</code> - List both versioned and unversioned models.</p>
    /// </li>
    /// </ul>
    pub model_package_type: &'a std::option::Option<crate::model::ModelPackageType>,
    /// <p>If the response to a previous <code>ListModelPackages</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of model
    /// packages, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The parameter by which to sort the results. The default is
    /// <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ModelPackageSortBy>,
    /// <p>The sort order for the results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListModelPackagesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelPackagesInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_type", &self.model_package_type);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelQualityJobDefinitionsInputBody<'a> {
    /// <p>A filter that returns only model quality monitoring job definitions that are associated
    /// with the specified endpoint.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringJobDefinitionSortKey>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListModelQualityJobDefinitions</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// model quality monitoring job definitions, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a call to
    /// <code>ListModelQualityJobDefinitions</code>.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the transform job name. This filter returns only model quality monitoring
    /// job definitions whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only model quality monitoring job definitions created before the
    /// specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only model quality monitoring job definitions created after the
    /// specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListModelQualityJobDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelQualityJobDefinitionsInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelsInputBody<'a> {
    /// <p>Sorts the list of results. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ModelSortKey>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::OrderKey>,
    /// <p>If the response to a previous <code>ListModels</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To retrieve the next set of models, use the
    /// token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of models to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A string in the training job name. This filter returns only models in the training
    /// job whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only models created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only models with a creation time greater than or equal to the
    /// specified time (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListModelsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelsInputBody");
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMonitoringExecutionsInputBody<'a> {
    /// <p>Name of a specific schedule to fetch jobs for.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
    /// <p>Name of a specific endpoint to fetch jobs for.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>Whether to sort results by <code>Status</code>, <code>CreationTime</code>,
    /// <code>ScheduledTime</code> field. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringExecutionSortKey>,
    /// <p>Whether to sort the results in <code>Ascending</code> or <code>Descending</code> order.
    /// The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The token returned if the response is truncated. To retrieve the next set of job
    /// executions, use it in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of jobs to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Filter for jobs scheduled before a specified time.</p>
    pub scheduled_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Filter for jobs scheduled after a specified time.</p>
    pub scheduled_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only jobs created before a specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only jobs created after a specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only jobs modified after a specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only jobs modified before a specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that retrieves only jobs with a specific status.</p>
    pub status_equals: &'a std::option::Option<crate::model::ExecutionStatus>,
    /// <p>Gets a list of the monitoring job runs of the specified monitoring job
    /// definitions.</p>
    pub monitoring_job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only the monitoring job runs of the specified monitoring
    /// type.</p>
    pub monitoring_type_equals: &'a std::option::Option<crate::model::MonitoringType>,
}
impl<'a> std::fmt::Debug for ListMonitoringExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMonitoringExecutionsInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("scheduled_time_before", &self.scheduled_time_before);
        formatter.field("scheduled_time_after", &self.scheduled_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("status_equals", &self.status_equals);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type_equals", &self.monitoring_type_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMonitoringSchedulesInputBody<'a> {
    /// <p>Name of a specific endpoint to fetch schedules for.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>Whether to sort results by <code>Status</code>, <code>CreationTime</code>,
    /// <code>ScheduledTime</code> field. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::MonitoringScheduleSortKey>,
    /// <p>Whether to sort the results in <code>Ascending</code> or <code>Descending</code> order.
    /// The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The token returned if the response is truncated. To retrieve the next set of job
    /// executions, use it in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of jobs to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Filter for monitoring schedules whose name contains a specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only monitoring schedules created before a specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only monitoring schedules created after a specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only monitoring schedules modified before a specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only monitoring schedules modified after a specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only monitoring schedules modified before a specified time.</p>
    pub status_equals: &'a std::option::Option<crate::model::ScheduleStatus>,
    /// <p>Gets a list of the monitoring schedules for the specified monitoring job
    /// definition.</p>
    pub monitoring_job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only the monitoring schedules for the specified monitoring
    /// type.</p>
    pub monitoring_type_equals: &'a std::option::Option<crate::model::MonitoringType>,
}
impl<'a> std::fmt::Debug for ListMonitoringSchedulesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMonitoringSchedulesInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("status_equals", &self.status_equals);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type_equals", &self.monitoring_type_equals);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotebookInstanceLifecycleConfigsInputBody<'a> {
    /// <p>If the result of a <code>ListNotebookInstanceLifecycleConfigs</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To get the next set of
    /// lifecycle configurations, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of lifecycle configurations to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Sorts the list of results. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::NotebookInstanceLifecycleConfigSortKey>,
    /// <p>The sort order for results.</p>
    pub sort_order: &'a std::option::Option<crate::model::NotebookInstanceLifecycleConfigSortOrder>,
    /// <p>A string in the lifecycle configuration name. This filter returns only lifecycle
    /// configurations whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only lifecycle configurations that were created before the
    /// specified time (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only lifecycle configurations that were created after the
    /// specified time (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only lifecycle configurations that were modified before the
    /// specified time (timestamp).</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only lifecycle configurations that were modified after the
    /// specified time (timestamp).</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for ListNotebookInstanceLifecycleConfigsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotebookInstanceLifecycleConfigsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotebookInstancesInputBody<'a> {
    /// <p> If the previous call to the <code>ListNotebookInstances</code> is truncated, the
    /// response includes a <code>NextToken</code>. You can use this token in your subsequent
    /// <code>ListNotebookInstances</code> request to fetch the next set of notebook
    /// instances. </p>
    /// <note>
    /// <p>You might specify a filter or a sort order in your request. When response is
    /// truncated, you must use the same values for the filer and sort order in the next
    /// request. </p>
    /// </note>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of notebook instances to return.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The field to sort results by. The default is <code>Name</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::NotebookInstanceSortKey>,
    /// <p>The sort order for results. </p>
    pub sort_order: &'a std::option::Option<crate::model::NotebookInstanceSortOrder>,
    /// <p>A string in the notebook instances' name. This filter returns only notebook
    /// instances whose name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only notebook instances that were created before the
    /// specified time (timestamp). </p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only notebook instances that were created after the specified
    /// time (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only notebook instances that were modified before the
    /// specified time (timestamp).</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only notebook instances that were modified after the
    /// specified time (timestamp).</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only notebook instances with the specified status.</p>
    pub status_equals: &'a std::option::Option<crate::model::NotebookInstanceStatus>,
    /// <p>A string in the name of a notebook instances lifecycle configuration associated with
    /// this notebook instance. This filter returns only notebook instances associated with a
    /// lifecycle configuration with a name that contains the specified string.</p>
    pub notebook_instance_lifecycle_config_name_contains:
        &'a std::option::Option<std::string::String>,
    /// <p>A string in the name or URL of a Git repository associated with this notebook
    /// instance. This filter returns only notebook instances associated with a git repository
    /// with a name that contains the specified string.</p>
    pub default_code_repository_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only notebook instances with associated with the specified git
    /// repository.</p>
    pub additional_code_repository_equals: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListNotebookInstancesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotebookInstancesInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("status_equals", &self.status_equals);
        formatter.field(
            "notebook_instance_lifecycle_config_name_contains",
            &self.notebook_instance_lifecycle_config_name_contains,
        );
        formatter.field(
            "default_code_repository_contains",
            &self.default_code_repository_contains,
        );
        formatter.field(
            "additional_code_repository_equals",
            &self.additional_code_repository_equals,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineExecutionsInputBody<'a> {
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns the pipeline executions that were created after a specified
    /// time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the pipeline executions that were created before a specified
    /// time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The field by which to sort results. The default is <code>CreatedTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortPipelineExecutionsBy>,
    /// <p>The sort order for results.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListPipelineExecutions</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipeline executions, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of pipeline executions to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListPipelineExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineExecutionsInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineExecutionStepsInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListPipelineExecutionSteps</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipeline execution steps, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of pipeline execution steps to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The field by which to sort results. The default is <code>CreatedTime</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListPipelineExecutionStepsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineExecutionStepsInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineParametersForExecutionInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListPipelineParametersForExecution</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of parameters, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of parameters to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListPipelineParametersForExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineParametersForExecutionInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelinesInputBody<'a> {
    /// <p>The prefix of the pipeline name.</p>
    pub pipeline_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns the pipelines that were created after a specified
    /// time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the pipelines that were created before a specified
    /// time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The field by which to sort results. The default is <code>CreatedTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortPipelinesBy>,
    /// <p>The sort order for results.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListPipelines</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipelines, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of pipelines to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListPipelinesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelinesInputBody");
        formatter.field("pipeline_name_prefix", &self.pipeline_name_prefix);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProcessingJobsInputBody<'a> {
    /// <p>A filter that returns only processing jobs created after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only processing jobs created after the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only processing jobs modified after the specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only processing jobs modified before the specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A string in the processing job name. This filter returns only processing jobs whose
    /// name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that retrieves only processing jobs with a specific status.</p>
    pub status_equals: &'a std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListProcessingJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of processing
    /// jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of processing jobs to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListProcessingJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProcessingJobsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProjectsInputBody<'a> {
    /// <p>A filter that returns the projects that were created after a specified
    /// time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns the projects that were created before a specified
    /// time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of projects to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A filter that returns the projects whose name contains a specified
    /// string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListProjects</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of projects, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The field by which to sort results. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ProjectSortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::ProjectSortOrder>,
}
impl<'a> std::fmt::Debug for ListProjectsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProjectsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSubscribedWorkteamsInputBody<'a> {
    /// <p>A string in the work team name. This filter returns only work teams whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListSubscribedWorkteams</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of
    /// labeling jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of work teams to return in each page of the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListSubscribedWorkteamsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSubscribedWorkteamsInputBody");
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to
    /// retrieve.</p>
    pub resource_arn: &'a std::option::Option<std::string::String>,
    /// <p> If the response to the previous <code>ListTags</code> request is truncated, Amazon SageMaker
    /// returns this token. To retrieve the next set of tags, use it in the subsequent request.
    /// </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Maximum number of tags to return.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListTagsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsInputBody");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrainingJobsInputBody<'a> {
    /// <p>If the result of the previous <code>ListTrainingJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of training
    /// jobs, use the token in the next request. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of training jobs to return in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A filter that returns only training jobs created after the specified time
    /// (timestamp).</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only training jobs created before the specified time
    /// (timestamp).</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only training jobs modified after the specified time
    /// (timestamp).</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only training jobs modified before the specified time
    /// (timestamp).</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A string in the training job name. This filter returns only training jobs whose
    /// name contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that retrieves only training jobs with a specific status.</p>
    pub status_equals: &'a std::option::Option<crate::model::TrainingJobStatus>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortBy>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListTrainingJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrainingJobsInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrainingJobsForHyperParameterTuningJobInputBody<'a> {
    /// <p>The name of the tuning job whose training jobs you want to list.</p>
    pub hyper_parameter_tuning_job_name: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListTrainingJobsForHyperParameterTuningJob</code>
    /// request was truncated, the response includes a <code>NextToken</code>. To retrieve the
    /// next set of training jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of training jobs to return. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A filter that returns only training jobs with the
    /// specified
    /// status.</p>
    pub status_equals: &'a std::option::Option<crate::model::TrainingJobStatus>,
    /// <p>The field to sort
    /// results
    /// by. The default is <code>Name</code>.</p>
    /// <p>If the value of this field is <code>FinalObjectiveMetricValue</code>, any training
    /// jobs that did not return an objective metric are not listed.</p>
    pub sort_by: &'a std::option::Option<crate::model::TrainingJobSortByOptions>,
    /// <p>The sort order
    /// for
    /// results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
}
impl<'a> std::fmt::Debug for ListTrainingJobsForHyperParameterTuningJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrainingJobsForHyperParameterTuningJobInputBody");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTransformJobsInputBody<'a> {
    /// <p>A filter that returns only transform jobs created after the specified time.</p>
    pub creation_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only transform jobs created before the specified time.</p>
    pub creation_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only transform jobs modified after the specified time.</p>
    pub last_modified_time_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only transform jobs modified before the specified time.</p>
    pub last_modified_time_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A string in the transform job name. This filter returns only transform jobs whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A filter that retrieves only transform jobs with a specific status.</p>
    pub status_equals: &'a std::option::Option<crate::model::TransformJobStatus>,
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortBy>,
    /// <p>The sort order for results. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>If the result of the previous <code>ListTransformJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of transform
    /// jobs, use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of transform jobs to return in the response. The default value is <code>10</code>.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListTransformJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTransformJobsInputBody");
        formatter.field("creation_time_after", &self.creation_time_after);
        formatter.field("creation_time_before", &self.creation_time_before);
        formatter.field("last_modified_time_after", &self.last_modified_time_after);
        formatter.field("last_modified_time_before", &self.last_modified_time_before);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("status_equals", &self.status_equals);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrialComponentsInputBody<'a> {
    /// <p>A filter that returns only components that are part of the specified experiment. If you
    /// specify <code>ExperimentName</code>, you can't filter by <code>SourceArn</code> or
    /// <code>TrialName</code>.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only components that are part of the specified trial. If you specify
    /// <code>TrialName</code>, you can't filter by <code>ExperimentName</code> or
    /// <code>SourceArn</code>.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only components that have the specified source Amazon Resource Name
    /// (ARN). If you specify <code>SourceArn</code>, you can't filter by <code>ExperimentName</code>
    /// or <code>TrialName</code>.</p>
    pub source_arn: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only components created after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only components created before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortTrialComponentsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The maximum number of components to return in the response. The default value is
    /// 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous call to <code>ListTrialComponents</code> didn't return the full set of
    /// components, the call returns a token for getting the next set of components.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListTrialComponentsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrialComponentsInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.field("source_arn", &self.source_arn);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrialsInputBody<'a> {
    /// <p>A filter that returns only trials that are part of the specified experiment.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only trials that are associated with the specified trial
    /// component.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter that returns only trials created after the specified time.</p>
    pub created_after: &'a std::option::Option<smithy_types::Instant>,
    /// <p>A filter that returns only trials created before the specified time.</p>
    pub created_before: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The property used to sort results. The default value is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::SortTrialsBy>,
    /// <p>The sort order. The default value is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The maximum number of trials to return in the response. The default value is 10.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>If the previous call to <code>ListTrials</code> didn't return the full set of trials, the
    /// call returns a token for getting the next set of trials.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListTrialsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrialsInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("created_after", &self.created_after);
        formatter.field("created_before", &self.created_before);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUserProfilesInputBody<'a> {
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Returns a list up to a specified limit.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The sort order for the results. The default is Ascending.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>The parameter by which to sort the results. The default is CreationTime.</p>
    pub sort_by: &'a std::option::Option<crate::model::UserProfileSortKey>,
    /// <p>A parameter by which to filter the results.</p>
    pub domain_id_equals: &'a std::option::Option<std::string::String>,
    /// <p>A parameter by which to filter the results.</p>
    pub user_profile_name_contains: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListUserProfilesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUserProfilesInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("domain_id_equals", &self.domain_id_equals);
        formatter.field(
            "user_profile_name_contains",
            &self.user_profile_name_contains,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkforcesInputBody<'a> {
    /// <p>Sort workforces using the workforce name or creation date.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListWorkforcesSortByOptions>,
    /// <p>Sort workforces in ascending or descending order.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A filter you can use to search for workforces using part of the workforce name.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>A token to resume pagination.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of workforces returned in the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListWorkforcesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkforcesInputBody");
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkteamsInputBody<'a> {
    /// <p>The field to sort results by. The default is <code>CreationTime</code>.</p>
    pub sort_by: &'a std::option::Option<crate::model::ListWorkteamsSortByOptions>,
    /// <p>The sort order for results. The default is <code>Ascending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrder>,
    /// <p>A string in the work team's name. This filter returns only work teams whose name
    /// contains the specified string.</p>
    pub name_contains: &'a std::option::Option<std::string::String>,
    /// <p>If the result of the previous <code>ListWorkteams</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To retrieve the next set of labeling jobs,
    /// use the token in the next request.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of work teams to return in each page of the response.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListWorkteamsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkteamsInputBody");
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutModelPackageGroupPolicyInputBody<'a> {
    /// <p>The name of the model group to add a resource policy to.</p>
    pub model_package_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The resource policy for the model group.</p>
    pub resource_policy: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutModelPackageGroupPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutModelPackageGroupPolicyInputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterDevicesInputBody<'a> {
    /// <p>The name of the fleet.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of devices to register with SageMaker Edge Manager.</p>
    pub devices: &'a std::option::Option<std::vec::Vec<crate::model::Device>>,
    /// <p>The tags associated with devices.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for RegisterDevicesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterDevicesInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("devices", &self.devices);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderUiTemplateInputBody<'a> {
    /// <p>A <code>Template</code> object containing the worker UI template to render.</p>
    pub ui_template: &'a std::option::Option<crate::model::UiTemplate>,
    /// <p>A <code>RenderableTask</code> object containing a representative task to
    /// render.</p>
    pub task: &'a std::option::Option<crate::model::RenderableTask>,
    /// <p>The Amazon Resource Name (ARN) that has access to the S3 objects that are used by the
    /// template.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The <code>HumanTaskUiArn</code> of the worker UI that you want to render. Do not
    /// provide a <code>HumanTaskUiArn</code> if you use the <code>UiTemplate</code>
    /// parameter.</p>
    /// <p>See a list of available Human Ui Amazon Resource Names (ARNs) in <a>UiConfig</a>.</p>
    pub human_task_ui_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RenderUiTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderUiTemplateInputBody");
        formatter.field("ui_template", &self.ui_template);
        formatter.field("task", &self.task);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchInputBody<'a> {
    /// <p>The name of the Amazon SageMaker resource to search for.</p>
    pub resource: &'a std::option::Option<crate::model::ResourceType>,
    /// <p>A Boolean conditional statement. Resources must satisfy this condition to be
    /// included in search results. You must provide at least one subexpression, filter, or
    /// nested filter. The maximum number of recursive <code>SubExpressions</code>,
    /// <code>NestedFilters</code>, and <code>Filters</code> that can be included in a
    /// <code>SearchExpression</code> object is 50.</p>
    pub search_expression: &'a std::option::Option<crate::model::SearchExpression>,
    /// <p>The name of the resource property used to sort the <code>SearchResults</code>. The
    /// default is <code>LastModifiedTime</code>.</p>
    pub sort_by: &'a std::option::Option<std::string::String>,
    /// <p>How <code>SearchResults</code> are ordered. Valid values are <code>Ascending</code> or
    /// <code>Descending</code>. The default is <code>Descending</code>.</p>
    pub sort_order: &'a std::option::Option<crate::model::SearchSortOrder>,
    /// <p>If more than <code>MaxResults</code> resources match the specified
    /// <code>SearchExpression</code>, the response includes a
    /// <code>NextToken</code>. The <code>NextToken</code> can be passed to the next
    /// <code>SearchRequest</code> to continue retrieving results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for SearchInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchInputBody");
        formatter.field("resource", &self.resource);
        formatter.field("search_expression", &self.search_expression);
        formatter.field("sort_by", &self.sort_by);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendPipelineExecutionStepFailureInputBody<'a> {
    /// <p>The pipeline generated token from the Amazon SQS queue.</p>
    pub callback_token: &'a std::option::Option<std::string::String>,
    /// <p>A message describing why the step failed.</p>
    pub failure_reason: &'a std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for SendPipelineExecutionStepFailureInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendPipelineExecutionStepFailureInputBody");
        formatter.field("callback_token", &self.callback_token);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendPipelineExecutionStepSuccessInputBody<'a> {
    /// <p>The pipeline generated token from the Amazon SQS queue.</p>
    pub callback_token: &'a std::option::Option<std::string::String>,
    /// <p>A list of the output parameters of the callback step.</p>
    pub output_parameters: &'a std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for SendPipelineExecutionStepSuccessInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendPipelineExecutionStepSuccessInputBody");
        formatter.field("callback_token", &self.callback_token);
        formatter.field("output_parameters", &self.output_parameters);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMonitoringScheduleInputBody<'a> {
    /// <p>The name of the schedule to start.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StartMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartNotebookInstanceInputBody<'a> {
    /// <p>The name of the notebook instance to start.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StartNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPipelineExecutionInputBody<'a> {
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: &'a std::option::Option<std::string::String>,
    /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
    pub pipeline_parameters: &'a std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: &'a std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StartPipelineExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPipelineExecutionInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.field("pipeline_parameters", &self.pipeline_parameters);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopAutoMLJobInputBody<'a> {
    /// <p>The name of the object you are requesting.</p>
    pub auto_ml_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopAutoMLJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopAutoMLJobInputBody");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopCompilationJobInputBody<'a> {
    /// <p>The name of the model compilation job to stop.</p>
    pub compilation_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopCompilationJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopCompilationJobInputBody");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEdgePackagingJobInputBody<'a> {
    /// <p>The name of the edge packaging job.</p>
    pub edge_packaging_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopEdgePackagingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEdgePackagingJobInputBody");
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopHyperParameterTuningJobInputBody<'a> {
    /// <p>The name of the tuning job to stop.</p>
    pub hyper_parameter_tuning_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopHyperParameterTuningJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopHyperParameterTuningJobInputBody");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopLabelingJobInputBody<'a> {
    /// <p>The name of the labeling job to stop.</p>
    pub labeling_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopLabelingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopLabelingJobInputBody");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopMonitoringScheduleInputBody<'a> {
    /// <p>The name of the schedule to stop.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopNotebookInstanceInputBody<'a> {
    /// <p>The name of the notebook instance to terminate.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPipelineExecutionInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// operation. An idempotent operation completes no more than one time.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopPipelineExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPipelineExecutionInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopProcessingJobInputBody<'a> {
    /// <p>The name of the processing job to stop.</p>
    pub processing_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopProcessingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopProcessingJobInputBody");
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTrainingJobInputBody<'a> {
    /// <p>The name of the training job to stop.</p>
    pub training_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopTrainingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTrainingJobInputBody");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTransformJobInputBody<'a> {
    /// <p>The name of the transform job to stop.</p>
    pub transform_job_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopTransformJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTransformJobInputBody");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateActionInputBody<'a> {
    /// <p>The name of the action to update.</p>
    pub action_name: &'a std::option::Option<std::string::String>,
    /// <p>The new description for the action.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The new status for the action.</p>
    pub status: &'a std::option::Option<crate::model::ActionStatus>,
    /// <p>The new list of properties. Overwrites the current property list.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of properties to remove.</p>
    pub properties_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateActionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateActionInputBody");
        formatter.field("action_name", &self.action_name);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("properties", &self.properties);
        formatter.field("properties_to_remove", &self.properties_to_remove);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAppImageConfigInputBody<'a> {
    /// <p>The name of the AppImageConfig to update.</p>
    pub app_image_config_name: &'a std::option::Option<std::string::String>,
    /// <p>The new KernelGateway app to run on the image.</p>
    pub kernel_gateway_image_config:
        &'a std::option::Option<crate::model::KernelGatewayImageConfig>,
}
impl<'a> std::fmt::Debug for UpdateAppImageConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAppImageConfigInputBody");
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.field(
            "kernel_gateway_image_config",
            &self.kernel_gateway_image_config,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateArtifactInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the artifact to update.</p>
    pub artifact_arn: &'a std::option::Option<std::string::String>,
    /// <p>The new name for the artifact.</p>
    pub artifact_name: &'a std::option::Option<std::string::String>,
    /// <p>The new list of properties. Overwrites the current property list.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of properties to remove.</p>
    pub properties_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateArtifactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateArtifactInputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.field("artifact_name", &self.artifact_name);
        formatter.field("properties", &self.properties);
        formatter.field("properties_to_remove", &self.properties_to_remove);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCodeRepositoryInputBody<'a> {
    /// <p>The name of the Git repository to update.</p>
    pub code_repository_name: &'a std::option::Option<std::string::String>,
    /// <p>The configuration of the git repository, including the URL and the Amazon Resource
    /// Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to
    /// access the repository. The secret must have a staging label of <code>AWSCURRENT</code>
    /// and must be in the following format:</p>
    /// <p>
    /// <code>{"username": <i>UserName</i>, "password":
    /// <i>Password</i>}</code>
    /// </p>
    pub git_config: &'a std::option::Option<crate::model::GitConfigForUpdate>,
}
impl<'a> std::fmt::Debug for UpdateCodeRepositoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCodeRepositoryInputBody");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.field("git_config", &self.git_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateContextInputBody<'a> {
    /// <p>The name of the context to update.</p>
    pub context_name: &'a std::option::Option<std::string::String>,
    /// <p>The new description for the context.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The new list of properties. Overwrites the current property list.</p>
    pub properties: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of properties to remove.</p>
    pub properties_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateContextInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateContextInputBody");
        formatter.field("context_name", &self.context_name);
        formatter.field("description", &self.description);
        formatter.field("properties", &self.properties);
        formatter.field("properties_to_remove", &self.properties_to_remove);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDeviceFleetInputBody<'a> {
    /// <p>The name of the fleet.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>Description of the fleet.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Output configuration  for storing sample data collected by the fleet.</p>
    pub output_config: &'a std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>Whether to create an AWS IoT Role Alias during device fleet creation.
    /// The name of the role alias generated will match this pattern:
    /// "SageMakerEdge-{DeviceFleetName}".</p>
    /// <p>For example, if your device fleet is called "demo-fleet", the name of
    /// the role alias will be "SageMakerEdge-demo-fleet".</p>
    pub enable_iot_role_alias: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdateDeviceFleetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDeviceFleetInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("description", &self.description);
        formatter.field("output_config", &self.output_config);
        formatter.field("enable_iot_role_alias", &self.enable_iot_role_alias);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDevicesInputBody<'a> {
    /// <p>The name of the fleet the devices belong to.</p>
    pub device_fleet_name: &'a std::option::Option<std::string::String>,
    /// <p>List of devices to register with Edge Manager agent.</p>
    pub devices: &'a std::option::Option<std::vec::Vec<crate::model::Device>>,
}
impl<'a> std::fmt::Debug for UpdateDevicesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDevicesInputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("devices", &self.devices);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDomainInputBody<'a> {
    /// <p>The ID of the domain to be updated.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>A collection of settings.</p>
    pub default_user_settings: &'a std::option::Option<crate::model::UserSettings>,
}
impl<'a> std::fmt::Debug for UpdateDomainInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDomainInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("default_user_settings", &self.default_user_settings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointInputBody<'a> {
    /// <p>The name of the endpoint whose configuration you want to update.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the new endpoint configuration.</p>
    pub endpoint_config_name: &'a std::option::Option<std::string::String>,
    /// <p>When updating endpoint resources, enables or disables the retention of <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_VariantProperty.html">variant properties</a>, such as the instance count or the variant weight. To
    /// retain the variant properties of an endpoint when updating it, set
    /// <code>RetainAllVariantProperties</code> to <code>true</code>. To use the variant
    /// properties specified in a new <code>EndpointConfig</code> call when updating an
    /// endpoint, set <code>RetainAllVariantProperties</code> to <code>false</code>. The default
    /// is <code>false</code>.</p>
    pub retain_all_variant_properties: &'a bool,
    /// <p>When you are updating endpoint resources with <a>UpdateEndpointInput$RetainAllVariantProperties</a>, whose value is set to
    /// <code>true</code>, <code>ExcludeRetainedVariantProperties</code> specifies the list
    /// of type <a>VariantProperty</a> to override with the values provided by
    /// <code>EndpointConfig</code>. If you don't specify a value for
    /// <code>ExcludeAllVariantProperties</code>, no variant properties are overridden.
    /// </p>
    pub exclude_retained_variant_properties:
        &'a std::option::Option<std::vec::Vec<crate::model::VariantProperty>>,
    /// <p>The deployment configuration for the endpoint to be updated.</p>
    pub deployment_config: &'a std::option::Option<crate::model::DeploymentConfig>,
}
impl<'a> std::fmt::Debug for UpdateEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field(
            "retain_all_variant_properties",
            &self.retain_all_variant_properties,
        );
        formatter.field(
            "exclude_retained_variant_properties",
            &self.exclude_retained_variant_properties,
        );
        formatter.field("deployment_config", &self.deployment_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointWeightsAndCapacitiesInputBody<'a> {
    /// <p>The name of an existing Amazon SageMaker endpoint.</p>
    pub endpoint_name: &'a std::option::Option<std::string::String>,
    /// <p>An object that provides new capacity and weight values for a variant.</p>
    pub desired_weights_and_capacities:
        &'a std::option::Option<std::vec::Vec<crate::model::DesiredWeightAndCapacity>>,
}
impl<'a> std::fmt::Debug for UpdateEndpointWeightsAndCapacitiesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointWeightsAndCapacitiesInputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "desired_weights_and_capacities",
            &self.desired_weights_and_capacities,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateExperimentInputBody<'a> {
    /// <p>The name of the experiment to update.</p>
    pub experiment_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. The name doesn't need to be unique. If
    /// <code>DisplayName</code> isn't specified, <code>ExperimentName</code> is displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The description of the experiment.</p>
    pub description: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateExperimentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateExperimentInputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateImageInputBody<'a> {
    /// <p>A list of properties to delete. Only the <code>Description</code> and
    /// <code>DisplayName</code> properties can be deleted.</p>
    pub delete_properties: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The new description for the image.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The new display name for the image.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the image to update.</p>
    pub image_name: &'a std::option::Option<std::string::String>,
    /// <p>The new Amazon Resource Name (ARN) for the IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateImageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateImageInputBody");
        formatter.field("delete_properties", &self.delete_properties);
        formatter.field("description", &self.description);
        formatter.field("display_name", &self.display_name);
        formatter.field("image_name", &self.image_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateModelPackageInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub model_package_arn: &'a std::option::Option<std::string::String>,
    /// <p>The approval status of the model.</p>
    pub model_approval_status: &'a std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>A description for the approval status of the model.</p>
    pub approval_description: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateModelPackageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateModelPackageInputBody");
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("approval_description", &self.approval_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMonitoringScheduleInputBody<'a> {
    /// <p>The name of the monitoring schedule. The name must be unique within an AWS Region within
    /// an AWS account.</p>
    pub monitoring_schedule_name: &'a std::option::Option<std::string::String>,
    /// <p>The configuration object that specifies the monitoring schedule and defines the
    /// monitoring job.</p>
    pub monitoring_schedule_config: &'a std::option::Option<crate::model::MonitoringScheduleConfig>,
}
impl<'a> std::fmt::Debug for UpdateMonitoringScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMonitoringScheduleInputBody");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field(
            "monitoring_schedule_config",
            &self.monitoring_schedule_config,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNotebookInstanceInputBody<'a> {
    /// <p>The name of the notebook instance to update.</p>
    pub notebook_instance_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon ML compute instance type.</p>
    pub instance_type: &'a std::option::Option<crate::model::InstanceType>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that Amazon SageMaker can assume to access the
    /// notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-roles.html">Amazon SageMaker Roles</a>. </p>
    /// <note>
    /// <p>To be able to pass this role to Amazon SageMaker, the caller of this API must have the
    /// <code>iam:PassRole</code> permission.</p>
    /// </note>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The name of a lifecycle configuration to associate with the notebook instance. For
    /// information about lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step 2.1: (Optional)
    /// Customize a Notebook Instance</a>.</p>
    pub lifecycle_config_name: &'a std::option::Option<std::string::String>,
    /// <p>Set to <code>true</code> to remove the notebook instance lifecycle configuration
    /// currently associated with the notebook instance. This operation is idempotent. If you
    /// specify a lifecycle configuration that is not associated with the notebook instance when
    /// you call this method, it does not throw an error.</p>
    pub disassociate_lifecycle_config: &'a bool,
    /// <p>The size, in GB, of the ML storage volume to attach to the notebook instance. The
    /// default value is 5 GB. ML storage volumes are encrypted, so Amazon SageMaker can't determine the
    /// amount of available free space on the volume. Because of this, you can increase the
    /// volume size when you update a notebook instance, but you can't decrease the volume size.
    /// If you want to decrease the size of the ML storage volume in use, create a new notebook
    /// instance with the desired size.</p>
    pub volume_size_in_gb: &'a std::option::Option<i32>,
    /// <p>The Git repository to associate with the notebook instance as its default code
    /// repository. This can be either the name of a Git repository stored as a resource in your
    /// account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. When you open a notebook instance, it opens in the directory that
    /// contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with Amazon SageMaker
    /// Notebook Instances</a>.</p>
    pub default_code_repository: &'a std::option::Option<std::string::String>,
    /// <p>An array of up to three Git repositories to associate with the notebook instance.
    /// These can be either the names of Git repositories stored as resources in your account,
    /// or the URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. These repositories are cloned at the same level as the default
    /// repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git
    /// Repositories with Amazon SageMaker Notebook Instances</a>.</p>
    pub additional_code_repositories: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of the Elastic Inference (EI) instance types to associate with this notebook
    /// instance. Currently only one EI instance type can be associated with a notebook
    /// instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon
    /// SageMaker</a>.</p>
    pub accelerator_types:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceAcceleratorType>>,
    /// <p>A list of the Elastic Inference (EI) instance types to remove from this notebook
    /// instance. This operation is idempotent. If you specify an accelerator type that is not
    /// associated with the notebook instance when you call this method, it does not throw an
    /// error.</p>
    pub disassociate_accelerator_types: &'a bool,
    /// <p>The name or URL of the default Git repository to remove from this notebook instance.
    /// This operation is idempotent. If you specify a Git repository that is not associated
    /// with the notebook instance when you call this method, it does not throw an error.</p>
    pub disassociate_default_code_repository: &'a bool,
    /// <p>A list of names or URLs of the default Git repositories to remove from this notebook
    /// instance. This operation is idempotent. If you specify a Git repository that is not
    /// associated with the notebook instance when you call this method, it does not throw an
    /// error.</p>
    pub disassociate_additional_code_repositories: &'a bool,
    /// <p>Whether root access is enabled or disabled for users of the notebook instance. The
    /// default value is <code>Enabled</code>.</p>
    /// <note>
    /// <p>If you set this to <code>Disabled</code>, users don't have root access on the
    /// notebook instance, but lifecycle configuration scripts still run with root
    /// permissions.</p>
    /// </note>
    pub root_access: &'a std::option::Option<crate::model::RootAccess>,
}
impl<'a> std::fmt::Debug for UpdateNotebookInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateNotebookInstanceInputBody");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("lifecycle_config_name", &self.lifecycle_config_name);
        formatter.field(
            "disassociate_lifecycle_config",
            &self.disassociate_lifecycle_config,
        );
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("default_code_repository", &self.default_code_repository);
        formatter.field(
            "additional_code_repositories",
            &self.additional_code_repositories,
        );
        formatter.field("accelerator_types", &self.accelerator_types);
        formatter.field(
            "disassociate_accelerator_types",
            &self.disassociate_accelerator_types,
        );
        formatter.field(
            "disassociate_default_code_repository",
            &self.disassociate_default_code_repository,
        );
        formatter.field(
            "disassociate_additional_code_repositories",
            &self.disassociate_additional_code_repositories,
        );
        formatter.field("root_access", &self.root_access);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNotebookInstanceLifecycleConfigInputBody<'a> {
    /// <p>The name of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_name: &'a std::option::Option<std::string::String>,
    /// <p>The shell script that runs only once, when you create a notebook instance. The shell
    /// script must be a base64-encoded string.</p>
    pub on_create:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
    /// <p>The shell script that runs every time you start a notebook instance, including when
    /// you create the notebook instance. The shell script must be a base64-encoded
    /// string.</p>
    pub on_start:
        &'a std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
}
impl<'a> std::fmt::Debug for UpdateNotebookInstanceLifecycleConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateNotebookInstanceLifecycleConfigInputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("on_create", &self.on_create);
        formatter.field("on_start", &self.on_start);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineInputBody<'a> {
    /// <p>The name of the pipeline to update.</p>
    pub pipeline_name: &'a std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: &'a std::option::Option<std::string::String>,
    /// <p>The JSON pipeline definition.</p>
    pub pipeline_definition: &'a std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    pub pipeline_description: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that the pipeline uses to execute.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdatePipelineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineInputBody");
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_definition", &self.pipeline_definition);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineExecutionInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: &'a std::option::Option<std::string::String>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: &'a std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdatePipelineExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineExecutionInputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrainingJobInputBody<'a> {
    /// <p>The name of a training job to update the Debugger profiling configuration.</p>
    pub training_job_name: &'a std::option::Option<std::string::String>,
    /// <p>Configuration information for Debugger system monitoring, framework profiling, and
    /// storage paths.</p>
    pub profiler_config: &'a std::option::Option<crate::model::ProfilerConfigForUpdate>,
    /// <p>Configuration information for Debugger rules for profiling system and framework
    /// metrics.</p>
    pub profiler_rule_configurations:
        &'a std::option::Option<std::vec::Vec<crate::model::ProfilerRuleConfiguration>>,
}
impl<'a> std::fmt::Debug for UpdateTrainingJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrainingJobInputBody");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("profiler_config", &self.profiler_config);
        formatter.field(
            "profiler_rule_configurations",
            &self.profiler_rule_configurations,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrialInputBody<'a> {
    /// <p>The name of the trial to update.</p>
    pub trial_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. The name doesn't need to be unique. If
    /// <code>DisplayName</code> isn't specified, <code>TrialName</code> is displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateTrialInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrialInputBody");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrialComponentInputBody<'a> {
    /// <p>The name of the component to update.</p>
    pub trial_component_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. The name doesn't need to be unique. If
    /// <code>DisplayName</code> isn't specified, <code>TrialComponentName</code> is
    /// displayed.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>The new status of the component.</p>
    pub status: &'a std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>When the component ended.</p>
    pub end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Replaces all of the component's hyperparameters with the specified hyperparameters.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    >,
    /// <p>The hyperparameters to remove from the component.</p>
    pub parameters_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replaces all of the component's input artifacts with the specified artifacts.</p>
    pub input_artifacts: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The input artifacts to remove from the component.</p>
    pub input_artifacts_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replaces all of the component's output artifacts with the specified artifacts.</p>
    pub output_artifacts: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The output artifacts to remove from the component.</p>
    pub output_artifacts_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateTrialComponentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrialComponentInputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("parameters", &self.parameters);
        formatter.field("parameters_to_remove", &self.parameters_to_remove);
        formatter.field("input_artifacts", &self.input_artifacts);
        formatter.field("input_artifacts_to_remove", &self.input_artifacts_to_remove);
        formatter.field("output_artifacts", &self.output_artifacts);
        formatter.field(
            "output_artifacts_to_remove",
            &self.output_artifacts_to_remove,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserProfileInputBody<'a> {
    /// <p>The domain ID.</p>
    pub domain_id: &'a std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: &'a std::option::Option<std::string::String>,
    /// <p>A collection of settings.</p>
    pub user_settings: &'a std::option::Option<crate::model::UserSettings>,
}
impl<'a> std::fmt::Debug for UpdateUserProfileInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserProfileInputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("user_settings", &self.user_settings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkforceInputBody<'a> {
    /// <p>The name of the private workforce that you want to update. You can find your workforce
    /// name by using the  operation.</p>
    pub workforce_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of one to ten worker IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) that can be used to
    /// access tasks assigned to this workforce.</p>
    /// <p>Maximum: Ten CIDR values</p>
    pub source_ip_config: &'a std::option::Option<crate::model::SourceIpConfig>,
    /// <p>Use this parameter to update your OIDC Identity Provider (IdP)
    /// configuration for a workforce made using your own IdP.</p>
    pub oidc_config: &'a std::option::Option<crate::model::OidcConfig>,
}
impl<'a> std::fmt::Debug for UpdateWorkforceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkforceInputBody");
        formatter.field("workforce_name", &self.workforce_name);
        formatter.field("source_ip_config", &self.source_ip_config);
        formatter.field("oidc_config", &self.oidc_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkteamInputBody<'a> {
    /// <p>The name of the work team to update.</p>
    pub workteam_name: &'a std::option::Option<std::string::String>,
    /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify
    /// the workers that make up the work team. </p>
    /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP).
    /// For private workforces created using Amazon Cognito use
    /// <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity
    /// provider (IdP) use <code>OidcMemberDefinition</code>. You should not provide input
    /// for both of these parameters in a single request.</p>
    /// <p>For workforces created using Amazon Cognito, private work teams correspond to Amazon Cognito
    /// <i>user groups</i> within the user pool used to create a workforce. All of the
    /// <code>CognitoMemberDefinition</code> objects that make up the member definition must
    /// have the same <code>ClientId</code> and <code>UserPool</code> values. To add a Amazon
    /// Cognito user group to an existing worker pool, see <a href="">Adding groups to a User
    /// Pool</a>. For more information about user pools, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">Amazon Cognito User
    /// Pools</a>.</p>
    /// <p>For workforces created using your own OIDC IdP, specify the user groups that you want
    /// to include in your private work team in <code>OidcMemberDefinition</code> by listing
    /// those groups in <code>Groups</code>. Be aware that user groups that are already in the
    /// work team must also be listed in <code>Groups</code> when you make this request to
    /// remain on the work team. If you do not include these user groups, they will no longer be
    /// associated with the work team you update. </p>
    pub member_definitions: &'a std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
    /// <p>An updated description for the work team.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Configures SNS topic notifications for available or expiring work items</p>
    pub notification_configuration:
        &'a std::option::Option<crate::model::NotificationConfiguration>,
}
impl<'a> std::fmt::Debug for UpdateWorkteamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkteamInputBody");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.field("member_definitions", &self.member_definitions);
        formatter.field("description", &self.description);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AddAssociationOutputBody {
    /// <p>The ARN of the source.</p>
    #[serde(rename = "SourceArn")]
    #[serde(default)]
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    #[serde(rename = "DestinationArn")]
    #[serde(default)]
    pub destination_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddAssociationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddAssociationOutputBody");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AddTagsOutputBody {
    /// <p>A list of tags associated with the Amazon SageMaker resource.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for AddTagsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddTagsOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateTrialComponentOutputBody {
    /// <p>The ARN of the trial component.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateTrialComponentOutputBody");
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("trial_arn", &self.trial_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateActionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    #[serde(rename = "ActionArn")]
    #[serde(default)]
    pub action_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateActionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateActionOutputBody");
        formatter.field("action_arn", &self.action_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAlgorithmOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the new algorithm.</p>
    #[serde(rename = "AlgorithmArn")]
    #[serde(default)]
    pub algorithm_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAlgorithmOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAlgorithmOutputBody");
        formatter.field("algorithm_arn", &self.algorithm_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the app.</p>
    #[serde(rename = "AppArn")]
    #[serde(default)]
    pub app_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAppOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppOutputBody");
        formatter.field("app_arn", &self.app_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppImageConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
    #[serde(rename = "AppImageConfigArn")]
    #[serde(default)]
    pub app_image_config_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAppImageConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppImageConfigOutputBody");
        formatter.field("app_image_config_arn", &self.app_image_config_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateArtifactOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    #[serde(rename = "ArtifactArn")]
    #[serde(default)]
    pub artifact_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateArtifactOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateArtifactOutputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAutoMLJobOutputBody {
    /// <p>The unique ARN that is assigned to the AutoML job when it is created.</p>
    #[serde(rename = "AutoMLJobArn")]
    #[serde(default)]
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAutoMLJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAutoMLJobOutputBody");
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCodeRepositoryOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the new repository.</p>
    #[serde(rename = "CodeRepositoryArn")]
    #[serde(default)]
    pub code_repository_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateCodeRepositoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCodeRepositoryOutputBody");
        formatter.field("code_repository_arn", &self.code_repository_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCompilationJobOutputBody {
    /// <p>If the action is successful, the service sends back an HTTP 200 response. Amazon SageMaker returns
    /// the following data in JSON format:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CompilationJobArn</code>: The Amazon Resource Name (ARN) of the compiled
    /// job.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "CompilationJobArn")]
    #[serde(default)]
    pub compilation_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateCompilationJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCompilationJobOutputBody");
        formatter.field("compilation_job_arn", &self.compilation_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContextOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    #[serde(rename = "ContextArn")]
    #[serde(default)]
    pub context_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateContextOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContextOutputBody");
        formatter.field("context_arn", &self.context_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDataQualityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the job definition.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateDataQualityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDataQualityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the created domain.</p>
    #[serde(rename = "DomainArn")]
    #[serde(default)]
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The URL to the created domain.</p>
    #[serde(rename = "Url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateDomainOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainOutputBody");
        formatter.field("domain_arn", &self.domain_arn);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    #[serde(rename = "EndpointArn")]
    #[serde(default)]
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointOutputBody");
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the endpoint configuration. </p>
    #[serde(rename = "EndpointConfigArn")]
    #[serde(default)]
    pub endpoint_config_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateEndpointConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointConfigOutputBody");
        formatter.field("endpoint_config_arn", &self.endpoint_config_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateExperimentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    #[serde(rename = "ExperimentArn")]
    #[serde(default)]
    pub experiment_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateExperimentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateExperimentOutputBody");
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFeatureGroupOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the <code>FeatureGroup</code>. This is a unique
    /// identifier for the feature group. </p>
    #[serde(rename = "FeatureGroupArn")]
    #[serde(default)]
    pub feature_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateFeatureGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFeatureGroupOutputBody");
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFlowDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the flow definition you create.</p>
    #[serde(rename = "FlowDefinitionArn")]
    #[serde(default)]
    pub flow_definition_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateFlowDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFlowDefinitionOutputBody");
        formatter.field("flow_definition_arn", &self.flow_definition_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHumanTaskUiOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the human review workflow user interface you create.</p>
    #[serde(rename = "HumanTaskUiArn")]
    #[serde(default)]
    pub human_task_ui_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateHumanTaskUiOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHumanTaskUiOutputBody");
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHyperParameterTuningJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the tuning job. Amazon SageMaker assigns an ARN to a
    /// hyperparameter tuning job when you create it.</p>
    #[serde(rename = "HyperParameterTuningJobArn")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateHyperParameterTuningJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHyperParameterTuningJobOutputBody");
        formatter.field(
            "hyper_parameter_tuning_job_arn",
            &self.hyper_parameter_tuning_job_arn,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImageOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    #[serde(rename = "ImageArn")]
    #[serde(default)]
    pub image_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateImageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImageOutputBody");
        formatter.field("image_arn", &self.image_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImageVersionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the image version.</p>
    #[serde(rename = "ImageVersionArn")]
    #[serde(default)]
    pub image_version_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateImageVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImageVersionOutputBody");
        formatter.field("image_version_arn", &self.image_version_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLabelingJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the labeling job. You use this ARN to identify the
    /// labeling job.</p>
    #[serde(rename = "LabelingJobArn")]
    #[serde(default)]
    pub labeling_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateLabelingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLabelingJobOutputBody");
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelOutputBody {
    /// <p>The ARN of the model created in Amazon SageMaker.</p>
    #[serde(rename = "ModelArn")]
    #[serde(default)]
    pub model_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelOutputBody");
        formatter.field("model_arn", &self.model_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelBiasJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model bias job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelBiasJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelBiasJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelExplainabilityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model explainability job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelExplainabilityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelExplainabilityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelPackageOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the new model package.</p>
    #[serde(rename = "ModelPackageArn")]
    #[serde(default)]
    pub model_package_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelPackageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelPackageOutputBody");
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelPackageGroupOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    #[serde(rename = "ModelPackageGroupArn")]
    #[serde(default)]
    pub model_package_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelPackageGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelPackageGroupOutputBody");
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateModelQualityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model quality monitoring job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateModelQualityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateModelQualityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMonitoringScheduleOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    #[serde(rename = "MonitoringScheduleArn")]
    #[serde(default)]
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateMonitoringScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMonitoringScheduleOutputBody");
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateNotebookInstanceOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the notebook instance. </p>
    #[serde(rename = "NotebookInstanceArn")]
    #[serde(default)]
    pub notebook_instance_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateNotebookInstanceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateNotebookInstanceOutputBody");
        formatter.field("notebook_instance_arn", &self.notebook_instance_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateNotebookInstanceLifecycleConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
    #[serde(rename = "NotebookInstanceLifecycleConfigArn")]
    #[serde(default)]
    pub notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateNotebookInstanceLifecycleConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateNotebookInstanceLifecycleConfigOutputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_arn",
            &self.notebook_instance_lifecycle_config_arn,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePipelineOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the created pipeline.</p>
    #[serde(rename = "PipelineArn")]
    #[serde(default)]
    pub pipeline_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreatePipelineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePipelineOutputBody");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePresignedDomainUrlOutputBody {
    /// <p>The presigned URL.</p>
    #[serde(rename = "AuthorizedUrl")]
    #[serde(default)]
    pub authorized_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreatePresignedDomainUrlOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePresignedDomainUrlOutputBody");
        formatter.field("authorized_url", &self.authorized_url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePresignedNotebookInstanceUrlOutputBody {
    /// <p>A JSON object that contains the URL string. </p>
    #[serde(rename = "AuthorizedUrl")]
    #[serde(default)]
    pub authorized_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreatePresignedNotebookInstanceUrlOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePresignedNotebookInstanceUrlOutputBody");
        formatter.field("authorized_url", &self.authorized_url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProcessingJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
    #[serde(rename = "ProcessingJobArn")]
    #[serde(default)]
    pub processing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateProcessingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProcessingJobOutputBody");
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProjectOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    #[serde(rename = "ProjectArn")]
    #[serde(default)]
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the new project.</p>
    #[serde(rename = "ProjectId")]
    #[serde(default)]
    pub project_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateProjectOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProjectOutputBody");
        formatter.field("project_arn", &self.project_arn);
        formatter.field("project_id", &self.project_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrainingJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    #[serde(rename = "TrainingJobArn")]
    #[serde(default)]
    pub training_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateTrainingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrainingJobOutputBody");
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTransformJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    #[serde(rename = "TransformJobArn")]
    #[serde(default)]
    pub transform_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateTransformJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTransformJobOutputBody");
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrialOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateTrialOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrialOutputBody");
        formatter.field("trial_arn", &self.trial_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTrialComponentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTrialComponentOutputBody");
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateUserProfileOutputBody {
    /// <p>The user profile Amazon Resource Name (ARN).</p>
    #[serde(rename = "UserProfileArn")]
    #[serde(default)]
    pub user_profile_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateUserProfileOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateUserProfileOutputBody");
        formatter.field("user_profile_arn", &self.user_profile_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkforceOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
    #[serde(rename = "WorkforceArn")]
    #[serde(default)]
    pub workforce_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateWorkforceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkforceOutputBody");
        formatter.field("workforce_arn", &self.workforce_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkteamOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the work team. You can use this ARN to identify the
    /// work team.</p>
    #[serde(rename = "WorkteamArn")]
    #[serde(default)]
    pub workteam_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkteamOutputBody");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteActionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    #[serde(rename = "ActionArn")]
    #[serde(default)]
    pub action_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteActionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteActionOutputBody");
        formatter.field("action_arn", &self.action_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteArtifactOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    #[serde(rename = "ArtifactArn")]
    #[serde(default)]
    pub artifact_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteArtifactOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteArtifactOutputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAssociationOutputBody {
    /// <p>The ARN of the source.</p>
    #[serde(rename = "SourceArn")]
    #[serde(default)]
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    #[serde(rename = "DestinationArn")]
    #[serde(default)]
    pub destination_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteAssociationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAssociationOutputBody");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteContextOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    #[serde(rename = "ContextArn")]
    #[serde(default)]
    pub context_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteContextOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteContextOutputBody");
        formatter.field("context_arn", &self.context_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteExperimentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the experiment that is being deleted.</p>
    #[serde(rename = "ExperimentArn")]
    #[serde(default)]
    pub experiment_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteExperimentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteExperimentOutputBody");
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePipelineOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline to delete.</p>
    #[serde(rename = "PipelineArn")]
    #[serde(default)]
    pub pipeline_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePipelineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePipelineOutputBody");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTrialOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the trial that is being deleted.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteTrialOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTrialOutputBody");
        formatter.field("trial_arn", &self.trial_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTrialComponentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the component is being deleted.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTrialComponentOutputBody");
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkteamOutputBody {
    /// <p>Returns <code>true</code> if the work team was successfully deleted; otherwise,
    /// returns <code>false</code>.</p>
    #[serde(rename = "Success")]
    #[serde(default)]
    pub success: bool,
}
impl std::fmt::Debug for DeleteWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkteamOutputBody");
        formatter.field("success", &self.success);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActionOutputBody {
    /// <p>The name of the action.</p>
    #[serde(rename = "ActionName")]
    #[serde(default)]
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    #[serde(rename = "ActionArn")]
    #[serde(default)]
    pub action_arn: std::option::Option<std::string::String>,
    /// <p>The source of the action.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::ActionSource>,
    /// <p>The type of the action.</p>
    #[serde(rename = "ActionType")]
    #[serde(default)]
    pub action_type: std::option::Option<std::string::String>,
    /// <p>The description of the action.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ActionStatus>,
    /// <p>A list of the action's properties.</p>
    #[serde(rename = "Properties")]
    #[serde(default)]
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>When the action was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the action was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    #[serde(rename = "MetadataProperties")]
    #[serde(default)]
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
}
impl std::fmt::Debug for DescribeActionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActionOutputBody");
        formatter.field("action_name", &self.action_name);
        formatter.field("action_arn", &self.action_arn);
        formatter.field("source", &self.source);
        formatter.field("action_type", &self.action_type);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("properties", &self.properties);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAlgorithmOutputBody {
    /// <p>The name of the algorithm being described.</p>
    #[serde(rename = "AlgorithmName")]
    #[serde(default)]
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
    #[serde(rename = "AlgorithmArn")]
    #[serde(default)]
    pub algorithm_arn: std::option::Option<std::string::String>,
    /// <p>A brief summary about the algorithm.</p>
    #[serde(rename = "AlgorithmDescription")]
    #[serde(default)]
    pub algorithm_description: std::option::Option<std::string::String>,
    /// <p>A timestamp specifying when the algorithm was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Details about training jobs run by this algorithm.</p>
    #[serde(rename = "TrainingSpecification")]
    #[serde(default)]
    pub training_specification: std::option::Option<crate::model::TrainingSpecification>,
    /// <p>Details about inference jobs that the algorithm runs.</p>
    #[serde(rename = "InferenceSpecification")]
    #[serde(default)]
    pub inference_specification: std::option::Option<crate::model::InferenceSpecification>,
    /// <p>Details about configurations for one or more training jobs that Amazon SageMaker runs to test the
    /// algorithm.</p>
    #[serde(rename = "ValidationSpecification")]
    #[serde(default)]
    pub validation_specification:
        std::option::Option<crate::model::AlgorithmValidationSpecification>,
    /// <p>The current status of the algorithm.</p>
    #[serde(rename = "AlgorithmStatus")]
    #[serde(default)]
    pub algorithm_status: std::option::Option<crate::model::AlgorithmStatus>,
    /// <p>Details about the current status of the algorithm.</p>
    #[serde(rename = "AlgorithmStatusDetails")]
    #[serde(default)]
    pub algorithm_status_details: std::option::Option<crate::model::AlgorithmStatusDetails>,
    /// <p>The product identifier of the algorithm.</p>
    #[serde(rename = "ProductId")]
    #[serde(default)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>Whether the algorithm is certified to be listed in AWS Marketplace.</p>
    #[serde(rename = "CertifyForMarketplace")]
    #[serde(default)]
    pub certify_for_marketplace: bool,
}
impl std::fmt::Debug for DescribeAlgorithmOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAlgorithmOutputBody");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("algorithm_arn", &self.algorithm_arn);
        formatter.field("algorithm_description", &self.algorithm_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_specification", &self.training_specification);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field("algorithm_status", &self.algorithm_status);
        formatter.field("algorithm_status_details", &self.algorithm_status_details);
        formatter.field("product_id", &self.product_id);
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the app.</p>
    #[serde(rename = "AppArn")]
    #[serde(default)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>The type of app.</p>
    #[serde(rename = "AppType")]
    #[serde(default)]
    pub app_type: std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    #[serde(rename = "AppName")]
    #[serde(default)]
    pub app_name: std::option::Option<std::string::String>,
    /// <p>The domain ID.</p>
    #[serde(rename = "DomainId")]
    #[serde(default)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    #[serde(rename = "UserProfileName")]
    #[serde(default)]
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::AppStatus>,
    /// <p>The timestamp of the last health check.</p>
    #[serde(rename = "LastHealthCheckTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_health_check_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp of the last user's activity.</p>
    #[serde(rename = "LastUserActivityTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_user_activity_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The creation time.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The failure reason.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
    #[serde(rename = "ResourceSpec")]
    #[serde(default)]
    pub resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl std::fmt::Debug for DescribeAppOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppOutputBody");
        formatter.field("app_arn", &self.app_arn);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("status", &self.status);
        formatter.field(
            "last_health_check_timestamp",
            &self.last_health_check_timestamp,
        );
        formatter.field(
            "last_user_activity_timestamp",
            &self.last_user_activity_timestamp,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("resource_spec", &self.resource_spec);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppImageConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
    #[serde(rename = "AppImageConfigArn")]
    #[serde(default)]
    pub app_image_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the AppImageConfig.</p>
    #[serde(rename = "AppImageConfigName")]
    #[serde(default)]
    pub app_image_config_name: std::option::Option<std::string::String>,
    /// <p>When the AppImageConfig was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the AppImageConfig was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The configuration of a KernelGateway app.</p>
    #[serde(rename = "KernelGatewayImageConfig")]
    #[serde(default)]
    pub kernel_gateway_image_config: std::option::Option<crate::model::KernelGatewayImageConfig>,
}
impl std::fmt::Debug for DescribeAppImageConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppImageConfigOutputBody");
        formatter.field("app_image_config_arn", &self.app_image_config_arn);
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "kernel_gateway_image_config",
            &self.kernel_gateway_image_config,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeArtifactOutputBody {
    /// <p>The name of the artifact.</p>
    #[serde(rename = "ArtifactName")]
    #[serde(default)]
    pub artifact_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    #[serde(rename = "ArtifactArn")]
    #[serde(default)]
    pub artifact_arn: std::option::Option<std::string::String>,
    /// <p>The source of the artifact.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::ArtifactSource>,
    /// <p>The type of the artifact.</p>
    #[serde(rename = "ArtifactType")]
    #[serde(default)]
    pub artifact_type: std::option::Option<std::string::String>,
    /// <p>A list of the artifact's properties.</p>
    #[serde(rename = "Properties")]
    #[serde(default)]
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>When the artifact was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the artifact was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    #[serde(rename = "MetadataProperties")]
    #[serde(default)]
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
}
impl std::fmt::Debug for DescribeArtifactOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeArtifactOutputBody");
        formatter.field("artifact_name", &self.artifact_name);
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.field("source", &self.source);
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("properties", &self.properties);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutoMLJobOutputBody {
    /// <p>Returns the name of the AutoML job.</p>
    #[serde(rename = "AutoMLJobName")]
    #[serde(default)]
    pub auto_ml_job_name: std::option::Option<std::string::String>,
    /// <p>Returns the ARN of the AutoML job.</p>
    #[serde(rename = "AutoMLJobArn")]
    #[serde(default)]
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>Returns the input data configuration for the AutoML job..</p>
    #[serde(rename = "InputDataConfig")]
    #[serde(default)]
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::AutoMLChannel>>,
    /// <p>Returns the job's output data config.</p>
    #[serde(rename = "OutputDataConfig")]
    #[serde(default)]
    pub output_data_config: std::option::Option<crate::model::AutoMLOutputDataConfig>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that has read permission to
    /// the input data location and write permission to the output data location in Amazon S3.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Returns the job's objective.</p>
    #[serde(rename = "AutoMLJobObjective")]
    #[serde(default)]
    pub auto_ml_job_objective: std::option::Option<crate::model::AutoMLJobObjective>,
    /// <p>Returns the job's problem type.</p>
    #[serde(rename = "ProblemType")]
    #[serde(default)]
    pub problem_type: std::option::Option<crate::model::ProblemType>,
    /// <p>Returns the configuration for the AutoML job.</p>
    #[serde(rename = "AutoMLJobConfig")]
    #[serde(default)]
    pub auto_ml_job_config: std::option::Option<crate::model::AutoMLJobConfig>,
    /// <p>Returns the creation time of the AutoML job.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Returns the end time of the AutoML job.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>Returns the job's last modified time.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Returns the failure reason for an AutoML job, when applicable.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Returns a list of reasons for partial failures within an AutoML job.</p>
    #[serde(rename = "PartialFailureReasons")]
    #[serde(default)]
    pub partial_failure_reasons:
        std::option::Option<std::vec::Vec<crate::model::AutoMLPartialFailureReason>>,
    /// <p>Returns the job's best <code>AutoMLCandidate</code>.</p>
    #[serde(rename = "BestCandidate")]
    #[serde(default)]
    pub best_candidate: std::option::Option<crate::model::AutoMLCandidate>,
    /// <p>Returns the status of the AutoML job.</p>
    #[serde(rename = "AutoMLJobStatus")]
    #[serde(default)]
    pub auto_ml_job_status: std::option::Option<crate::model::AutoMlJobStatus>,
    /// <p>Returns the secondary status of the AutoML job.</p>
    #[serde(rename = "AutoMLJobSecondaryStatus")]
    #[serde(default)]
    pub auto_ml_job_secondary_status: std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
    /// <p>Indicates whether the output for an AutoML job generates candidate definitions
    /// only.</p>
    #[serde(rename = "GenerateCandidateDefinitionsOnly")]
    #[serde(default)]
    pub generate_candidate_definitions_only: bool,
    /// <p>Returns information on the job's artifacts found in
    /// <code>AutoMLJobArtifacts</code>.</p>
    #[serde(rename = "AutoMLJobArtifacts")]
    #[serde(default)]
    pub auto_ml_job_artifacts: std::option::Option<crate::model::AutoMLJobArtifacts>,
    /// <p>This contains <code>ProblemType</code>, <code>AutoMLJobObjective</code> and
    /// <code>CompletionCriteria</code>. If you do not provide these values, they are
    /// auto-inferred. If you do provide them, the values used are the ones you provide.</p>
    #[serde(rename = "ResolvedAttributes")]
    #[serde(default)]
    pub resolved_attributes: std::option::Option<crate::model::ResolvedAttributes>,
    /// <p>Indicates whether the model was deployed automatically to an endpoint and the name of
    /// that endpoint if deployed automatically.</p>
    #[serde(rename = "ModelDeployConfig")]
    #[serde(default)]
    pub model_deploy_config: std::option::Option<crate::model::ModelDeployConfig>,
    /// <p>Provides information about endpoint for the model deployment.</p>
    #[serde(rename = "ModelDeployResult")]
    #[serde(default)]
    pub model_deploy_result: std::option::Option<crate::model::ModelDeployResult>,
}
impl std::fmt::Debug for DescribeAutoMLJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutoMLJobOutputBody");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("auto_ml_job_objective", &self.auto_ml_job_objective);
        formatter.field("problem_type", &self.problem_type);
        formatter.field("auto_ml_job_config", &self.auto_ml_job_config);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("partial_failure_reasons", &self.partial_failure_reasons);
        formatter.field("best_candidate", &self.best_candidate);
        formatter.field("auto_ml_job_status", &self.auto_ml_job_status);
        formatter.field(
            "auto_ml_job_secondary_status",
            &self.auto_ml_job_secondary_status,
        );
        formatter.field(
            "generate_candidate_definitions_only",
            &self.generate_candidate_definitions_only,
        );
        formatter.field("auto_ml_job_artifacts", &self.auto_ml_job_artifacts);
        formatter.field("resolved_attributes", &self.resolved_attributes);
        formatter.field("model_deploy_config", &self.model_deploy_config);
        formatter.field("model_deploy_result", &self.model_deploy_result);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCodeRepositoryOutputBody {
    /// <p>The name of the Git repository.</p>
    #[serde(rename = "CodeRepositoryName")]
    #[serde(default)]
    pub code_repository_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
    #[serde(rename = "CodeRepositoryArn")]
    #[serde(default)]
    pub code_repository_arn: std::option::Option<std::string::String>,
    /// <p>The date and time that the repository was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the repository was last changed.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Configuration details about the repository, including the URL where the repository is
    /// located, the default branch, and the Amazon Resource Name (ARN) of the AWS Secrets
    /// Manager secret that contains the credentials used to access the repository.</p>
    #[serde(rename = "GitConfig")]
    #[serde(default)]
    pub git_config: std::option::Option<crate::model::GitConfig>,
}
impl std::fmt::Debug for DescribeCodeRepositoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCodeRepositoryOutputBody");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.field("code_repository_arn", &self.code_repository_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("git_config", &self.git_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCompilationJobOutputBody {
    /// <p>The name of the model compilation job.</p>
    #[serde(rename = "CompilationJobName")]
    #[serde(default)]
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
    #[serde(rename = "CompilationJobArn")]
    #[serde(default)]
    pub compilation_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the model compilation job.</p>
    #[serde(rename = "CompilationJobStatus")]
    #[serde(default)]
    pub compilation_job_status: std::option::Option<crate::model::CompilationJobStatus>,
    /// <p>The time when the model compilation job started the <code>CompilationJob</code>
    /// instances. </p>
    /// <p>You are billed for the time between this timestamp and the timestamp in the <a>DescribeCompilationJobResponse$CompilationEndTime</a> field. In Amazon CloudWatch Logs,
    /// the start time might be later than this time. That's because it takes time to download
    /// the compilation job, which depends on the size of the compilation job container. </p>
    #[serde(rename = "CompilationStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub compilation_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the model compilation job on a compilation job instance ended. For a
    /// successful or stopped job, this is when the job's model artifacts have finished
    /// uploading. For a failed job, this is when Amazon SageMaker detected that the job failed. </p>
    #[serde(rename = "CompilationEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub compilation_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies a limit to how long a model compilation job can run. When the job reaches
    /// the time limit, Amazon SageMaker ends the compilation job. Use this API to cap model training
    /// costs.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>The time that the model compilation job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the status
    /// of
    /// the model compilation job was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>If a model compilation job failed, the reason it failed. </p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Information about the location in Amazon S3 that has been configured for storing the model
    /// artifacts used in the compilation job.</p>
    #[serde(rename = "ModelArtifacts")]
    #[serde(default)]
    pub model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
    /// <p>Provides a BLAKE2 hash value that identifies the compiled model artifacts in Amazon S3.</p>
    #[serde(rename = "ModelDigests")]
    #[serde(default)]
    pub model_digests: std::option::Option<crate::model::ModelDigests>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker assumes to perform the model
    /// compilation job.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Information about the location in Amazon S3 of the input model artifacts, the name and
    /// shape of the expected data inputs, and the framework in which the model was
    /// trained.</p>
    #[serde(rename = "InputConfig")]
    #[serde(default)]
    pub input_config: std::option::Option<crate::model::InputConfig>,
    /// <p>Information about the output location for the compiled model and the target device
    /// that the model runs on.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::OutputConfig>,
}
impl std::fmt::Debug for DescribeCompilationJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCompilationJobOutputBody");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("compilation_job_arn", &self.compilation_job_arn);
        formatter.field("compilation_job_status", &self.compilation_job_status);
        formatter.field("compilation_start_time", &self.compilation_start_time);
        formatter.field("compilation_end_time", &self.compilation_end_time);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("model_artifacts", &self.model_artifacts);
        formatter.field("model_digests", &self.model_digests);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_config", &self.input_config);
        formatter.field("output_config", &self.output_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeContextOutputBody {
    /// <p>The name of the context.</p>
    #[serde(rename = "ContextName")]
    #[serde(default)]
    pub context_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    #[serde(rename = "ContextArn")]
    #[serde(default)]
    pub context_arn: std::option::Option<std::string::String>,
    /// <p>The source of the context.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::ContextSource>,
    /// <p>The type of the context.</p>
    #[serde(rename = "ContextType")]
    #[serde(default)]
    pub context_type: std::option::Option<std::string::String>,
    /// <p>The description of the context.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A list of the context's properties.</p>
    #[serde(rename = "Properties")]
    #[serde(default)]
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>When the context was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the context was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for DescribeContextOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeContextOutputBody");
        formatter.field("context_name", &self.context_name);
        formatter.field("context_arn", &self.context_arn);
        formatter.field("source", &self.source);
        formatter.field("context_type", &self.context_type);
        formatter.field("description", &self.description);
        formatter.field("properties", &self.properties);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDataQualityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the data quality monitoring job definition.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The name of the data quality monitoring job definition.</p>
    #[serde(rename = "JobDefinitionName")]
    #[serde(default)]
    pub job_definition_name: std::option::Option<std::string::String>,
    /// <p>The time that the data quality monitoring job definition was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The constraints and baselines for the data quality monitoring job definition.</p>
    #[serde(rename = "DataQualityBaselineConfig")]
    #[serde(default)]
    pub data_quality_baseline_config: std::option::Option<crate::model::DataQualityBaselineConfig>,
    /// <p>Information about the container that runs the data quality monitoring job.</p>
    #[serde(rename = "DataQualityAppSpecification")]
    #[serde(default)]
    pub data_quality_app_specification:
        std::option::Option<crate::model::DataQualityAppSpecification>,
    /// <p>The list of inputs for the data quality monitoring job. Currently endpoints are
    /// supported.</p>
    #[serde(rename = "DataQualityJobInput")]
    #[serde(default)]
    pub data_quality_job_input: std::option::Option<crate::model::DataQualityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    #[serde(rename = "DataQualityJobOutputConfig")]
    #[serde(default)]
    pub data_quality_job_output_config: std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    #[serde(rename = "JobResources")]
    #[serde(default)]
    pub job_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>The networking configuration for the data quality monitoring job.</p>
    #[serde(rename = "NetworkConfig")]
    #[serde(default)]
    pub network_config: std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
}
impl std::fmt::Debug for DescribeDataQualityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDataQualityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "data_quality_baseline_config",
            &self.data_quality_baseline_config,
        );
        formatter.field(
            "data_quality_app_specification",
            &self.data_quality_app_specification,
        );
        formatter.field("data_quality_job_input", &self.data_quality_job_input);
        formatter.field(
            "data_quality_job_output_config",
            &self.data_quality_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDeviceOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    #[serde(rename = "DeviceArn")]
    #[serde(default)]
    pub device_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the device.</p>
    #[serde(rename = "DeviceName")]
    #[serde(default)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>A description of the device.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the fleet the device belongs to.</p>
    #[serde(rename = "DeviceFleetName")]
    #[serde(default)]
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>The AWS Internet of Things (IoT) object thing name associated with the device.</p>
    #[serde(rename = "IotThingName")]
    #[serde(default)]
    pub iot_thing_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last registration or de-reregistration.</p>
    #[serde(rename = "RegistrationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub registration_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last heartbeat received from the device.</p>
    #[serde(rename = "LatestHeartbeat")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub latest_heartbeat: std::option::Option<smithy_types::Instant>,
    /// <p>Models on the device.</p>
    #[serde(rename = "Models")]
    #[serde(default)]
    pub models: std::option::Option<std::vec::Vec<crate::model::EdgeModel>>,
    /// <p>The maximum number of models.</p>
    #[serde(rename = "MaxModels")]
    #[serde(default)]
    pub max_models: i32,
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeDeviceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDeviceOutputBody");
        formatter.field("device_arn", &self.device_arn);
        formatter.field("device_name", &self.device_name);
        formatter.field("description", &self.description);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("iot_thing_name", &self.iot_thing_name);
        formatter.field("registration_time", &self.registration_time);
        formatter.field("latest_heartbeat", &self.latest_heartbeat);
        formatter.field("models", &self.models);
        formatter.field("max_models", &self.max_models);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDeviceFleetOutputBody {
    /// <p>The name of the fleet.</p>
    #[serde(rename = "DeviceFleetName")]
    #[serde(default)]
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>The The Amazon Resource Name (ARN) of the fleet.</p>
    #[serde(rename = "DeviceFleetArn")]
    #[serde(default)]
    pub device_fleet_arn: std::option::Option<std::string::String>,
    /// <p>The output configuration for storing sampled data.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>A description of the fleet.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the device fleet was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Timestamp of when the device fleet was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) that has access to AWS Internet of Things (IoT).</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) alias created in AWS Internet of Things (IoT).</p>
    #[serde(rename = "IotRoleAlias")]
    #[serde(default)]
    pub iot_role_alias: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeDeviceFleetOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDeviceFleetOutputBody");
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("device_fleet_arn", &self.device_fleet_arn);
        formatter.field("output_config", &self.output_config);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("iot_role_alias", &self.iot_role_alias);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDomainOutputBody {
    /// <p>The domain's Amazon Resource Name (ARN).</p>
    #[serde(rename = "DomainArn")]
    #[serde(default)]
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The domain ID.</p>
    #[serde(rename = "DomainId")]
    #[serde(default)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The domain name.</p>
    #[serde(rename = "DomainName")]
    #[serde(default)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Elastic File System (EFS) managed by this Domain.</p>
    #[serde(rename = "HomeEfsFileSystemId")]
    #[serde(default)]
    pub home_efs_file_system_id: std::option::Option<std::string::String>,
    /// <p>The SSO managed application instance ID.</p>
    #[serde(rename = "SingleSignOnManagedApplicationInstanceId")]
    #[serde(default)]
    pub single_sign_on_managed_application_instance_id: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::DomainStatus>,
    /// <p>The creation time.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last modified time.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The failure reason.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The domain's authentication mode.</p>
    #[serde(rename = "AuthMode")]
    #[serde(default)]
    pub auth_mode: std::option::Option<crate::model::AuthMode>,
    /// <p>Settings which are applied to UserProfiles in this domain if settings are not explicitly specified
    /// in a given UserProfile.
    /// </p>
    #[serde(rename = "DefaultUserSettings")]
    #[serde(default)]
    pub default_user_settings: std::option::Option<crate::model::UserSettings>,
    /// <p>Specifies the VPC used for non-EFS traffic. The default value is
    /// <code>PublicInternetOnly</code>.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PublicInternetOnly</code> - Non-EFS traffic is through a VPC managed by
    /// Amazon SageMaker, which allows direct internet access</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>VpcOnly</code> - All Studio traffic is through the specified VPC and subnets</p>
    /// </li>
    /// </ul>
    #[serde(rename = "AppNetworkAccessType")]
    #[serde(default)]
    pub app_network_access_type: std::option::Option<crate::model::AppNetworkAccessType>,
    /// <p>This member is deprecated and replaced with <code>KmsKeyId</code>.</p>
    #[serde(rename = "HomeEfsFileSystemKmsKeyId")]
    #[serde(default)]
    pub home_efs_file_system_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The VPC subnets that Studio uses for communication.</p>
    #[serde(rename = "SubnetIds")]
    #[serde(default)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The domain's URL.</p>
    #[serde(rename = "Url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
    #[serde(rename = "VpcId")]
    #[serde(default)]
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The AWS KMS customer managed CMK used to encrypt
    /// the EFS volume attached to the domain.</p>
    #[serde(rename = "KmsKeyId")]
    #[serde(default)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeDomainOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDomainOutputBody");
        formatter.field("domain_arn", &self.domain_arn);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("home_efs_file_system_id", &self.home_efs_file_system_id);
        formatter.field(
            "single_sign_on_managed_application_instance_id",
            &self.single_sign_on_managed_application_instance_id,
        );
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("auth_mode", &self.auth_mode);
        formatter.field("default_user_settings", &self.default_user_settings);
        formatter.field("app_network_access_type", &self.app_network_access_type);
        formatter.field(
            "home_efs_file_system_kms_key_id",
            &self.home_efs_file_system_kms_key_id,
        );
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("url", &self.url);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEdgePackagingJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
    #[serde(rename = "EdgePackagingJobArn")]
    #[serde(default)]
    pub edge_packaging_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the edge packaging job.</p>
    #[serde(rename = "EdgePackagingJobName")]
    #[serde(default)]
    pub edge_packaging_job_name: std::option::Option<std::string::String>,
    /// <p>The name of the SageMaker Neo compilation job that is used to locate model artifacts that are being packaged.</p>
    #[serde(rename = "CompilationJobName")]
    #[serde(default)]
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The name of the model.</p>
    #[serde(rename = "ModelName")]
    #[serde(default)]
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The version of the model.</p>
    #[serde(rename = "ModelVersion")]
    #[serde(default)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to  download and upload the model, and to contact Neo.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The output configuration for the edge packaging job.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>The CMK to use when encrypting the EBS volume the job run on.</p>
    #[serde(rename = "ResourceKey")]
    #[serde(default)]
    pub resource_key: std::option::Option<std::string::String>,
    /// <p>The current status of the packaging job.</p>
    #[serde(rename = "EdgePackagingJobStatus")]
    #[serde(default)]
    pub edge_packaging_job_status: std::option::Option<crate::model::EdgePackagingJobStatus>,
    /// <p>Returns a message describing the job status and error messages.</p>
    #[serde(rename = "EdgePackagingJobStatusMessage")]
    #[serde(default)]
    pub edge_packaging_job_status_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the packaging job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp of when the job was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Simple Storage (S3) URI where model artifacts ares stored.</p>
    #[serde(rename = "ModelArtifact")]
    #[serde(default)]
    pub model_artifact: std::option::Option<std::string::String>,
    /// <p>The signature document of files in the model artifact.</p>
    #[serde(rename = "ModelSignature")]
    #[serde(default)]
    pub model_signature: std::option::Option<std::string::String>,
    /// <p>The output of a SageMaker Edge Manager deployable resource.</p>
    #[serde(rename = "PresetDeploymentOutput")]
    #[serde(default)]
    pub preset_deployment_output: std::option::Option<crate::model::EdgePresetDeploymentOutput>,
}
impl std::fmt::Debug for DescribeEdgePackagingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEdgePackagingJobOutputBody");
        formatter.field("edge_packaging_job_arn", &self.edge_packaging_job_arn);
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("output_config", &self.output_config);
        formatter.field("resource_key", &self.resource_key);
        formatter.field("edge_packaging_job_status", &self.edge_packaging_job_status);
        formatter.field(
            "edge_packaging_job_status_message",
            &self.edge_packaging_job_status_message,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("model_artifact", &self.model_artifact);
        formatter.field("model_signature", &self.model_signature);
        formatter.field("preset_deployment_output", &self.preset_deployment_output);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointOutputBody {
    /// <p>Name of the endpoint.</p>
    #[serde(rename = "EndpointName")]
    #[serde(default)]
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    #[serde(rename = "EndpointArn")]
    #[serde(default)]
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>The name of the endpoint configuration associated with this endpoint.</p>
    #[serde(rename = "EndpointConfigName")]
    #[serde(default)]
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p> An array of <a>ProductionVariantSummary</a> objects, one for each model
    /// hosted behind this endpoint. </p>
    #[serde(rename = "ProductionVariants")]
    #[serde(default)]
    pub production_variants:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
    /// <p></p>
    #[serde(rename = "DataCaptureConfig")]
    #[serde(default)]
    pub data_capture_config: std::option::Option<crate::model::DataCaptureConfigSummary>,
    /// <p>The status of the endpoint.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>OutOfService</code>: Endpoint is not available to take incoming
    /// requests.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Creating</code>: <a>CreateEndpoint</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Updating</code>: <a>UpdateEndpoint</a> or <a>UpdateEndpointWeightsAndCapacities</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be
    /// updated or deleted or re-scaled until it has completed. This maintenance
    /// operation does not change any customer-specified values such as VPC config, KMS
    /// encryption, model, instance type, or instance count.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RollingBack</code>: Endpoint fails to scale up or down or change its
    /// variant weight and is in the process of rolling back to its previous
    /// configuration. Once the rollback completes, endpoint returns to an
    /// <code>InService</code> status. This transitional status only applies to an
    /// endpoint that has autoscaling enabled and is undergoing variant weight or
    /// capacity changes as part of an <a>UpdateEndpointWeightsAndCapacities</a> call or when the <a>UpdateEndpointWeightsAndCapacities</a> operation is called
    /// explicitly.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InService</code>: Endpoint is available to process incoming
    /// requests.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Deleting</code>: <a>DeleteEndpoint</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use
    /// <a>DescribeEndpointOutput$FailureReason</a> for information about
    /// the failure. <a>DeleteEndpoint</a> is the only operation that can be
    /// performed on a failed endpoint.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EndpointStatus")]
    #[serde(default)]
    pub endpoint_status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>If the status of the endpoint is <code>Failed</code>, the reason why it failed.
    /// </p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the endpoint was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The most recent deployment configuration for the endpoint.</p>
    #[serde(rename = "LastDeploymentConfig")]
    #[serde(default)]
    pub last_deployment_config: std::option::Option<crate::model::DeploymentConfig>,
}
impl std::fmt::Debug for DescribeEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointOutputBody");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("data_capture_config", &self.data_capture_config);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_deployment_config", &self.last_deployment_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointConfigOutputBody {
    /// <p>Name of the Amazon SageMaker endpoint configuration.</p>
    #[serde(rename = "EndpointConfigName")]
    #[serde(default)]
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
    #[serde(rename = "EndpointConfigArn")]
    #[serde(default)]
    pub endpoint_config_arn: std::option::Option<std::string::String>,
    /// <p>An array of <code>ProductionVariant</code> objects, one for each model that you
    /// want to host at this endpoint.</p>
    #[serde(rename = "ProductionVariants")]
    #[serde(default)]
    pub production_variants: std::option::Option<std::vec::Vec<crate::model::ProductionVariant>>,
    /// <p></p>
    #[serde(rename = "DataCaptureConfig")]
    #[serde(default)]
    pub data_capture_config: std::option::Option<crate::model::DataCaptureConfig>,
    /// <p>AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage
    /// volume attached to the instance.</p>
    #[serde(rename = "KmsKeyId")]
    #[serde(default)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint configuration was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DescribeEndpointConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointConfigOutputBody");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("endpoint_config_arn", &self.endpoint_config_arn);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("data_capture_config", &self.data_capture_config);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeExperimentOutputBody {
    /// <p>The name of the experiment.</p>
    #[serde(rename = "ExperimentName")]
    #[serde(default)]
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    #[serde(rename = "ExperimentArn")]
    #[serde(default)]
    pub experiment_arn: std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>ExperimentName</code> is displayed.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the source and, optionally, the type.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::ExperimentSource>,
    /// <p>The description of the experiment.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>When the experiment was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who created the experiment.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the experiment was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who last modified the experiment.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for DescribeExperimentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeExperimentOutputBody");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("source", &self.source);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFeatureGroupOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the <code>FeatureGroup</code>.  </p>
    #[serde(rename = "FeatureGroupArn")]
    #[serde(default)]
    pub feature_group_arn: std::option::Option<std::string::String>,
    /// <p>he name of the <code>FeatureGroup</code>.</p>
    #[serde(rename = "FeatureGroupName")]
    #[serde(default)]
    pub feature_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the <code>Feature</code> used for <code>RecordIdentifier</code>, whose value
    /// uniquely identifies a record stored in the feature store.</p>
    #[serde(rename = "RecordIdentifierFeatureName")]
    #[serde(default)]
    pub record_identifier_feature_name: std::option::Option<std::string::String>,
    /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a
    /// <code>FeatureGroup</code>.</p>
    /// <p> An <code>EventTime</code> is a point in time when a new event occurs that
    /// corresponds to the creation or update of a <code>Record</code> in a
    /// <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code>
    /// have a corresponding <code>EventTime</code>.</p>
    #[serde(rename = "EventTimeFeatureName")]
    #[serde(default)]
    pub event_time_feature_name: std::option::Option<std::string::String>,
    /// <p>A list of the <code>Features</code> in the <code>FeatureGroup</code>.
    /// Each feature is defined by a <code>FeatureName</code> and <code>FeatureType</code>.</p>
    #[serde(rename = "FeatureDefinitions")]
    #[serde(default)]
    pub feature_definitions: std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
    /// <p>A timestamp indicating when SageMaker created the <code>FeatureGroup</code>.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The configuration for the <code>OnlineStore</code>.</p>
    #[serde(rename = "OnlineStoreConfig")]
    #[serde(default)]
    pub online_store_config: std::option::Option<crate::model::OnlineStoreConfig>,
    /// <p>The configuration of the <code>OfflineStore</code>, inducing the S3 location of the
    /// <code>OfflineStore</code>, AWS Glue or AWS Hive data catalogue configurations, and the
    /// security configuration.</p>
    #[serde(rename = "OfflineStoreConfig")]
    #[serde(default)]
    pub offline_store_config: std::option::Option<crate::model::OfflineStoreConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to persist data into the
    /// <code>OfflineStore</code> if an <code>OfflineStoreConfig</code> is provided.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of the feature group.</p>
    #[serde(rename = "FeatureGroupStatus")]
    #[serde(default)]
    pub feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>The status of the <code>OfflineStore</code>. Notifies you if replicating data into the
    /// <code>OfflineStore</code> has failed. Returns either: <code>Active</code> or
    /// <code>Blocked</code>
    /// </p>
    #[serde(rename = "OfflineStoreStatus")]
    #[serde(default)]
    pub offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
    /// <p>The reason that the <code>FeatureGroup</code> failed to be replicated in the
    /// <code>OfflineStore</code>. This is failure can occur because:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>FeatureGroup</code> could not be created in the
    /// <code>OfflineStore</code>.</p>
    /// </li>
    /// <li>
    /// <p>The <code>FeatureGroup</code> could not be deleted from the
    /// <code>OfflineStore</code>.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>A free form description of the feature group.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A token to resume pagination of the list of <code>Features</code>
    /// (<code>FeatureDefinitions</code>).</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeFeatureGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFeatureGroupOutputBody");
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field(
            "record_identifier_feature_name",
            &self.record_identifier_feature_name,
        );
        formatter.field("event_time_feature_name", &self.event_time_feature_name);
        formatter.field("feature_definitions", &self.feature_definitions);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("online_store_config", &self.online_store_config);
        formatter.field("offline_store_config", &self.offline_store_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("feature_group_status", &self.feature_group_status);
        formatter.field("offline_store_status", &self.offline_store_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("description", &self.description);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFlowDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the flow defintion.</p>
    #[serde(rename = "FlowDefinitionArn")]
    #[serde(default)]
    pub flow_definition_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    #[serde(rename = "FlowDefinitionName")]
    #[serde(default)]
    pub flow_definition_name: std::option::Option<std::string::String>,
    /// <p>The status of the flow definition. Valid values are listed below.</p>
    #[serde(rename = "FlowDefinitionStatus")]
    #[serde(default)]
    pub flow_definition_status: std::option::Option<crate::model::FlowDefinitionStatus>,
    /// <p>The timestamp when the flow definition was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Container for configuring the source of human task requests. Used to specify if
    /// Amazon Rekognition or Amazon Textract is used as an integration source.</p>
    #[serde(rename = "HumanLoopRequestSource")]
    #[serde(default)]
    pub human_loop_request_source: std::option::Option<crate::model::HumanLoopRequestSource>,
    /// <p>An object containing information about what triggers a human review workflow.</p>
    #[serde(rename = "HumanLoopActivationConfig")]
    #[serde(default)]
    pub human_loop_activation_config: std::option::Option<crate::model::HumanLoopActivationConfig>,
    /// <p>An object containing information about who works on the task, the workforce task price, and other task details.</p>
    #[serde(rename = "HumanLoopConfig")]
    #[serde(default)]
    pub human_loop_config: std::option::Option<crate::model::HumanLoopConfig>,
    /// <p>An object containing information about the output file.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::FlowDefinitionOutputConfig>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) execution role for the flow definition.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The reason your flow definition failed.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeFlowDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFlowDefinitionOutputBody");
        formatter.field("flow_definition_arn", &self.flow_definition_arn);
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.field("flow_definition_status", &self.flow_definition_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("human_loop_request_source", &self.human_loop_request_source);
        formatter.field(
            "human_loop_activation_config",
            &self.human_loop_activation_config,
        );
        formatter.field("human_loop_config", &self.human_loop_config);
        formatter.field("output_config", &self.output_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeHumanTaskUiOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the human task user interface (worker task template).</p>
    #[serde(rename = "HumanTaskUiArn")]
    #[serde(default)]
    pub human_task_ui_arn: std::option::Option<std::string::String>,
    /// <p>The name of the human task user interface (worker task template).</p>
    #[serde(rename = "HumanTaskUiName")]
    #[serde(default)]
    pub human_task_ui_name: std::option::Option<std::string::String>,
    /// <p>The status of the human task user interface (worker task template). Valid values are listed below.</p>
    #[serde(rename = "HumanTaskUiStatus")]
    #[serde(default)]
    pub human_task_ui_status: std::option::Option<crate::model::HumanTaskUiStatus>,
    /// <p>The timestamp when the human task user interface was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Container for user interface template information.</p>
    #[serde(rename = "UiTemplate")]
    #[serde(default)]
    pub ui_template: std::option::Option<crate::model::UiTemplateInfo>,
}
impl std::fmt::Debug for DescribeHumanTaskUiOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeHumanTaskUiOutputBody");
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.field("human_task_ui_status", &self.human_task_ui_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("ui_template", &self.ui_template);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeHyperParameterTuningJobOutputBody {
    /// <p>The name of the tuning job.</p>
    #[serde(rename = "HyperParameterTuningJobName")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
    /// <p>The
    /// Amazon Resource Name (ARN) of the tuning job.</p>
    #[serde(rename = "HyperParameterTuningJobArn")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The <a>HyperParameterTuningJobConfig</a> object that specifies the
    /// configuration of the tuning job.</p>
    #[serde(rename = "HyperParameterTuningJobConfig")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_config:
        std::option::Option<crate::model::HyperParameterTuningJobConfig>,
    /// <p>The <a>HyperParameterTrainingJobDefinition</a> object that specifies the
    /// definition of the training jobs that this tuning job launches.</p>
    #[serde(rename = "TrainingJobDefinition")]
    #[serde(default)]
    pub training_job_definition:
        std::option::Option<crate::model::HyperParameterTrainingJobDefinition>,
    /// <p>A list of the <a>HyperParameterTrainingJobDefinition</a> objects launched
    /// for this tuning job.</p>
    #[serde(rename = "TrainingJobDefinitions")]
    #[serde(default)]
    pub training_job_definitions:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterTrainingJobDefinition>>,
    /// <p>The status of the tuning job: InProgress, Completed, Failed, Stopping, or
    /// Stopped.</p>
    #[serde(rename = "HyperParameterTuningJobStatus")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_status:
        std::option::Option<crate::model::HyperParameterTuningJobStatus>,
    /// <p>The date and time that the tuning job started.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the tuning job ended.</p>
    #[serde(rename = "HyperParameterTuningEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub hyper_parameter_tuning_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the status of the tuning job was modified. </p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The <a>TrainingJobStatusCounters</a> object that specifies the number of
    /// training jobs, categorized by status, that this tuning job launched.</p>
    #[serde(rename = "TrainingJobStatusCounters")]
    #[serde(default)]
    pub training_job_status_counters: std::option::Option<crate::model::TrainingJobStatusCounters>,
    /// <p>The <a>ObjectiveStatusCounters</a> object that specifies the number of
    /// training jobs, categorized by the status of their final objective metric, that this
    /// tuning job launched.</p>
    #[serde(rename = "ObjectiveStatusCounters")]
    #[serde(default)]
    pub objective_status_counters: std::option::Option<crate::model::ObjectiveStatusCounters>,
    /// <p>A <a>TrainingJobSummary</a> object that describes the training job that
    /// completed with the best current <a>HyperParameterTuningJobObjective</a>.</p>
    #[serde(rename = "BestTrainingJob")]
    #[serde(default)]
    pub best_training_job: std::option::Option<crate::model::HyperParameterTrainingJobSummary>,
    /// <p>If the hyperparameter tuning job is an warm start tuning job with a
    /// <code>WarmStartType</code> of <code>IDENTICAL_DATA_AND_ALGORITHM</code>, this is the
    /// <a>TrainingJobSummary</a> for the training job with the best objective
    /// metric value of all training jobs launched by this tuning job and all parent jobs
    /// specified for the warm start tuning job.</p>
    #[serde(rename = "OverallBestTrainingJob")]
    #[serde(default)]
    pub overall_best_training_job:
        std::option::Option<crate::model::HyperParameterTrainingJobSummary>,
    /// <p>The configuration for starting the hyperparameter parameter tuning job using one or
    /// more previous tuning jobs as a starting point. The results of previous tuning jobs are
    /// used to inform which combinations of hyperparameters to search over in the new tuning
    /// job.</p>
    #[serde(rename = "WarmStartConfig")]
    #[serde(default)]
    pub warm_start_config:
        std::option::Option<crate::model::HyperParameterTuningJobWarmStartConfig>,
    /// <p>If the tuning job failed, the reason it failed.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeHyperParameterTuningJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeHyperParameterTuningJobOutputBody");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.field(
            "hyper_parameter_tuning_job_arn",
            &self.hyper_parameter_tuning_job_arn,
        );
        formatter.field(
            "hyper_parameter_tuning_job_config",
            &self.hyper_parameter_tuning_job_config,
        );
        formatter.field("training_job_definition", &self.training_job_definition);
        formatter.field("training_job_definitions", &self.training_job_definitions);
        formatter.field(
            "hyper_parameter_tuning_job_status",
            &self.hyper_parameter_tuning_job_status,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "hyper_parameter_tuning_end_time",
            &self.hyper_parameter_tuning_end_time,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "training_job_status_counters",
            &self.training_job_status_counters,
        );
        formatter.field("objective_status_counters", &self.objective_status_counters);
        formatter.field("best_training_job", &self.best_training_job);
        formatter.field("overall_best_training_job", &self.overall_best_training_job);
        formatter.field("warm_start_config", &self.warm_start_config);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeImageOutputBody {
    /// <p>When the image was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The description of the image.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the image as displayed.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    #[serde(rename = "ImageArn")]
    #[serde(default)]
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The name of the image.</p>
    #[serde(rename = "ImageName")]
    #[serde(default)]
    pub image_name: std::option::Option<std::string::String>,
    /// <p>The status of the image.</p>
    #[serde(rename = "ImageStatus")]
    #[serde(default)]
    pub image_status: std::option::Option<crate::model::ImageStatus>,
    /// <p>When the image was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that enables Amazon SageMaker to perform tasks on your behalf.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeImageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeImageOutputBody");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("display_name", &self.display_name);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_name", &self.image_name);
        formatter.field("image_status", &self.image_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeImageVersionOutputBody {
    /// <p>The registry path of the container image on which this image version is based.</p>
    #[serde(rename = "BaseImage")]
    #[serde(default)]
    pub base_image: std::option::Option<std::string::String>,
    /// <p>The registry path of the container image that contains this image version.</p>
    #[serde(rename = "ContainerImage")]
    #[serde(default)]
    pub container_image: std::option::Option<std::string::String>,
    /// <p>When the version was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When a create or delete operation fails, the reason for the failure.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
    #[serde(rename = "ImageArn")]
    #[serde(default)]
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the version.</p>
    #[serde(rename = "ImageVersionArn")]
    #[serde(default)]
    pub image_version_arn: std::option::Option<std::string::String>,
    /// <p>The status of the version.</p>
    #[serde(rename = "ImageVersionStatus")]
    #[serde(default)]
    pub image_version_status: std::option::Option<crate::model::ImageVersionStatus>,
    /// <p>When the version was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The version number.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeImageVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeImageVersionOutputBody");
        formatter.field("base_image", &self.base_image);
        formatter.field("container_image", &self.container_image);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_version_arn", &self.image_version_arn);
        formatter.field("image_version_status", &self.image_version_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLabelingJobOutputBody {
    /// <p>The processing status of the labeling job. </p>
    #[serde(rename = "LabelingJobStatus")]
    #[serde(default)]
    pub labeling_job_status: std::option::Option<crate::model::LabelingJobStatus>,
    /// <p>Provides a breakdown of the number of data objects labeled by humans, the number of
    /// objects labeled by machine, the number of objects than couldn't be labeled, and the
    /// total number of objects labeled. </p>
    #[serde(rename = "LabelCounters")]
    #[serde(default)]
    pub label_counters: std::option::Option<crate::model::LabelCounters>,
    /// <p>If the job failed, the reason that it failed. </p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that the labeling job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the labeling job was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A unique identifier for work done as part of a labeling job.</p>
    #[serde(rename = "JobReferenceCode")]
    #[serde(default)]
    pub job_reference_code: std::option::Option<std::string::String>,
    /// <p>The name assigned to the labeling job when it was created.</p>
    #[serde(rename = "LabelingJobName")]
    #[serde(default)]
    pub labeling_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
    #[serde(rename = "LabelingJobArn")]
    #[serde(default)]
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The attribute used as the label in the output manifest file.</p>
    #[serde(rename = "LabelAttributeName")]
    #[serde(default)]
    pub label_attribute_name: std::option::Option<std::string::String>,
    /// <p>Input configuration information for the labeling job, such as the Amazon S3 location of the
    /// data objects and the location of the manifest file that describes the data
    /// objects.</p>
    #[serde(rename = "InputConfig")]
    #[serde(default)]
    pub input_config: std::option::Option<crate::model::LabelingJobInputConfig>,
    /// <p>The location of the job's output data and the AWS Key Management Service key ID for the key used to
    /// encrypt the output data, if any.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::LabelingJobOutputConfig>,
    /// <p>The Amazon Resource Name (ARN) that Amazon SageMaker assumes to perform tasks on your behalf
    /// during data labeling.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The S3 location of the JSON file that defines the categories used to label data
    /// objects. Please note the following label-category limits:</p>
    /// <ul>
    /// <li>
    /// <p>Semantic segmentation labeling jobs using automated labeling: 20 labels</p>
    /// </li>
    /// <li>
    /// <p>Box bounding labeling jobs (all): 10 labels</p>
    /// </li>
    /// </ul>
    /// <p>The file is a JSON structure in the following format:</p>
    /// <p>
    /// <code>{</code>
    /// </p>
    /// <p>
    /// <code> "document-version": "2018-11-28"</code>
    /// </p>
    /// <p>
    /// <code> "labels": [</code>
    /// </p>
    /// <p>
    /// <code> {</code>
    /// </p>
    /// <p>
    /// <code> "label": "<i>label 1</i>"</code>
    /// </p>
    /// <p>
    /// <code> },</code>
    /// </p>
    /// <p>
    /// <code> {</code>
    /// </p>
    /// <p>
    /// <code> "label": "<i>label 2</i>"</code>
    /// </p>
    /// <p>
    /// <code> },</code>
    /// </p>
    /// <p>
    /// <code> ...</code>
    /// </p>
    /// <p>
    /// <code> {</code>
    /// </p>
    /// <p>
    /// <code> "label": "<i>label n</i>"</code>
    /// </p>
    /// <p>
    /// <code> }</code>
    /// </p>
    /// <p>
    /// <code> ]</code>
    /// </p>
    /// <p>
    /// <code>}</code>
    /// </p>
    #[serde(rename = "LabelCategoryConfigS3Uri")]
    #[serde(default)]
    pub label_category_config_s3_uri: std::option::Option<std::string::String>,
    /// <p>A set of conditions for stopping a labeling job. If any of the conditions are met, the
    /// job is automatically stopped.</p>
    #[serde(rename = "StoppingConditions")]
    #[serde(default)]
    pub stopping_conditions: std::option::Option<crate::model::LabelingJobStoppingConditions>,
    /// <p>Configuration information for automated data labeling.</p>
    #[serde(rename = "LabelingJobAlgorithmsConfig")]
    #[serde(default)]
    pub labeling_job_algorithms_config:
        std::option::Option<crate::model::LabelingJobAlgorithmsConfig>,
    /// <p>Configuration information required for human workers to complete a labeling
    /// task.</p>
    #[serde(rename = "HumanTaskConfig")]
    #[serde(default)]
    pub human_task_config: std::option::Option<crate::model::HumanTaskConfig>,
    /// <p>An array of key-value pairs. You can use tags to categorize your AWS resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    /// Resources</a>.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The location of the output produced by the labeling job.</p>
    #[serde(rename = "LabelingJobOutput")]
    #[serde(default)]
    pub labeling_job_output: std::option::Option<crate::model::LabelingJobOutput>,
}
impl std::fmt::Debug for DescribeLabelingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLabelingJobOutputBody");
        formatter.field("labeling_job_status", &self.labeling_job_status);
        formatter.field("label_counters", &self.label_counters);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("job_reference_code", &self.job_reference_code);
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("label_attribute_name", &self.label_attribute_name);
        formatter.field("input_config", &self.input_config);
        formatter.field("output_config", &self.output_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "label_category_config_s3_uri",
            &self.label_category_config_s3_uri,
        );
        formatter.field("stopping_conditions", &self.stopping_conditions);
        formatter.field(
            "labeling_job_algorithms_config",
            &self.labeling_job_algorithms_config,
        );
        formatter.field("human_task_config", &self.human_task_config);
        formatter.field("tags", &self.tags);
        formatter.field("labeling_job_output", &self.labeling_job_output);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelOutputBody {
    /// <p>Name of the Amazon SageMaker model.</p>
    #[serde(rename = "ModelName")]
    #[serde(default)]
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The location of the primary inference code, associated artifacts, and custom
    /// environment map that the inference code uses when it is deployed in production.
    /// </p>
    #[serde(rename = "PrimaryContainer")]
    #[serde(default)]
    pub primary_container: std::option::Option<crate::model::ContainerDefinition>,
    /// <p>The containers in the inference pipeline.</p>
    #[serde(rename = "Containers")]
    #[serde(default)]
    pub containers: std::option::Option<std::vec::Vec<crate::model::ContainerDefinition>>,
    /// <p>Specifies details of how containers in a multi-container endpoint are called.</p>
    #[serde(rename = "InferenceExecutionConfig")]
    #[serde(default)]
    pub inference_execution_config: std::option::Option<crate::model::InferenceExecutionConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that you specified for the
    /// model.</p>
    #[serde(rename = "ExecutionRoleArn")]
    #[serde(default)]
    pub execution_role_arn: std::option::Option<std::string::String>,
    /// <p>A <a>VpcConfig</a> object that specifies the VPC that this model has access
    /// to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual
    /// Private Cloud</a>
    /// </p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>A timestamp that shows when the model was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    #[serde(rename = "ModelArn")]
    #[serde(default)]
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>If <code>True</code>, no inbound or outbound network calls can be made to or from the
    /// model container.</p>
    #[serde(rename = "EnableNetworkIsolation")]
    #[serde(default)]
    pub enable_network_isolation: bool,
}
impl std::fmt::Debug for DescribeModelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelOutputBody");
        formatter.field("model_name", &self.model_name);
        formatter.field("primary_container", &self.primary_container);
        formatter.field("containers", &self.containers);
        formatter.field(
            "inference_execution_config",
            &self.inference_execution_config,
        );
        formatter.field("execution_role_arn", &self.execution_role_arn);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("model_arn", &self.model_arn);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelBiasJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model bias job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The name of the bias job definition. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    #[serde(rename = "JobDefinitionName")]
    #[serde(default)]
    pub job_definition_name: std::option::Option<std::string::String>,
    /// <p>The time at which the model bias job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The baseline configuration for a model bias job.</p>
    #[serde(rename = "ModelBiasBaselineConfig")]
    #[serde(default)]
    pub model_bias_baseline_config: std::option::Option<crate::model::ModelBiasBaselineConfig>,
    /// <p>Configures the model bias job to run a specified Docker container image.</p>
    #[serde(rename = "ModelBiasAppSpecification")]
    #[serde(default)]
    pub model_bias_app_specification: std::option::Option<crate::model::ModelBiasAppSpecification>,
    /// <p>Inputs for the model bias job.</p>
    #[serde(rename = "ModelBiasJobInput")]
    #[serde(default)]
    pub model_bias_job_input: std::option::Option<crate::model::ModelBiasJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    #[serde(rename = "ModelBiasJobOutputConfig")]
    #[serde(default)]
    pub model_bias_job_output_config: std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    #[serde(rename = "JobResources")]
    #[serde(default)]
    pub job_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>Networking options for a model bias job.</p>
    #[serde(rename = "NetworkConfig")]
    #[serde(default)]
    pub network_config: std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    /// has read permission to the input data location and write permission to the output data
    /// location in Amazon S3.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
}
impl std::fmt::Debug for DescribeModelBiasJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelBiasJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "model_bias_baseline_config",
            &self.model_bias_baseline_config,
        );
        formatter.field(
            "model_bias_app_specification",
            &self.model_bias_app_specification,
        );
        formatter.field("model_bias_job_input", &self.model_bias_job_input);
        formatter.field(
            "model_bias_job_output_config",
            &self.model_bias_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelExplainabilityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model explainability job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The name of the explainability job definition. The name must be unique within an AWS
    /// Region in the AWS account.</p>
    #[serde(rename = "JobDefinitionName")]
    #[serde(default)]
    pub job_definition_name: std::option::Option<std::string::String>,
    /// <p>The time at which the model explainability job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The baseline configuration for a model explainability job.</p>
    #[serde(rename = "ModelExplainabilityBaselineConfig")]
    #[serde(default)]
    pub model_explainability_baseline_config:
        std::option::Option<crate::model::ModelExplainabilityBaselineConfig>,
    /// <p>Configures the model explainability job to run a specified Docker container
    /// image.</p>
    #[serde(rename = "ModelExplainabilityAppSpecification")]
    #[serde(default)]
    pub model_explainability_app_specification:
        std::option::Option<crate::model::ModelExplainabilityAppSpecification>,
    /// <p>Inputs for the model explainability job.</p>
    #[serde(rename = "ModelExplainabilityJobInput")]
    #[serde(default)]
    pub model_explainability_job_input:
        std::option::Option<crate::model::ModelExplainabilityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    #[serde(rename = "ModelExplainabilityJobOutputConfig")]
    #[serde(default)]
    pub model_explainability_job_output_config:
        std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    #[serde(rename = "JobResources")]
    #[serde(default)]
    pub job_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>Networking options for a model explainability job.</p>
    #[serde(rename = "NetworkConfig")]
    #[serde(default)]
    pub network_config: std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    /// has read permission to the input data location and write permission to the output data
    /// location in Amazon S3.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
}
impl std::fmt::Debug for DescribeModelExplainabilityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelExplainabilityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "model_explainability_baseline_config",
            &self.model_explainability_baseline_config,
        );
        formatter.field(
            "model_explainability_app_specification",
            &self.model_explainability_app_specification,
        );
        formatter.field(
            "model_explainability_job_input",
            &self.model_explainability_job_input,
        );
        formatter.field(
            "model_explainability_job_output_config",
            &self.model_explainability_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelPackageOutputBody {
    /// <p>The name of the model package being described.</p>
    #[serde(rename = "ModelPackageName")]
    #[serde(default)]
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>If the model is a versioned model, the name of the model group that the versioned
    /// model belongs to.</p>
    #[serde(rename = "ModelPackageGroupName")]
    #[serde(default)]
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The version of the model package.</p>
    #[serde(rename = "ModelPackageVersion")]
    #[serde(default)]
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    #[serde(rename = "ModelPackageArn")]
    #[serde(default)]
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>A brief summary of the model package.</p>
    #[serde(rename = "ModelPackageDescription")]
    #[serde(default)]
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>A timestamp specifying when the model package was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Details about inference jobs that can be run with models based on this model
    /// package.</p>
    #[serde(rename = "InferenceSpecification")]
    #[serde(default)]
    pub inference_specification: std::option::Option<crate::model::InferenceSpecification>,
    /// <p>Details about the algorithm that was used to create the model package.</p>
    #[serde(rename = "SourceAlgorithmSpecification")]
    #[serde(default)]
    pub source_algorithm_specification:
        std::option::Option<crate::model::SourceAlgorithmSpecification>,
    /// <p>Configurations for one or more transform jobs that Amazon SageMaker runs to test the model
    /// package.</p>
    #[serde(rename = "ValidationSpecification")]
    #[serde(default)]
    pub validation_specification:
        std::option::Option<crate::model::ModelPackageValidationSpecification>,
    /// <p>The current status of the model package.</p>
    #[serde(rename = "ModelPackageStatus")]
    #[serde(default)]
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>Details about the current status of the model package.</p>
    #[serde(rename = "ModelPackageStatusDetails")]
    #[serde(default)]
    pub model_package_status_details: std::option::Option<crate::model::ModelPackageStatusDetails>,
    /// <p>Whether the model package is certified for listing on AWS Marketplace.</p>
    #[serde(rename = "CertifyForMarketplace")]
    #[serde(default)]
    pub certify_for_marketplace: bool,
    /// <p>The approval status of the model package.</p>
    #[serde(rename = "ModelApprovalStatus")]
    #[serde(default)]
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    #[serde(rename = "MetadataProperties")]
    #[serde(default)]
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>Metrics for the model.</p>
    #[serde(rename = "ModelMetrics")]
    #[serde(default)]
    pub model_metrics: std::option::Option<crate::model::ModelMetrics>,
    /// <p>The last time the model package was modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>A description provided for the model approval.</p>
    #[serde(rename = "ApprovalDescription")]
    #[serde(default)]
    pub approval_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeModelPackageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelPackageOutputBody");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field(
            "source_algorithm_specification",
            &self.source_algorithm_specification,
        );
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field(
            "model_package_status_details",
            &self.model_package_status_details,
        );
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("created_by", &self.created_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("model_metrics", &self.model_metrics);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("approval_description", &self.approval_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelPackageGroupOutputBody {
    /// <p>The name of the model group.</p>
    #[serde(rename = "ModelPackageGroupName")]
    #[serde(default)]
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    #[serde(rename = "ModelPackageGroupArn")]
    #[serde(default)]
    pub model_package_group_arn: std::option::Option<std::string::String>,
    /// <p>A description of the model group.</p>
    #[serde(rename = "ModelPackageGroupDescription")]
    #[serde(default)]
    pub model_package_group_description: std::option::Option<std::string::String>,
    /// <p>The time that the model group was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>The status of the model group.</p>
    #[serde(rename = "ModelPackageGroupStatus")]
    #[serde(default)]
    pub model_package_group_status: std::option::Option<crate::model::ModelPackageGroupStatus>,
}
impl std::fmt::Debug for DescribeModelPackageGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelPackageGroupOutputBody");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field(
            "model_package_group_status",
            &self.model_package_group_status,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeModelQualityJobDefinitionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model quality job.</p>
    #[serde(rename = "JobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The name of the quality job definition. The name must be unique within an AWS Region in
    /// the AWS account.</p>
    #[serde(rename = "JobDefinitionName")]
    #[serde(default)]
    pub job_definition_name: std::option::Option<std::string::String>,
    /// <p>The time at which the model quality job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The baseline configuration for a model quality job.</p>
    #[serde(rename = "ModelQualityBaselineConfig")]
    #[serde(default)]
    pub model_quality_baseline_config:
        std::option::Option<crate::model::ModelQualityBaselineConfig>,
    /// <p>Configures the model quality job to run a specified Docker container image.</p>
    #[serde(rename = "ModelQualityAppSpecification")]
    #[serde(default)]
    pub model_quality_app_specification:
        std::option::Option<crate::model::ModelQualityAppSpecification>,
    /// <p>Inputs for the model quality job.</p>
    #[serde(rename = "ModelQualityJobInput")]
    #[serde(default)]
    pub model_quality_job_input: std::option::Option<crate::model::ModelQualityJobInput>,
    /// <p>The output configuration for monitoring jobs.</p>
    #[serde(rename = "ModelQualityJobOutputConfig")]
    #[serde(default)]
    pub model_quality_job_output_config: std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources to deploy for a monitoring job.</p>
    #[serde(rename = "JobResources")]
    #[serde(default)]
    pub job_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>Networking options for a model quality job.</p>
    #[serde(rename = "NetworkConfig")]
    #[serde(default)]
    pub network_config: std::option::Option<crate::model::MonitoringNetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to
    /// perform tasks on your behalf.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
}
impl std::fmt::Debug for DescribeModelQualityJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeModelQualityJobDefinitionOutputBody");
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "model_quality_baseline_config",
            &self.model_quality_baseline_config,
        );
        formatter.field(
            "model_quality_app_specification",
            &self.model_quality_app_specification,
        );
        formatter.field("model_quality_job_input", &self.model_quality_job_input);
        formatter.field(
            "model_quality_job_output_config",
            &self.model_quality_job_output_config,
        );
        formatter.field("job_resources", &self.job_resources);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMonitoringScheduleOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    #[serde(rename = "MonitoringScheduleArn")]
    #[serde(default)]
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>Name of the monitoring schedule.</p>
    #[serde(rename = "MonitoringScheduleName")]
    #[serde(default)]
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The status of an monitoring job.</p>
    #[serde(rename = "MonitoringScheduleStatus")]
    #[serde(default)]
    pub monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
    /// <p>The type of the monitoring job that this schedule runs. This is one of the following
    /// values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DATA_QUALITY</code> - The schedule is for a data quality monitoring
    /// job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODEL_QUALITY</code> - The schedule is for a model quality monitoring
    /// job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODEL_BIAS</code> - The schedule is for a bias monitoring job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODEL_EXPLAINABILITY</code> - The schedule is for an explainability
    /// monitoring job.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "MonitoringType")]
    #[serde(default)]
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
    /// <p>A string, up to one KB in size, that contains the reason a monitoring job failed, if it
    /// failed.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time at which the monitoring job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the monitoring job was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The configuration object that specifies the monitoring schedule and defines the
    /// monitoring job.</p>
    #[serde(rename = "MonitoringScheduleConfig")]
    #[serde(default)]
    pub monitoring_schedule_config: std::option::Option<crate::model::MonitoringScheduleConfig>,
    /// <p> The name of the endpoint for the monitoring job.</p>
    #[serde(rename = "EndpointName")]
    #[serde(default)]
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Describes metadata on the last execution to run, if there was one.</p>
    #[serde(rename = "LastMonitoringExecutionSummary")]
    #[serde(default)]
    pub last_monitoring_execution_summary:
        std::option::Option<crate::model::MonitoringExecutionSummary>,
}
impl std::fmt::Debug for DescribeMonitoringScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMonitoringScheduleOutputBody");
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field(
            "monitoring_schedule_status",
            &self.monitoring_schedule_status,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_schedule_config",
            &self.monitoring_schedule_config,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "last_monitoring_execution_summary",
            &self.last_monitoring_execution_summary,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeNotebookInstanceOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
    #[serde(rename = "NotebookInstanceArn")]
    #[serde(default)]
    pub notebook_instance_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon SageMaker notebook instance. </p>
    #[serde(rename = "NotebookInstanceName")]
    #[serde(default)]
    pub notebook_instance_name: std::option::Option<std::string::String>,
    /// <p>The status of the notebook instance.</p>
    #[serde(rename = "NotebookInstanceStatus")]
    #[serde(default)]
    pub notebook_instance_status: std::option::Option<crate::model::NotebookInstanceStatus>,
    /// <p>If status is <code>Failed</code>, the reason it failed.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The URL that you use to connect to the Jupyter notebook that is running in your
    /// notebook instance. </p>
    #[serde(rename = "Url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The type of ML compute instance running on the notebook instance.</p>
    #[serde(rename = "InstanceType")]
    #[serde(default)]
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The ID of the VPC subnet.</p>
    #[serde(rename = "SubnetId")]
    #[serde(default)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the VPC security groups.</p>
    #[serde(rename = "SecurityGroups")]
    #[serde(default)]
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the instance.
    /// </p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage
    /// volume attached to the instance. </p>
    #[serde(rename = "KmsKeyId")]
    #[serde(default)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The network interface IDs that Amazon SageMaker created at the time of creating the instance.
    /// </p>
    #[serde(rename = "NetworkInterfaceId")]
    #[serde(default)]
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>A timestamp. Use this parameter to retrieve the time when the notebook instance was
    /// last modified. </p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp. Use this parameter to return the time when the notebook instance was
    /// created</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Returns the name of a notebook instance lifecycle configuration.</p>
    /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step
    /// 2.1: (Optional) Customize a Notebook Instance</a>
    /// </p>
    #[serde(rename = "NotebookInstanceLifecycleConfigName")]
    #[serde(default)]
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>Describes whether Amazon SageMaker provides internet access to the notebook instance. If this
    /// value is set to <i>Disabled</i>, the notebook instance does not have
    /// internet access, and cannot connect to Amazon SageMaker training and endpoint services.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/appendix-additional-considerations.html#appendix-notebook-and-internet-access">Notebook Instances Are Internet-Enabled by Default</a>.</p>
    #[serde(rename = "DirectInternetAccess")]
    #[serde(default)]
    pub direct_internet_access: std::option::Option<crate::model::DirectInternetAccess>,
    /// <p>The size, in GB, of the ML storage volume attached to the notebook instance.</p>
    #[serde(rename = "VolumeSizeInGB")]
    #[serde(default)]
    pub volume_size_in_gb: std::option::Option<i32>,
    /// <p>A list of the Elastic Inference (EI) instance types associated with this notebook
    /// instance. Currently only one EI instance type can be associated with a notebook
    /// instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic Inference in Amazon
    /// SageMaker</a>.</p>
    #[serde(rename = "AcceleratorTypes")]
    #[serde(default)]
    pub accelerator_types:
        std::option::Option<std::vec::Vec<crate::model::NotebookInstanceAcceleratorType>>,
    /// <p>The Git repository associated with the notebook instance as its default code
    /// repository. This can be either the name of a Git repository stored as a resource in your
    /// account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. When you open a notebook instance, it opens in the directory that
    /// contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with Amazon SageMaker
    /// Notebook Instances</a>.</p>
    #[serde(rename = "DefaultCodeRepository")]
    #[serde(default)]
    pub default_code_repository: std::option::Option<std::string::String>,
    /// <p>An array of up to three Git repositories associated with the notebook instance. These
    /// can be either the names of Git repositories stored as resources in your account, or the
    /// URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a> or in any
    /// other Git repository. These repositories are cloned at the same level as the default
    /// repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git
    /// Repositories with Amazon SageMaker Notebook Instances</a>.</p>
    #[serde(rename = "AdditionalCodeRepositories")]
    #[serde(default)]
    pub additional_code_repositories: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether root access is enabled or disabled for users of the notebook instance.</p>
    /// <note>
    /// <p>Lifecycle configurations need root access to be able to set up a notebook
    /// instance. Because of this, lifecycle configurations associated with a notebook
    /// instance always run with root access even if you disable root access for
    /// users.</p>
    /// </note>
    #[serde(rename = "RootAccess")]
    #[serde(default)]
    pub root_access: std::option::Option<crate::model::RootAccess>,
}
impl std::fmt::Debug for DescribeNotebookInstanceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotebookInstanceOutputBody");
        formatter.field("notebook_instance_arn", &self.notebook_instance_arn);
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field("notebook_instance_status", &self.notebook_instance_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("url", &self.url);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("direct_internet_access", &self.direct_internet_access);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("accelerator_types", &self.accelerator_types);
        formatter.field("default_code_repository", &self.default_code_repository);
        formatter.field(
            "additional_code_repositories",
            &self.additional_code_repositories,
        );
        formatter.field("root_access", &self.root_access);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeNotebookInstanceLifecycleConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
    #[serde(rename = "NotebookInstanceLifecycleConfigArn")]
    #[serde(default)]
    pub notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the lifecycle configuration.</p>
    #[serde(rename = "NotebookInstanceLifecycleConfigName")]
    #[serde(default)]
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The shell script that runs only once, when you create a notebook instance.</p>
    #[serde(rename = "OnCreate")]
    #[serde(default)]
    pub on_create: std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
    /// <p>The shell script that runs every time you start a notebook instance, including when
    /// you create the notebook instance.</p>
    #[serde(rename = "OnStart")]
    #[serde(default)]
    pub on_start: std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleHook>>,
    /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DescribeNotebookInstanceLifecycleConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotebookInstanceLifecycleConfigOutputBody");
        formatter.field(
            "notebook_instance_lifecycle_config_arn",
            &self.notebook_instance_lifecycle_config_arn,
        );
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("on_create", &self.on_create);
        formatter.field("on_start", &self.on_start);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    #[serde(rename = "PipelineArn")]
    #[serde(default)]
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline.</p>
    #[serde(rename = "PipelineName")]
    #[serde(default)]
    pub pipeline_name: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    #[serde(rename = "PipelineDisplayName")]
    #[serde(default)]
    pub pipeline_display_name: std::option::Option<std::string::String>,
    /// <p>The JSON pipeline definition.</p>
    #[serde(rename = "PipelineDefinition")]
    #[serde(default)]
    pub pipeline_definition: std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    #[serde(rename = "PipelineDescription")]
    #[serde(default)]
    pub pipeline_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that the pipeline uses to execute.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline execution.</p>
    #[serde(rename = "PipelineStatus")]
    #[serde(default)]
    pub pipeline_status: std::option::Option<crate::model::PipelineStatus>,
    /// <p>The time when the pipeline was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the pipeline was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the pipeline was last run.</p>
    #[serde(rename = "LastRunTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_run_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for DescribePipelineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineOutputBody");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_definition", &self.pipeline_definition);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("pipeline_status", &self.pipeline_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_run_time", &self.last_run_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineDefinitionForExecutionOutputBody {
    /// <p>The JSON pipeline definition.</p>
    #[serde(rename = "PipelineDefinition")]
    #[serde(default)]
    pub pipeline_definition: std::option::Option<std::string::String>,
    /// <p>The time when the pipeline was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DescribePipelineDefinitionForExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineDefinitionForExecutionOutputBody");
        formatter.field("pipeline_definition", &self.pipeline_definition);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePipelineExecutionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    #[serde(rename = "PipelineArn")]
    #[serde(default)]
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionDisplayName")]
    #[serde(default)]
    pub pipeline_execution_display_name: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionStatus")]
    #[serde(default)]
    pub pipeline_execution_status: std::option::Option<crate::model::PipelineExecutionStatus>,
    /// <p>The description of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionDescription")]
    #[serde(default)]
    pub pipeline_execution_description: std::option::Option<std::string::String>,
    /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
    #[serde(rename = "PipelineExperimentConfig")]
    #[serde(default)]
    pub pipeline_experiment_config: std::option::Option<crate::model::PipelineExperimentConfig>,
    /// <p>If the execution failed, a message describing why.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time when the pipeline execution was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the pipeline execution was modified last.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for DescribePipelineExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePipelineExecutionOutputBody");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.field("pipeline_execution_status", &self.pipeline_execution_status);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_experiment_config",
            &self.pipeline_experiment_config,
        );
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProcessingJobOutputBody {
    /// <p>The inputs for a processing job.</p>
    #[serde(rename = "ProcessingInputs")]
    #[serde(default)]
    pub processing_inputs: std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
    /// <p>Output configuration for the processing job.</p>
    #[serde(rename = "ProcessingOutputConfig")]
    #[serde(default)]
    pub processing_output_config: std::option::Option<crate::model::ProcessingOutputConfig>,
    /// <p>The name of the processing job. The name must be unique within an AWS Region in the
    /// AWS account.</p>
    #[serde(rename = "ProcessingJobName")]
    #[serde(default)]
    pub processing_job_name: std::option::Option<std::string::String>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
    /// processing job. In distributed training, you specify more than one instance.</p>
    #[serde(rename = "ProcessingResources")]
    #[serde(default)]
    pub processing_resources: std::option::Option<crate::model::ProcessingResources>,
    /// <p>The time limit for how long the processing job is allowed to run.</p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::ProcessingStoppingCondition>,
    /// <p>Configures the processing job to run a specified container image.</p>
    #[serde(rename = "AppSpecification")]
    #[serde(default)]
    pub app_specification: std::option::Option<crate::model::AppSpecification>,
    /// <p>The environment variables set in the Docker container.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Networking options for a processing job.</p>
    #[serde(rename = "NetworkConfig")]
    #[serde(default)]
    pub network_config: std::option::Option<crate::model::NetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on
    /// your behalf.</p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The configuration information used to create an experiment.</p>
    #[serde(rename = "ExperimentConfig")]
    #[serde(default)]
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
    #[serde(rename = "ProcessingJobArn")]
    #[serde(default)]
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>Provides the status of a processing job.</p>
    #[serde(rename = "ProcessingJobStatus")]
    #[serde(default)]
    pub processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>An optional string, up to one KB in size, that contains metadata from the processing
    /// container when the processing job exits.</p>
    #[serde(rename = "ExitMessage")]
    #[serde(default)]
    pub exit_message: std::option::Option<std::string::String>,
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if
    /// it failed.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time at which the processing job completed.</p>
    #[serde(rename = "ProcessingEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub processing_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the processing job started.</p>
    #[serde(rename = "ProcessingStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub processing_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the processing job was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the processing job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing
    /// job.</p>
    #[serde(rename = "MonitoringScheduleArn")]
    #[serde(default)]
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of an AutoML job associated with this processing job.</p>
    #[serde(rename = "AutoMLJobArn")]
    #[serde(default)]
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a training job associated with this processing job.</p>
    #[serde(rename = "TrainingJobArn")]
    #[serde(default)]
    pub training_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeProcessingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProcessingJobOutputBody");
        formatter.field("processing_inputs", &self.processing_inputs);
        formatter.field("processing_output_config", &self.processing_output_config);
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_resources", &self.processing_resources);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("app_specification", &self.app_specification);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("processing_job_status", &self.processing_job_status);
        formatter.field("exit_message", &self.exit_message);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("processing_end_time", &self.processing_end_time);
        formatter.field("processing_start_time", &self.processing_start_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProjectOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    #[serde(rename = "ProjectArn")]
    #[serde(default)]
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[serde(rename = "ProjectName")]
    #[serde(default)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The ID of the project.</p>
    #[serde(rename = "ProjectId")]
    #[serde(default)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The description of the project.</p>
    #[serde(rename = "ProjectDescription")]
    #[serde(default)]
    pub project_description: std::option::Option<std::string::String>,
    /// <p>Information used to provision a service catalog product. For information, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is AWS Service
    /// Catalog</a>.</p>
    #[serde(rename = "ServiceCatalogProvisioningDetails")]
    #[serde(default)]
    pub service_catalog_provisioning_details:
        std::option::Option<crate::model::ServiceCatalogProvisioningDetails>,
    /// <p>Information about a provisioned service catalog product.</p>
    #[serde(rename = "ServiceCatalogProvisionedProductDetails")]
    #[serde(default)]
    pub service_catalog_provisioned_product_details:
        std::option::Option<crate::model::ServiceCatalogProvisionedProductDetails>,
    /// <p>The status of the project.</p>
    #[serde(rename = "ProjectStatus")]
    #[serde(default)]
    pub project_status: std::option::Option<crate::model::ProjectStatus>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>The time when the project was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DescribeProjectOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProjectOutputBody");
        formatter.field("project_arn", &self.project_arn);
        formatter.field("project_name", &self.project_name);
        formatter.field("project_id", &self.project_id);
        formatter.field("project_description", &self.project_description);
        formatter.field(
            "service_catalog_provisioning_details",
            &self.service_catalog_provisioning_details,
        );
        formatter.field(
            "service_catalog_provisioned_product_details",
            &self.service_catalog_provisioned_product_details,
        );
        formatter.field("project_status", &self.project_status);
        formatter.field("created_by", &self.created_by);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscribedWorkteamOutputBody {
    /// <p>A <code>Workteam</code> instance that contains information about the work team.</p>
    #[serde(rename = "SubscribedWorkteam")]
    #[serde(default)]
    pub subscribed_workteam: std::option::Option<crate::model::SubscribedWorkteam>,
}
impl std::fmt::Debug for DescribeSubscribedWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscribedWorkteamOutputBody");
        formatter.field("subscribed_workteam", &self.subscribed_workteam);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrainingJobOutputBody {
    /// <p> Name of the model training job. </p>
    #[serde(rename = "TrainingJobName")]
    #[serde(default)]
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    #[serde(rename = "TrainingJobArn")]
    #[serde(default)]
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the
    /// training job was launched by a hyperparameter tuning job.</p>
    #[serde(rename = "TuningJobArn")]
    #[serde(default)]
    pub tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the
    /// transform or training job.</p>
    #[serde(rename = "LabelingJobArn")]
    #[serde(default)]
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an AutoML job.</p>
    #[serde(rename = "AutoMLJobArn")]
    #[serde(default)]
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>Information about the Amazon S3 location that is configured for storing model artifacts.
    /// </p>
    #[serde(rename = "ModelArtifacts")]
    #[serde(default)]
    pub model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
    /// <p>The status of the
    /// training
    /// job.</p>
    /// <p>Amazon SageMaker provides the following training job statuses:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>InProgress</code> - The training is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The training job has completed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The training job has failed. To see the reason for the
    /// failure, see the <code>FailureReason</code> field in the response to a
    /// <code>DescribeTrainingJobResponse</code> call.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - The training job is stopping.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The training job has stopped.</p>
    /// </li>
    /// </ul>
    /// <p>For
    /// more detailed information, see <code>SecondaryStatus</code>. </p>
    #[serde(rename = "TrainingJobStatus")]
    #[serde(default)]
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    /// <p> Provides detailed information about the state of the training job. For detailed
    /// information on the secondary status of the training job, see <code>StatusMessage</code>
    /// under <a>SecondaryStatusTransition</a>.</p>
    /// <p>Amazon SageMaker provides primary statuses and secondary statuses that apply to each of
    /// them:</p>
    /// <dl>
    /// <dt>InProgress</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Starting</code>
    /// - Starting the training job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Downloading</code> - An optional stage for algorithms that
    /// support <code>File</code> training input mode. It indicates that
    /// data is being downloaded to the ML storage volumes.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Training</code> - Training is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Interrupted</code> - The job stopped because the managed
    /// spot training instances were interrupted. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Uploading</code> - Training is complete and the model
    /// artifacts are being uploaded to the S3 location.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The training job has completed.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The training job has failed. The reason for
    /// the failure is returned in the <code>FailureReason</code> field of
    /// <code>DescribeTrainingJobResponse</code>.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopped</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MaxRuntimeExceeded</code> - The job stopped because it
    /// exceeded the maximum allowed runtime.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MaxWaitTimeExceeded</code> - The job stopped because it
    /// exceeded the maximum allowed wait time.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The training job has stopped.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopping</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - Stopping the training job.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <important>
    /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
    /// </important>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>LaunchingMLInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PreparingTraining</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DownloadingTrainingImage</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "SecondaryStatus")]
    #[serde(default)]
    pub secondary_status: std::option::Option<crate::model::SecondaryStatus>,
    /// <p>If the training job failed, the reason it failed. </p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Algorithm-specific parameters. </p>
    #[serde(rename = "HyperParameters")]
    #[serde(default)]
    pub hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information about the algorithm used for training, and algorithm metadata.
    /// </p>
    #[serde(rename = "AlgorithmSpecification")]
    #[serde(default)]
    pub algorithm_specification: std::option::Option<crate::model::AlgorithmSpecification>,
    /// <p>The AWS Identity and Access Management (IAM) role configured for the training job. </p>
    #[serde(rename = "RoleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An array of <code>Channel</code> objects that describes each data input channel.
    /// </p>
    #[serde(rename = "InputDataConfig")]
    #[serde(default)]
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>The S3 path where model artifacts that you configured when creating the job are
    /// stored. Amazon SageMaker creates subfolders for model artifacts. </p>
    #[serde(rename = "OutputDataConfig")]
    #[serde(default)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>Resources, including ML compute instances and ML storage volumes, that are
    /// configured for model training. </p>
    #[serde(rename = "ResourceConfig")]
    #[serde(default)]
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>A <a>VpcConfig</a> object that specifies the VPC that this training job has
    /// access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon
    /// Virtual Private Cloud</a>.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
    /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
    /// ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, Amazon SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays
    /// job termination for 120 seconds. Algorithms can use this 120-second window to save the
    /// model artifacts, so the results of training are not lost. </p>
    #[serde(rename = "StoppingCondition")]
    #[serde(default)]
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>A timestamp that indicates when the training job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the time when the training job starts on training instances. You are
    /// billed for the time interval between this time and the value of
    /// <code>TrainingEndTime</code>. The start time in CloudWatch Logs might be later than this time.
    /// The difference is due to the time it takes to download the training data and to the size
    /// of the training container.</p>
    #[serde(rename = "TrainingStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub training_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the time when the training job ends on training instances. You are billed
    /// for the time interval between the value of <code>TrainingStartTime</code> and this time.
    /// For successful jobs and stopped jobs, this is the time after model artifacts are
    /// uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.</p>
    #[serde(rename = "TrainingEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub training_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that indicates when the status of the training job was last
    /// modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A history of all of the secondary statuses that the training job has transitioned
    /// through.</p>
    #[serde(rename = "SecondaryStatusTransitions")]
    #[serde(default)]
    pub secondary_status_transitions:
        std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
    /// <p>A collection of <code>MetricData</code> objects that specify the names, values, and
    /// dates and times that the training algorithm emitted to Amazon CloudWatch.</p>
    #[serde(rename = "FinalMetricDataList")]
    #[serde(default)]
    pub final_metric_data_list: std::option::Option<std::vec::Vec<crate::model::MetricData>>,
    /// <p>If you want to allow inbound or outbound network calls, except for calls between peers
    /// within a training cluster for distributed training, choose <code>True</code>. If you
    /// enable network isolation for training jobs that are configured to use a VPC, Amazon SageMaker
    /// downloads and uploads customer data and model artifacts through the specified VPC, but
    /// the training container does not have network access.</p>
    #[serde(rename = "EnableNetworkIsolation")]
    #[serde(default)]
    pub enable_network_isolation: bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training,
    /// choose <code>True</code>. Encryption provides greater security for distributed training,
    /// but training might take longer. How long it takes depends on the amount of communication
    /// between compute instances, especially if you use a deep learning algorithms in
    /// distributed training.</p>
    #[serde(rename = "EnableInterContainerTrafficEncryption")]
    #[serde(default)]
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or
    /// not (<code>False</code>).</p>
    #[serde(rename = "EnableManagedSpotTraining")]
    #[serde(default)]
    pub enable_managed_spot_training: bool,
    /// <p>Contains information about the output location for managed spot training checkpoint
    /// data. </p>
    #[serde(rename = "CheckpointConfig")]
    #[serde(default)]
    pub checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
    /// <p>The training time in seconds.</p>
    #[serde(rename = "TrainingTimeInSeconds")]
    #[serde(default)]
    pub training_time_in_seconds: std::option::Option<i32>,
    /// <p>The billable time in seconds. Billable time refers to the absolute wall-clock
    /// time.</p>
    /// <p>Multiply <code>BillableTimeInSeconds</code> by the number of instances
    /// (<code>InstanceCount</code>) in your training cluster to get the total compute time
    /// Amazon SageMaker will bill you if you run distributed training. The formula is as follows:
    /// <code>BillableTimeInSeconds * InstanceCount</code> .</p>
    /// <p>You can calculate the savings from using managed spot training using the formula
    /// <code>(1 - BillableTimeInSeconds / TrainingTimeInSeconds) * 100</code>. For example,
    /// if <code>BillableTimeInSeconds</code> is 100 and <code>TrainingTimeInSeconds</code> is
    /// 500, the savings is 80%.</p>
    #[serde(rename = "BillableTimeInSeconds")]
    #[serde(default)]
    pub billable_time_in_seconds: std::option::Option<i32>,
    /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and
    /// storage paths. To learn more about
    /// how to configure the <code>DebugHookConfig</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
    #[serde(rename = "DebugHookConfig")]
    #[serde(default)]
    pub debug_hook_config: std::option::Option<crate::model::DebugHookConfig>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "ExperimentConfig")]
    #[serde(default)]
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>Configuration information for Debugger rules for debugging output tensors.</p>
    #[serde(rename = "DebugRuleConfigurations")]
    #[serde(default)]
    pub debug_rule_configurations:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
    /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
    #[serde(rename = "TensorBoardOutputConfig")]
    #[serde(default)]
    pub tensor_board_output_config: std::option::Option<crate::model::TensorBoardOutputConfig>,
    /// <p>Evaluation status of Debugger rules for debugging on a training job.</p>
    #[serde(rename = "DebugRuleEvaluationStatuses")]
    #[serde(default)]
    pub debug_rule_evaluation_statuses:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
    /// <p>Configuration information for Debugger system monitoring, framework profiling, and
    /// storage paths.</p>
    #[serde(rename = "ProfilerConfig")]
    #[serde(default)]
    pub profiler_config: std::option::Option<crate::model::ProfilerConfig>,
    /// <p>Configuration information for Debugger rules for profiling system and framework
    /// metrics.</p>
    #[serde(rename = "ProfilerRuleConfigurations")]
    #[serde(default)]
    pub profiler_rule_configurations:
        std::option::Option<std::vec::Vec<crate::model::ProfilerRuleConfiguration>>,
    /// <p>Evaluation status of Debugger rules for profiling on a training job.</p>
    #[serde(rename = "ProfilerRuleEvaluationStatuses")]
    #[serde(default)]
    pub profiler_rule_evaluation_statuses:
        std::option::Option<std::vec::Vec<crate::model::ProfilerRuleEvaluationStatus>>,
    /// <p>Profiling status of a training job.</p>
    #[serde(rename = "ProfilingStatus")]
    #[serde(default)]
    pub profiling_status: std::option::Option<crate::model::ProfilingStatus>,
    /// <p>The number of times to retry the job when the job fails due to an
    /// <code>InternalServerError</code>.</p>
    #[serde(rename = "RetryStrategy")]
    #[serde(default)]
    pub retry_strategy: std::option::Option<crate::model::RetryStrategy>,
    /// <p>The environment variables to set in the Docker container.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DescribeTrainingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrainingJobOutputBody");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tuning_job_arn", &self.tuning_job_arn);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("model_artifacts", &self.model_artifacts);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.field("secondary_status", &self.secondary_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "secondary_status_transitions",
            &self.secondary_status_transitions,
        );
        formatter.field("final_metric_data_list", &self.final_metric_data_list);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("training_time_in_seconds", &self.training_time_in_seconds);
        formatter.field("billable_time_in_seconds", &self.billable_time_in_seconds);
        formatter.field("debug_hook_config", &self.debug_hook_config);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("debug_rule_configurations", &self.debug_rule_configurations);
        formatter.field(
            "tensor_board_output_config",
            &self.tensor_board_output_config,
        );
        formatter.field(
            "debug_rule_evaluation_statuses",
            &self.debug_rule_evaluation_statuses,
        );
        formatter.field("profiler_config", &self.profiler_config);
        formatter.field(
            "profiler_rule_configurations",
            &self.profiler_rule_configurations,
        );
        formatter.field(
            "profiler_rule_evaluation_statuses",
            &self.profiler_rule_evaluation_statuses,
        );
        formatter.field("profiling_status", &self.profiling_status);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTransformJobOutputBody {
    /// <p>The name of the transform job.</p>
    #[serde(rename = "TransformJobName")]
    #[serde(default)]
    pub transform_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    #[serde(rename = "TransformJobArn")]
    #[serde(default)]
    pub transform_job_arn: std::option::Option<std::string::String>,
    /// <p>The
    /// status of the transform job. If the transform job failed, the reason
    /// is returned in the <code>FailureReason</code> field.</p>
    #[serde(rename = "TransformJobStatus")]
    #[serde(default)]
    pub transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
    /// <p>If the transform job failed, <code>FailureReason</code> describes
    /// why
    /// it failed. A transform job creates a log file, which includes error
    /// messages, and stores it
    /// as
    /// an Amazon S3 object. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/logging-cloudwatch.html">Log Amazon SageMaker Events with
    /// Amazon CloudWatch</a>.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The name of the model used in the transform job.</p>
    #[serde(rename = "ModelName")]
    #[serde(default)]
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The
    /// maximum number
    /// of
    /// parallel requests on each instance node
    /// that can be launched in a transform job. The default value is 1.</p>
    #[serde(rename = "MaxConcurrentTransforms")]
    #[serde(default)]
    pub max_concurrent_transforms: std::option::Option<i32>,
    /// <p>The timeout and maximum number of retries for processing a transform job
    /// invocation.</p>
    #[serde(rename = "ModelClientConfig")]
    #[serde(default)]
    pub model_client_config: std::option::Option<crate::model::ModelClientConfig>,
    /// <p>The
    /// maximum
    /// payload size, in MB, used in the
    /// transform job.</p>
    #[serde(rename = "MaxPayloadInMB")]
    #[serde(default)]
    pub max_payload_in_mb: std::option::Option<i32>,
    /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference
    /// request.
    /// A <i>record</i>
    /// <i></i> is a single unit of input data that inference
    /// can be made on. For example, a single line in a CSV file is a record. </p>
    /// <p>To enable the batch strategy, you must set <code>SplitType</code>
    /// to
    /// <code>Line</code>, <code>RecordIO</code>, or
    /// <code>TFRecord</code>.</p>
    #[serde(rename = "BatchStrategy")]
    #[serde(default)]
    pub batch_strategy: std::option::Option<crate::model::BatchStrategy>,
    /// <p>The
    /// environment variables to set in the Docker container. We support up to 16 key and values
    /// entries in the map.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Describes the dataset to be transformed and the Amazon S3 location where it is
    /// stored.</p>
    #[serde(rename = "TransformInput")]
    #[serde(default)]
    pub transform_input: std::option::Option<crate::model::TransformInput>,
    /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the
    /// transform job.</p>
    #[serde(rename = "TransformOutput")]
    #[serde(default)]
    pub transform_output: std::option::Option<crate::model::TransformOutput>,
    /// <p>Describes
    /// the resources, including ML instance types and ML instance count, to
    /// use for the transform job.</p>
    #[serde(rename = "TransformResources")]
    #[serde(default)]
    pub transform_resources: std::option::Option<crate::model::TransformResources>,
    /// <p>A timestamp that shows when the transform Job was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform job starts
    /// on
    /// ML instances. You are billed for the time interval between this time
    /// and the value of <code>TransformEndTime</code>.</p>
    #[serde(rename = "TransformStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub transform_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform job has been
    /// completed, or has stopped or failed. You are billed for the time
    /// interval between this time and the value of <code>TransformStartTime</code>.</p>
    #[serde(rename = "TransformEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub transform_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the
    /// transform or training job.</p>
    #[serde(rename = "LabelingJobArn")]
    #[serde(default)]
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AutoML transform job.</p>
    #[serde(rename = "AutoMLJobArn")]
    #[serde(default)]
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The data structure used to specify the data to be used for inference in a batch
    /// transform job and to associate the data that is relevant to the prediction results in
    /// the output. The input filter provided allows you to exclude input data that is not
    /// needed for inference in a batch transform job. The output filter provided allows you to
    /// include input data relevant to interpreting the predictions in the output from the job.
    /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction
    /// Results with their Corresponding Input Records</a>.</p>
    #[serde(rename = "DataProcessing")]
    #[serde(default)]
    pub data_processing: std::option::Option<crate::model::DataProcessing>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "ExperimentConfig")]
    #[serde(default)]
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
}
impl std::fmt::Debug for DescribeTransformJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTransformJobOutputBody");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.field("transform_job_status", &self.transform_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("model_name", &self.model_name);
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("model_client_config", &self.model_client_config);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("transform_start_time", &self.transform_start_time);
        formatter.field("transform_end_time", &self.transform_end_time);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("data_processing", &self.data_processing);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrialOutputBody {
    /// <p>The name of the trial.</p>
    #[serde(rename = "TrialName")]
    #[serde(default)]
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialName</code> is displayed.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment the trial is part of.</p>
    #[serde(rename = "ExperimentName")]
    #[serde(default)]
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source and, optionally, the job type.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::TrialSource>,
    /// <p>When the trial was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who created the trial.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the trial was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who last modified the trial.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    #[serde(rename = "MetadataProperties")]
    #[serde(default)]
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
}
impl std::fmt::Debug for DescribeTrialOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrialOutputBody");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("trial_arn", &self.trial_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("source", &self.source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTrialComponentOutputBody {
    /// <p>The name of the trial component.</p>
    #[serde(rename = "TrialComponentName")]
    #[serde(default)]
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialComponentName</code> is displayed.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source and, optionally, the job type.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>The status of the component. States include:</p>
    /// <ul>
    /// <li>
    /// <p>InProgress</p>
    /// </li>
    /// <li>
    /// <p>Completed</p>
    /// </li>
    /// <li>
    /// <p>Failed</p>
    /// </li>
    /// </ul>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component ended.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component was created.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who created the component.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the component was last modified.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who last modified the component.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The hyperparameters of the component.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    >,
    /// <p>The input artifacts of the component.</p>
    #[serde(rename = "InputArtifacts")]
    #[serde(default)]
    pub input_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The output artifacts of the component.</p>
    #[serde(rename = "OutputArtifacts")]
    #[serde(default)]
    pub output_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    #[serde(rename = "MetadataProperties")]
    #[serde(default)]
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>The metrics for the component.</p>
    #[serde(rename = "Metrics")]
    #[serde(default)]
    pub metrics: std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
}
impl std::fmt::Debug for DescribeTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTrialComponentOutputBody");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("source", &self.source);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("parameters", &self.parameters);
        formatter.field("input_artifacts", &self.input_artifacts);
        formatter.field("output_artifacts", &self.output_artifacts);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("metrics", &self.metrics);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeUserProfileOutputBody {
    /// <p>The ID of the domain that contains the profile.</p>
    #[serde(rename = "DomainId")]
    #[serde(default)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile Amazon Resource Name (ARN).</p>
    #[serde(rename = "UserProfileArn")]
    #[serde(default)]
    pub user_profile_arn: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    #[serde(rename = "UserProfileName")]
    #[serde(default)]
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The ID of the user's profile in the Amazon Elastic File System (EFS) volume.</p>
    #[serde(rename = "HomeEfsFileSystemUid")]
    #[serde(default)]
    pub home_efs_file_system_uid: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::UserProfileStatus>,
    /// <p>The last modified time.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The creation time.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The failure reason.</p>
    #[serde(rename = "FailureReason")]
    #[serde(default)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The SSO user identifier.</p>
    #[serde(rename = "SingleSignOnUserIdentifier")]
    #[serde(default)]
    pub single_sign_on_user_identifier: std::option::Option<std::string::String>,
    /// <p>The SSO user value.</p>
    #[serde(rename = "SingleSignOnUserValue")]
    #[serde(default)]
    pub single_sign_on_user_value: std::option::Option<std::string::String>,
    /// <p>A collection of settings.</p>
    #[serde(rename = "UserSettings")]
    #[serde(default)]
    pub user_settings: std::option::Option<crate::model::UserSettings>,
}
impl std::fmt::Debug for DescribeUserProfileOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeUserProfileOutputBody");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_arn", &self.user_profile_arn);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("home_efs_file_system_uid", &self.home_efs_file_system_uid);
        formatter.field("status", &self.status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field(
            "single_sign_on_user_identifier",
            &self.single_sign_on_user_identifier,
        );
        formatter.field("single_sign_on_user_value", &self.single_sign_on_user_value);
        formatter.field("user_settings", &self.user_settings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkforceOutputBody {
    /// <p>A single private workforce, which is automatically created when you create your first
    /// private work team. You can create one private work force in each AWS Region. By default,
    /// any workforce-related API operation used in a specific region will apply to the
    /// workforce created in that region. To learn how to create a private workforce, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-create-private.html">Create a Private Workforce</a>.</p>
    #[serde(rename = "Workforce")]
    #[serde(default)]
    pub workforce: std::option::Option<crate::model::Workforce>,
}
impl std::fmt::Debug for DescribeWorkforceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkforceOutputBody");
        formatter.field("workforce", &self.workforce);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkteamOutputBody {
    /// <p>A <code>Workteam</code> instance that contains information about the work team.
    /// </p>
    #[serde(rename = "Workteam")]
    #[serde(default)]
    pub workteam: std::option::Option<crate::model::Workteam>,
}
impl std::fmt::Debug for DescribeWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkteamOutputBody");
        formatter.field("workteam", &self.workteam);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateTrialComponentOutputBody {
    /// <p>The ARN of the trial component.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateTrialComponentOutputBody");
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("trial_arn", &self.trial_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeviceFleetReportOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    #[serde(rename = "DeviceFleetArn")]
    #[serde(default)]
    pub device_fleet_arn: std::option::Option<std::string::String>,
    /// <p>The name of the fleet.</p>
    #[serde(rename = "DeviceFleetName")]
    #[serde(default)]
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>The output configuration for storing sample data collected by the fleet.</p>
    #[serde(rename = "OutputConfig")]
    #[serde(default)]
    pub output_config: std::option::Option<crate::model::EdgeOutputConfig>,
    /// <p>Description of the fleet.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the report was generated.</p>
    #[serde(rename = "ReportGenerated")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub report_generated: std::option::Option<smithy_types::Instant>,
    /// <p>Status of devices.</p>
    #[serde(rename = "DeviceStats")]
    #[serde(default)]
    pub device_stats: std::option::Option<crate::model::DeviceStats>,
    /// <p>The versions of Edge Manager agent deployed on the fleet.</p>
    #[serde(rename = "AgentVersions")]
    #[serde(default)]
    pub agent_versions: std::option::Option<std::vec::Vec<crate::model::AgentVersion>>,
    /// <p>Status of model on device.</p>
    #[serde(rename = "ModelStats")]
    #[serde(default)]
    pub model_stats: std::option::Option<std::vec::Vec<crate::model::EdgeModelStat>>,
}
impl std::fmt::Debug for GetDeviceFleetReportOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeviceFleetReportOutputBody");
        formatter.field("device_fleet_arn", &self.device_fleet_arn);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("output_config", &self.output_config);
        formatter.field("description", &self.description);
        formatter.field("report_generated", &self.report_generated);
        formatter.field("device_stats", &self.device_stats);
        formatter.field("agent_versions", &self.agent_versions);
        formatter.field("model_stats", &self.model_stats);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetModelPackageGroupPolicyOutputBody {
    /// <p>The resource policy for the model group.</p>
    #[serde(rename = "ResourcePolicy")]
    #[serde(default)]
    pub resource_policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetModelPackageGroupPolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetModelPackageGroupPolicyOutputBody");
        formatter.field("resource_policy", &self.resource_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSagemakerServicecatalogPortfolioStatusOutputBody {
    /// <p>Whether Service Catalog is enabled or disabled in SageMaker.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::SagemakerServicecatalogStatus>,
}
impl std::fmt::Debug for GetSagemakerServicecatalogPortfolioStatusOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSagemakerServicecatalogPortfolioStatusOutputBody");
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSearchSuggestionsOutputBody {
    /// <p>A list of property names for a <code>Resource</code> that match a
    /// <code>SuggestionQuery</code>.</p>
    #[serde(rename = "PropertyNameSuggestions")]
    #[serde(default)]
    pub property_name_suggestions:
        std::option::Option<std::vec::Vec<crate::model::PropertyNameSuggestion>>,
}
impl std::fmt::Debug for GetSearchSuggestionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSearchSuggestionsOutputBody");
        formatter.field("property_name_suggestions", &self.property_name_suggestions);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListActionsOutputBody {
    /// <p>A list of actions and their properties.</p>
    #[serde(rename = "ActionSummaries")]
    #[serde(default)]
    pub action_summaries: std::option::Option<std::vec::Vec<crate::model::ActionSummary>>,
    /// <p>A token for getting the next set of actions, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListActionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListActionsOutputBody");
        formatter.field("action_summaries", &self.action_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAlgorithmsOutputBody {
    /// <p>>An array of <code>AlgorithmSummary</code> objects, each of which lists an
    /// algorithm.</p>
    #[serde(rename = "AlgorithmSummaryList")]
    #[serde(default)]
    pub algorithm_summary_list: std::option::Option<std::vec::Vec<crate::model::AlgorithmSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// algorithms, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAlgorithmsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAlgorithmsOutputBody");
        formatter.field("algorithm_summary_list", &self.algorithm_summary_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppImageConfigsOutputBody {
    /// <p>A token for getting the next set of AppImageConfigs, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of AppImageConfigs and their properties.</p>
    #[serde(rename = "AppImageConfigs")]
    #[serde(default)]
    pub app_image_configs: std::option::Option<std::vec::Vec<crate::model::AppImageConfigDetails>>,
}
impl std::fmt::Debug for ListAppImageConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppImageConfigsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("app_image_configs", &self.app_image_configs);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppsOutputBody {
    /// <p>The list of apps.</p>
    #[serde(rename = "Apps")]
    #[serde(default)]
    pub apps: std::option::Option<std::vec::Vec<crate::model::AppDetails>>,
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAppsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppsOutputBody");
        formatter.field("apps", &self.apps);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListArtifactsOutputBody {
    /// <p>A list of artifacts and their properties.</p>
    #[serde(rename = "ArtifactSummaries")]
    #[serde(default)]
    pub artifact_summaries: std::option::Option<std::vec::Vec<crate::model::ArtifactSummary>>,
    /// <p>A token for getting the next set of artifacts, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListArtifactsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListArtifactsOutputBody");
        formatter.field("artifact_summaries", &self.artifact_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationsOutputBody {
    /// <p>A list of associations and their properties.</p>
    #[serde(rename = "AssociationSummaries")]
    #[serde(default)]
    pub association_summaries: std::option::Option<std::vec::Vec<crate::model::AssociationSummary>>,
    /// <p>A token for getting the next set of associations, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAssociationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationsOutputBody");
        formatter.field("association_summaries", &self.association_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAutoMLJobsOutputBody {
    /// <p>Returns a summary list of jobs.</p>
    #[serde(rename = "AutoMLJobSummaries")]
    #[serde(default)]
    pub auto_ml_job_summaries: std::option::Option<std::vec::Vec<crate::model::AutoMLJobSummary>>,
    /// <p>If the previous response was truncated, you receive this token. Use it in your next
    /// request to receive the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAutoMLJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAutoMLJobsOutputBody");
        formatter.field("auto_ml_job_summaries", &self.auto_ml_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCandidatesForAutoMLJobOutputBody {
    /// <p>Summaries about the <code>AutoMLCandidates</code>.</p>
    #[serde(rename = "Candidates")]
    #[serde(default)]
    pub candidates: std::option::Option<std::vec::Vec<crate::model::AutoMLCandidate>>,
    /// <p>If the previous response was truncated, you receive this token. Use it in your next
    /// request to receive the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCandidatesForAutoMLJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCandidatesForAutoMLJobOutputBody");
        formatter.field("candidates", &self.candidates);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCodeRepositoriesOutputBody {
    /// <p>Gets a list of summaries of the Git repositories. Each summary specifies the following
    /// values for the repository: </p>
    /// <ul>
    /// <li>
    /// <p>Name</p>
    /// </li>
    /// <li>
    /// <p>Amazon Resource Name (ARN)</p>
    /// </li>
    /// <li>
    /// <p>Creation time</p>
    /// </li>
    /// <li>
    /// <p>Last modified time</p>
    /// </li>
    /// <li>
    /// <p>Configuration information, including the URL location of the repository and
    /// the ARN of the AWS Secrets Manager secret that contains the credentials used
    /// to access the repository.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "CodeRepositorySummaryList")]
    #[serde(default)]
    pub code_repository_summary_list:
        std::option::Option<std::vec::Vec<crate::model::CodeRepositorySummary>>,
    /// <p>If the result of a <code>ListCodeRepositoriesOutput</code> request was truncated, the
    /// response includes a <code>NextToken</code>. To get the next set of Git repositories, use
    /// the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCodeRepositoriesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCodeRepositoriesOutputBody");
        formatter.field(
            "code_repository_summary_list",
            &self.code_repository_summary_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCompilationJobsOutputBody {
    /// <p>An array of <a>CompilationJobSummary</a> objects, each describing a model
    /// compilation job. </p>
    #[serde(rename = "CompilationJobSummaries")]
    #[serde(default)]
    pub compilation_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::CompilationJobSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this <code>NextToken</code>. To retrieve
    /// the next set of model compilation jobs, use this token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCompilationJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCompilationJobsOutputBody");
        formatter.field("compilation_job_summaries", &self.compilation_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListContextsOutputBody {
    /// <p>A list of contexts and their properties.</p>
    #[serde(rename = "ContextSummaries")]
    #[serde(default)]
    pub context_summaries: std::option::Option<std::vec::Vec<crate::model::ContextSummary>>,
    /// <p>A token for getting the next set of contexts, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListContextsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListContextsOutputBody");
        formatter.field("context_summaries", &self.context_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDataQualityJobDefinitionsOutputBody {
    /// <p>A list of data quality monitoring job definitions.</p>
    #[serde(rename = "JobDefinitionSummaries")]
    #[serde(default)]
    pub job_definition_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringJobDefinitionSummary>>,
    /// <p>If the result of the previous <code>ListDataQualityJobDefinitions</code> request was
    /// truncated, the response includes a <code>NextToken</code>. To retrieve the next set of data
    /// quality monitoring job definitions, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDataQualityJobDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDataQualityJobDefinitionsOutputBody");
        formatter.field("job_definition_summaries", &self.job_definition_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDeviceFleetsOutputBody {
    /// <p>Summary of the device fleet.</p>
    #[serde(rename = "DeviceFleetSummaries")]
    #[serde(default)]
    pub device_fleet_summaries:
        std::option::Option<std::vec::Vec<crate::model::DeviceFleetSummary>>,
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDeviceFleetsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDeviceFleetsOutputBody");
        formatter.field("device_fleet_summaries", &self.device_fleet_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDevicesOutputBody {
    /// <p>Summary of devices.</p>
    #[serde(rename = "DeviceSummaries")]
    #[serde(default)]
    pub device_summaries: std::option::Option<std::vec::Vec<crate::model::DeviceSummary>>,
    /// <p>The response from the last list when returning a list large enough to need tokening.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDevicesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDevicesOutputBody");
        formatter.field("device_summaries", &self.device_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainsOutputBody {
    /// <p>The list of domains.</p>
    #[serde(rename = "Domains")]
    #[serde(default)]
    pub domains: std::option::Option<std::vec::Vec<crate::model::DomainDetails>>,
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDomainsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainsOutputBody");
        formatter.field("domains", &self.domains);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEdgePackagingJobsOutputBody {
    /// <p>Summaries of edge packaging jobs.</p>
    #[serde(rename = "EdgePackagingJobSummaries")]
    #[serde(default)]
    pub edge_packaging_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::EdgePackagingJobSummary>>,
    /// <p>Token to use when calling the next page of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEdgePackagingJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEdgePackagingJobsOutputBody");
        formatter.field(
            "edge_packaging_job_summaries",
            &self.edge_packaging_job_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointConfigsOutputBody {
    /// <p>An array of endpoint configurations.</p>
    #[serde(rename = "EndpointConfigs")]
    #[serde(default)]
    pub endpoint_configs: std::option::Option<std::vec::Vec<crate::model::EndpointConfigSummary>>,
    /// <p> If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// endpoint configurations, use it in the subsequent request </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEndpointConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointConfigsOutputBody");
        formatter.field("endpoint_configs", &self.endpoint_configs);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointsOutputBody {
    /// <p> An array or endpoint objects. </p>
    #[serde(rename = "Endpoints")]
    #[serde(default)]
    pub endpoints: std::option::Option<std::vec::Vec<crate::model::EndpointSummary>>,
    /// <p> If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// training jobs, use it in the subsequent request. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEndpointsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointsOutputBody");
        formatter.field("endpoints", &self.endpoints);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListExperimentsOutputBody {
    /// <p>A list of the summaries of your experiments.</p>
    #[serde(rename = "ExperimentSummaries")]
    #[serde(default)]
    pub experiment_summaries: std::option::Option<std::vec::Vec<crate::model::ExperimentSummary>>,
    /// <p>A token for getting the next set of experiments, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListExperimentsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListExperimentsOutputBody");
        formatter.field("experiment_summaries", &self.experiment_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFeatureGroupsOutputBody {
    /// <p>A summary of feature groups.</p>
    #[serde(rename = "FeatureGroupSummaries")]
    #[serde(default)]
    pub feature_group_summaries:
        std::option::Option<std::vec::Vec<crate::model::FeatureGroupSummary>>,
    /// <p>A token to resume pagination of <code>ListFeatureGroups</code> results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListFeatureGroupsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFeatureGroupsOutputBody");
        formatter.field("feature_group_summaries", &self.feature_group_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFlowDefinitionsOutputBody {
    /// <p>An array of objects describing the flow definitions.</p>
    #[serde(rename = "FlowDefinitionSummaries")]
    #[serde(default)]
    pub flow_definition_summaries:
        std::option::Option<std::vec::Vec<crate::model::FlowDefinitionSummary>>,
    /// <p>A token to resume pagination.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListFlowDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFlowDefinitionsOutputBody");
        formatter.field("flow_definition_summaries", &self.flow_definition_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHumanTaskUisOutputBody {
    /// <p>An array of objects describing the human task user interfaces.</p>
    #[serde(rename = "HumanTaskUiSummaries")]
    #[serde(default)]
    pub human_task_ui_summaries:
        std::option::Option<std::vec::Vec<crate::model::HumanTaskUiSummary>>,
    /// <p>A token to resume pagination.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListHumanTaskUisOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHumanTaskUisOutputBody");
        formatter.field("human_task_ui_summaries", &self.human_task_ui_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHyperParameterTuningJobsOutputBody {
    /// <p>A list of <a>HyperParameterTuningJobSummary</a> objects that
    /// describe
    /// the tuning jobs that the <code>ListHyperParameterTuningJobs</code>
    /// request returned.</p>
    #[serde(rename = "HyperParameterTuningJobSummaries")]
    #[serde(default)]
    pub hyper_parameter_tuning_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterTuningJobSummary>>,
    /// <p>If the result of this <code>ListHyperParameterTuningJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of tuning jobs,
    /// use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListHyperParameterTuningJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHyperParameterTuningJobsOutputBody");
        formatter.field(
            "hyper_parameter_tuning_job_summaries",
            &self.hyper_parameter_tuning_job_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImagesOutputBody {
    /// <p>A list of images and their properties.</p>
    #[serde(rename = "Images")]
    #[serde(default)]
    pub images: std::option::Option<std::vec::Vec<crate::model::Image>>,
    /// <p>A token for getting the next set of images, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListImagesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImagesOutputBody");
        formatter.field("images", &self.images);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImageVersionsOutputBody {
    /// <p>A list of versions and their properties.</p>
    #[serde(rename = "ImageVersions")]
    #[serde(default)]
    pub image_versions: std::option::Option<std::vec::Vec<crate::model::ImageVersion>>,
    /// <p>A token for getting the next set of versions, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListImageVersionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImageVersionsOutputBody");
        formatter.field("image_versions", &self.image_versions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLabelingJobsOutputBody {
    /// <p>An array of <code>LabelingJobSummary</code> objects, each describing a labeling
    /// job.</p>
    #[serde(rename = "LabelingJobSummaryList")]
    #[serde(default)]
    pub labeling_job_summary_list:
        std::option::Option<std::vec::Vec<crate::model::LabelingJobSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// labeling jobs, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListLabelingJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLabelingJobsOutputBody");
        formatter.field("labeling_job_summary_list", &self.labeling_job_summary_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLabelingJobsForWorkteamOutputBody {
    /// <p>An array of <code>LabelingJobSummary</code> objects, each describing a labeling
    /// job.</p>
    #[serde(rename = "LabelingJobSummaryList")]
    #[serde(default)]
    pub labeling_job_summary_list:
        std::option::Option<std::vec::Vec<crate::model::LabelingJobForWorkteamSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// labeling jobs, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListLabelingJobsForWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLabelingJobsForWorkteamOutputBody");
        formatter.field("labeling_job_summary_list", &self.labeling_job_summary_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelBiasJobDefinitionsOutputBody {
    /// <p>A JSON array in which each element is a summary for a model bias jobs.</p>
    #[serde(rename = "JobDefinitionSummaries")]
    #[serde(default)]
    pub job_definition_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringJobDefinitionSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs,
    /// use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelBiasJobDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelBiasJobDefinitionsOutputBody");
        formatter.field("job_definition_summaries", &self.job_definition_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelExplainabilityJobDefinitionsOutputBody {
    /// <p>A JSON array in which each element is a summary for a explainability bias jobs.</p>
    #[serde(rename = "JobDefinitionSummaries")]
    #[serde(default)]
    pub job_definition_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringJobDefinitionSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs,
    /// use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelExplainabilityJobDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelExplainabilityJobDefinitionsOutputBody");
        formatter.field("job_definition_summaries", &self.job_definition_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelPackageGroupsOutputBody {
    /// <p>A list of summaries of the model groups in your AWS account.</p>
    #[serde(rename = "ModelPackageGroupSummaryList")]
    #[serde(default)]
    pub model_package_group_summary_list:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageGroupSummary>>,
    /// <p>If the response is truncated, SageMaker returns this token. To retrieve the next set
    /// of model groups, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelPackageGroupsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelPackageGroupsOutputBody");
        formatter.field(
            "model_package_group_summary_list",
            &self.model_package_group_summary_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelPackagesOutputBody {
    /// <p>An array of <code>ModelPackageSummary</code> objects, each of which lists a model
    /// package.</p>
    #[serde(rename = "ModelPackageSummaryList")]
    #[serde(default)]
    pub model_package_summary_list:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// model packages, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelPackagesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelPackagesOutputBody");
        formatter.field(
            "model_package_summary_list",
            &self.model_package_summary_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelQualityJobDefinitionsOutputBody {
    /// <p>A list of summaries of model quality monitoring job definitions.</p>
    #[serde(rename = "JobDefinitionSummaries")]
    #[serde(default)]
    pub job_definition_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringJobDefinitionSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of model
    /// quality monitoring job definitions, use it in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelQualityJobDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelQualityJobDefinitionsOutputBody");
        formatter.field("job_definition_summaries", &self.job_definition_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListModelsOutputBody {
    /// <p>An array of <code>ModelSummary</code> objects, each of which lists a
    /// model.</p>
    #[serde(rename = "Models")]
    #[serde(default)]
    pub models: std::option::Option<std::vec::Vec<crate::model::ModelSummary>>,
    /// <p> If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// models, use it in the subsequent request. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListModelsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListModelsOutputBody");
        formatter.field("models", &self.models);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMonitoringExecutionsOutputBody {
    /// <p>A JSON array in which each element is a summary for a monitoring execution.</p>
    #[serde(rename = "MonitoringExecutionSummaries")]
    #[serde(default)]
    pub monitoring_execution_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringExecutionSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs,
    /// use it in the subsequent reques</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMonitoringExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMonitoringExecutionsOutputBody");
        formatter.field(
            "monitoring_execution_summaries",
            &self.monitoring_execution_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMonitoringSchedulesOutputBody {
    /// <p>A JSON array in which each element is a summary for a monitoring schedule.</p>
    #[serde(rename = "MonitoringScheduleSummaries")]
    #[serde(default)]
    pub monitoring_schedule_summaries:
        std::option::Option<std::vec::Vec<crate::model::MonitoringScheduleSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs,
    /// use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMonitoringSchedulesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMonitoringSchedulesOutputBody");
        formatter.field(
            "monitoring_schedule_summaries",
            &self.monitoring_schedule_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotebookInstanceLifecycleConfigsOutputBody {
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To get the next set of
    /// lifecycle configurations, use it in the next request. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>An array of <code>NotebookInstanceLifecycleConfiguration</code> objects, each listing
    /// a lifecycle configuration.</p>
    #[serde(rename = "NotebookInstanceLifecycleConfigs")]
    #[serde(default)]
    pub notebook_instance_lifecycle_configs:
        std::option::Option<std::vec::Vec<crate::model::NotebookInstanceLifecycleConfigSummary>>,
}
impl std::fmt::Debug for ListNotebookInstanceLifecycleConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotebookInstanceLifecycleConfigsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field(
            "notebook_instance_lifecycle_configs",
            &self.notebook_instance_lifecycle_configs,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotebookInstancesOutputBody {
    /// <p>If the response to the previous <code>ListNotebookInstances</code> request was
    /// truncated, Amazon SageMaker returns this token. To retrieve the next set of notebook instances, use
    /// the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>An array of <code>NotebookInstanceSummary</code> objects, one for each notebook
    /// instance.</p>
    #[serde(rename = "NotebookInstances")]
    #[serde(default)]
    pub notebook_instances:
        std::option::Option<std::vec::Vec<crate::model::NotebookInstanceSummary>>,
}
impl std::fmt::Debug for ListNotebookInstancesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotebookInstancesOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("notebook_instances", &self.notebook_instances);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineExecutionsOutputBody {
    /// <p>Contains a sorted list of pipeline execution summary objects matching the specified
    /// filters. Each run summary includes the Amazon Resource Name (ARN) of the pipeline execution, the run date,
    /// and the status. This list can be empty. </p>
    #[serde(rename = "PipelineExecutionSummaries")]
    #[serde(default)]
    pub pipeline_execution_summaries:
        std::option::Option<std::vec::Vec<crate::model::PipelineExecutionSummary>>,
    /// <p>If the result of the previous <code>ListPipelineExecutions</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipeline executions, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPipelineExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineExecutionsOutputBody");
        formatter.field(
            "pipeline_execution_summaries",
            &self.pipeline_execution_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineExecutionStepsOutputBody {
    /// <p>A list of <code>PipeLineExecutionStep</code> objects. Each
    /// <code>PipeLineExecutionStep</code> consists of StepName, StartTime, EndTime, StepStatus,
    /// and Metadata. Metadata is an object with properties for each job that contains relevant
    /// information about the job created by the step.</p>
    #[serde(rename = "PipelineExecutionSteps")]
    #[serde(default)]
    pub pipeline_execution_steps:
        std::option::Option<std::vec::Vec<crate::model::PipelineExecutionStep>>,
    /// <p>If the result of the previous <code>ListPipelineExecutionSteps</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipeline execution steps, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPipelineExecutionStepsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineExecutionStepsOutputBody");
        formatter.field("pipeline_execution_steps", &self.pipeline_execution_steps);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelineParametersForExecutionOutputBody {
    /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
    #[serde(rename = "PipelineParameters")]
    #[serde(default)]
    pub pipeline_parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>If the result of the previous <code>ListPipelineParametersForExecution</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of parameters, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPipelineParametersForExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelineParametersForExecutionOutputBody");
        formatter.field("pipeline_parameters", &self.pipeline_parameters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelinesOutputBody {
    /// <p>Contains a sorted list of <code>PipelineSummary</code> objects matching the specified
    /// filters. Each <code>PipelineSummary</code> consists of PipelineArn, PipelineName,
    /// ExperimentName, PipelineDescription, CreationTime, LastModifiedTime, LastRunTime, and
    /// RoleArn. This list can be empty. </p>
    #[serde(rename = "PipelineSummaries")]
    #[serde(default)]
    pub pipeline_summaries: std::option::Option<std::vec::Vec<crate::model::PipelineSummary>>,
    /// <p>If the result of the previous <code>ListPipelines</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of pipelines, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPipelinesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelinesOutputBody");
        formatter.field("pipeline_summaries", &self.pipeline_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProcessingJobsOutputBody {
    /// <p>An array of <code>ProcessingJobSummary</code> objects, each listing a processing
    /// job.</p>
    #[serde(rename = "ProcessingJobSummaries")]
    #[serde(default)]
    pub processing_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::ProcessingJobSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// processing jobs, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListProcessingJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProcessingJobsOutputBody");
        formatter.field("processing_job_summaries", &self.processing_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProjectsOutputBody {
    /// <p>A list of summaries of projects.</p>
    #[serde(rename = "ProjectSummaryList")]
    #[serde(default)]
    pub project_summary_list: std::option::Option<std::vec::Vec<crate::model::ProjectSummary>>,
    /// <p>If the result of the previous <code>ListCompilationJobs</code> request was truncated,
    /// the response includes a <code>NextToken</code>. To retrieve the next set of model
    /// compilation jobs, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListProjectsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProjectsOutputBody");
        formatter.field("project_summary_list", &self.project_summary_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSubscribedWorkteamsOutputBody {
    /// <p>An array of <code>Workteam</code> objects, each describing a work team.</p>
    #[serde(rename = "SubscribedWorkteams")]
    #[serde(default)]
    pub subscribed_workteams: std::option::Option<std::vec::Vec<crate::model::SubscribedWorkteam>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// work teams, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSubscribedWorkteamsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSubscribedWorkteamsOutputBody");
        formatter.field("subscribed_workteams", &self.subscribed_workteams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsOutputBody {
    /// <p>An array of <code>Tag</code> objects, each with a tag key and a value.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p> If response is truncated, Amazon SageMaker includes a token in the response. You can use this
    /// token in your subsequent request to fetch next set of tokens. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsOutputBody");
        formatter.field("tags", &self.tags);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrainingJobsOutputBody {
    /// <p>An array of <code>TrainingJobSummary</code> objects, each listing a training
    /// job.</p>
    #[serde(rename = "TrainingJobSummaries")]
    #[serde(default)]
    pub training_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::TrainingJobSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// training jobs, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTrainingJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrainingJobsOutputBody");
        formatter.field("training_job_summaries", &self.training_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrainingJobsForHyperParameterTuningJobOutputBody {
    /// <p>A list of <a>TrainingJobSummary</a> objects that
    /// describe
    /// the training jobs that the
    /// <code>ListTrainingJobsForHyperParameterTuningJob</code> request returned.</p>
    #[serde(rename = "TrainingJobSummaries")]
    #[serde(default)]
    pub training_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterTrainingJobSummary>>,
    /// <p>If the result of this <code>ListTrainingJobsForHyperParameterTuningJob</code> request
    /// was truncated, the response includes a <code>NextToken</code>. To retrieve the next set
    /// of training jobs, use the token in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTrainingJobsForHyperParameterTuningJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrainingJobsForHyperParameterTuningJobOutputBody");
        formatter.field("training_job_summaries", &self.training_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTransformJobsOutputBody {
    /// <p>An array of
    /// <code>TransformJobSummary</code>
    /// objects.</p>
    #[serde(rename = "TransformJobSummaries")]
    #[serde(default)]
    pub transform_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::TransformJobSummary>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// transform jobs, use it in the next request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTransformJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTransformJobsOutputBody");
        formatter.field("transform_job_summaries", &self.transform_job_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrialComponentsOutputBody {
    /// <p>A list of the summaries of your trial components.</p>
    #[serde(rename = "TrialComponentSummaries")]
    #[serde(default)]
    pub trial_component_summaries:
        std::option::Option<std::vec::Vec<crate::model::TrialComponentSummary>>,
    /// <p>A token for getting the next set of components, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTrialComponentsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrialComponentsOutputBody");
        formatter.field("trial_component_summaries", &self.trial_component_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrialsOutputBody {
    /// <p>A list of the summaries of your trials.</p>
    #[serde(rename = "TrialSummaries")]
    #[serde(default)]
    pub trial_summaries: std::option::Option<std::vec::Vec<crate::model::TrialSummary>>,
    /// <p>A token for getting the next set of trials, if there are any.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTrialsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrialsOutputBody");
        formatter.field("trial_summaries", &self.trial_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUserProfilesOutputBody {
    /// <p>The list of user profiles.</p>
    #[serde(rename = "UserProfiles")]
    #[serde(default)]
    pub user_profiles: std::option::Option<std::vec::Vec<crate::model::UserProfileDetails>>,
    /// <p>If the previous response was truncated, you will receive this token.
    /// Use it in your next request to receive the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListUserProfilesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUserProfilesOutputBody");
        formatter.field("user_profiles", &self.user_profiles);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkforcesOutputBody {
    /// <p>A list containing information about your workforce.</p>
    #[serde(rename = "Workforces")]
    #[serde(default)]
    pub workforces: std::option::Option<std::vec::Vec<crate::model::Workforce>>,
    /// <p>A token to resume pagination.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListWorkforcesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkforcesOutputBody");
        formatter.field("workforces", &self.workforces);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkteamsOutputBody {
    /// <p>An array of <code>Workteam</code> objects, each describing a work team.</p>
    #[serde(rename = "Workteams")]
    #[serde(default)]
    pub workteams: std::option::Option<std::vec::Vec<crate::model::Workteam>>,
    /// <p>If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of
    /// work teams, use it in the subsequent request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListWorkteamsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkteamsOutputBody");
        formatter.field("workteams", &self.workteams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutModelPackageGroupPolicyOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model package group.</p>
    #[serde(rename = "ModelPackageGroupArn")]
    #[serde(default)]
    pub model_package_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutModelPackageGroupPolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutModelPackageGroupPolicyOutputBody");
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderUiTemplateOutputBody {
    /// <p>A Liquid template that renders the HTML for the worker UI.</p>
    #[serde(rename = "RenderedContent")]
    #[serde(default)]
    pub rendered_content: std::option::Option<std::string::String>,
    /// <p>A list of one or more <code>RenderingError</code> objects if any were encountered
    /// while rendering the template. If there were no errors, the list is empty.</p>
    #[serde(rename = "Errors")]
    #[serde(default)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::RenderingError>>,
}
impl std::fmt::Debug for RenderUiTemplateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderUiTemplateOutputBody");
        formatter.field("rendered_content", &self.rendered_content);
        formatter.field("errors", &self.errors);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchOutputBody {
    /// <p>A list of <code>SearchRecord</code> objects.</p>
    #[serde(rename = "Results")]
    #[serde(default)]
    pub results: std::option::Option<std::vec::Vec<crate::model::SearchRecord>>,
    /// <p>If the result of the previous <code>Search</code> request was truncated, the response
    /// includes a NextToken. To retrieve the next set of results, use the token in the next
    /// request.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SearchOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchOutputBody");
        formatter.field("results", &self.results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendPipelineExecutionStepFailureOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendPipelineExecutionStepFailureOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendPipelineExecutionStepFailureOutputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendPipelineExecutionStepSuccessOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendPipelineExecutionStepSuccessOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendPipelineExecutionStepSuccessOutputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPipelineExecutionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartPipelineExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPipelineExecutionOutputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPipelineExecutionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopPipelineExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPipelineExecutionOutputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateActionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    #[serde(rename = "ActionArn")]
    #[serde(default)]
    pub action_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateActionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateActionOutputBody");
        formatter.field("action_arn", &self.action_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAppImageConfigOutputBody {
    /// <p>The Amazon Resource Name (ARN) for the AppImageConfig.</p>
    #[serde(rename = "AppImageConfigArn")]
    #[serde(default)]
    pub app_image_config_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateAppImageConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAppImageConfigOutputBody");
        formatter.field("app_image_config_arn", &self.app_image_config_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateArtifactOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    #[serde(rename = "ArtifactArn")]
    #[serde(default)]
    pub artifact_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateArtifactOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateArtifactOutputBody");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCodeRepositoryOutputBody {
    /// <p>The ARN of the Git repository.</p>
    #[serde(rename = "CodeRepositoryArn")]
    #[serde(default)]
    pub code_repository_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateCodeRepositoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCodeRepositoryOutputBody");
        formatter.field("code_repository_arn", &self.code_repository_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateContextOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    #[serde(rename = "ContextArn")]
    #[serde(default)]
    pub context_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateContextOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateContextOutputBody");
        formatter.field("context_arn", &self.context_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDomainOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the domain.</p>
    #[serde(rename = "DomainArn")]
    #[serde(default)]
    pub domain_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateDomainOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDomainOutputBody");
        formatter.field("domain_arn", &self.domain_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    #[serde(rename = "EndpointArn")]
    #[serde(default)]
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointOutputBody");
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointWeightsAndCapacitiesOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the updated endpoint.</p>
    #[serde(rename = "EndpointArn")]
    #[serde(default)]
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateEndpointWeightsAndCapacitiesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointWeightsAndCapacitiesOutputBody");
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateExperimentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    #[serde(rename = "ExperimentArn")]
    #[serde(default)]
    pub experiment_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateExperimentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateExperimentOutputBody");
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateImageOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    #[serde(rename = "ImageArn")]
    #[serde(default)]
    pub image_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateImageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateImageOutputBody");
        formatter.field("image_arn", &self.image_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateModelPackageOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    #[serde(rename = "ModelPackageArn")]
    #[serde(default)]
    pub model_package_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateModelPackageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateModelPackageOutputBody");
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMonitoringScheduleOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    #[serde(rename = "MonitoringScheduleArn")]
    #[serde(default)]
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateMonitoringScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMonitoringScheduleOutputBody");
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the updated pipeline.</p>
    #[serde(rename = "PipelineArn")]
    #[serde(default)]
    pub pipeline_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdatePipelineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineOutputBody");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineExecutionOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the updated pipeline execution.</p>
    #[serde(rename = "PipelineExecutionArn")]
    #[serde(default)]
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdatePipelineExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineExecutionOutputBody");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrainingJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    #[serde(rename = "TrainingJobArn")]
    #[serde(default)]
    pub training_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateTrainingJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrainingJobOutputBody");
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrialOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    #[serde(rename = "TrialArn")]
    #[serde(default)]
    pub trial_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateTrialOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrialOutputBody");
        formatter.field("trial_arn", &self.trial_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTrialComponentOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    #[serde(rename = "TrialComponentArn")]
    #[serde(default)]
    pub trial_component_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateTrialComponentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTrialComponentOutputBody");
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserProfileOutputBody {
    /// <p>The user profile Amazon Resource Name (ARN).</p>
    #[serde(rename = "UserProfileArn")]
    #[serde(default)]
    pub user_profile_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateUserProfileOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserProfileOutputBody");
        formatter.field("user_profile_arn", &self.user_profile_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkforceOutputBody {
    /// <p>A single private workforce. You can create one private work force in each AWS Region. By default,
    /// any workforce-related API operation used in a specific region will apply to the
    /// workforce created in that region. To learn how to create a private workforce, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-create-private.html">Create a Private Workforce</a>.</p>
    #[serde(rename = "Workforce")]
    #[serde(default)]
    pub workforce: std::option::Option<crate::model::Workforce>,
}
impl std::fmt::Debug for UpdateWorkforceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkforceOutputBody");
        formatter.field("workforce", &self.workforce);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkteamOutputBody {
    /// <p>A <code>Workteam</code> object that describes the updated work team.</p>
    #[serde(rename = "Workteam")]
    #[serde(default)]
    pub workteam: std::option::Option<crate::model::Workteam>,
}
impl std::fmt::Debug for UpdateWorkteamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkteamOutputBody");
        formatter.field("workteam", &self.workteam);
        formatter.finish()
    }
}
