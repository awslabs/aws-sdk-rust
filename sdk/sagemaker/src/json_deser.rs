// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn add_association_deser_operation(
    input: &[u8],
    mut builder: crate::output::add_association_output::Builder,
) -> std::result::Result<crate::output::add_association_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::AddAssociationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_source_arn(parsed_body.source_arn);
    builder = builder.set_destination_arn(parsed_body.destination_arn);
    Ok(builder)
}

pub fn add_tags_deser_operation(
    input: &[u8],
    mut builder: crate::output::add_tags_output::Builder,
) -> std::result::Result<crate::output::add_tags_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::AddTagsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn associate_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::associate_trial_component_output::Builder,
) -> std::result::Result<crate::output::associate_trial_component_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::AssociateTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    Ok(builder)
}

pub fn create_action_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_action_output::Builder,
) -> std::result::Result<crate::output::create_action_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateActionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_action_arn(parsed_body.action_arn);
    Ok(builder)
}

pub fn create_algorithm_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_algorithm_output::Builder,
) -> std::result::Result<crate::output::create_algorithm_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateAlgorithmOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_algorithm_arn(parsed_body.algorithm_arn);
    Ok(builder)
}

pub fn create_app_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_app_output::Builder,
) -> std::result::Result<crate::output::create_app_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateAppOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_app_arn(parsed_body.app_arn);
    Ok(builder)
}

pub fn create_app_image_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_app_image_config_output::Builder,
) -> std::result::Result<crate::output::create_app_image_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateAppImageConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_app_image_config_arn(parsed_body.app_image_config_arn);
    Ok(builder)
}

pub fn create_artifact_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_artifact_output::Builder,
) -> std::result::Result<crate::output::create_artifact_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateArtifactOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_artifact_arn(parsed_body.artifact_arn);
    Ok(builder)
}

pub fn create_auto_ml_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_auto_ml_job_output::Builder,
) -> std::result::Result<crate::output::create_auto_ml_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateAutoMLJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_auto_ml_job_arn(parsed_body.auto_ml_job_arn);
    Ok(builder)
}

pub fn create_code_repository_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_code_repository_output::Builder,
) -> std::result::Result<crate::output::create_code_repository_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateCodeRepositoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_repository_arn(parsed_body.code_repository_arn);
    Ok(builder)
}

pub fn create_compilation_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_compilation_job_output::Builder,
) -> std::result::Result<crate::output::create_compilation_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateCompilationJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_compilation_job_arn(parsed_body.compilation_job_arn);
    Ok(builder)
}

pub fn create_context_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_context_output::Builder,
) -> std::result::Result<crate::output::create_context_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateContextOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_context_arn(parsed_body.context_arn);
    Ok(builder)
}

pub fn create_data_quality_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_data_quality_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::create_data_quality_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateDataQualityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    Ok(builder)
}

pub fn create_domain_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_domain_output::Builder,
) -> std::result::Result<crate::output::create_domain_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateDomainOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_domain_arn(parsed_body.domain_arn);
    builder = builder.set_url(parsed_body.url);
    Ok(builder)
}

pub fn create_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_endpoint_output::Builder,
) -> std::result::Result<crate::output::create_endpoint_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_arn(parsed_body.endpoint_arn);
    Ok(builder)
}

pub fn create_endpoint_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_endpoint_config_output::Builder,
) -> std::result::Result<crate::output::create_endpoint_config_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateEndpointConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_config_arn(parsed_body.endpoint_config_arn);
    Ok(builder)
}

pub fn create_experiment_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_experiment_output::Builder,
) -> std::result::Result<crate::output::create_experiment_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateExperimentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_experiment_arn(parsed_body.experiment_arn);
    Ok(builder)
}

pub fn create_feature_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_feature_group_output::Builder,
) -> std::result::Result<crate::output::create_feature_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateFeatureGroupOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_feature_group_arn(parsed_body.feature_group_arn);
    Ok(builder)
}

pub fn create_flow_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_flow_definition_output::Builder,
) -> std::result::Result<crate::output::create_flow_definition_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateFlowDefinitionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_flow_definition_arn(parsed_body.flow_definition_arn);
    Ok(builder)
}

pub fn create_human_task_ui_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_human_task_ui_output::Builder,
) -> std::result::Result<crate::output::create_human_task_ui_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateHumanTaskUiOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_human_task_ui_arn(parsed_body.human_task_ui_arn);
    Ok(builder)
}

pub fn create_hyper_parameter_tuning_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_hyper_parameter_tuning_job_output::Builder,
) -> std::result::Result<
    crate::output::create_hyper_parameter_tuning_job_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateHyperParameterTuningJobOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder =
        builder.set_hyper_parameter_tuning_job_arn(parsed_body.hyper_parameter_tuning_job_arn);
    Ok(builder)
}

pub fn create_image_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_image_output::Builder,
) -> std::result::Result<crate::output::create_image_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateImageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_image_arn(parsed_body.image_arn);
    Ok(builder)
}

pub fn create_image_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_image_version_output::Builder,
) -> std::result::Result<crate::output::create_image_version_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateImageVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_image_version_arn(parsed_body.image_version_arn);
    Ok(builder)
}

pub fn create_labeling_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_labeling_job_output::Builder,
) -> std::result::Result<crate::output::create_labeling_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateLabelingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_labeling_job_arn(parsed_body.labeling_job_arn);
    Ok(builder)
}

pub fn create_model_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_output::Builder,
) -> std::result::Result<crate::output::create_model_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateModelOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_arn(parsed_body.model_arn);
    Ok(builder)
}

pub fn create_model_bias_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_bias_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::create_model_bias_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateModelBiasJobDefinitionOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    Ok(builder)
}

pub fn create_model_explainability_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_explainability_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::create_model_explainability_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateModelExplainabilityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    Ok(builder)
}

pub fn create_model_package_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_package_output::Builder,
) -> std::result::Result<crate::output::create_model_package_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateModelPackageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_arn(parsed_body.model_package_arn);
    Ok(builder)
}

pub fn create_model_package_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_package_group_output::Builder,
) -> std::result::Result<crate::output::create_model_package_group_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateModelPackageGroupOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_group_arn(parsed_body.model_package_group_arn);
    Ok(builder)
}

pub fn create_model_quality_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_model_quality_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::create_model_quality_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateModelQualityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    Ok(builder)
}

pub fn create_monitoring_schedule_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_monitoring_schedule_output::Builder,
) -> std::result::Result<crate::output::create_monitoring_schedule_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateMonitoringScheduleOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_monitoring_schedule_arn(parsed_body.monitoring_schedule_arn);
    Ok(builder)
}

pub fn create_notebook_instance_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_notebook_instance_output::Builder,
) -> std::result::Result<crate::output::create_notebook_instance_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateNotebookInstanceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_notebook_instance_arn(parsed_body.notebook_instance_arn);
    Ok(builder)
}

pub fn create_notebook_instance_lifecycle_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_notebook_instance_lifecycle_config_output::Builder,
) -> std::result::Result<
    crate::output::create_notebook_instance_lifecycle_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateNotebookInstanceLifecycleConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_notebook_instance_lifecycle_config_arn(
        parsed_body.notebook_instance_lifecycle_config_arn,
    );
    Ok(builder)
}

pub fn create_pipeline_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_pipeline_output::Builder,
) -> std::result::Result<crate::output::create_pipeline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreatePipelineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_arn(parsed_body.pipeline_arn);
    Ok(builder)
}

pub fn create_presigned_domain_url_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_presigned_domain_url_output::Builder,
) -> std::result::Result<
    crate::output::create_presigned_domain_url_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreatePresignedDomainUrlOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_authorized_url(parsed_body.authorized_url);
    Ok(builder)
}

pub fn create_presigned_notebook_instance_url_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_presigned_notebook_instance_url_output::Builder,
) -> std::result::Result<
    crate::output::create_presigned_notebook_instance_url_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreatePresignedNotebookInstanceUrlOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_authorized_url(parsed_body.authorized_url);
    Ok(builder)
}

pub fn create_processing_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_processing_job_output::Builder,
) -> std::result::Result<crate::output::create_processing_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateProcessingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_processing_job_arn(parsed_body.processing_job_arn);
    Ok(builder)
}

pub fn create_project_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_project_output::Builder,
) -> std::result::Result<crate::output::create_project_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateProjectOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_project_arn(parsed_body.project_arn);
    builder = builder.set_project_id(parsed_body.project_id);
    Ok(builder)
}

pub fn create_training_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_training_job_output::Builder,
) -> std::result::Result<crate::output::create_training_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateTrainingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_training_job_arn(parsed_body.training_job_arn);
    Ok(builder)
}

pub fn create_transform_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_transform_job_output::Builder,
) -> std::result::Result<crate::output::create_transform_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateTransformJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_transform_job_arn(parsed_body.transform_job_arn);
    Ok(builder)
}

pub fn create_trial_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_trial_output::Builder,
) -> std::result::Result<crate::output::create_trial_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateTrialOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    Ok(builder)
}

pub fn create_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_trial_component_output::Builder,
) -> std::result::Result<crate::output::create_trial_component_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    Ok(builder)
}

pub fn create_user_profile_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_user_profile_output::Builder,
) -> std::result::Result<crate::output::create_user_profile_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateUserProfileOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_user_profile_arn(parsed_body.user_profile_arn);
    Ok(builder)
}

pub fn create_workforce_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_workforce_output::Builder,
) -> std::result::Result<crate::output::create_workforce_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateWorkforceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workforce_arn(parsed_body.workforce_arn);
    Ok(builder)
}

pub fn create_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_workteam_output::Builder,
) -> std::result::Result<crate::output::create_workteam_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateWorkteamOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workteam_arn(parsed_body.workteam_arn);
    Ok(builder)
}

pub fn delete_action_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_action_output::Builder,
) -> std::result::Result<crate::output::delete_action_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteActionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_action_arn(parsed_body.action_arn);
    Ok(builder)
}

pub fn delete_artifact_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_artifact_output::Builder,
) -> std::result::Result<crate::output::delete_artifact_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteArtifactOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_artifact_arn(parsed_body.artifact_arn);
    Ok(builder)
}

pub fn delete_association_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_association_output::Builder,
) -> std::result::Result<crate::output::delete_association_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteAssociationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_source_arn(parsed_body.source_arn);
    builder = builder.set_destination_arn(parsed_body.destination_arn);
    Ok(builder)
}

pub fn delete_context_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_context_output::Builder,
) -> std::result::Result<crate::output::delete_context_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteContextOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_context_arn(parsed_body.context_arn);
    Ok(builder)
}

pub fn delete_experiment_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_experiment_output::Builder,
) -> std::result::Result<crate::output::delete_experiment_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteExperimentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_experiment_arn(parsed_body.experiment_arn);
    Ok(builder)
}

pub fn delete_pipeline_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_pipeline_output::Builder,
) -> std::result::Result<crate::output::delete_pipeline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeletePipelineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_arn(parsed_body.pipeline_arn);
    Ok(builder)
}

pub fn delete_trial_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_trial_output::Builder,
) -> std::result::Result<crate::output::delete_trial_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteTrialOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    Ok(builder)
}

pub fn delete_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_trial_component_output::Builder,
) -> std::result::Result<crate::output::delete_trial_component_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    Ok(builder)
}

pub fn delete_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_workteam_output::Builder,
) -> std::result::Result<crate::output::delete_workteam_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteWorkteamOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_success(Some(parsed_body.success));
    Ok(builder)
}

pub fn describe_action_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_action_output::Builder,
) -> std::result::Result<crate::output::describe_action_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeActionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_action_name(parsed_body.action_name);
    builder = builder.set_action_arn(parsed_body.action_arn);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_action_type(parsed_body.action_type);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_properties(parsed_body.properties);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    builder = builder.set_metadata_properties(parsed_body.metadata_properties);
    Ok(builder)
}

pub fn describe_algorithm_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_algorithm_output::Builder,
) -> std::result::Result<crate::output::describe_algorithm_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeAlgorithmOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_algorithm_name(parsed_body.algorithm_name);
    builder = builder.set_algorithm_arn(parsed_body.algorithm_arn);
    builder = builder.set_algorithm_description(parsed_body.algorithm_description);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_training_specification(parsed_body.training_specification);
    builder = builder.set_inference_specification(parsed_body.inference_specification);
    builder = builder.set_validation_specification(parsed_body.validation_specification);
    builder = builder.set_algorithm_status(parsed_body.algorithm_status);
    builder = builder.set_algorithm_status_details(parsed_body.algorithm_status_details);
    builder = builder.set_product_id(parsed_body.product_id);
    builder = builder.set_certify_for_marketplace(Some(parsed_body.certify_for_marketplace));
    Ok(builder)
}

pub fn describe_app_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_app_output::Builder,
) -> std::result::Result<crate::output::describe_app_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeAppOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_app_arn(parsed_body.app_arn);
    builder = builder.set_app_type(parsed_body.app_type);
    builder = builder.set_app_name(parsed_body.app_name);
    builder = builder.set_domain_id(parsed_body.domain_id);
    builder = builder.set_user_profile_name(parsed_body.user_profile_name);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_last_health_check_timestamp(parsed_body.last_health_check_timestamp);
    builder = builder.set_last_user_activity_timestamp(parsed_body.last_user_activity_timestamp);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_resource_spec(parsed_body.resource_spec);
    Ok(builder)
}

pub fn describe_app_image_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_app_image_config_output::Builder,
) -> std::result::Result<crate::output::describe_app_image_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeAppImageConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_app_image_config_arn(parsed_body.app_image_config_arn);
    builder = builder.set_app_image_config_name(parsed_body.app_image_config_name);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_kernel_gateway_image_config(parsed_body.kernel_gateway_image_config);
    Ok(builder)
}

pub fn describe_artifact_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_artifact_output::Builder,
) -> std::result::Result<crate::output::describe_artifact_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeArtifactOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_artifact_name(parsed_body.artifact_name);
    builder = builder.set_artifact_arn(parsed_body.artifact_arn);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_artifact_type(parsed_body.artifact_type);
    builder = builder.set_properties(parsed_body.properties);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    builder = builder.set_metadata_properties(parsed_body.metadata_properties);
    Ok(builder)
}

pub fn describe_auto_ml_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_auto_ml_job_output::Builder,
) -> std::result::Result<crate::output::describe_auto_ml_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeAutoMLJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_auto_ml_job_name(parsed_body.auto_ml_job_name);
    builder = builder.set_auto_ml_job_arn(parsed_body.auto_ml_job_arn);
    builder = builder.set_input_data_config(parsed_body.input_data_config);
    builder = builder.set_output_data_config(parsed_body.output_data_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_auto_ml_job_objective(parsed_body.auto_ml_job_objective);
    builder = builder.set_problem_type(parsed_body.problem_type);
    builder = builder.set_auto_ml_job_config(parsed_body.auto_ml_job_config);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_end_time(parsed_body.end_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_partial_failure_reasons(parsed_body.partial_failure_reasons);
    builder = builder.set_best_candidate(parsed_body.best_candidate);
    builder = builder.set_auto_ml_job_status(parsed_body.auto_ml_job_status);
    builder = builder.set_auto_ml_job_secondary_status(parsed_body.auto_ml_job_secondary_status);
    builder = builder.set_generate_candidate_definitions_only(Some(
        parsed_body.generate_candidate_definitions_only,
    ));
    builder = builder.set_auto_ml_job_artifacts(parsed_body.auto_ml_job_artifacts);
    builder = builder.set_resolved_attributes(parsed_body.resolved_attributes);
    builder = builder.set_model_deploy_config(parsed_body.model_deploy_config);
    builder = builder.set_model_deploy_result(parsed_body.model_deploy_result);
    Ok(builder)
}

pub fn describe_code_repository_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_code_repository_output::Builder,
) -> std::result::Result<crate::output::describe_code_repository_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeCodeRepositoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_repository_name(parsed_body.code_repository_name);
    builder = builder.set_code_repository_arn(parsed_body.code_repository_arn);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_git_config(parsed_body.git_config);
    Ok(builder)
}

pub fn describe_compilation_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_compilation_job_output::Builder,
) -> std::result::Result<crate::output::describe_compilation_job_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeCompilationJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_compilation_job_name(parsed_body.compilation_job_name);
    builder = builder.set_compilation_job_arn(parsed_body.compilation_job_arn);
    builder = builder.set_compilation_job_status(parsed_body.compilation_job_status);
    builder = builder.set_compilation_start_time(parsed_body.compilation_start_time);
    builder = builder.set_compilation_end_time(parsed_body.compilation_end_time);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_model_artifacts(parsed_body.model_artifacts);
    builder = builder.set_model_digests(parsed_body.model_digests);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_input_config(parsed_body.input_config);
    builder = builder.set_output_config(parsed_body.output_config);
    Ok(builder)
}

pub fn describe_context_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_context_output::Builder,
) -> std::result::Result<crate::output::describe_context_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeContextOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_context_name(parsed_body.context_name);
    builder = builder.set_context_arn(parsed_body.context_arn);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_context_type(parsed_body.context_type);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_properties(parsed_body.properties);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    Ok(builder)
}

pub fn describe_data_quality_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_data_quality_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::describe_data_quality_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeDataQualityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    builder = builder.set_job_definition_name(parsed_body.job_definition_name);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_data_quality_baseline_config(parsed_body.data_quality_baseline_config);
    builder =
        builder.set_data_quality_app_specification(parsed_body.data_quality_app_specification);
    builder = builder.set_data_quality_job_input(parsed_body.data_quality_job_input);
    builder =
        builder.set_data_quality_job_output_config(parsed_body.data_quality_job_output_config);
    builder = builder.set_job_resources(parsed_body.job_resources);
    builder = builder.set_network_config(parsed_body.network_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    Ok(builder)
}

pub fn describe_device_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_device_output::Builder,
) -> std::result::Result<crate::output::describe_device_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeDeviceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_device_arn(parsed_body.device_arn);
    builder = builder.set_device_name(parsed_body.device_name);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_device_fleet_name(parsed_body.device_fleet_name);
    builder = builder.set_iot_thing_name(parsed_body.iot_thing_name);
    builder = builder.set_registration_time(parsed_body.registration_time);
    builder = builder.set_latest_heartbeat(parsed_body.latest_heartbeat);
    builder = builder.set_models(parsed_body.models);
    builder = builder.set_max_models(Some(parsed_body.max_models));
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_device_fleet_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_device_fleet_output::Builder,
) -> std::result::Result<crate::output::describe_device_fleet_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeDeviceFleetOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_device_fleet_name(parsed_body.device_fleet_name);
    builder = builder.set_device_fleet_arn(parsed_body.device_fleet_arn);
    builder = builder.set_output_config(parsed_body.output_config);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_iot_role_alias(parsed_body.iot_role_alias);
    Ok(builder)
}

pub fn describe_domain_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_domain_output::Builder,
) -> std::result::Result<crate::output::describe_domain_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeDomainOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_domain_arn(parsed_body.domain_arn);
    builder = builder.set_domain_id(parsed_body.domain_id);
    builder = builder.set_domain_name(parsed_body.domain_name);
    builder = builder.set_home_efs_file_system_id(parsed_body.home_efs_file_system_id);
    builder = builder.set_single_sign_on_managed_application_instance_id(
        parsed_body.single_sign_on_managed_application_instance_id,
    );
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_auth_mode(parsed_body.auth_mode);
    builder = builder.set_default_user_settings(parsed_body.default_user_settings);
    builder = builder.set_app_network_access_type(parsed_body.app_network_access_type);
    builder =
        builder.set_home_efs_file_system_kms_key_id(parsed_body.home_efs_file_system_kms_key_id);
    builder = builder.set_subnet_ids(parsed_body.subnet_ids);
    builder = builder.set_url(parsed_body.url);
    builder = builder.set_vpc_id(parsed_body.vpc_id);
    builder = builder.set_kms_key_id(parsed_body.kms_key_id);
    Ok(builder)
}

pub fn describe_edge_packaging_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_edge_packaging_job_output::Builder,
) -> std::result::Result<
    crate::output::describe_edge_packaging_job_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeEdgePackagingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_edge_packaging_job_arn(parsed_body.edge_packaging_job_arn);
    builder = builder.set_edge_packaging_job_name(parsed_body.edge_packaging_job_name);
    builder = builder.set_compilation_job_name(parsed_body.compilation_job_name);
    builder = builder.set_model_name(parsed_body.model_name);
    builder = builder.set_model_version(parsed_body.model_version);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_output_config(parsed_body.output_config);
    builder = builder.set_resource_key(parsed_body.resource_key);
    builder = builder.set_edge_packaging_job_status(parsed_body.edge_packaging_job_status);
    builder = builder
        .set_edge_packaging_job_status_message(parsed_body.edge_packaging_job_status_message);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_model_artifact(parsed_body.model_artifact);
    builder = builder.set_model_signature(parsed_body.model_signature);
    builder = builder.set_preset_deployment_output(parsed_body.preset_deployment_output);
    Ok(builder)
}

pub fn describe_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_endpoint_output::Builder,
) -> std::result::Result<crate::output::describe_endpoint_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_name(parsed_body.endpoint_name);
    builder = builder.set_endpoint_arn(parsed_body.endpoint_arn);
    builder = builder.set_endpoint_config_name(parsed_body.endpoint_config_name);
    builder = builder.set_production_variants(parsed_body.production_variants);
    builder = builder.set_data_capture_config(parsed_body.data_capture_config);
    builder = builder.set_endpoint_status(parsed_body.endpoint_status);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_deployment_config(parsed_body.last_deployment_config);
    Ok(builder)
}

pub fn describe_endpoint_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_endpoint_config_output::Builder,
) -> std::result::Result<crate::output::describe_endpoint_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeEndpointConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_config_name(parsed_body.endpoint_config_name);
    builder = builder.set_endpoint_config_arn(parsed_body.endpoint_config_arn);
    builder = builder.set_production_variants(parsed_body.production_variants);
    builder = builder.set_data_capture_config(parsed_body.data_capture_config);
    builder = builder.set_kms_key_id(parsed_body.kms_key_id);
    builder = builder.set_creation_time(parsed_body.creation_time);
    Ok(builder)
}

pub fn describe_experiment_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_experiment_output::Builder,
) -> std::result::Result<crate::output::describe_experiment_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeExperimentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_experiment_name(parsed_body.experiment_name);
    builder = builder.set_experiment_arn(parsed_body.experiment_arn);
    builder = builder.set_display_name(parsed_body.display_name);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    Ok(builder)
}

pub fn describe_feature_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_feature_group_output::Builder,
) -> std::result::Result<crate::output::describe_feature_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeFeatureGroupOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_feature_group_arn(parsed_body.feature_group_arn);
    builder = builder.set_feature_group_name(parsed_body.feature_group_name);
    builder =
        builder.set_record_identifier_feature_name(parsed_body.record_identifier_feature_name);
    builder = builder.set_event_time_feature_name(parsed_body.event_time_feature_name);
    builder = builder.set_feature_definitions(parsed_body.feature_definitions);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_online_store_config(parsed_body.online_store_config);
    builder = builder.set_offline_store_config(parsed_body.offline_store_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_feature_group_status(parsed_body.feature_group_status);
    builder = builder.set_offline_store_status(parsed_body.offline_store_status);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_flow_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_flow_definition_output::Builder,
) -> std::result::Result<crate::output::describe_flow_definition_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeFlowDefinitionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_flow_definition_arn(parsed_body.flow_definition_arn);
    builder = builder.set_flow_definition_name(parsed_body.flow_definition_name);
    builder = builder.set_flow_definition_status(parsed_body.flow_definition_status);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_human_loop_request_source(parsed_body.human_loop_request_source);
    builder = builder.set_human_loop_activation_config(parsed_body.human_loop_activation_config);
    builder = builder.set_human_loop_config(parsed_body.human_loop_config);
    builder = builder.set_output_config(parsed_body.output_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    Ok(builder)
}

pub fn describe_human_task_ui_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_human_task_ui_output::Builder,
) -> std::result::Result<crate::output::describe_human_task_ui_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeHumanTaskUiOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_human_task_ui_arn(parsed_body.human_task_ui_arn);
    builder = builder.set_human_task_ui_name(parsed_body.human_task_ui_name);
    builder = builder.set_human_task_ui_status(parsed_body.human_task_ui_status);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_ui_template(parsed_body.ui_template);
    Ok(builder)
}

pub fn describe_hyper_parameter_tuning_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_hyper_parameter_tuning_job_output::Builder,
) -> std::result::Result<
    crate::output::describe_hyper_parameter_tuning_job_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeHyperParameterTuningJobOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder =
        builder.set_hyper_parameter_tuning_job_name(parsed_body.hyper_parameter_tuning_job_name);
    builder =
        builder.set_hyper_parameter_tuning_job_arn(parsed_body.hyper_parameter_tuning_job_arn);
    builder = builder
        .set_hyper_parameter_tuning_job_config(parsed_body.hyper_parameter_tuning_job_config);
    builder = builder.set_training_job_definition(parsed_body.training_job_definition);
    builder = builder.set_training_job_definitions(parsed_body.training_job_definitions);
    builder = builder
        .set_hyper_parameter_tuning_job_status(parsed_body.hyper_parameter_tuning_job_status);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder =
        builder.set_hyper_parameter_tuning_end_time(parsed_body.hyper_parameter_tuning_end_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_training_job_status_counters(parsed_body.training_job_status_counters);
    builder = builder.set_objective_status_counters(parsed_body.objective_status_counters);
    builder = builder.set_best_training_job(parsed_body.best_training_job);
    builder = builder.set_overall_best_training_job(parsed_body.overall_best_training_job);
    builder = builder.set_warm_start_config(parsed_body.warm_start_config);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    Ok(builder)
}

pub fn describe_image_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_image_output::Builder,
) -> std::result::Result<crate::output::describe_image_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeImageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_display_name(parsed_body.display_name);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_image_arn(parsed_body.image_arn);
    builder = builder.set_image_name(parsed_body.image_name);
    builder = builder.set_image_status(parsed_body.image_status);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_role_arn(parsed_body.role_arn);
    Ok(builder)
}

pub fn describe_image_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_image_version_output::Builder,
) -> std::result::Result<crate::output::describe_image_version_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeImageVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_base_image(parsed_body.base_image);
    builder = builder.set_container_image(parsed_body.container_image);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_image_arn(parsed_body.image_arn);
    builder = builder.set_image_version_arn(parsed_body.image_version_arn);
    builder = builder.set_image_version_status(parsed_body.image_version_status);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_version(parsed_body.version);
    Ok(builder)
}

pub fn describe_labeling_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_labeling_job_output::Builder,
) -> std::result::Result<crate::output::describe_labeling_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeLabelingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_labeling_job_status(parsed_body.labeling_job_status);
    builder = builder.set_label_counters(parsed_body.label_counters);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_job_reference_code(parsed_body.job_reference_code);
    builder = builder.set_labeling_job_name(parsed_body.labeling_job_name);
    builder = builder.set_labeling_job_arn(parsed_body.labeling_job_arn);
    builder = builder.set_label_attribute_name(parsed_body.label_attribute_name);
    builder = builder.set_input_config(parsed_body.input_config);
    builder = builder.set_output_config(parsed_body.output_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_label_category_config_s3_uri(parsed_body.label_category_config_s3_uri);
    builder = builder.set_stopping_conditions(parsed_body.stopping_conditions);
    builder =
        builder.set_labeling_job_algorithms_config(parsed_body.labeling_job_algorithms_config);
    builder = builder.set_human_task_config(parsed_body.human_task_config);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_labeling_job_output(parsed_body.labeling_job_output);
    Ok(builder)
}

pub fn describe_model_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_output::Builder,
) -> std::result::Result<crate::output::describe_model_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeModelOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_name(parsed_body.model_name);
    builder = builder.set_primary_container(parsed_body.primary_container);
    builder = builder.set_containers(parsed_body.containers);
    builder = builder.set_inference_execution_config(parsed_body.inference_execution_config);
    builder = builder.set_execution_role_arn(parsed_body.execution_role_arn);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_model_arn(parsed_body.model_arn);
    builder = builder.set_enable_network_isolation(Some(parsed_body.enable_network_isolation));
    Ok(builder)
}

pub fn describe_model_bias_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_bias_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::describe_model_bias_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeModelBiasJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    builder = builder.set_job_definition_name(parsed_body.job_definition_name);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_model_bias_baseline_config(parsed_body.model_bias_baseline_config);
    builder = builder.set_model_bias_app_specification(parsed_body.model_bias_app_specification);
    builder = builder.set_model_bias_job_input(parsed_body.model_bias_job_input);
    builder = builder.set_model_bias_job_output_config(parsed_body.model_bias_job_output_config);
    builder = builder.set_job_resources(parsed_body.job_resources);
    builder = builder.set_network_config(parsed_body.network_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    Ok(builder)
}

pub fn describe_model_explainability_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_explainability_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::describe_model_explainability_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeModelExplainabilityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    builder = builder.set_job_definition_name(parsed_body.job_definition_name);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder
        .set_model_explainability_baseline_config(parsed_body.model_explainability_baseline_config);
    builder = builder.set_model_explainability_app_specification(
        parsed_body.model_explainability_app_specification,
    );
    builder =
        builder.set_model_explainability_job_input(parsed_body.model_explainability_job_input);
    builder = builder.set_model_explainability_job_output_config(
        parsed_body.model_explainability_job_output_config,
    );
    builder = builder.set_job_resources(parsed_body.job_resources);
    builder = builder.set_network_config(parsed_body.network_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    Ok(builder)
}

pub fn describe_model_package_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_package_output::Builder,
) -> std::result::Result<crate::output::describe_model_package_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeModelPackageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_name(parsed_body.model_package_name);
    builder = builder.set_model_package_group_name(parsed_body.model_package_group_name);
    builder = builder.set_model_package_version(parsed_body.model_package_version);
    builder = builder.set_model_package_arn(parsed_body.model_package_arn);
    builder = builder.set_model_package_description(parsed_body.model_package_description);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_inference_specification(parsed_body.inference_specification);
    builder =
        builder.set_source_algorithm_specification(parsed_body.source_algorithm_specification);
    builder = builder.set_validation_specification(parsed_body.validation_specification);
    builder = builder.set_model_package_status(parsed_body.model_package_status);
    builder = builder.set_model_package_status_details(parsed_body.model_package_status_details);
    builder = builder.set_certify_for_marketplace(Some(parsed_body.certify_for_marketplace));
    builder = builder.set_model_approval_status(parsed_body.model_approval_status);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_metadata_properties(parsed_body.metadata_properties);
    builder = builder.set_model_metrics(parsed_body.model_metrics);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    builder = builder.set_approval_description(parsed_body.approval_description);
    Ok(builder)
}

pub fn describe_model_package_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_package_group_output::Builder,
) -> std::result::Result<
    crate::output::describe_model_package_group_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeModelPackageGroupOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_group_name(parsed_body.model_package_group_name);
    builder = builder.set_model_package_group_arn(parsed_body.model_package_group_arn);
    builder =
        builder.set_model_package_group_description(parsed_body.model_package_group_description);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_model_package_group_status(parsed_body.model_package_group_status);
    Ok(builder)
}

pub fn describe_model_quality_job_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_model_quality_job_definition_output::Builder,
) -> std::result::Result<
    crate::output::describe_model_quality_job_definition_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeModelQualityJobDefinitionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_arn(parsed_body.job_definition_arn);
    builder = builder.set_job_definition_name(parsed_body.job_definition_name);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_model_quality_baseline_config(parsed_body.model_quality_baseline_config);
    builder =
        builder.set_model_quality_app_specification(parsed_body.model_quality_app_specification);
    builder = builder.set_model_quality_job_input(parsed_body.model_quality_job_input);
    builder =
        builder.set_model_quality_job_output_config(parsed_body.model_quality_job_output_config);
    builder = builder.set_job_resources(parsed_body.job_resources);
    builder = builder.set_network_config(parsed_body.network_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    Ok(builder)
}

pub fn describe_monitoring_schedule_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_monitoring_schedule_output::Builder,
) -> std::result::Result<
    crate::output::describe_monitoring_schedule_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMonitoringScheduleOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_monitoring_schedule_arn(parsed_body.monitoring_schedule_arn);
    builder = builder.set_monitoring_schedule_name(parsed_body.monitoring_schedule_name);
    builder = builder.set_monitoring_schedule_status(parsed_body.monitoring_schedule_status);
    builder = builder.set_monitoring_type(parsed_body.monitoring_type);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_monitoring_schedule_config(parsed_body.monitoring_schedule_config);
    builder = builder.set_endpoint_name(parsed_body.endpoint_name);
    builder = builder
        .set_last_monitoring_execution_summary(parsed_body.last_monitoring_execution_summary);
    Ok(builder)
}

pub fn describe_notebook_instance_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_notebook_instance_output::Builder,
) -> std::result::Result<crate::output::describe_notebook_instance_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeNotebookInstanceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_notebook_instance_arn(parsed_body.notebook_instance_arn);
    builder = builder.set_notebook_instance_name(parsed_body.notebook_instance_name);
    builder = builder.set_notebook_instance_status(parsed_body.notebook_instance_status);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_url(parsed_body.url);
    builder = builder.set_instance_type(parsed_body.instance_type);
    builder = builder.set_subnet_id(parsed_body.subnet_id);
    builder = builder.set_security_groups(parsed_body.security_groups);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_kms_key_id(parsed_body.kms_key_id);
    builder = builder.set_network_interface_id(parsed_body.network_interface_id);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_notebook_instance_lifecycle_config_name(
        parsed_body.notebook_instance_lifecycle_config_name,
    );
    builder = builder.set_direct_internet_access(parsed_body.direct_internet_access);
    builder = builder.set_volume_size_in_gb(parsed_body.volume_size_in_gb);
    builder = builder.set_accelerator_types(parsed_body.accelerator_types);
    builder = builder.set_default_code_repository(parsed_body.default_code_repository);
    builder = builder.set_additional_code_repositories(parsed_body.additional_code_repositories);
    builder = builder.set_root_access(parsed_body.root_access);
    Ok(builder)
}

pub fn describe_notebook_instance_lifecycle_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_notebook_instance_lifecycle_config_output::Builder,
) -> std::result::Result<
    crate::output::describe_notebook_instance_lifecycle_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeNotebookInstanceLifecycleConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_notebook_instance_lifecycle_config_arn(
        parsed_body.notebook_instance_lifecycle_config_arn,
    );
    builder = builder.set_notebook_instance_lifecycle_config_name(
        parsed_body.notebook_instance_lifecycle_config_name,
    );
    builder = builder.set_on_create(parsed_body.on_create);
    builder = builder.set_on_start(parsed_body.on_start);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_creation_time(parsed_body.creation_time);
    Ok(builder)
}

pub fn describe_pipeline_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_pipeline_output::Builder,
) -> std::result::Result<crate::output::describe_pipeline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribePipelineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_arn(parsed_body.pipeline_arn);
    builder = builder.set_pipeline_name(parsed_body.pipeline_name);
    builder = builder.set_pipeline_display_name(parsed_body.pipeline_display_name);
    builder = builder.set_pipeline_definition(parsed_body.pipeline_definition);
    builder = builder.set_pipeline_description(parsed_body.pipeline_description);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_pipeline_status(parsed_body.pipeline_status);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_run_time(parsed_body.last_run_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    Ok(builder)
}

pub fn describe_pipeline_definition_for_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_pipeline_definition_for_execution_output::Builder,
) -> std::result::Result<
    crate::output::describe_pipeline_definition_for_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribePipelineDefinitionForExecutionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_pipeline_definition(parsed_body.pipeline_definition);
    builder = builder.set_creation_time(parsed_body.creation_time);
    Ok(builder)
}

pub fn describe_pipeline_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_pipeline_execution_output::Builder,
) -> std::result::Result<
    crate::output::describe_pipeline_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribePipelineExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_arn(parsed_body.pipeline_arn);
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    builder =
        builder.set_pipeline_execution_display_name(parsed_body.pipeline_execution_display_name);
    builder = builder.set_pipeline_execution_status(parsed_body.pipeline_execution_status);
    builder =
        builder.set_pipeline_execution_description(parsed_body.pipeline_execution_description);
    builder = builder.set_pipeline_experiment_config(parsed_body.pipeline_experiment_config);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    Ok(builder)
}

pub fn describe_processing_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_processing_job_output::Builder,
) -> std::result::Result<crate::output::describe_processing_job_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeProcessingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_processing_inputs(parsed_body.processing_inputs);
    builder = builder.set_processing_output_config(parsed_body.processing_output_config);
    builder = builder.set_processing_job_name(parsed_body.processing_job_name);
    builder = builder.set_processing_resources(parsed_body.processing_resources);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    builder = builder.set_app_specification(parsed_body.app_specification);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_network_config(parsed_body.network_config);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_experiment_config(parsed_body.experiment_config);
    builder = builder.set_processing_job_arn(parsed_body.processing_job_arn);
    builder = builder.set_processing_job_status(parsed_body.processing_job_status);
    builder = builder.set_exit_message(parsed_body.exit_message);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_processing_end_time(parsed_body.processing_end_time);
    builder = builder.set_processing_start_time(parsed_body.processing_start_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_monitoring_schedule_arn(parsed_body.monitoring_schedule_arn);
    builder = builder.set_auto_ml_job_arn(parsed_body.auto_ml_job_arn);
    builder = builder.set_training_job_arn(parsed_body.training_job_arn);
    Ok(builder)
}

pub fn describe_project_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_project_output::Builder,
) -> std::result::Result<crate::output::describe_project_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeProjectOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_project_arn(parsed_body.project_arn);
    builder = builder.set_project_name(parsed_body.project_name);
    builder = builder.set_project_id(parsed_body.project_id);
    builder = builder.set_project_description(parsed_body.project_description);
    builder = builder
        .set_service_catalog_provisioning_details(parsed_body.service_catalog_provisioning_details);
    builder = builder.set_service_catalog_provisioned_product_details(
        parsed_body.service_catalog_provisioned_product_details,
    );
    builder = builder.set_project_status(parsed_body.project_status);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_creation_time(parsed_body.creation_time);
    Ok(builder)
}

pub fn describe_subscribed_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_subscribed_workteam_output::Builder,
) -> std::result::Result<
    crate::output::describe_subscribed_workteam_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeSubscribedWorkteamOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_subscribed_workteam(parsed_body.subscribed_workteam);
    Ok(builder)
}

pub fn describe_training_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_training_job_output::Builder,
) -> std::result::Result<crate::output::describe_training_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTrainingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_training_job_name(parsed_body.training_job_name);
    builder = builder.set_training_job_arn(parsed_body.training_job_arn);
    builder = builder.set_tuning_job_arn(parsed_body.tuning_job_arn);
    builder = builder.set_labeling_job_arn(parsed_body.labeling_job_arn);
    builder = builder.set_auto_ml_job_arn(parsed_body.auto_ml_job_arn);
    builder = builder.set_model_artifacts(parsed_body.model_artifacts);
    builder = builder.set_training_job_status(parsed_body.training_job_status);
    builder = builder.set_secondary_status(parsed_body.secondary_status);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_hyper_parameters(parsed_body.hyper_parameters);
    builder = builder.set_algorithm_specification(parsed_body.algorithm_specification);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_input_data_config(parsed_body.input_data_config);
    builder = builder.set_output_data_config(parsed_body.output_data_config);
    builder = builder.set_resource_config(parsed_body.resource_config);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_stopping_condition(parsed_body.stopping_condition);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_training_start_time(parsed_body.training_start_time);
    builder = builder.set_training_end_time(parsed_body.training_end_time);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_secondary_status_transitions(parsed_body.secondary_status_transitions);
    builder = builder.set_final_metric_data_list(parsed_body.final_metric_data_list);
    builder = builder.set_enable_network_isolation(Some(parsed_body.enable_network_isolation));
    builder = builder.set_enable_inter_container_traffic_encryption(Some(
        parsed_body.enable_inter_container_traffic_encryption,
    ));
    builder =
        builder.set_enable_managed_spot_training(Some(parsed_body.enable_managed_spot_training));
    builder = builder.set_checkpoint_config(parsed_body.checkpoint_config);
    builder = builder.set_training_time_in_seconds(parsed_body.training_time_in_seconds);
    builder = builder.set_billable_time_in_seconds(parsed_body.billable_time_in_seconds);
    builder = builder.set_debug_hook_config(parsed_body.debug_hook_config);
    builder = builder.set_experiment_config(parsed_body.experiment_config);
    builder = builder.set_debug_rule_configurations(parsed_body.debug_rule_configurations);
    builder = builder.set_tensor_board_output_config(parsed_body.tensor_board_output_config);
    builder =
        builder.set_debug_rule_evaluation_statuses(parsed_body.debug_rule_evaluation_statuses);
    builder = builder.set_profiler_config(parsed_body.profiler_config);
    builder = builder.set_profiler_rule_configurations(parsed_body.profiler_rule_configurations);
    builder = builder
        .set_profiler_rule_evaluation_statuses(parsed_body.profiler_rule_evaluation_statuses);
    builder = builder.set_profiling_status(parsed_body.profiling_status);
    builder = builder.set_retry_strategy(parsed_body.retry_strategy);
    builder = builder.set_environment(parsed_body.environment);
    Ok(builder)
}

pub fn describe_transform_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_transform_job_output::Builder,
) -> std::result::Result<crate::output::describe_transform_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTransformJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_transform_job_name(parsed_body.transform_job_name);
    builder = builder.set_transform_job_arn(parsed_body.transform_job_arn);
    builder = builder.set_transform_job_status(parsed_body.transform_job_status);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_model_name(parsed_body.model_name);
    builder = builder.set_max_concurrent_transforms(parsed_body.max_concurrent_transforms);
    builder = builder.set_model_client_config(parsed_body.model_client_config);
    builder = builder.set_max_payload_in_mb(parsed_body.max_payload_in_mb);
    builder = builder.set_batch_strategy(parsed_body.batch_strategy);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_transform_input(parsed_body.transform_input);
    builder = builder.set_transform_output(parsed_body.transform_output);
    builder = builder.set_transform_resources(parsed_body.transform_resources);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_transform_start_time(parsed_body.transform_start_time);
    builder = builder.set_transform_end_time(parsed_body.transform_end_time);
    builder = builder.set_labeling_job_arn(parsed_body.labeling_job_arn);
    builder = builder.set_auto_ml_job_arn(parsed_body.auto_ml_job_arn);
    builder = builder.set_data_processing(parsed_body.data_processing);
    builder = builder.set_experiment_config(parsed_body.experiment_config);
    Ok(builder)
}

pub fn describe_trial_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_trial_output::Builder,
) -> std::result::Result<crate::output::describe_trial_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTrialOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_name(parsed_body.trial_name);
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    builder = builder.set_display_name(parsed_body.display_name);
    builder = builder.set_experiment_name(parsed_body.experiment_name);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    builder = builder.set_metadata_properties(parsed_body.metadata_properties);
    Ok(builder)
}

pub fn describe_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_trial_component_output::Builder,
) -> std::result::Result<crate::output::describe_trial_component_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_name(parsed_body.trial_component_name);
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    builder = builder.set_display_name(parsed_body.display_name);
    builder = builder.set_source(parsed_body.source);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_end_time(parsed_body.end_time);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_created_by(parsed_body.created_by);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_last_modified_by(parsed_body.last_modified_by);
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_input_artifacts(parsed_body.input_artifacts);
    builder = builder.set_output_artifacts(parsed_body.output_artifacts);
    builder = builder.set_metadata_properties(parsed_body.metadata_properties);
    builder = builder.set_metrics(parsed_body.metrics);
    Ok(builder)
}

pub fn describe_user_profile_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_user_profile_output::Builder,
) -> std::result::Result<crate::output::describe_user_profile_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeUserProfileOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_domain_id(parsed_body.domain_id);
    builder = builder.set_user_profile_arn(parsed_body.user_profile_arn);
    builder = builder.set_user_profile_name(parsed_body.user_profile_name);
    builder = builder.set_home_efs_file_system_uid(parsed_body.home_efs_file_system_uid);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_last_modified_time(parsed_body.last_modified_time);
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder =
        builder.set_single_sign_on_user_identifier(parsed_body.single_sign_on_user_identifier);
    builder = builder.set_single_sign_on_user_value(parsed_body.single_sign_on_user_value);
    builder = builder.set_user_settings(parsed_body.user_settings);
    Ok(builder)
}

pub fn describe_workforce_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_workforce_output::Builder,
) -> std::result::Result<crate::output::describe_workforce_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeWorkforceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workforce(parsed_body.workforce);
    Ok(builder)
}

pub fn describe_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_workteam_output::Builder,
) -> std::result::Result<crate::output::describe_workteam_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeWorkteamOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workteam(parsed_body.workteam);
    Ok(builder)
}

pub fn disassociate_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::disassociate_trial_component_output::Builder,
) -> std::result::Result<
    crate::output::disassociate_trial_component_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DisassociateTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    Ok(builder)
}

pub fn get_device_fleet_report_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_device_fleet_report_output::Builder,
) -> std::result::Result<crate::output::get_device_fleet_report_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetDeviceFleetReportOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_device_fleet_arn(parsed_body.device_fleet_arn);
    builder = builder.set_device_fleet_name(parsed_body.device_fleet_name);
    builder = builder.set_output_config(parsed_body.output_config);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_report_generated(parsed_body.report_generated);
    builder = builder.set_device_stats(parsed_body.device_stats);
    builder = builder.set_agent_versions(parsed_body.agent_versions);
    builder = builder.set_model_stats(parsed_body.model_stats);
    Ok(builder)
}

pub fn get_model_package_group_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_model_package_group_policy_output::Builder,
) -> std::result::Result<
    crate::output::get_model_package_group_policy_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetModelPackageGroupPolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_resource_policy(parsed_body.resource_policy);
    Ok(builder)
}

pub fn get_sagemaker_servicecatalog_portfolio_status_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_sagemaker_servicecatalog_portfolio_status_output::Builder,
) -> std::result::Result<
    crate::output::get_sagemaker_servicecatalog_portfolio_status_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetSagemakerServicecatalogPortfolioStatusOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_status(parsed_body.status);
    Ok(builder)
}

pub fn get_search_suggestions_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_search_suggestions_output::Builder,
) -> std::result::Result<crate::output::get_search_suggestions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetSearchSuggestionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_property_name_suggestions(parsed_body.property_name_suggestions);
    Ok(builder)
}

pub fn list_actions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_actions_output::Builder,
) -> std::result::Result<crate::output::list_actions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListActionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_action_summaries(parsed_body.action_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_algorithms_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_algorithms_output::Builder,
) -> std::result::Result<crate::output::list_algorithms_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAlgorithmsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_algorithm_summary_list(parsed_body.algorithm_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_app_image_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_app_image_configs_output::Builder,
) -> std::result::Result<crate::output::list_app_image_configs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAppImageConfigsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_app_image_configs(parsed_body.app_image_configs);
    Ok(builder)
}

pub fn list_apps_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_apps_output::Builder,
) -> std::result::Result<crate::output::list_apps_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAppsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_apps(parsed_body.apps);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_artifacts_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_artifacts_output::Builder,
) -> std::result::Result<crate::output::list_artifacts_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListArtifactsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_artifact_summaries(parsed_body.artifact_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_associations_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_associations_output::Builder,
) -> std::result::Result<crate::output::list_associations_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAssociationsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_summaries(parsed_body.association_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_auto_ml_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_auto_ml_jobs_output::Builder,
) -> std::result::Result<crate::output::list_auto_ml_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAutoMLJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_auto_ml_job_summaries(parsed_body.auto_ml_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_candidates_for_auto_ml_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_candidates_for_auto_ml_job_output::Builder,
) -> std::result::Result<
    crate::output::list_candidates_for_auto_ml_job_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListCandidatesForAutoMLJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_candidates(parsed_body.candidates);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_code_repositories_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_code_repositories_output::Builder,
) -> std::result::Result<crate::output::list_code_repositories_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListCodeRepositoriesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_repository_summary_list(parsed_body.code_repository_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_compilation_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_compilation_jobs_output::Builder,
) -> std::result::Result<crate::output::list_compilation_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListCompilationJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_compilation_job_summaries(parsed_body.compilation_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_contexts_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_contexts_output::Builder,
) -> std::result::Result<crate::output::list_contexts_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListContextsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_context_summaries(parsed_body.context_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_data_quality_job_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_data_quality_job_definitions_output::Builder,
) -> std::result::Result<
    crate::output::list_data_quality_job_definitions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListDataQualityJobDefinitionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_summaries(parsed_body.job_definition_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_device_fleets_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_device_fleets_output::Builder,
) -> std::result::Result<crate::output::list_device_fleets_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListDeviceFleetsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_device_fleet_summaries(parsed_body.device_fleet_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_devices_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_devices_output::Builder,
) -> std::result::Result<crate::output::list_devices_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListDevicesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_device_summaries(parsed_body.device_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_domains_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_domains_output::Builder,
) -> std::result::Result<crate::output::list_domains_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListDomainsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_domains(parsed_body.domains);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_edge_packaging_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_edge_packaging_jobs_output::Builder,
) -> std::result::Result<crate::output::list_edge_packaging_jobs_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListEdgePackagingJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_edge_packaging_job_summaries(parsed_body.edge_packaging_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_endpoint_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_endpoint_configs_output::Builder,
) -> std::result::Result<crate::output::list_endpoint_configs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListEndpointConfigsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_configs(parsed_body.endpoint_configs);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_endpoints_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_endpoints_output::Builder,
) -> std::result::Result<crate::output::list_endpoints_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListEndpointsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoints(parsed_body.endpoints);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_experiments_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_experiments_output::Builder,
) -> std::result::Result<crate::output::list_experiments_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListExperimentsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_experiment_summaries(parsed_body.experiment_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_feature_groups_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_feature_groups_output::Builder,
) -> std::result::Result<crate::output::list_feature_groups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListFeatureGroupsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_feature_group_summaries(parsed_body.feature_group_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_flow_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_flow_definitions_output::Builder,
) -> std::result::Result<crate::output::list_flow_definitions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListFlowDefinitionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_flow_definition_summaries(parsed_body.flow_definition_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_human_task_uis_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_human_task_uis_output::Builder,
) -> std::result::Result<crate::output::list_human_task_uis_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListHumanTaskUisOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_human_task_ui_summaries(parsed_body.human_task_ui_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_hyper_parameter_tuning_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_hyper_parameter_tuning_jobs_output::Builder,
) -> std::result::Result<
    crate::output::list_hyper_parameter_tuning_jobs_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListHyperParameterTuningJobsOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder
        .set_hyper_parameter_tuning_job_summaries(parsed_body.hyper_parameter_tuning_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_images_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_images_output::Builder,
) -> std::result::Result<crate::output::list_images_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListImagesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_images(parsed_body.images);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_image_versions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_image_versions_output::Builder,
) -> std::result::Result<crate::output::list_image_versions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListImageVersionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_image_versions(parsed_body.image_versions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_labeling_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_labeling_jobs_output::Builder,
) -> std::result::Result<crate::output::list_labeling_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListLabelingJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_labeling_job_summary_list(parsed_body.labeling_job_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_labeling_jobs_for_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_labeling_jobs_for_workteam_output::Builder,
) -> std::result::Result<
    crate::output::list_labeling_jobs_for_workteam_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListLabelingJobsForWorkteamOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_labeling_job_summary_list(parsed_body.labeling_job_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_model_bias_job_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_model_bias_job_definitions_output::Builder,
) -> std::result::Result<
    crate::output::list_model_bias_job_definitions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListModelBiasJobDefinitionsOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_job_definition_summaries(parsed_body.job_definition_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_model_explainability_job_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_model_explainability_job_definitions_output::Builder,
) -> std::result::Result<
    crate::output::list_model_explainability_job_definitions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListModelExplainabilityJobDefinitionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_summaries(parsed_body.job_definition_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_model_package_groups_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_model_package_groups_output::Builder,
) -> std::result::Result<crate::output::list_model_package_groups_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListModelPackageGroupsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder =
        builder.set_model_package_group_summary_list(parsed_body.model_package_group_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_model_packages_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_model_packages_output::Builder,
) -> std::result::Result<crate::output::list_model_packages_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListModelPackagesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_summary_list(parsed_body.model_package_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_model_quality_job_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_model_quality_job_definitions_output::Builder,
) -> std::result::Result<
    crate::output::list_model_quality_job_definitions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListModelQualityJobDefinitionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_job_definition_summaries(parsed_body.job_definition_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_models_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_models_output::Builder,
) -> std::result::Result<crate::output::list_models_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListModelsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_models(parsed_body.models);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_monitoring_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_monitoring_executions_output::Builder,
) -> std::result::Result<crate::output::list_monitoring_executions_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListMonitoringExecutionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder =
        builder.set_monitoring_execution_summaries(parsed_body.monitoring_execution_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_monitoring_schedules_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_monitoring_schedules_output::Builder,
) -> std::result::Result<crate::output::list_monitoring_schedules_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListMonitoringSchedulesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_monitoring_schedule_summaries(parsed_body.monitoring_schedule_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_notebook_instance_lifecycle_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_notebook_instance_lifecycle_configs_output::Builder,
) -> std::result::Result<
    crate::output::list_notebook_instance_lifecycle_configs_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListNotebookInstanceLifecycleConfigsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder
        .set_notebook_instance_lifecycle_configs(parsed_body.notebook_instance_lifecycle_configs);
    Ok(builder)
}

pub fn list_notebook_instances_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_notebook_instances_output::Builder,
) -> std::result::Result<crate::output::list_notebook_instances_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListNotebookInstancesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_notebook_instances(parsed_body.notebook_instances);
    Ok(builder)
}

pub fn list_pipeline_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_pipeline_executions_output::Builder,
) -> std::result::Result<crate::output::list_pipeline_executions_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListPipelineExecutionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_execution_summaries(parsed_body.pipeline_execution_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_pipeline_execution_steps_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_pipeline_execution_steps_output::Builder,
) -> std::result::Result<
    crate::output::list_pipeline_execution_steps_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListPipelineExecutionStepsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_execution_steps(parsed_body.pipeline_execution_steps);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_pipeline_parameters_for_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_pipeline_parameters_for_execution_output::Builder,
) -> std::result::Result<
    crate::output::list_pipeline_parameters_for_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListPipelineParametersForExecutionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_pipeline_parameters(parsed_body.pipeline_parameters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_pipelines_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_pipelines_output::Builder,
) -> std::result::Result<crate::output::list_pipelines_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListPipelinesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_summaries(parsed_body.pipeline_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_processing_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_processing_jobs_output::Builder,
) -> std::result::Result<crate::output::list_processing_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListProcessingJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_processing_job_summaries(parsed_body.processing_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_projects_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_projects_output::Builder,
) -> std::result::Result<crate::output::list_projects_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListProjectsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_project_summary_list(parsed_body.project_summary_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_subscribed_workteams_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_subscribed_workteams_output::Builder,
) -> std::result::Result<crate::output::list_subscribed_workteams_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListSubscribedWorkteamsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_subscribed_workteams(parsed_body.subscribed_workteams);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_tags_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_tags_output::Builder,
) -> std::result::Result<crate::output::list_tags_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_training_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_training_jobs_output::Builder,
) -> std::result::Result<crate::output::list_training_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTrainingJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_training_job_summaries(parsed_body.training_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_training_jobs_for_hyper_parameter_tuning_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_training_jobs_for_hyper_parameter_tuning_job_output::Builder,
) -> std::result::Result<
    crate::output::list_training_jobs_for_hyper_parameter_tuning_job_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListTrainingJobsForHyperParameterTuningJobOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_training_job_summaries(parsed_body.training_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_transform_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_transform_jobs_output::Builder,
) -> std::result::Result<crate::output::list_transform_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTransformJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_transform_job_summaries(parsed_body.transform_job_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_trial_components_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_trial_components_output::Builder,
) -> std::result::Result<crate::output::list_trial_components_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTrialComponentsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_summaries(parsed_body.trial_component_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_trials_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_trials_output::Builder,
) -> std::result::Result<crate::output::list_trials_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTrialsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_summaries(parsed_body.trial_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_user_profiles_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_user_profiles_output::Builder,
) -> std::result::Result<crate::output::list_user_profiles_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListUserProfilesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_user_profiles(parsed_body.user_profiles);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_workforces_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_workforces_output::Builder,
) -> std::result::Result<crate::output::list_workforces_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListWorkforcesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workforces(parsed_body.workforces);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_workteams_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_workteams_output::Builder,
) -> std::result::Result<crate::output::list_workteams_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListWorkteamsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workteams(parsed_body.workteams);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn put_model_package_group_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_model_package_group_policy_output::Builder,
) -> std::result::Result<
    crate::output::put_model_package_group_policy_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::PutModelPackageGroupPolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_group_arn(parsed_body.model_package_group_arn);
    Ok(builder)
}

pub fn render_ui_template_deser_operation(
    input: &[u8],
    mut builder: crate::output::render_ui_template_output::Builder,
) -> std::result::Result<crate::output::render_ui_template_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::RenderUiTemplateOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_rendered_content(parsed_body.rendered_content);
    builder = builder.set_errors(parsed_body.errors);
    Ok(builder)
}

pub fn search_deser_operation(
    input: &[u8],
    mut builder: crate::output::search_output::Builder,
) -> std::result::Result<crate::output::search_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::SearchOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_results(parsed_body.results);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn send_pipeline_execution_step_failure_deser_operation(
    input: &[u8],
    mut builder: crate::output::send_pipeline_execution_step_failure_output::Builder,
) -> std::result::Result<
    crate::output::send_pipeline_execution_step_failure_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::SendPipelineExecutionStepFailureOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    Ok(builder)
}

pub fn send_pipeline_execution_step_success_deser_operation(
    input: &[u8],
    mut builder: crate::output::send_pipeline_execution_step_success_output::Builder,
) -> std::result::Result<
    crate::output::send_pipeline_execution_step_success_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::SendPipelineExecutionStepSuccessOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    Ok(builder)
}

pub fn start_pipeline_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_pipeline_execution_output::Builder,
) -> std::result::Result<crate::output::start_pipeline_execution_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::StartPipelineExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    Ok(builder)
}

pub fn stop_pipeline_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::stop_pipeline_execution_output::Builder,
) -> std::result::Result<crate::output::stop_pipeline_execution_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::StopPipelineExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    Ok(builder)
}

pub fn update_action_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_action_output::Builder,
) -> std::result::Result<crate::output::update_action_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateActionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_action_arn(parsed_body.action_arn);
    Ok(builder)
}

pub fn update_app_image_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_app_image_config_output::Builder,
) -> std::result::Result<crate::output::update_app_image_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdateAppImageConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_app_image_config_arn(parsed_body.app_image_config_arn);
    Ok(builder)
}

pub fn update_artifact_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_artifact_output::Builder,
) -> std::result::Result<crate::output::update_artifact_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateArtifactOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_artifact_arn(parsed_body.artifact_arn);
    Ok(builder)
}

pub fn update_code_repository_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_code_repository_output::Builder,
) -> std::result::Result<crate::output::update_code_repository_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateCodeRepositoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_repository_arn(parsed_body.code_repository_arn);
    Ok(builder)
}

pub fn update_context_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_context_output::Builder,
) -> std::result::Result<crate::output::update_context_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateContextOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_context_arn(parsed_body.context_arn);
    Ok(builder)
}

pub fn update_domain_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_domain_output::Builder,
) -> std::result::Result<crate::output::update_domain_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateDomainOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_domain_arn(parsed_body.domain_arn);
    Ok(builder)
}

pub fn update_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_endpoint_output::Builder,
) -> std::result::Result<crate::output::update_endpoint_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_endpoint_arn(parsed_body.endpoint_arn);
    Ok(builder)
}

pub fn update_endpoint_weights_and_capacities_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_endpoint_weights_and_capacities_output::Builder,
) -> std::result::Result<
    crate::output::update_endpoint_weights_and_capacities_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateEndpointWeightsAndCapacitiesOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_endpoint_arn(parsed_body.endpoint_arn);
    Ok(builder)
}

pub fn update_experiment_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_experiment_output::Builder,
) -> std::result::Result<crate::output::update_experiment_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateExperimentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_experiment_arn(parsed_body.experiment_arn);
    Ok(builder)
}

pub fn update_image_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_image_output::Builder,
) -> std::result::Result<crate::output::update_image_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateImageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_image_arn(parsed_body.image_arn);
    Ok(builder)
}

pub fn update_model_package_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_model_package_output::Builder,
) -> std::result::Result<crate::output::update_model_package_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateModelPackageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_model_package_arn(parsed_body.model_package_arn);
    Ok(builder)
}

pub fn update_monitoring_schedule_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_monitoring_schedule_output::Builder,
) -> std::result::Result<crate::output::update_monitoring_schedule_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdateMonitoringScheduleOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_monitoring_schedule_arn(parsed_body.monitoring_schedule_arn);
    Ok(builder)
}

pub fn update_pipeline_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_pipeline_output::Builder,
) -> std::result::Result<crate::output::update_pipeline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdatePipelineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_arn(parsed_body.pipeline_arn);
    Ok(builder)
}

pub fn update_pipeline_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_pipeline_execution_output::Builder,
) -> std::result::Result<crate::output::update_pipeline_execution_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdatePipelineExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_pipeline_execution_arn(parsed_body.pipeline_execution_arn);
    Ok(builder)
}

pub fn update_training_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_training_job_output::Builder,
) -> std::result::Result<crate::output::update_training_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTrainingJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_training_job_arn(parsed_body.training_job_arn);
    Ok(builder)
}

pub fn update_trial_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_trial_output::Builder,
) -> std::result::Result<crate::output::update_trial_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTrialOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_arn(parsed_body.trial_arn);
    Ok(builder)
}

pub fn update_trial_component_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_trial_component_output::Builder,
) -> std::result::Result<crate::output::update_trial_component_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTrialComponentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_trial_component_arn(parsed_body.trial_component_arn);
    Ok(builder)
}

pub fn update_user_profile_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_user_profile_output::Builder,
) -> std::result::Result<crate::output::update_user_profile_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateUserProfileOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_user_profile_arn(parsed_body.user_profile_arn);
    Ok(builder)
}

pub fn update_workforce_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_workforce_output::Builder,
) -> std::result::Result<crate::output::update_workforce_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateWorkforceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workforce(parsed_body.workforce);
    Ok(builder)
}

pub fn update_workteam_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_workteam_output::Builder,
) -> std::result::Result<crate::output::update_workteam_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateWorkteamOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_workteam(parsed_body.workteam);
    Ok(builder)
}
