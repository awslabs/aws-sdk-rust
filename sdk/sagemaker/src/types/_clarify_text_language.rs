// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ClarifyTextLanguage`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let clarifytextlanguage = unimplemented!();
/// match clarifytextlanguage {
///     ClarifyTextLanguage::Afrikaans => { /* ... */ },
///     ClarifyTextLanguage::Arabic => { /* ... */ },
///     ClarifyTextLanguage::Bulgarian => { /* ... */ },
///     ClarifyTextLanguage::Bengali => { /* ... */ },
///     ClarifyTextLanguage::Catalan => { /* ... */ },
///     ClarifyTextLanguage::Czech => { /* ... */ },
///     ClarifyTextLanguage::Danish => { /* ... */ },
///     ClarifyTextLanguage::German => { /* ... */ },
///     ClarifyTextLanguage::Greek => { /* ... */ },
///     ClarifyTextLanguage::English => { /* ... */ },
///     ClarifyTextLanguage::Spanish => { /* ... */ },
///     ClarifyTextLanguage::Estonian => { /* ... */ },
///     ClarifyTextLanguage::Basque => { /* ... */ },
///     ClarifyTextLanguage::Persian => { /* ... */ },
///     ClarifyTextLanguage::Finnish => { /* ... */ },
///     ClarifyTextLanguage::French => { /* ... */ },
///     ClarifyTextLanguage::Irish => { /* ... */ },
///     ClarifyTextLanguage::Gujarati => { /* ... */ },
///     ClarifyTextLanguage::Hebrew => { /* ... */ },
///     ClarifyTextLanguage::Hindi => { /* ... */ },
///     ClarifyTextLanguage::Croatian => { /* ... */ },
///     ClarifyTextLanguage::Hungarian => { /* ... */ },
///     ClarifyTextLanguage::Armenian => { /* ... */ },
///     ClarifyTextLanguage::Indonesian => { /* ... */ },
///     ClarifyTextLanguage::Icelandic => { /* ... */ },
///     ClarifyTextLanguage::Italian => { /* ... */ },
///     ClarifyTextLanguage::Kannada => { /* ... */ },
///     ClarifyTextLanguage::Kyrgyz => { /* ... */ },
///     ClarifyTextLanguage::Luxembourgish => { /* ... */ },
///     ClarifyTextLanguage::Ligurian => { /* ... */ },
///     ClarifyTextLanguage::Lithuanian => { /* ... */ },
///     ClarifyTextLanguage::Latvian => { /* ... */ },
///     ClarifyTextLanguage::Macedonian => { /* ... */ },
///     ClarifyTextLanguage::Malayalam => { /* ... */ },
///     ClarifyTextLanguage::Marathi => { /* ... */ },
///     ClarifyTextLanguage::NorwegianBokmal => { /* ... */ },
///     ClarifyTextLanguage::Nepali => { /* ... */ },
///     ClarifyTextLanguage::Dutch => { /* ... */ },
///     ClarifyTextLanguage::Polish => { /* ... */ },
///     ClarifyTextLanguage::Portuguese => { /* ... */ },
///     ClarifyTextLanguage::Romanian => { /* ... */ },
///     ClarifyTextLanguage::Russian => { /* ... */ },
///     ClarifyTextLanguage::Sanskrit => { /* ... */ },
///     ClarifyTextLanguage::Sinhala => { /* ... */ },
///     ClarifyTextLanguage::Slovak => { /* ... */ },
///     ClarifyTextLanguage::Slovenian => { /* ... */ },
///     ClarifyTextLanguage::Albanian => { /* ... */ },
///     ClarifyTextLanguage::Serbian => { /* ... */ },
///     ClarifyTextLanguage::Swedish => { /* ... */ },
///     ClarifyTextLanguage::Tamil => { /* ... */ },
///     ClarifyTextLanguage::Telugu => { /* ... */ },
///     ClarifyTextLanguage::Tagalog => { /* ... */ },
///     ClarifyTextLanguage::Setswana => { /* ... */ },
///     ClarifyTextLanguage::Turkish => { /* ... */ },
///     ClarifyTextLanguage::Tatar => { /* ... */ },
///     ClarifyTextLanguage::Ukrainian => { /* ... */ },
///     ClarifyTextLanguage::Urdu => { /* ... */ },
///     ClarifyTextLanguage::MultiLanguage => { /* ... */ },
///     ClarifyTextLanguage::Yoruba => { /* ... */ },
///     ClarifyTextLanguage::Chinese => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clarifytextlanguage` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClarifyTextLanguage::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClarifyTextLanguage::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClarifyTextLanguage::NewFeature` is defined.
/// Specifically, when `clarifytextlanguage` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClarifyTextLanguage::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ClarifyTextLanguage {
    #[allow(missing_docs)] // documentation missing in model
    Afrikaans,
    #[allow(missing_docs)] // documentation missing in model
    Arabic,
    #[allow(missing_docs)] // documentation missing in model
    Bulgarian,
    #[allow(missing_docs)] // documentation missing in model
    Bengali,
    #[allow(missing_docs)] // documentation missing in model
    Catalan,
    #[allow(missing_docs)] // documentation missing in model
    Czech,
    #[allow(missing_docs)] // documentation missing in model
    Danish,
    #[allow(missing_docs)] // documentation missing in model
    German,
    #[allow(missing_docs)] // documentation missing in model
    Greek,
    #[allow(missing_docs)] // documentation missing in model
    English,
    #[allow(missing_docs)] // documentation missing in model
    Spanish,
    #[allow(missing_docs)] // documentation missing in model
    Estonian,
    #[allow(missing_docs)] // documentation missing in model
    Basque,
    #[allow(missing_docs)] // documentation missing in model
    Persian,
    #[allow(missing_docs)] // documentation missing in model
    Finnish,
    #[allow(missing_docs)] // documentation missing in model
    French,
    #[allow(missing_docs)] // documentation missing in model
    Irish,
    #[allow(missing_docs)] // documentation missing in model
    Gujarati,
    #[allow(missing_docs)] // documentation missing in model
    Hebrew,
    #[allow(missing_docs)] // documentation missing in model
    Hindi,
    #[allow(missing_docs)] // documentation missing in model
    Croatian,
    #[allow(missing_docs)] // documentation missing in model
    Hungarian,
    #[allow(missing_docs)] // documentation missing in model
    Armenian,
    #[allow(missing_docs)] // documentation missing in model
    Indonesian,
    #[allow(missing_docs)] // documentation missing in model
    Icelandic,
    #[allow(missing_docs)] // documentation missing in model
    Italian,
    #[allow(missing_docs)] // documentation missing in model
    Kannada,
    #[allow(missing_docs)] // documentation missing in model
    Kyrgyz,
    #[allow(missing_docs)] // documentation missing in model
    Luxembourgish,
    #[allow(missing_docs)] // documentation missing in model
    Ligurian,
    #[allow(missing_docs)] // documentation missing in model
    Lithuanian,
    #[allow(missing_docs)] // documentation missing in model
    Latvian,
    #[allow(missing_docs)] // documentation missing in model
    Macedonian,
    #[allow(missing_docs)] // documentation missing in model
    Malayalam,
    #[allow(missing_docs)] // documentation missing in model
    Marathi,
    #[allow(missing_docs)] // documentation missing in model
    NorwegianBokmal,
    #[allow(missing_docs)] // documentation missing in model
    Nepali,
    #[allow(missing_docs)] // documentation missing in model
    Dutch,
    #[allow(missing_docs)] // documentation missing in model
    Polish,
    #[allow(missing_docs)] // documentation missing in model
    Portuguese,
    #[allow(missing_docs)] // documentation missing in model
    Romanian,
    #[allow(missing_docs)] // documentation missing in model
    Russian,
    #[allow(missing_docs)] // documentation missing in model
    Sanskrit,
    #[allow(missing_docs)] // documentation missing in model
    Sinhala,
    #[allow(missing_docs)] // documentation missing in model
    Slovak,
    #[allow(missing_docs)] // documentation missing in model
    Slovenian,
    #[allow(missing_docs)] // documentation missing in model
    Albanian,
    #[allow(missing_docs)] // documentation missing in model
    Serbian,
    #[allow(missing_docs)] // documentation missing in model
    Swedish,
    #[allow(missing_docs)] // documentation missing in model
    Tamil,
    #[allow(missing_docs)] // documentation missing in model
    Telugu,
    #[allow(missing_docs)] // documentation missing in model
    Tagalog,
    #[allow(missing_docs)] // documentation missing in model
    Setswana,
    #[allow(missing_docs)] // documentation missing in model
    Turkish,
    #[allow(missing_docs)] // documentation missing in model
    Tatar,
    #[allow(missing_docs)] // documentation missing in model
    Ukrainian,
    #[allow(missing_docs)] // documentation missing in model
    Urdu,
    #[allow(missing_docs)] // documentation missing in model
    MultiLanguage,
    #[allow(missing_docs)] // documentation missing in model
    Yoruba,
    #[allow(missing_docs)] // documentation missing in model
    Chinese,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue)
}
impl std::convert::From<&str> for ClarifyTextLanguage {
                fn from(s: &str) -> Self {
                    match s {
                        "af" => ClarifyTextLanguage::Afrikaans,
"ar" => ClarifyTextLanguage::Arabic,
"bg" => ClarifyTextLanguage::Bulgarian,
"bn" => ClarifyTextLanguage::Bengali,
"ca" => ClarifyTextLanguage::Catalan,
"cs" => ClarifyTextLanguage::Czech,
"da" => ClarifyTextLanguage::Danish,
"de" => ClarifyTextLanguage::German,
"el" => ClarifyTextLanguage::Greek,
"en" => ClarifyTextLanguage::English,
"es" => ClarifyTextLanguage::Spanish,
"et" => ClarifyTextLanguage::Estonian,
"eu" => ClarifyTextLanguage::Basque,
"fa" => ClarifyTextLanguage::Persian,
"fi" => ClarifyTextLanguage::Finnish,
"fr" => ClarifyTextLanguage::French,
"ga" => ClarifyTextLanguage::Irish,
"gu" => ClarifyTextLanguage::Gujarati,
"he" => ClarifyTextLanguage::Hebrew,
"hi" => ClarifyTextLanguage::Hindi,
"hr" => ClarifyTextLanguage::Croatian,
"hu" => ClarifyTextLanguage::Hungarian,
"hy" => ClarifyTextLanguage::Armenian,
"id" => ClarifyTextLanguage::Indonesian,
"is" => ClarifyTextLanguage::Icelandic,
"it" => ClarifyTextLanguage::Italian,
"kn" => ClarifyTextLanguage::Kannada,
"ky" => ClarifyTextLanguage::Kyrgyz,
"lb" => ClarifyTextLanguage::Luxembourgish,
"lij" => ClarifyTextLanguage::Ligurian,
"lt" => ClarifyTextLanguage::Lithuanian,
"lv" => ClarifyTextLanguage::Latvian,
"mk" => ClarifyTextLanguage::Macedonian,
"ml" => ClarifyTextLanguage::Malayalam,
"mr" => ClarifyTextLanguage::Marathi,
"nb" => ClarifyTextLanguage::NorwegianBokmal,
"ne" => ClarifyTextLanguage::Nepali,
"nl" => ClarifyTextLanguage::Dutch,
"pl" => ClarifyTextLanguage::Polish,
"pt" => ClarifyTextLanguage::Portuguese,
"ro" => ClarifyTextLanguage::Romanian,
"ru" => ClarifyTextLanguage::Russian,
"sa" => ClarifyTextLanguage::Sanskrit,
"si" => ClarifyTextLanguage::Sinhala,
"sk" => ClarifyTextLanguage::Slovak,
"sl" => ClarifyTextLanguage::Slovenian,
"sq" => ClarifyTextLanguage::Albanian,
"sr" => ClarifyTextLanguage::Serbian,
"sv" => ClarifyTextLanguage::Swedish,
"ta" => ClarifyTextLanguage::Tamil,
"te" => ClarifyTextLanguage::Telugu,
"tl" => ClarifyTextLanguage::Tagalog,
"tn" => ClarifyTextLanguage::Setswana,
"tr" => ClarifyTextLanguage::Turkish,
"tt" => ClarifyTextLanguage::Tatar,
"uk" => ClarifyTextLanguage::Ukrainian,
"ur" => ClarifyTextLanguage::Urdu,
"xx" => ClarifyTextLanguage::MultiLanguage,
"yo" => ClarifyTextLanguage::Yoruba,
"zh" => ClarifyTextLanguage::Chinese,
other => ClarifyTextLanguage::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
                    }
                }
            }
impl std::str::FromStr for ClarifyTextLanguage {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ClarifyTextLanguage::from(s))
                }
            }
impl ClarifyTextLanguage {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ClarifyTextLanguage::Afrikaans => "af",
    ClarifyTextLanguage::Arabic => "ar",
    ClarifyTextLanguage::Bulgarian => "bg",
    ClarifyTextLanguage::Bengali => "bn",
    ClarifyTextLanguage::Catalan => "ca",
    ClarifyTextLanguage::Czech => "cs",
    ClarifyTextLanguage::Danish => "da",
    ClarifyTextLanguage::German => "de",
    ClarifyTextLanguage::Greek => "el",
    ClarifyTextLanguage::English => "en",
    ClarifyTextLanguage::Spanish => "es",
    ClarifyTextLanguage::Estonian => "et",
    ClarifyTextLanguage::Basque => "eu",
    ClarifyTextLanguage::Persian => "fa",
    ClarifyTextLanguage::Finnish => "fi",
    ClarifyTextLanguage::French => "fr",
    ClarifyTextLanguage::Irish => "ga",
    ClarifyTextLanguage::Gujarati => "gu",
    ClarifyTextLanguage::Hebrew => "he",
    ClarifyTextLanguage::Hindi => "hi",
    ClarifyTextLanguage::Croatian => "hr",
    ClarifyTextLanguage::Hungarian => "hu",
    ClarifyTextLanguage::Armenian => "hy",
    ClarifyTextLanguage::Indonesian => "id",
    ClarifyTextLanguage::Icelandic => "is",
    ClarifyTextLanguage::Italian => "it",
    ClarifyTextLanguage::Kannada => "kn",
    ClarifyTextLanguage::Kyrgyz => "ky",
    ClarifyTextLanguage::Luxembourgish => "lb",
    ClarifyTextLanguage::Ligurian => "lij",
    ClarifyTextLanguage::Lithuanian => "lt",
    ClarifyTextLanguage::Latvian => "lv",
    ClarifyTextLanguage::Macedonian => "mk",
    ClarifyTextLanguage::Malayalam => "ml",
    ClarifyTextLanguage::Marathi => "mr",
    ClarifyTextLanguage::NorwegianBokmal => "nb",
    ClarifyTextLanguage::Nepali => "ne",
    ClarifyTextLanguage::Dutch => "nl",
    ClarifyTextLanguage::Polish => "pl",
    ClarifyTextLanguage::Portuguese => "pt",
    ClarifyTextLanguage::Romanian => "ro",
    ClarifyTextLanguage::Russian => "ru",
    ClarifyTextLanguage::Sanskrit => "sa",
    ClarifyTextLanguage::Sinhala => "si",
    ClarifyTextLanguage::Slovak => "sk",
    ClarifyTextLanguage::Slovenian => "sl",
    ClarifyTextLanguage::Albanian => "sq",
    ClarifyTextLanguage::Serbian => "sr",
    ClarifyTextLanguage::Swedish => "sv",
    ClarifyTextLanguage::Tamil => "ta",
    ClarifyTextLanguage::Telugu => "te",
    ClarifyTextLanguage::Tagalog => "tl",
    ClarifyTextLanguage::Setswana => "tn",
    ClarifyTextLanguage::Turkish => "tr",
    ClarifyTextLanguage::Tatar => "tt",
    ClarifyTextLanguage::Ukrainian => "uk",
    ClarifyTextLanguage::Urdu => "ur",
    ClarifyTextLanguage::MultiLanguage => "xx",
    ClarifyTextLanguage::Yoruba => "yo",
    ClarifyTextLanguage::Chinese => "zh",
    ClarifyTextLanguage::Unknown(value) => value.as_str()
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["af", "ar", "bg", "bn", "ca", "cs", "da", "de", "el", "en", "es", "et", "eu", "fa", "fi", "fr", "ga", "gu", "he", "hi", "hr", "hu", "hy", "id", "is", "it", "kn", "ky", "lb", "lij", "lt", "lv", "mk", "ml", "mr", "nb", "ne", "nl", "pl", "pt", "ro", "ru", "sa", "si", "sk", "sl", "sq", "sr", "sv", "ta", "te", "tl", "tn", "tr", "tt", "uk", "ur", "xx", "yo", "zh"]
                }
            }
impl AsRef<str> for ClarifyTextLanguage {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }

