// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines a named input source, called a channel, to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ChannelSpecification {
    /// <p>The name of the channel.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>A brief description of the channel.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub is_required: ::std::option::Option<bool>,
    /// <p>The supported MIME types for the data.</p>
    pub supported_content_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The allowed compression types, if data compression is used.</p>
    pub supported_compression_types: ::std::option::Option<::std::vec::Vec<crate::types::CompressionType>>,
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub supported_input_modes: ::std::option::Option<::std::vec::Vec<crate::types::TrainingInputMode>>,
}
impl ChannelSpecification {
    /// <p>The name of the channel.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the channel.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub fn is_required(&self) -> ::std::option::Option<bool> {
        self.is_required
    }
    /// <p>The supported MIME types for the data.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.supported_content_types.is_none()`.
    pub fn supported_content_types(&self) -> &[::std::string::String] {
        self.supported_content_types.as_deref().unwrap_or_default()
    }
    /// <p>The allowed compression types, if data compression is used.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.supported_compression_types.is_none()`.
    pub fn supported_compression_types(&self) -> &[crate::types::CompressionType] {
        self.supported_compression_types.as_deref().unwrap_or_default()
    }
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.supported_input_modes.is_none()`.
    pub fn supported_input_modes(&self) -> &[crate::types::TrainingInputMode] {
        self.supported_input_modes.as_deref().unwrap_or_default()
    }
}
impl ChannelSpecification {
    /// Creates a new builder-style object to manufacture [`ChannelSpecification`](crate::types::ChannelSpecification).
    pub fn builder() -> crate::types::builders::ChannelSpecificationBuilder {
        crate::types::builders::ChannelSpecificationBuilder::default()
    }
}

/// A builder for [`ChannelSpecification`](crate::types::ChannelSpecification).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ChannelSpecificationBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) is_required: ::std::option::Option<bool>,
    pub(crate) supported_content_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) supported_compression_types: ::std::option::Option<::std::vec::Vec<crate::types::CompressionType>>,
    pub(crate) supported_input_modes: ::std::option::Option<::std::vec::Vec<crate::types::TrainingInputMode>>,
}
impl ChannelSpecificationBuilder {
    /// <p>The name of the channel.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the channel.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the channel.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>A brief description of the channel.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A brief description of the channel.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A brief description of the channel.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub fn is_required(mut self, input: bool) -> Self {
        self.is_required = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub fn set_is_required(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_required = input;
        self
    }
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub fn get_is_required(&self) -> &::std::option::Option<bool> {
        &self.is_required
    }
    /// Appends an item to `supported_content_types`.
    ///
    /// To override the contents of this collection use [`set_supported_content_types`](Self::set_supported_content_types).
    ///
    /// <p>The supported MIME types for the data.</p>
    pub fn supported_content_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.supported_content_types.unwrap_or_default();
        v.push(input.into());
        self.supported_content_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The supported MIME types for the data.</p>
    pub fn set_supported_content_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.supported_content_types = input;
        self
    }
    /// <p>The supported MIME types for the data.</p>
    pub fn get_supported_content_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.supported_content_types
    }
    /// Appends an item to `supported_compression_types`.
    ///
    /// To override the contents of this collection use [`set_supported_compression_types`](Self::set_supported_compression_types).
    ///
    /// <p>The allowed compression types, if data compression is used.</p>
    pub fn supported_compression_types(mut self, input: crate::types::CompressionType) -> Self {
        let mut v = self.supported_compression_types.unwrap_or_default();
        v.push(input);
        self.supported_compression_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The allowed compression types, if data compression is used.</p>
    pub fn set_supported_compression_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CompressionType>>) -> Self {
        self.supported_compression_types = input;
        self
    }
    /// <p>The allowed compression types, if data compression is used.</p>
    pub fn get_supported_compression_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CompressionType>> {
        &self.supported_compression_types
    }
    /// Appends an item to `supported_input_modes`.
    ///
    /// To override the contents of this collection use [`set_supported_input_modes`](Self::set_supported_input_modes).
    ///
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub fn supported_input_modes(mut self, input: crate::types::TrainingInputMode) -> Self {
        let mut v = self.supported_input_modes.unwrap_or_default();
        v.push(input);
        self.supported_input_modes = ::std::option::Option::Some(v);
        self
    }
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub fn set_supported_input_modes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::TrainingInputMode>>) -> Self {
        self.supported_input_modes = input;
        self
    }
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.</p>
    pub fn get_supported_input_modes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::TrainingInputMode>> {
        &self.supported_input_modes
    }
    /// Consumes the builder and constructs a [`ChannelSpecification`](crate::types::ChannelSpecification).
    pub fn build(self) -> crate::types::ChannelSpecification {
        crate::types::ChannelSpecification {
            name: self.name,
            description: self.description,
            is_required: self.is_required,
            supported_content_types: self.supported_content_types,
            supported_compression_types: self.supported_compression_types,
            supported_input_modes: self.supported_input_modes,
        }
    }
}
