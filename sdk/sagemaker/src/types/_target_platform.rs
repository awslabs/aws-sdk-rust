// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetPlatform  {
    /// <p>Specifies a target platform OS.</p> 
    /// <ul> 
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li> 
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub os: std::option::Option<crate::types::TargetPlatformOs>,
    /// <p>Specifies a target platform architecture.</p> 
    /// <ul> 
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li> 
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li> 
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub arch: std::option::Option<crate::types::TargetPlatformArch>,
    /// <p>Specifies a target platform accelerator (optional).</p> 
    /// <ul> 
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li> 
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li> 
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub accelerator: std::option::Option<crate::types::TargetPlatformAccelerator>,
}
impl TargetPlatform {
    /// <p>Specifies a target platform OS.</p> 
    /// <ul> 
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li> 
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li> 
    /// </ul>
    pub fn os(&self) -> std::option::Option<& crate::types::TargetPlatformOs> {
        self.os.as_ref()
    }
    /// <p>Specifies a target platform architecture.</p> 
    /// <ul> 
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li> 
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li> 
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li> 
    /// </ul>
    pub fn arch(&self) -> std::option::Option<& crate::types::TargetPlatformArch> {
        self.arch.as_ref()
    }
    /// <p>Specifies a target platform accelerator (optional).</p> 
    /// <ul> 
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li> 
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li> 
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li> 
    /// </ul>
    pub fn accelerator(&self) -> std::option::Option<& crate::types::TargetPlatformAccelerator> {
        self.accelerator.as_ref()
    }
}
impl TargetPlatform {
    /// Creates a new builder-style object to manufacture [`TargetPlatform`](crate::types::TargetPlatform).
    pub fn builder() -> crate::types::builders::TargetPlatformBuilder {
        crate::types::builders::TargetPlatformBuilder::default()
    }
}

/// A builder for [`TargetPlatform`](crate::types::TargetPlatform).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct TargetPlatformBuilder {
    pub(crate) os: std::option::Option<crate::types::TargetPlatformOs>,
    pub(crate) arch: std::option::Option<crate::types::TargetPlatformArch>,
    pub(crate) accelerator: std::option::Option<crate::types::TargetPlatformAccelerator>,
}
impl TargetPlatformBuilder {
    /// <p>Specifies a target platform OS.</p> 
    /// <ul> 
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li> 
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li> 
    /// </ul>
    pub fn os(mut self, input: crate::types::TargetPlatformOs) -> Self {
        self.os = Some(input);
        self
    }
    /// <p>Specifies a target platform OS.</p> 
    /// <ul> 
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li> 
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li> 
    /// </ul>
    pub fn set_os(mut self, input: std::option::Option<crate::types::TargetPlatformOs>) -> Self {
        self.os = input; self
    }
    /// <p>Specifies a target platform architecture.</p> 
    /// <ul> 
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li> 
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li> 
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li> 
    /// </ul>
    pub fn arch(mut self, input: crate::types::TargetPlatformArch) -> Self {
        self.arch = Some(input);
        self
    }
    /// <p>Specifies a target platform architecture.</p> 
    /// <ul> 
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li> 
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li> 
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li> 
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li> 
    /// </ul>
    pub fn set_arch(mut self, input: std::option::Option<crate::types::TargetPlatformArch>) -> Self {
        self.arch = input; self
    }
    /// <p>Specifies a target platform accelerator (optional).</p> 
    /// <ul> 
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li> 
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li> 
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li> 
    /// </ul>
    pub fn accelerator(mut self, input: crate::types::TargetPlatformAccelerator) -> Self {
        self.accelerator = Some(input);
        self
    }
    /// <p>Specifies a target platform accelerator (optional).</p> 
    /// <ul> 
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li> 
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li> 
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li> 
    /// </ul>
    pub fn set_accelerator(mut self, input: std::option::Option<crate::types::TargetPlatformAccelerator>) -> Self {
        self.accelerator = input; self
    }
    /// Consumes the builder and constructs a [`TargetPlatform`](crate::types::TargetPlatform).
    pub fn build(self) -> crate::types::TargetPlatform {
        crate::types::TargetPlatform {
            os: self.os
            ,
            arch: self.arch
            ,
            accelerator: self.accelerator
            ,
        }
    }
}

