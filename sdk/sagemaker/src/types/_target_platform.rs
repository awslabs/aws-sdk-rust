// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of <code>TargetDevice</code>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TargetPlatform {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub os: ::std::option::Option<crate::types::TargetPlatformOs>,
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub arch: ::std::option::Option<crate::types::TargetPlatformArch>,
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub accelerator: ::std::option::Option<crate::types::TargetPlatformAccelerator>,
}
impl TargetPlatform {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub fn os(&self) -> ::std::option::Option<&crate::types::TargetPlatformOs> {
        self.os.as_ref()
    }
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub fn arch(&self) -> ::std::option::Option<&crate::types::TargetPlatformArch> {
        self.arch.as_ref()
    }
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub fn accelerator(&self) -> ::std::option::Option<&crate::types::TargetPlatformAccelerator> {
        self.accelerator.as_ref()
    }
}
impl TargetPlatform {
    /// Creates a new builder-style object to manufacture [`TargetPlatform`](crate::types::TargetPlatform).
    pub fn builder() -> crate::types::builders::TargetPlatformBuilder {
        crate::types::builders::TargetPlatformBuilder::default()
    }
}

/// A builder for [`TargetPlatform`](crate::types::TargetPlatform).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct TargetPlatformBuilder {
    pub(crate) os: ::std::option::Option<crate::types::TargetPlatformOs>,
    pub(crate) arch: ::std::option::Option<crate::types::TargetPlatformArch>,
    pub(crate) accelerator: ::std::option::Option<crate::types::TargetPlatformAccelerator>,
}
impl TargetPlatformBuilder {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    /// This field is required.
    pub fn os(mut self, input: crate::types::TargetPlatformOs) -> Self {
        self.os = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub fn set_os(mut self, input: ::std::option::Option<crate::types::TargetPlatformOs>) -> Self {
        self.os = input;
        self
    }
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li> <p> <code>LINUX</code>: Linux-based operating systems.</p> </li>
    /// <li> <p> <code>ANDROID</code>: Android operating systems. Android API level can be specified using the <code>ANDROID_PLATFORM</code> compiler option. For example, <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code> </p> </li>
    /// </ul>
    pub fn get_os(&self) -> &::std::option::Option<crate::types::TargetPlatformOs> {
        &self.os
    }
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    /// This field is required.
    pub fn arch(mut self, input: crate::types::TargetPlatformArch) -> Self {
        self.arch = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub fn set_arch(mut self, input: ::std::option::Option<crate::types::TargetPlatformArch>) -> Self {
        self.arch = input;
        self
    }
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li> <p> <code>X86_64</code>: 64-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>X86</code>: 32-bit version of the x86 instruction set.</p> </li>
    /// <li> <p> <code>ARM64</code>: ARMv8 64-bit CPU.</p> </li>
    /// <li> <p> <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p> </li>
    /// <li> <p> <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.</p> </li>
    /// </ul>
    pub fn get_arch(&self) -> &::std::option::Option<crate::types::TargetPlatformArch> {
        &self.arch
    }
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub fn accelerator(mut self, input: crate::types::TargetPlatformAccelerator) -> Self {
        self.accelerator = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub fn set_accelerator(mut self, input: ::std::option::Option<crate::types::TargetPlatformAccelerator>) -> Self {
        self.accelerator = input;
        self
    }
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li> <p> <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler options</p> </li>
    /// <li> <p> <code>MALI</code>: ARM Mali graphics processor</p> </li>
    /// <li> <p> <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p> </li>
    /// </ul>
    pub fn get_accelerator(&self) -> &::std::option::Option<crate::types::TargetPlatformAccelerator> {
        &self.accelerator
    }
    /// Consumes the builder and constructs a [`TargetPlatform`](crate::types::TargetPlatform).
    pub fn build(self) -> crate::types::TargetPlatform {
        crate::types::TargetPlatform {
            os: self.os,
            arch: self.arch,
            accelerator: self.accelerator,
        }
    }
}
