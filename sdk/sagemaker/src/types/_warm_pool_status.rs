// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Status and billing information about the warm pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WarmPoolStatus {
    /// <p>The status of the warm pool.</p>
    /// <ul>
    /// <li> <p> <code>InUse</code>: The warm pool is in use for the training job.</p> </li>
    /// <li> <p> <code>Available</code>: The warm pool is available to reuse for a matching training job.</p> </li>
    /// <li> <p> <code>Reused</code>: The warm pool moved to a matching training job for reuse.</p> </li>
    /// <li> <p> <code>Terminated</code>: The warm pool is no longer available. Warm pools are unavailable if they are terminated by a user, terminated for a patch update, or terminated for exceeding the specified <code>KeepAlivePeriodInSeconds</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::WarmPoolResourceStatus>,
    /// <p>The billable time in seconds used by the warm pool. Billable time refers to the absolute wall-clock time.</p>
    /// <p>Multiply <code>ResourceRetainedBillableTimeInSeconds</code> by the number of instances (<code>InstanceCount</code>) in your training cluster to get the total compute time SageMaker bills you if you run warm pool training. The formula is as follows: <code>ResourceRetainedBillableTimeInSeconds * InstanceCount</code>.</p>
    #[doc(hidden)]
    pub resource_retained_billable_time_in_seconds: std::option::Option<i32>,
    /// <p>The name of the matching training job that reused the warm pool.</p>
    #[doc(hidden)]
    pub reused_by_job: std::option::Option<std::string::String>,
}
impl WarmPoolStatus {
    /// <p>The status of the warm pool.</p>
    /// <ul>
    /// <li> <p> <code>InUse</code>: The warm pool is in use for the training job.</p> </li>
    /// <li> <p> <code>Available</code>: The warm pool is available to reuse for a matching training job.</p> </li>
    /// <li> <p> <code>Reused</code>: The warm pool moved to a matching training job for reuse.</p> </li>
    /// <li> <p> <code>Terminated</code>: The warm pool is no longer available. Warm pools are unavailable if they are terminated by a user, terminated for a patch update, or terminated for exceeding the specified <code>KeepAlivePeriodInSeconds</code>.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::types::WarmPoolResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The billable time in seconds used by the warm pool. Billable time refers to the absolute wall-clock time.</p>
    /// <p>Multiply <code>ResourceRetainedBillableTimeInSeconds</code> by the number of instances (<code>InstanceCount</code>) in your training cluster to get the total compute time SageMaker bills you if you run warm pool training. The formula is as follows: <code>ResourceRetainedBillableTimeInSeconds * InstanceCount</code>.</p>
    pub fn resource_retained_billable_time_in_seconds(&self) -> std::option::Option<i32> {
        self.resource_retained_billable_time_in_seconds
    }
    /// <p>The name of the matching training job that reused the warm pool.</p>
    pub fn reused_by_job(&self) -> std::option::Option<&str> {
        self.reused_by_job.as_deref()
    }
}
impl WarmPoolStatus {
    /// Creates a new builder-style object to manufacture [`WarmPoolStatus`](crate::types::WarmPoolStatus).
    pub fn builder() -> crate::types::builders::WarmPoolStatusBuilder {
        crate::types::builders::WarmPoolStatusBuilder::default()
    }
}

/// A builder for [`WarmPoolStatus`](crate::types::WarmPoolStatus).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct WarmPoolStatusBuilder {
    pub(crate) status: std::option::Option<crate::types::WarmPoolResourceStatus>,
    pub(crate) resource_retained_billable_time_in_seconds: std::option::Option<i32>,
    pub(crate) reused_by_job: std::option::Option<std::string::String>,
}
impl WarmPoolStatusBuilder {
    /// <p>The status of the warm pool.</p>
    /// <ul>
    /// <li> <p> <code>InUse</code>: The warm pool is in use for the training job.</p> </li>
    /// <li> <p> <code>Available</code>: The warm pool is available to reuse for a matching training job.</p> </li>
    /// <li> <p> <code>Reused</code>: The warm pool moved to a matching training job for reuse.</p> </li>
    /// <li> <p> <code>Terminated</code>: The warm pool is no longer available. Warm pools are unavailable if they are terminated by a user, terminated for a patch update, or terminated for exceeding the specified <code>KeepAlivePeriodInSeconds</code>.</p> </li>
    /// </ul>
    pub fn status(mut self, input: crate::types::WarmPoolResourceStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status of the warm pool.</p>
    /// <ul>
    /// <li> <p> <code>InUse</code>: The warm pool is in use for the training job.</p> </li>
    /// <li> <p> <code>Available</code>: The warm pool is available to reuse for a matching training job.</p> </li>
    /// <li> <p> <code>Reused</code>: The warm pool moved to a matching training job for reuse.</p> </li>
    /// <li> <p> <code>Terminated</code>: The warm pool is no longer available. Warm pools are unavailable if they are terminated by a user, terminated for a patch update, or terminated for exceeding the specified <code>KeepAlivePeriodInSeconds</code>.</p> </li>
    /// </ul>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::WarmPoolResourceStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>The billable time in seconds used by the warm pool. Billable time refers to the absolute wall-clock time.</p>
    /// <p>Multiply <code>ResourceRetainedBillableTimeInSeconds</code> by the number of instances (<code>InstanceCount</code>) in your training cluster to get the total compute time SageMaker bills you if you run warm pool training. The formula is as follows: <code>ResourceRetainedBillableTimeInSeconds * InstanceCount</code>.</p>
    pub fn resource_retained_billable_time_in_seconds(mut self, input: i32) -> Self {
        self.resource_retained_billable_time_in_seconds = Some(input);
        self
    }
    /// <p>The billable time in seconds used by the warm pool. Billable time refers to the absolute wall-clock time.</p>
    /// <p>Multiply <code>ResourceRetainedBillableTimeInSeconds</code> by the number of instances (<code>InstanceCount</code>) in your training cluster to get the total compute time SageMaker bills you if you run warm pool training. The formula is as follows: <code>ResourceRetainedBillableTimeInSeconds * InstanceCount</code>.</p>
    pub fn set_resource_retained_billable_time_in_seconds(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.resource_retained_billable_time_in_seconds = input;
        self
    }
    /// <p>The name of the matching training job that reused the warm pool.</p>
    pub fn reused_by_job(mut self, input: impl Into<std::string::String>) -> Self {
        self.reused_by_job = Some(input.into());
        self
    }
    /// <p>The name of the matching training job that reused the warm pool.</p>
    pub fn set_reused_by_job(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.reused_by_job = input;
        self
    }
    /// Consumes the builder and constructs a [`WarmPoolStatus`](crate::types::WarmPoolStatus).
    pub fn build(self) -> crate::types::WarmPoolStatus {
        crate::types::WarmPoolStatus {
            status: self.status,
            resource_retained_billable_time_in_seconds: self
                .resource_retained_billable_time_in_seconds,
            reused_by_job: self.reused_by_job,
        }
    }
}
