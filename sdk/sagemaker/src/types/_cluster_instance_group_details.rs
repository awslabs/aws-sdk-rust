// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Details of an instance group in a SageMaker HyperPod cluster.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ClusterInstanceGroupDetails {
    /// <p>The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.</p>
    pub current_count: ::std::option::Option<i32>,
    /// <p>The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.</p>
    pub target_count: ::std::option::Option<i32>,
    /// <p>The minimum number of instances that must be available in the instance group of a SageMaker HyperPod cluster before it transitions to <code>InService</code> status.</p>
    pub min_count: ::std::option::Option<i32>,
    /// <p>The name of the instance group of a SageMaker HyperPod cluster.</p>
    pub instance_group_name: ::std::option::Option<::std::string::String>,
    /// <p>The instance type of the instance group of a SageMaker HyperPod cluster.</p>
    pub instance_type: ::std::option::Option<crate::types::ClusterInstanceType>,
    /// <p>Details of LifeCycle configuration for the instance group.</p>
    pub life_cycle_config: ::std::option::Option<crate::types::ClusterLifeCycleConfig>,
    /// <p>The execution role for the instance group to assume.</p>
    pub execution_role: ::std::option::Option<::std::string::String>,
    /// <p>The number you specified to <code>TreadsPerCore</code> in <code>CreateCluster</code> for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading. For more information, see the reference table of <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cpu-options-supported-instances-values.html">CPU cores and threads per CPU core per instance type</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub threads_per_core: ::std::option::Option<i32>,
    /// <p>The additional storage configurations for the instances in the SageMaker HyperPod cluster instance group.</p>
    pub instance_storage_configs: ::std::option::Option<::std::vec::Vec<crate::types::ClusterInstanceStorageConfig>>,
    /// <p>A flag indicating whether deep health checks should be performed when the cluster instance group is created or updated.</p>
    pub on_start_deep_health_checks: ::std::option::Option<::std::vec::Vec<crate::types::DeepHealthCheckType>>,
    /// <p>The current status of the cluster instance group.</p>
    /// <ul>
    /// <li>
    /// <p><code>InService</code>: The instance group is active and healthy.</p></li>
    /// <li>
    /// <p><code>Creating</code>: The instance group is being provisioned.</p></li>
    /// <li>
    /// <p><code>Updating</code>: The instance group is being updated.</p></li>
    /// <li>
    /// <p><code>Failed</code>: The instance group has failed to provision or is no longer healthy.</p></li>
    /// <li>
    /// <p><code>Degraded</code>: The instance group is degraded, meaning that some instances have failed to provision or are no longer healthy.</p></li>
    /// <li>
    /// <p><code>Deleting</code>: The instance group is being deleted.</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::InstanceGroupStatus>,
    /// <p>The Amazon Resource Name (ARN); of the training plan associated with this cluster instance group.</p>
    /// <p>For more information about how to reserve GPU capacity for your SageMaker HyperPod clusters using Amazon SageMaker Training Plan, see <code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingPlan.html">CreateTrainingPlan</a> </code>.</p>
    pub training_plan_arn: ::std::option::Option<::std::string::String>,
    /// <p>The current status of the training plan associated with this cluster instance group.</p>
    pub training_plan_status: ::std::option::Option<::std::string::String>,
    /// <p>The customized Amazon VPC configuration at the instance group level that overrides the default Amazon VPC configuration of the SageMaker HyperPod cluster.</p>
    pub override_vpc_config: ::std::option::Option<crate::types::VpcConfig>,
    /// <p>The configuration object of the schedule that SageMaker follows when updating the AMI.</p>
    pub scheduled_update_config: ::std::option::Option<crate::types::ScheduledUpdateConfig>,
    /// <p>The ID of the Amazon Machine Image (AMI) currently in use by the instance group.</p>
    pub current_image_id: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the Amazon Machine Image (AMI) desired for the instance group.</p>
    pub desired_image_id: ::std::option::Option<::std::string::String>,
    /// <p>A map indicating active operations currently in progress for the instance group of a SageMaker HyperPod cluster. When there is a scaling operation in progress, this map contains a key <code>Scaling</code> with value 1.</p>
    pub active_operations: ::std::option::Option<::std::collections::HashMap<crate::types::ActiveClusterOperationName, i32>>,
    /// <p>The Kubernetes configuration for the instance group that contains labels and taints to be applied for the nodes in this instance group.</p>
    pub kubernetes_config: ::std::option::Option<crate::types::ClusterKubernetesConfigDetails>,
    /// <p>The instance capacity requirements for the instance group.</p>
    pub capacity_requirements: ::std::option::Option<crate::types::ClusterCapacityRequirements>,
    /// <p>Represents the number of running nodes using the desired Image ID.</p>
    /// <ol>
    /// <li>
    /// <p><b>During software update operations:</b> This count shows the number of nodes running on the desired Image ID. If a rollback occurs, the current image ID and desired image ID (both included in the describe cluster response) swap values. The TargetStateCount then shows the number of nodes running on the newly designated desired image ID (which was previously the current image ID).</p></li>
    /// <li>
    /// <p><b>During simultaneous scaling and software update operations:</b> This count shows the number of instances running on the desired image ID, including any new instances created as part of the scaling request. New nodes are always created using the desired image ID, so TargetStateCount reflects the total count of nodes running on the desired image ID, even during rollback scenarios.</p></li>
    /// </ol>
    pub target_state_count: ::std::option::Option<i32>,
    /// <p>Status of the last software udpate request.</p>
    /// <p>Status transitions follow these possible sequences:</p>
    /// <ul>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; Succeeded</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; RollbackComplete</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; Failed</p></li>
    /// </ul>
    pub software_update_status: ::std::option::Option<crate::types::SoftwareUpdateStatus>,
    /// <p>The configuration to use when updating the AMI versions.</p>
    pub active_software_update_config: ::std::option::Option<crate::types::DeploymentConfiguration>,
    /// <p>The Slurm configuration for the instance group.</p>
    pub slurm_config: ::std::option::Option<crate::types::ClusterSlurmConfigDetails>,
}
impl ClusterInstanceGroupDetails {
    /// <p>The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.</p>
    pub fn current_count(&self) -> ::std::option::Option<i32> {
        self.current_count
    }
    /// <p>The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.</p>
    pub fn target_count(&self) -> ::std::option::Option<i32> {
        self.target_count
    }
    /// <p>The minimum number of instances that must be available in the instance group of a SageMaker HyperPod cluster before it transitions to <code>InService</code> status.</p>
    pub fn min_count(&self) -> ::std::option::Option<i32> {
        self.min_count
    }
    /// <p>The name of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn instance_group_name(&self) -> ::std::option::Option<&str> {
        self.instance_group_name.as_deref()
    }
    /// <p>The instance type of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn instance_type(&self) -> ::std::option::Option<&crate::types::ClusterInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>Details of LifeCycle configuration for the instance group.</p>
    pub fn life_cycle_config(&self) -> ::std::option::Option<&crate::types::ClusterLifeCycleConfig> {
        self.life_cycle_config.as_ref()
    }
    /// <p>The execution role for the instance group to assume.</p>
    pub fn execution_role(&self) -> ::std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The number you specified to <code>TreadsPerCore</code> in <code>CreateCluster</code> for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading. For more information, see the reference table of <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cpu-options-supported-instances-values.html">CPU cores and threads per CPU core per instance type</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub fn threads_per_core(&self) -> ::std::option::Option<i32> {
        self.threads_per_core
    }
    /// <p>The additional storage configurations for the instances in the SageMaker HyperPod cluster instance group.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.instance_storage_configs.is_none()`.
    pub fn instance_storage_configs(&self) -> &[crate::types::ClusterInstanceStorageConfig] {
        self.instance_storage_configs.as_deref().unwrap_or_default()
    }
    /// <p>A flag indicating whether deep health checks should be performed when the cluster instance group is created or updated.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.on_start_deep_health_checks.is_none()`.
    pub fn on_start_deep_health_checks(&self) -> &[crate::types::DeepHealthCheckType] {
        self.on_start_deep_health_checks.as_deref().unwrap_or_default()
    }
    /// <p>The current status of the cluster instance group.</p>
    /// <ul>
    /// <li>
    /// <p><code>InService</code>: The instance group is active and healthy.</p></li>
    /// <li>
    /// <p><code>Creating</code>: The instance group is being provisioned.</p></li>
    /// <li>
    /// <p><code>Updating</code>: The instance group is being updated.</p></li>
    /// <li>
    /// <p><code>Failed</code>: The instance group has failed to provision or is no longer healthy.</p></li>
    /// <li>
    /// <p><code>Degraded</code>: The instance group is degraded, meaning that some instances have failed to provision or are no longer healthy.</p></li>
    /// <li>
    /// <p><code>Deleting</code>: The instance group is being deleted.</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::InstanceGroupStatus> {
        self.status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN); of the training plan associated with this cluster instance group.</p>
    /// <p>For more information about how to reserve GPU capacity for your SageMaker HyperPod clusters using Amazon SageMaker Training Plan, see <code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingPlan.html">CreateTrainingPlan</a> </code>.</p>
    pub fn training_plan_arn(&self) -> ::std::option::Option<&str> {
        self.training_plan_arn.as_deref()
    }
    /// <p>The current status of the training plan associated with this cluster instance group.</p>
    pub fn training_plan_status(&self) -> ::std::option::Option<&str> {
        self.training_plan_status.as_deref()
    }
    /// <p>The customized Amazon VPC configuration at the instance group level that overrides the default Amazon VPC configuration of the SageMaker HyperPod cluster.</p>
    pub fn override_vpc_config(&self) -> ::std::option::Option<&crate::types::VpcConfig> {
        self.override_vpc_config.as_ref()
    }
    /// <p>The configuration object of the schedule that SageMaker follows when updating the AMI.</p>
    pub fn scheduled_update_config(&self) -> ::std::option::Option<&crate::types::ScheduledUpdateConfig> {
        self.scheduled_update_config.as_ref()
    }
    /// <p>The ID of the Amazon Machine Image (AMI) currently in use by the instance group.</p>
    pub fn current_image_id(&self) -> ::std::option::Option<&str> {
        self.current_image_id.as_deref()
    }
    /// <p>The ID of the Amazon Machine Image (AMI) desired for the instance group.</p>
    pub fn desired_image_id(&self) -> ::std::option::Option<&str> {
        self.desired_image_id.as_deref()
    }
    /// <p>A map indicating active operations currently in progress for the instance group of a SageMaker HyperPod cluster. When there is a scaling operation in progress, this map contains a key <code>Scaling</code> with value 1.</p>
    pub fn active_operations(&self) -> ::std::option::Option<&::std::collections::HashMap<crate::types::ActiveClusterOperationName, i32>> {
        self.active_operations.as_ref()
    }
    /// <p>The Kubernetes configuration for the instance group that contains labels and taints to be applied for the nodes in this instance group.</p>
    pub fn kubernetes_config(&self) -> ::std::option::Option<&crate::types::ClusterKubernetesConfigDetails> {
        self.kubernetes_config.as_ref()
    }
    /// <p>The instance capacity requirements for the instance group.</p>
    pub fn capacity_requirements(&self) -> ::std::option::Option<&crate::types::ClusterCapacityRequirements> {
        self.capacity_requirements.as_ref()
    }
    /// <p>Represents the number of running nodes using the desired Image ID.</p>
    /// <ol>
    /// <li>
    /// <p><b>During software update operations:</b> This count shows the number of nodes running on the desired Image ID. If a rollback occurs, the current image ID and desired image ID (both included in the describe cluster response) swap values. The TargetStateCount then shows the number of nodes running on the newly designated desired image ID (which was previously the current image ID).</p></li>
    /// <li>
    /// <p><b>During simultaneous scaling and software update operations:</b> This count shows the number of instances running on the desired image ID, including any new instances created as part of the scaling request. New nodes are always created using the desired image ID, so TargetStateCount reflects the total count of nodes running on the desired image ID, even during rollback scenarios.</p></li>
    /// </ol>
    pub fn target_state_count(&self) -> ::std::option::Option<i32> {
        self.target_state_count
    }
    /// <p>Status of the last software udpate request.</p>
    /// <p>Status transitions follow these possible sequences:</p>
    /// <ul>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; Succeeded</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; RollbackComplete</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; Failed</p></li>
    /// </ul>
    pub fn software_update_status(&self) -> ::std::option::Option<&crate::types::SoftwareUpdateStatus> {
        self.software_update_status.as_ref()
    }
    /// <p>The configuration to use when updating the AMI versions.</p>
    pub fn active_software_update_config(&self) -> ::std::option::Option<&crate::types::DeploymentConfiguration> {
        self.active_software_update_config.as_ref()
    }
    /// <p>The Slurm configuration for the instance group.</p>
    pub fn slurm_config(&self) -> ::std::option::Option<&crate::types::ClusterSlurmConfigDetails> {
        self.slurm_config.as_ref()
    }
}
impl ClusterInstanceGroupDetails {
    /// Creates a new builder-style object to manufacture [`ClusterInstanceGroupDetails`](crate::types::ClusterInstanceGroupDetails).
    pub fn builder() -> crate::types::builders::ClusterInstanceGroupDetailsBuilder {
        crate::types::builders::ClusterInstanceGroupDetailsBuilder::default()
    }
}

/// A builder for [`ClusterInstanceGroupDetails`](crate::types::ClusterInstanceGroupDetails).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ClusterInstanceGroupDetailsBuilder {
    pub(crate) current_count: ::std::option::Option<i32>,
    pub(crate) target_count: ::std::option::Option<i32>,
    pub(crate) min_count: ::std::option::Option<i32>,
    pub(crate) instance_group_name: ::std::option::Option<::std::string::String>,
    pub(crate) instance_type: ::std::option::Option<crate::types::ClusterInstanceType>,
    pub(crate) life_cycle_config: ::std::option::Option<crate::types::ClusterLifeCycleConfig>,
    pub(crate) execution_role: ::std::option::Option<::std::string::String>,
    pub(crate) threads_per_core: ::std::option::Option<i32>,
    pub(crate) instance_storage_configs: ::std::option::Option<::std::vec::Vec<crate::types::ClusterInstanceStorageConfig>>,
    pub(crate) on_start_deep_health_checks: ::std::option::Option<::std::vec::Vec<crate::types::DeepHealthCheckType>>,
    pub(crate) status: ::std::option::Option<crate::types::InstanceGroupStatus>,
    pub(crate) training_plan_arn: ::std::option::Option<::std::string::String>,
    pub(crate) training_plan_status: ::std::option::Option<::std::string::String>,
    pub(crate) override_vpc_config: ::std::option::Option<crate::types::VpcConfig>,
    pub(crate) scheduled_update_config: ::std::option::Option<crate::types::ScheduledUpdateConfig>,
    pub(crate) current_image_id: ::std::option::Option<::std::string::String>,
    pub(crate) desired_image_id: ::std::option::Option<::std::string::String>,
    pub(crate) active_operations: ::std::option::Option<::std::collections::HashMap<crate::types::ActiveClusterOperationName, i32>>,
    pub(crate) kubernetes_config: ::std::option::Option<crate::types::ClusterKubernetesConfigDetails>,
    pub(crate) capacity_requirements: ::std::option::Option<crate::types::ClusterCapacityRequirements>,
    pub(crate) target_state_count: ::std::option::Option<i32>,
    pub(crate) software_update_status: ::std::option::Option<crate::types::SoftwareUpdateStatus>,
    pub(crate) active_software_update_config: ::std::option::Option<crate::types::DeploymentConfiguration>,
    pub(crate) slurm_config: ::std::option::Option<crate::types::ClusterSlurmConfigDetails>,
}
impl ClusterInstanceGroupDetailsBuilder {
    /// <p>The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.</p>
    pub fn current_count(mut self, input: i32) -> Self {
        self.current_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.</p>
    pub fn set_current_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.current_count = input;
        self
    }
    /// <p>The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.</p>
    pub fn get_current_count(&self) -> &::std::option::Option<i32> {
        &self.current_count
    }
    /// <p>The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.</p>
    pub fn target_count(mut self, input: i32) -> Self {
        self.target_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.</p>
    pub fn set_target_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.target_count = input;
        self
    }
    /// <p>The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.</p>
    pub fn get_target_count(&self) -> &::std::option::Option<i32> {
        &self.target_count
    }
    /// <p>The minimum number of instances that must be available in the instance group of a SageMaker HyperPod cluster before it transitions to <code>InService</code> status.</p>
    pub fn min_count(mut self, input: i32) -> Self {
        self.min_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum number of instances that must be available in the instance group of a SageMaker HyperPod cluster before it transitions to <code>InService</code> status.</p>
    pub fn set_min_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.min_count = input;
        self
    }
    /// <p>The minimum number of instances that must be available in the instance group of a SageMaker HyperPod cluster before it transitions to <code>InService</code> status.</p>
    pub fn get_min_count(&self) -> &::std::option::Option<i32> {
        &self.min_count
    }
    /// <p>The name of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn instance_group_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.instance_group_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn set_instance_group_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.instance_group_name = input;
        self
    }
    /// <p>The name of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn get_instance_group_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.instance_group_name
    }
    /// <p>The instance type of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn instance_type(mut self, input: crate::types::ClusterInstanceType) -> Self {
        self.instance_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The instance type of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn set_instance_type(mut self, input: ::std::option::Option<crate::types::ClusterInstanceType>) -> Self {
        self.instance_type = input;
        self
    }
    /// <p>The instance type of the instance group of a SageMaker HyperPod cluster.</p>
    pub fn get_instance_type(&self) -> &::std::option::Option<crate::types::ClusterInstanceType> {
        &self.instance_type
    }
    /// <p>Details of LifeCycle configuration for the instance group.</p>
    pub fn life_cycle_config(mut self, input: crate::types::ClusterLifeCycleConfig) -> Self {
        self.life_cycle_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>Details of LifeCycle configuration for the instance group.</p>
    pub fn set_life_cycle_config(mut self, input: ::std::option::Option<crate::types::ClusterLifeCycleConfig>) -> Self {
        self.life_cycle_config = input;
        self
    }
    /// <p>Details of LifeCycle configuration for the instance group.</p>
    pub fn get_life_cycle_config(&self) -> &::std::option::Option<crate::types::ClusterLifeCycleConfig> {
        &self.life_cycle_config
    }
    /// <p>The execution role for the instance group to assume.</p>
    pub fn execution_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_role = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The execution role for the instance group to assume.</p>
    pub fn set_execution_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_role = input;
        self
    }
    /// <p>The execution role for the instance group to assume.</p>
    pub fn get_execution_role(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_role
    }
    /// <p>The number you specified to <code>TreadsPerCore</code> in <code>CreateCluster</code> for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading. For more information, see the reference table of <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cpu-options-supported-instances-values.html">CPU cores and threads per CPU core per instance type</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub fn threads_per_core(mut self, input: i32) -> Self {
        self.threads_per_core = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number you specified to <code>TreadsPerCore</code> in <code>CreateCluster</code> for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading. For more information, see the reference table of <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cpu-options-supported-instances-values.html">CPU cores and threads per CPU core per instance type</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub fn set_threads_per_core(mut self, input: ::std::option::Option<i32>) -> Self {
        self.threads_per_core = input;
        self
    }
    /// <p>The number you specified to <code>TreadsPerCore</code> in <code>CreateCluster</code> for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading. For more information, see the reference table of <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cpu-options-supported-instances-values.html">CPU cores and threads per CPU core per instance type</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub fn get_threads_per_core(&self) -> &::std::option::Option<i32> {
        &self.threads_per_core
    }
    /// Appends an item to `instance_storage_configs`.
    ///
    /// To override the contents of this collection use [`set_instance_storage_configs`](Self::set_instance_storage_configs).
    ///
    /// <p>The additional storage configurations for the instances in the SageMaker HyperPod cluster instance group.</p>
    pub fn instance_storage_configs(mut self, input: crate::types::ClusterInstanceStorageConfig) -> Self {
        let mut v = self.instance_storage_configs.unwrap_or_default();
        v.push(input);
        self.instance_storage_configs = ::std::option::Option::Some(v);
        self
    }
    /// <p>The additional storage configurations for the instances in the SageMaker HyperPod cluster instance group.</p>
    pub fn set_instance_storage_configs(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ClusterInstanceStorageConfig>>) -> Self {
        self.instance_storage_configs = input;
        self
    }
    /// <p>The additional storage configurations for the instances in the SageMaker HyperPod cluster instance group.</p>
    pub fn get_instance_storage_configs(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ClusterInstanceStorageConfig>> {
        &self.instance_storage_configs
    }
    /// Appends an item to `on_start_deep_health_checks`.
    ///
    /// To override the contents of this collection use [`set_on_start_deep_health_checks`](Self::set_on_start_deep_health_checks).
    ///
    /// <p>A flag indicating whether deep health checks should be performed when the cluster instance group is created or updated.</p>
    pub fn on_start_deep_health_checks(mut self, input: crate::types::DeepHealthCheckType) -> Self {
        let mut v = self.on_start_deep_health_checks.unwrap_or_default();
        v.push(input);
        self.on_start_deep_health_checks = ::std::option::Option::Some(v);
        self
    }
    /// <p>A flag indicating whether deep health checks should be performed when the cluster instance group is created or updated.</p>
    pub fn set_on_start_deep_health_checks(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DeepHealthCheckType>>) -> Self {
        self.on_start_deep_health_checks = input;
        self
    }
    /// <p>A flag indicating whether deep health checks should be performed when the cluster instance group is created or updated.</p>
    pub fn get_on_start_deep_health_checks(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeepHealthCheckType>> {
        &self.on_start_deep_health_checks
    }
    /// <p>The current status of the cluster instance group.</p>
    /// <ul>
    /// <li>
    /// <p><code>InService</code>: The instance group is active and healthy.</p></li>
    /// <li>
    /// <p><code>Creating</code>: The instance group is being provisioned.</p></li>
    /// <li>
    /// <p><code>Updating</code>: The instance group is being updated.</p></li>
    /// <li>
    /// <p><code>Failed</code>: The instance group has failed to provision or is no longer healthy.</p></li>
    /// <li>
    /// <p><code>Degraded</code>: The instance group is degraded, meaning that some instances have failed to provision or are no longer healthy.</p></li>
    /// <li>
    /// <p><code>Deleting</code>: The instance group is being deleted.</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::InstanceGroupStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the cluster instance group.</p>
    /// <ul>
    /// <li>
    /// <p><code>InService</code>: The instance group is active and healthy.</p></li>
    /// <li>
    /// <p><code>Creating</code>: The instance group is being provisioned.</p></li>
    /// <li>
    /// <p><code>Updating</code>: The instance group is being updated.</p></li>
    /// <li>
    /// <p><code>Failed</code>: The instance group has failed to provision or is no longer healthy.</p></li>
    /// <li>
    /// <p><code>Degraded</code>: The instance group is degraded, meaning that some instances have failed to provision or are no longer healthy.</p></li>
    /// <li>
    /// <p><code>Deleting</code>: The instance group is being deleted.</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::InstanceGroupStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the cluster instance group.</p>
    /// <ul>
    /// <li>
    /// <p><code>InService</code>: The instance group is active and healthy.</p></li>
    /// <li>
    /// <p><code>Creating</code>: The instance group is being provisioned.</p></li>
    /// <li>
    /// <p><code>Updating</code>: The instance group is being updated.</p></li>
    /// <li>
    /// <p><code>Failed</code>: The instance group has failed to provision or is no longer healthy.</p></li>
    /// <li>
    /// <p><code>Degraded</code>: The instance group is degraded, meaning that some instances have failed to provision or are no longer healthy.</p></li>
    /// <li>
    /// <p><code>Deleting</code>: The instance group is being deleted.</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::InstanceGroupStatus> {
        &self.status
    }
    /// <p>The Amazon Resource Name (ARN); of the training plan associated with this cluster instance group.</p>
    /// <p>For more information about how to reserve GPU capacity for your SageMaker HyperPod clusters using Amazon SageMaker Training Plan, see <code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingPlan.html">CreateTrainingPlan</a> </code>.</p>
    pub fn training_plan_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.training_plan_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN); of the training plan associated with this cluster instance group.</p>
    /// <p>For more information about how to reserve GPU capacity for your SageMaker HyperPod clusters using Amazon SageMaker Training Plan, see <code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingPlan.html">CreateTrainingPlan</a> </code>.</p>
    pub fn set_training_plan_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.training_plan_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN); of the training plan associated with this cluster instance group.</p>
    /// <p>For more information about how to reserve GPU capacity for your SageMaker HyperPod clusters using Amazon SageMaker Training Plan, see <code> <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingPlan.html">CreateTrainingPlan</a> </code>.</p>
    pub fn get_training_plan_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.training_plan_arn
    }
    /// <p>The current status of the training plan associated with this cluster instance group.</p>
    pub fn training_plan_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.training_plan_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The current status of the training plan associated with this cluster instance group.</p>
    pub fn set_training_plan_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.training_plan_status = input;
        self
    }
    /// <p>The current status of the training plan associated with this cluster instance group.</p>
    pub fn get_training_plan_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.training_plan_status
    }
    /// <p>The customized Amazon VPC configuration at the instance group level that overrides the default Amazon VPC configuration of the SageMaker HyperPod cluster.</p>
    pub fn override_vpc_config(mut self, input: crate::types::VpcConfig) -> Self {
        self.override_vpc_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The customized Amazon VPC configuration at the instance group level that overrides the default Amazon VPC configuration of the SageMaker HyperPod cluster.</p>
    pub fn set_override_vpc_config(mut self, input: ::std::option::Option<crate::types::VpcConfig>) -> Self {
        self.override_vpc_config = input;
        self
    }
    /// <p>The customized Amazon VPC configuration at the instance group level that overrides the default Amazon VPC configuration of the SageMaker HyperPod cluster.</p>
    pub fn get_override_vpc_config(&self) -> &::std::option::Option<crate::types::VpcConfig> {
        &self.override_vpc_config
    }
    /// <p>The configuration object of the schedule that SageMaker follows when updating the AMI.</p>
    pub fn scheduled_update_config(mut self, input: crate::types::ScheduledUpdateConfig) -> Self {
        self.scheduled_update_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration object of the schedule that SageMaker follows when updating the AMI.</p>
    pub fn set_scheduled_update_config(mut self, input: ::std::option::Option<crate::types::ScheduledUpdateConfig>) -> Self {
        self.scheduled_update_config = input;
        self
    }
    /// <p>The configuration object of the schedule that SageMaker follows when updating the AMI.</p>
    pub fn get_scheduled_update_config(&self) -> &::std::option::Option<crate::types::ScheduledUpdateConfig> {
        &self.scheduled_update_config
    }
    /// <p>The ID of the Amazon Machine Image (AMI) currently in use by the instance group.</p>
    pub fn current_image_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.current_image_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the Amazon Machine Image (AMI) currently in use by the instance group.</p>
    pub fn set_current_image_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.current_image_id = input;
        self
    }
    /// <p>The ID of the Amazon Machine Image (AMI) currently in use by the instance group.</p>
    pub fn get_current_image_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.current_image_id
    }
    /// <p>The ID of the Amazon Machine Image (AMI) desired for the instance group.</p>
    pub fn desired_image_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.desired_image_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the Amazon Machine Image (AMI) desired for the instance group.</p>
    pub fn set_desired_image_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.desired_image_id = input;
        self
    }
    /// <p>The ID of the Amazon Machine Image (AMI) desired for the instance group.</p>
    pub fn get_desired_image_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.desired_image_id
    }
    /// Adds a key-value pair to `active_operations`.
    ///
    /// To override the contents of this collection use [`set_active_operations`](Self::set_active_operations).
    ///
    /// <p>A map indicating active operations currently in progress for the instance group of a SageMaker HyperPod cluster. When there is a scaling operation in progress, this map contains a key <code>Scaling</code> with value 1.</p>
    pub fn active_operations(mut self, k: crate::types::ActiveClusterOperationName, v: i32) -> Self {
        let mut hash_map = self.active_operations.unwrap_or_default();
        hash_map.insert(k, v);
        self.active_operations = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A map indicating active operations currently in progress for the instance group of a SageMaker HyperPod cluster. When there is a scaling operation in progress, this map contains a key <code>Scaling</code> with value 1.</p>
    pub fn set_active_operations(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<crate::types::ActiveClusterOperationName, i32>>,
    ) -> Self {
        self.active_operations = input;
        self
    }
    /// <p>A map indicating active operations currently in progress for the instance group of a SageMaker HyperPod cluster. When there is a scaling operation in progress, this map contains a key <code>Scaling</code> with value 1.</p>
    pub fn get_active_operations(&self) -> &::std::option::Option<::std::collections::HashMap<crate::types::ActiveClusterOperationName, i32>> {
        &self.active_operations
    }
    /// <p>The Kubernetes configuration for the instance group that contains labels and taints to be applied for the nodes in this instance group.</p>
    pub fn kubernetes_config(mut self, input: crate::types::ClusterKubernetesConfigDetails) -> Self {
        self.kubernetes_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Kubernetes configuration for the instance group that contains labels and taints to be applied for the nodes in this instance group.</p>
    pub fn set_kubernetes_config(mut self, input: ::std::option::Option<crate::types::ClusterKubernetesConfigDetails>) -> Self {
        self.kubernetes_config = input;
        self
    }
    /// <p>The Kubernetes configuration for the instance group that contains labels and taints to be applied for the nodes in this instance group.</p>
    pub fn get_kubernetes_config(&self) -> &::std::option::Option<crate::types::ClusterKubernetesConfigDetails> {
        &self.kubernetes_config
    }
    /// <p>The instance capacity requirements for the instance group.</p>
    pub fn capacity_requirements(mut self, input: crate::types::ClusterCapacityRequirements) -> Self {
        self.capacity_requirements = ::std::option::Option::Some(input);
        self
    }
    /// <p>The instance capacity requirements for the instance group.</p>
    pub fn set_capacity_requirements(mut self, input: ::std::option::Option<crate::types::ClusterCapacityRequirements>) -> Self {
        self.capacity_requirements = input;
        self
    }
    /// <p>The instance capacity requirements for the instance group.</p>
    pub fn get_capacity_requirements(&self) -> &::std::option::Option<crate::types::ClusterCapacityRequirements> {
        &self.capacity_requirements
    }
    /// <p>Represents the number of running nodes using the desired Image ID.</p>
    /// <ol>
    /// <li>
    /// <p><b>During software update operations:</b> This count shows the number of nodes running on the desired Image ID. If a rollback occurs, the current image ID and desired image ID (both included in the describe cluster response) swap values. The TargetStateCount then shows the number of nodes running on the newly designated desired image ID (which was previously the current image ID).</p></li>
    /// <li>
    /// <p><b>During simultaneous scaling and software update operations:</b> This count shows the number of instances running on the desired image ID, including any new instances created as part of the scaling request. New nodes are always created using the desired image ID, so TargetStateCount reflects the total count of nodes running on the desired image ID, even during rollback scenarios.</p></li>
    /// </ol>
    pub fn target_state_count(mut self, input: i32) -> Self {
        self.target_state_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Represents the number of running nodes using the desired Image ID.</p>
    /// <ol>
    /// <li>
    /// <p><b>During software update operations:</b> This count shows the number of nodes running on the desired Image ID. If a rollback occurs, the current image ID and desired image ID (both included in the describe cluster response) swap values. The TargetStateCount then shows the number of nodes running on the newly designated desired image ID (which was previously the current image ID).</p></li>
    /// <li>
    /// <p><b>During simultaneous scaling and software update operations:</b> This count shows the number of instances running on the desired image ID, including any new instances created as part of the scaling request. New nodes are always created using the desired image ID, so TargetStateCount reflects the total count of nodes running on the desired image ID, even during rollback scenarios.</p></li>
    /// </ol>
    pub fn set_target_state_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.target_state_count = input;
        self
    }
    /// <p>Represents the number of running nodes using the desired Image ID.</p>
    /// <ol>
    /// <li>
    /// <p><b>During software update operations:</b> This count shows the number of nodes running on the desired Image ID. If a rollback occurs, the current image ID and desired image ID (both included in the describe cluster response) swap values. The TargetStateCount then shows the number of nodes running on the newly designated desired image ID (which was previously the current image ID).</p></li>
    /// <li>
    /// <p><b>During simultaneous scaling and software update operations:</b> This count shows the number of instances running on the desired image ID, including any new instances created as part of the scaling request. New nodes are always created using the desired image ID, so TargetStateCount reflects the total count of nodes running on the desired image ID, even during rollback scenarios.</p></li>
    /// </ol>
    pub fn get_target_state_count(&self) -> &::std::option::Option<i32> {
        &self.target_state_count
    }
    /// <p>Status of the last software udpate request.</p>
    /// <p>Status transitions follow these possible sequences:</p>
    /// <ul>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; Succeeded</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; RollbackComplete</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; Failed</p></li>
    /// </ul>
    pub fn software_update_status(mut self, input: crate::types::SoftwareUpdateStatus) -> Self {
        self.software_update_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Status of the last software udpate request.</p>
    /// <p>Status transitions follow these possible sequences:</p>
    /// <ul>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; Succeeded</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; RollbackComplete</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; Failed</p></li>
    /// </ul>
    pub fn set_software_update_status(mut self, input: ::std::option::Option<crate::types::SoftwareUpdateStatus>) -> Self {
        self.software_update_status = input;
        self
    }
    /// <p>Status of the last software udpate request.</p>
    /// <p>Status transitions follow these possible sequences:</p>
    /// <ul>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; Succeeded</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; RollbackComplete</p></li>
    /// <li>
    /// <p>Pending -&gt; InProgress -&gt; RollbackInProgress -&gt; Failed</p></li>
    /// </ul>
    pub fn get_software_update_status(&self) -> &::std::option::Option<crate::types::SoftwareUpdateStatus> {
        &self.software_update_status
    }
    /// <p>The configuration to use when updating the AMI versions.</p>
    pub fn active_software_update_config(mut self, input: crate::types::DeploymentConfiguration) -> Self {
        self.active_software_update_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration to use when updating the AMI versions.</p>
    pub fn set_active_software_update_config(mut self, input: ::std::option::Option<crate::types::DeploymentConfiguration>) -> Self {
        self.active_software_update_config = input;
        self
    }
    /// <p>The configuration to use when updating the AMI versions.</p>
    pub fn get_active_software_update_config(&self) -> &::std::option::Option<crate::types::DeploymentConfiguration> {
        &self.active_software_update_config
    }
    /// <p>The Slurm configuration for the instance group.</p>
    pub fn slurm_config(mut self, input: crate::types::ClusterSlurmConfigDetails) -> Self {
        self.slurm_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Slurm configuration for the instance group.</p>
    pub fn set_slurm_config(mut self, input: ::std::option::Option<crate::types::ClusterSlurmConfigDetails>) -> Self {
        self.slurm_config = input;
        self
    }
    /// <p>The Slurm configuration for the instance group.</p>
    pub fn get_slurm_config(&self) -> &::std::option::Option<crate::types::ClusterSlurmConfigDetails> {
        &self.slurm_config
    }
    /// Consumes the builder and constructs a [`ClusterInstanceGroupDetails`](crate::types::ClusterInstanceGroupDetails).
    pub fn build(self) -> crate::types::ClusterInstanceGroupDetails {
        crate::types::ClusterInstanceGroupDetails {
            current_count: self.current_count,
            target_count: self.target_count,
            min_count: self.min_count,
            instance_group_name: self.instance_group_name,
            instance_type: self.instance_type,
            life_cycle_config: self.life_cycle_config,
            execution_role: self.execution_role,
            threads_per_core: self.threads_per_core,
            instance_storage_configs: self.instance_storage_configs,
            on_start_deep_health_checks: self.on_start_deep_health_checks,
            status: self.status,
            training_plan_arn: self.training_plan_arn,
            training_plan_status: self.training_plan_status,
            override_vpc_config: self.override_vpc_config,
            scheduled_update_config: self.scheduled_update_config,
            current_image_id: self.current_image_id,
            desired_image_id: self.desired_image_id,
            active_operations: self.active_operations,
            kubernetes_config: self.kubernetes_config,
            capacity_requirements: self.capacity_requirements,
            target_state_count: self.target_state_count,
            software_update_status: self.software_update_status,
            active_software_update_config: self.active_software_update_config,
            slurm_config: self.slurm_config,
        }
    }
}
