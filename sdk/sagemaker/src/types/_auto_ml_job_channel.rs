// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A channel is a named input source that training algorithms can consume. This channel is used for AutoML jobs V2 (jobs created by calling <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateAutoMLJobV2.html">CreateAutoMLJobV2</a>).</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AutoMlJobChannel {
    /// <p>The type of channel. Defines whether the data are used for training or validation. The default value is <code>training</code>. Channels for <code>training</code> and <code>validation</code> must share the same <code>ContentType</code></p><note>
    /// <p>The type of channel defaults to <code>training</code> for the time-series forecasting problem type.</p>
    /// </note>
    pub channel_type: ::std::option::Option<crate::types::AutoMlChannelType>,
    /// <p>The content type of the data from the input source. The following are the allowed content types for different problems:</p>
    /// <ul>
    /// <li>
    /// <p>For tabular problem types: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For image classification: <code>image/png</code>, <code>image/jpeg</code>, or <code>image/*</code>. The default value is <code>image/*</code>.</p></li>
    /// <li>
    /// <p>For text classification: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For time-series forecasting: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For text generation (LLMs fine-tuning): <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// </ul>
    pub content_type: ::std::option::Option<::std::string::String>,
    /// <p>The allowed compression types depend on the input format and problem type. We allow the compression type <code>Gzip</code> for <code>S3Prefix</code> inputs on tabular data only. For all other inputs, the compression type should be <code>None</code>. If no compression type is provided, we default to <code>None</code>.</p>
    pub compression_type: ::std::option::Option<crate::types::CompressionType>,
    /// <p>The data source for an AutoML channel (Required).</p>
    pub data_source: ::std::option::Option<crate::types::AutoMlDataSource>,
}
impl AutoMlJobChannel {
    /// <p>The type of channel. Defines whether the data are used for training or validation. The default value is <code>training</code>. Channels for <code>training</code> and <code>validation</code> must share the same <code>ContentType</code></p><note>
    /// <p>The type of channel defaults to <code>training</code> for the time-series forecasting problem type.</p>
    /// </note>
    pub fn channel_type(&self) -> ::std::option::Option<&crate::types::AutoMlChannelType> {
        self.channel_type.as_ref()
    }
    /// <p>The content type of the data from the input source. The following are the allowed content types for different problems:</p>
    /// <ul>
    /// <li>
    /// <p>For tabular problem types: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For image classification: <code>image/png</code>, <code>image/jpeg</code>, or <code>image/*</code>. The default value is <code>image/*</code>.</p></li>
    /// <li>
    /// <p>For text classification: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For time-series forecasting: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For text generation (LLMs fine-tuning): <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// </ul>
    pub fn content_type(&self) -> ::std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The allowed compression types depend on the input format and problem type. We allow the compression type <code>Gzip</code> for <code>S3Prefix</code> inputs on tabular data only. For all other inputs, the compression type should be <code>None</code>. If no compression type is provided, we default to <code>None</code>.</p>
    pub fn compression_type(&self) -> ::std::option::Option<&crate::types::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>The data source for an AutoML channel (Required).</p>
    pub fn data_source(&self) -> ::std::option::Option<&crate::types::AutoMlDataSource> {
        self.data_source.as_ref()
    }
}
impl AutoMlJobChannel {
    /// Creates a new builder-style object to manufacture [`AutoMlJobChannel`](crate::types::AutoMlJobChannel).
    pub fn builder() -> crate::types::builders::AutoMlJobChannelBuilder {
        crate::types::builders::AutoMlJobChannelBuilder::default()
    }
}

/// A builder for [`AutoMlJobChannel`](crate::types::AutoMlJobChannel).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct AutoMlJobChannelBuilder {
    pub(crate) channel_type: ::std::option::Option<crate::types::AutoMlChannelType>,
    pub(crate) content_type: ::std::option::Option<::std::string::String>,
    pub(crate) compression_type: ::std::option::Option<crate::types::CompressionType>,
    pub(crate) data_source: ::std::option::Option<crate::types::AutoMlDataSource>,
}
impl AutoMlJobChannelBuilder {
    /// <p>The type of channel. Defines whether the data are used for training or validation. The default value is <code>training</code>. Channels for <code>training</code> and <code>validation</code> must share the same <code>ContentType</code></p><note>
    /// <p>The type of channel defaults to <code>training</code> for the time-series forecasting problem type.</p>
    /// </note>
    pub fn channel_type(mut self, input: crate::types::AutoMlChannelType) -> Self {
        self.channel_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of channel. Defines whether the data are used for training or validation. The default value is <code>training</code>. Channels for <code>training</code> and <code>validation</code> must share the same <code>ContentType</code></p><note>
    /// <p>The type of channel defaults to <code>training</code> for the time-series forecasting problem type.</p>
    /// </note>
    pub fn set_channel_type(mut self, input: ::std::option::Option<crate::types::AutoMlChannelType>) -> Self {
        self.channel_type = input;
        self
    }
    /// <p>The type of channel. Defines whether the data are used for training or validation. The default value is <code>training</code>. Channels for <code>training</code> and <code>validation</code> must share the same <code>ContentType</code></p><note>
    /// <p>The type of channel defaults to <code>training</code> for the time-series forecasting problem type.</p>
    /// </note>
    pub fn get_channel_type(&self) -> &::std::option::Option<crate::types::AutoMlChannelType> {
        &self.channel_type
    }
    /// <p>The content type of the data from the input source. The following are the allowed content types for different problems:</p>
    /// <ul>
    /// <li>
    /// <p>For tabular problem types: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For image classification: <code>image/png</code>, <code>image/jpeg</code>, or <code>image/*</code>. The default value is <code>image/*</code>.</p></li>
    /// <li>
    /// <p>For text classification: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For time-series forecasting: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For text generation (LLMs fine-tuning): <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// </ul>
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The content type of the data from the input source. The following are the allowed content types for different problems:</p>
    /// <ul>
    /// <li>
    /// <p>For tabular problem types: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For image classification: <code>image/png</code>, <code>image/jpeg</code>, or <code>image/*</code>. The default value is <code>image/*</code>.</p></li>
    /// <li>
    /// <p>For text classification: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For time-series forecasting: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For text generation (LLMs fine-tuning): <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// </ul>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The content type of the data from the input source. The following are the allowed content types for different problems:</p>
    /// <ul>
    /// <li>
    /// <p>For tabular problem types: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For image classification: <code>image/png</code>, <code>image/jpeg</code>, or <code>image/*</code>. The default value is <code>image/*</code>.</p></li>
    /// <li>
    /// <p>For text classification: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For time-series forecasting: <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// <li>
    /// <p>For text generation (LLMs fine-tuning): <code>text/csv;header=present</code> or <code>x-application/vnd.amazon+parquet</code>. The default value is <code>text/csv;header=present</code>.</p></li>
    /// </ul>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_type
    }
    /// <p>The allowed compression types depend on the input format and problem type. We allow the compression type <code>Gzip</code> for <code>S3Prefix</code> inputs on tabular data only. For all other inputs, the compression type should be <code>None</code>. If no compression type is provided, we default to <code>None</code>.</p>
    pub fn compression_type(mut self, input: crate::types::CompressionType) -> Self {
        self.compression_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The allowed compression types depend on the input format and problem type. We allow the compression type <code>Gzip</code> for <code>S3Prefix</code> inputs on tabular data only. For all other inputs, the compression type should be <code>None</code>. If no compression type is provided, we default to <code>None</code>.</p>
    pub fn set_compression_type(mut self, input: ::std::option::Option<crate::types::CompressionType>) -> Self {
        self.compression_type = input;
        self
    }
    /// <p>The allowed compression types depend on the input format and problem type. We allow the compression type <code>Gzip</code> for <code>S3Prefix</code> inputs on tabular data only. For all other inputs, the compression type should be <code>None</code>. If no compression type is provided, we default to <code>None</code>.</p>
    pub fn get_compression_type(&self) -> &::std::option::Option<crate::types::CompressionType> {
        &self.compression_type
    }
    /// <p>The data source for an AutoML channel (Required).</p>
    pub fn data_source(mut self, input: crate::types::AutoMlDataSource) -> Self {
        self.data_source = ::std::option::Option::Some(input);
        self
    }
    /// <p>The data source for an AutoML channel (Required).</p>
    pub fn set_data_source(mut self, input: ::std::option::Option<crate::types::AutoMlDataSource>) -> Self {
        self.data_source = input;
        self
    }
    /// <p>The data source for an AutoML channel (Required).</p>
    pub fn get_data_source(&self) -> &::std::option::Option<crate::types::AutoMlDataSource> {
        &self.data_source
    }
    /// Consumes the builder and constructs a [`AutoMlJobChannel`](crate::types::AutoMlJobChannel).
    pub fn build(self) -> crate::types::AutoMlJobChannel {
        crate::types::AutoMlJobChannel {
            channel_type: self.channel_type,
            content_type: self.content_type,
            compression_type: self.compression_type,
            data_source: self.data_source,
        }
    }
}
