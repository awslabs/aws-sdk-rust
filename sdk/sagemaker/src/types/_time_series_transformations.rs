// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Transformations allowed on the dataset. Supported transformations are <code>Filling</code> and <code>Aggregation</code>. <code>Filling</code> specifies how to add values to missing values in the dataset. <code>Aggregation</code> defines how to aggregate data that does not align with forecast frequency.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TimeSeriesTransformations {
    /// <p>A key value pair defining the filling method for a column, where the key is the column name and the value is an object which defines the filling logic. You can specify multiple filling methods for a single column.</p>
    /// <p>The supported filling methods and their corresponding options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>frontfill</code>: <code>none</code> (Supported only for target column)</p></li>
    /// <li>
    /// <p><code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to the chosen filling method value (for example <code>"backfill" : "value"</code>), and define the filling value in an additional parameter prefixed with "_value". For example, to set <code>backfill</code> to a value of <code>2</code>, you must include two parameters: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>.</p>
    pub filling: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>>,
    >,
    /// <p>A key value pair defining the aggregation method for a column, where the key is the column name and the value is the aggregation method.</p>
    /// <p>The supported aggregation methods are <code>sum</code> (default), <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>.</p><note>
    /// <p>Aggregation is only supported for the target column.</p>
    /// </note>
    pub aggregation: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::AggregationTransformationValue>>,
}
impl TimeSeriesTransformations {
    /// <p>A key value pair defining the filling method for a column, where the key is the column name and the value is an object which defines the filling logic. You can specify multiple filling methods for a single column.</p>
    /// <p>The supported filling methods and their corresponding options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>frontfill</code>: <code>none</code> (Supported only for target column)</p></li>
    /// <li>
    /// <p><code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to the chosen filling method value (for example <code>"backfill" : "value"</code>), and define the filling value in an additional parameter prefixed with "_value". For example, to set <code>backfill</code> to a value of <code>2</code>, you must include two parameters: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>.</p>
    pub fn filling(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>>,
    > {
        self.filling.as_ref()
    }
    /// <p>A key value pair defining the aggregation method for a column, where the key is the column name and the value is the aggregation method.</p>
    /// <p>The supported aggregation methods are <code>sum</code> (default), <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>.</p><note>
    /// <p>Aggregation is only supported for the target column.</p>
    /// </note>
    pub fn aggregation(
        &self,
    ) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, crate::types::AggregationTransformationValue>> {
        self.aggregation.as_ref()
    }
}
impl TimeSeriesTransformations {
    /// Creates a new builder-style object to manufacture [`TimeSeriesTransformations`](crate::types::TimeSeriesTransformations).
    pub fn builder() -> crate::types::builders::TimeSeriesTransformationsBuilder {
        crate::types::builders::TimeSeriesTransformationsBuilder::default()
    }
}

/// A builder for [`TimeSeriesTransformations`](crate::types::TimeSeriesTransformations).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct TimeSeriesTransformationsBuilder {
    pub(crate) filling: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>>,
    >,
    pub(crate) aggregation: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::AggregationTransformationValue>>,
}
impl TimeSeriesTransformationsBuilder {
    /// Adds a key-value pair to `filling`.
    ///
    /// To override the contents of this collection use [`set_filling`](Self::set_filling).
    ///
    /// <p>A key value pair defining the filling method for a column, where the key is the column name and the value is an object which defines the filling logic. You can specify multiple filling methods for a single column.</p>
    /// <p>The supported filling methods and their corresponding options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>frontfill</code>: <code>none</code> (Supported only for target column)</p></li>
    /// <li>
    /// <p><code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to the chosen filling method value (for example <code>"backfill" : "value"</code>), and define the filling value in an additional parameter prefixed with "_value". For example, to set <code>backfill</code> to a value of <code>2</code>, you must include two parameters: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>.</p>
    pub fn filling(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>,
    ) -> Self {
        let mut hash_map = self.filling.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.filling = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A key value pair defining the filling method for a column, where the key is the column name and the value is an object which defines the filling logic. You can specify multiple filling methods for a single column.</p>
    /// <p>The supported filling methods and their corresponding options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>frontfill</code>: <code>none</code> (Supported only for target column)</p></li>
    /// <li>
    /// <p><code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to the chosen filling method value (for example <code>"backfill" : "value"</code>), and define the filling value in an additional parameter prefixed with "_value". For example, to set <code>backfill</code> to a value of <code>2</code>, you must include two parameters: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>.</p>
    pub fn set_filling(
        mut self,
        input: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>>,
        >,
    ) -> Self {
        self.filling = input;
        self
    }
    /// <p>A key value pair defining the filling method for a column, where the key is the column name and the value is an object which defines the filling logic. You can specify multiple filling methods for a single column.</p>
    /// <p>The supported filling methods and their corresponding options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>frontfill</code>: <code>none</code> (Supported only for target column)</p></li>
    /// <li>
    /// <p><code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// <li>
    /// <p><code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code></p></li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to the chosen filling method value (for example <code>"backfill" : "value"</code>), and define the filling value in an additional parameter prefixed with "_value". For example, to set <code>backfill</code> to a value of <code>2</code>, you must include two parameters: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>.</p>
    pub fn get_filling(
        &self,
    ) -> &::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::collections::HashMap<crate::types::FillingType, ::std::string::String>>,
    > {
        &self.filling
    }
    /// Adds a key-value pair to `aggregation`.
    ///
    /// To override the contents of this collection use [`set_aggregation`](Self::set_aggregation).
    ///
    /// <p>A key value pair defining the aggregation method for a column, where the key is the column name and the value is the aggregation method.</p>
    /// <p>The supported aggregation methods are <code>sum</code> (default), <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>.</p><note>
    /// <p>Aggregation is only supported for the target column.</p>
    /// </note>
    pub fn aggregation(mut self, k: impl ::std::convert::Into<::std::string::String>, v: crate::types::AggregationTransformationValue) -> Self {
        let mut hash_map = self.aggregation.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.aggregation = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A key value pair defining the aggregation method for a column, where the key is the column name and the value is the aggregation method.</p>
    /// <p>The supported aggregation methods are <code>sum</code> (default), <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>.</p><note>
    /// <p>Aggregation is only supported for the target column.</p>
    /// </note>
    pub fn set_aggregation(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::AggregationTransformationValue>>,
    ) -> Self {
        self.aggregation = input;
        self
    }
    /// <p>A key value pair defining the aggregation method for a column, where the key is the column name and the value is the aggregation method.</p>
    /// <p>The supported aggregation methods are <code>sum</code> (default), <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>.</p><note>
    /// <p>Aggregation is only supported for the target column.</p>
    /// </note>
    pub fn get_aggregation(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::AggregationTransformationValue>> {
        &self.aggregation
    }
    /// Consumes the builder and constructs a [`TimeSeriesTransformations`](crate::types::TimeSeriesTransformations).
    pub fn build(self) -> crate::types::TimeSeriesTransformations {
        crate::types::TimeSeriesTransformations {
            filling: self.filling,
            aggregation: self.aggregation,
        }
    }
}
