// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Detailed information about the input that failed to satisfy the constraints specified by a call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum BadRequestDetails {
    /// <p>Detailed information about the bad request exception error when creating a hosted configuration version.</p>
    InvalidConfiguration(std::vec::Vec<crate::model::InvalidConfigurationDetail>),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl BadRequestDetails {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`InvalidConfiguration`](crate::model::BadRequestDetails::InvalidConfiguration), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_invalid_configuration(
        &self,
    ) -> std::result::Result<&std::vec::Vec<crate::model::InvalidConfigurationDetail>, &Self> {
        if let BadRequestDetails::InvalidConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`InvalidConfiguration`](crate::model::BadRequestDetails::InvalidConfiguration).
    pub fn is_invalid_configuration(&self) -> bool {
        self.as_invalid_configuration().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Detailed information about the bad request exception error when creating a hosted configuration version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidConfigurationDetail {
    /// <p>The invalid or out-of-range validation constraint in your JSON schema that failed validation.</p>
    #[doc(hidden)]
    pub constraint: std::option::Option<std::string::String>,
    /// <p>Location of the validation constraint in the configuration JSON schema that failed validation.</p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>The reason for an invalid configuration error.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<std::string::String>,
    /// <p>The type of error for an invalid configuration.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Details about an error with Lambda when a synchronous extension experiences an error during an invocation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl InvalidConfigurationDetail {
    /// <p>The invalid or out-of-range validation constraint in your JSON schema that failed validation.</p>
    pub fn constraint(&self) -> std::option::Option<&str> {
        self.constraint.as_deref()
    }
    /// <p>Location of the validation constraint in the configuration JSON schema that failed validation.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>The reason for an invalid configuration error.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
    /// <p>The type of error for an invalid configuration.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Details about an error with Lambda when a synchronous extension experiences an error during an invocation.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`InvalidConfigurationDetail`](crate::model::InvalidConfigurationDetail).
pub mod invalid_configuration_detail {

    /// A builder for [`InvalidConfigurationDetail`](crate::model::InvalidConfigurationDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) constraint: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The invalid or out-of-range validation constraint in your JSON schema that failed validation.</p>
        pub fn constraint(mut self, input: impl Into<std::string::String>) -> Self {
            self.constraint = Some(input.into());
            self
        }
        /// <p>The invalid or out-of-range validation constraint in your JSON schema that failed validation.</p>
        pub fn set_constraint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.constraint = input;
            self
        }
        /// <p>Location of the validation constraint in the configuration JSON schema that failed validation.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>Location of the validation constraint in the configuration JSON schema that failed validation.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>The reason for an invalid configuration error.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>The reason for an invalid configuration error.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// <p>The type of error for an invalid configuration.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of error for an invalid configuration.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Details about an error with Lambda when a synchronous extension experiences an error during an invocation.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>Details about an error with Lambda when a synchronous extension experiences an error during an invocation.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConfigurationDetail`](crate::model::InvalidConfigurationDetail).
        pub fn build(self) -> crate::model::InvalidConfigurationDetail {
            crate::model::InvalidConfigurationDetail {
                constraint: self.constraint,
                location: self.location,
                reason: self.reason,
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl InvalidConfigurationDetail {
    /// Creates a new builder-style object to manufacture [`InvalidConfigurationDetail`](crate::model::InvalidConfigurationDetail).
    pub fn builder() -> crate::model::invalid_configuration_detail::Builder {
        crate::model::invalid_configuration_detail::Builder::default()
    }
}

/// When writing a match expression against `BadRequestReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let badrequestreason = unimplemented!();
/// match badrequestreason {
///     BadRequestReason::InvalidConfiguration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `badrequestreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BadRequestReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BadRequestReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BadRequestReason::NewFeature` is defined.
/// Specifically, when `badrequestreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BadRequestReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BadRequestReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidConfiguration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BadRequestReason {
    fn from(s: &str) -> Self {
        match s {
            "InvalidConfiguration" => BadRequestReason::InvalidConfiguration,
            other => BadRequestReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BadRequestReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BadRequestReason::from(s))
    }
}
impl BadRequestReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BadRequestReason::InvalidConfiguration => "InvalidConfiguration",
            BadRequestReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["InvalidConfiguration"]
    }
}
impl AsRef<str> for BadRequestReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A value such as an Amazon Resource Name (ARN) or an Amazon Simple Notification Service topic entered in an extension when invoked. Parameter values are specified in an extension association. For more information about extensions, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Parameter {
    /// <p>Information about the parameter.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A parameter value must be specified in the extension association.</p>
    #[doc(hidden)]
    pub required: bool,
}
impl Parameter {
    /// <p>Information about the parameter.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A parameter value must be specified in the extension association.</p>
    pub fn required(&self) -> bool {
        self.required
    }
}
/// See [`Parameter`](crate::model::Parameter).
pub mod parameter {

    /// A builder for [`Parameter`](crate::model::Parameter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) required: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Information about the parameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Information about the parameter.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A parameter value must be specified in the extension association.</p>
        pub fn required(mut self, input: bool) -> Self {
            self.required = Some(input);
            self
        }
        /// <p>A parameter value must be specified in the extension association.</p>
        pub fn set_required(mut self, input: std::option::Option<bool>) -> Self {
            self.required = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter).
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                description: self.description,
                required: self.required.unwrap_or_default(),
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter).
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

/// <p>An action defines the tasks the extension performs during the AppConfig workflow. Each action includes an action point such as <code>ON_CREATE_HOSTED_CONFIGURATION</code>, <code>PRE_DEPLOYMENT</code>, or <code>ON_DEPLOYMENT</code>. Each action also includes a name, a URI to an Lambda function, and an Amazon Resource Name (ARN) for an Identity and Access Management assume role. You specify the name, URI, and ARN for each <i>action point</i> defined in the extension. You can specify the following actions for an extension:</p>
/// <ul>
/// <li> <p> <code>PRE_CREATE_HOSTED_CONFIGURATION_VERSION</code> </p> </li>
/// <li> <p> <code>PRE_START_DEPLOYMENT</code> </p> </li>
/// <li> <p> <code>ON_DEPLOYMENT_START</code> </p> </li>
/// <li> <p> <code>ON_DEPLOYMENT_STEP</code> </p> </li>
/// <li> <p> <code>ON_DEPLOYMENT_BAKING</code> </p> </li>
/// <li> <p> <code>ON_DEPLOYMENT_COMPLETE</code> </p> </li>
/// <li> <p> <code>ON_DEPLOYMENT_ROLLED_BACK</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Action {
    /// <p>The action name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about the action.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl Action {
    /// <p>The action name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about the action.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`Action`](crate::model::Action).
pub mod action {

    /// A builder for [`Action`](crate::model::Action).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The action name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about the action.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Information about the action.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Action`](crate::model::Action).
        pub fn build(self) -> crate::model::Action {
            crate::model::Action {
                name: self.name,
                description: self.description,
                uri: self.uri,
                role_arn: self.role_arn,
            }
        }
    }
}
impl Action {
    /// Creates a new builder-style object to manufacture [`Action`](crate::model::Action).
    pub fn builder() -> crate::model::action::Builder {
        crate::model::action::Builder::default()
    }
}

/// When writing a match expression against `ActionPoint`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let actionpoint = unimplemented!();
/// match actionpoint {
///     ActionPoint::OnDeploymentBaking => { /* ... */ },
///     ActionPoint::OnDeploymentComplete => { /* ... */ },
///     ActionPoint::OnDeploymentRolledBack => { /* ... */ },
///     ActionPoint::OnDeploymentStart => { /* ... */ },
///     ActionPoint::OnDeploymentStep => { /* ... */ },
///     ActionPoint::PreCreateHostedConfigurationVersion => { /* ... */ },
///     ActionPoint::PreStartDeployment => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `actionpoint` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ActionPoint::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ActionPoint::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ActionPoint::NewFeature` is defined.
/// Specifically, when `actionpoint` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ActionPoint::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionPoint {
    #[allow(missing_docs)] // documentation missing in model
    OnDeploymentBaking,
    #[allow(missing_docs)] // documentation missing in model
    OnDeploymentComplete,
    #[allow(missing_docs)] // documentation missing in model
    OnDeploymentRolledBack,
    #[allow(missing_docs)] // documentation missing in model
    OnDeploymentStart,
    #[allow(missing_docs)] // documentation missing in model
    OnDeploymentStep,
    #[allow(missing_docs)] // documentation missing in model
    PreCreateHostedConfigurationVersion,
    #[allow(missing_docs)] // documentation missing in model
    PreStartDeployment,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ActionPoint {
    fn from(s: &str) -> Self {
        match s {
            "ON_DEPLOYMENT_BAKING" => ActionPoint::OnDeploymentBaking,
            "ON_DEPLOYMENT_COMPLETE" => ActionPoint::OnDeploymentComplete,
            "ON_DEPLOYMENT_ROLLED_BACK" => ActionPoint::OnDeploymentRolledBack,
            "ON_DEPLOYMENT_START" => ActionPoint::OnDeploymentStart,
            "ON_DEPLOYMENT_STEP" => ActionPoint::OnDeploymentStep,
            "PRE_CREATE_HOSTED_CONFIGURATION_VERSION" => {
                ActionPoint::PreCreateHostedConfigurationVersion
            }
            "PRE_START_DEPLOYMENT" => ActionPoint::PreStartDeployment,
            other => ActionPoint::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ActionPoint {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionPoint::from(s))
    }
}
impl ActionPoint {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionPoint::OnDeploymentBaking => "ON_DEPLOYMENT_BAKING",
            ActionPoint::OnDeploymentComplete => "ON_DEPLOYMENT_COMPLETE",
            ActionPoint::OnDeploymentRolledBack => "ON_DEPLOYMENT_ROLLED_BACK",
            ActionPoint::OnDeploymentStart => "ON_DEPLOYMENT_START",
            ActionPoint::OnDeploymentStep => "ON_DEPLOYMENT_STEP",
            ActionPoint::PreCreateHostedConfigurationVersion => {
                "PRE_CREATE_HOSTED_CONFIGURATION_VERSION"
            }
            ActionPoint::PreStartDeployment => "PRE_START_DEPLOYMENT",
            ActionPoint::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ON_DEPLOYMENT_BAKING",
            "ON_DEPLOYMENT_COMPLETE",
            "ON_DEPLOYMENT_ROLLED_BACK",
            "ON_DEPLOYMENT_START",
            "ON_DEPLOYMENT_STEP",
            "PRE_CREATE_HOSTED_CONFIGURATION_VERSION",
            "PRE_START_DEPLOYMENT",
        ]
    }
}
impl AsRef<str> for ActionPoint {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Amazon CloudWatch alarms to monitor during the deployment process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Monitor {
    /// <p>Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.</p>
    #[doc(hidden)]
    pub alarm_arn: std::option::Option<std::string::String>,
    /// <p>ARN of an Identity and Access Management (IAM) role for AppConfig to monitor <code>AlarmArn</code>.</p>
    #[doc(hidden)]
    pub alarm_role_arn: std::option::Option<std::string::String>,
}
impl Monitor {
    /// <p>Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.</p>
    pub fn alarm_arn(&self) -> std::option::Option<&str> {
        self.alarm_arn.as_deref()
    }
    /// <p>ARN of an Identity and Access Management (IAM) role for AppConfig to monitor <code>AlarmArn</code>.</p>
    pub fn alarm_role_arn(&self) -> std::option::Option<&str> {
        self.alarm_role_arn.as_deref()
    }
}
/// See [`Monitor`](crate::model::Monitor).
pub mod monitor {

    /// A builder for [`Monitor`](crate::model::Monitor).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_arn: std::option::Option<std::string::String>,
        pub(crate) alarm_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.</p>
        pub fn alarm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.</p>
        pub fn set_alarm_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_arn = input;
            self
        }
        /// <p>ARN of an Identity and Access Management (IAM) role for AppConfig to monitor <code>AlarmArn</code>.</p>
        pub fn alarm_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_role_arn = Some(input.into());
            self
        }
        /// <p>ARN of an Identity and Access Management (IAM) role for AppConfig to monitor <code>AlarmArn</code>.</p>
        pub fn set_alarm_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Monitor`](crate::model::Monitor).
        pub fn build(self) -> crate::model::Monitor {
            crate::model::Monitor {
                alarm_arn: self.alarm_arn,
                alarm_role_arn: self.alarm_role_arn,
            }
        }
    }
}
impl Monitor {
    /// Creates a new builder-style object to manufacture [`Monitor`](crate::model::Monitor).
    pub fn builder() -> crate::model::monitor::Builder {
        crate::model::monitor::Builder::default()
    }
}

/// When writing a match expression against `EnvironmentState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let environmentstate = unimplemented!();
/// match environmentstate {
///     EnvironmentState::Deploying => { /* ... */ },
///     EnvironmentState::ReadyForDeployment => { /* ... */ },
///     EnvironmentState::RolledBack => { /* ... */ },
///     EnvironmentState::RollingBack => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `environmentstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnvironmentState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnvironmentState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnvironmentState::NewFeature` is defined.
/// Specifically, when `environmentstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnvironmentState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnvironmentState {
    #[allow(missing_docs)] // documentation missing in model
    Deploying,
    #[allow(missing_docs)] // documentation missing in model
    ReadyForDeployment,
    #[allow(missing_docs)] // documentation missing in model
    RolledBack,
    #[allow(missing_docs)] // documentation missing in model
    RollingBack,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EnvironmentState {
    fn from(s: &str) -> Self {
        match s {
            "DEPLOYING" => EnvironmentState::Deploying,
            "READY_FOR_DEPLOYMENT" => EnvironmentState::ReadyForDeployment,
            "ROLLED_BACK" => EnvironmentState::RolledBack,
            "ROLLING_BACK" => EnvironmentState::RollingBack,
            other => EnvironmentState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EnvironmentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnvironmentState::from(s))
    }
}
impl EnvironmentState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnvironmentState::Deploying => "DEPLOYING",
            EnvironmentState::ReadyForDeployment => "READY_FOR_DEPLOYMENT",
            EnvironmentState::RolledBack => "ROLLED_BACK",
            EnvironmentState::RollingBack => "ROLLING_BACK",
            EnvironmentState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEPLOYING",
            "READY_FOR_DEPLOYMENT",
            "ROLLED_BACK",
            "ROLLING_BACK",
        ]
    }
}
impl AsRef<str> for EnvironmentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReplicateTo`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicateto = unimplemented!();
/// match replicateto {
///     ReplicateTo::None => { /* ... */ },
///     ReplicateTo::SsmDocument => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicateto` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicateTo::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicateTo::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicateTo::NewFeature` is defined.
/// Specifically, when `replicateto` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicateTo::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicateTo {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    SsmDocument,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicateTo {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => ReplicateTo::None,
            "SSM_DOCUMENT" => ReplicateTo::SsmDocument,
            other => ReplicateTo::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReplicateTo {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicateTo::from(s))
    }
}
impl ReplicateTo {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicateTo::None => "NONE",
            ReplicateTo::SsmDocument => "SSM_DOCUMENT",
            ReplicateTo::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "SSM_DOCUMENT"]
    }
}
impl AsRef<str> for ReplicateTo {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GrowthType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let growthtype = unimplemented!();
/// match growthtype {
///     GrowthType::Exponential => { /* ... */ },
///     GrowthType::Linear => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `growthtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GrowthType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GrowthType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GrowthType::NewFeature` is defined.
/// Specifically, when `growthtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GrowthType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GrowthType {
    #[allow(missing_docs)] // documentation missing in model
    Exponential,
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GrowthType {
    fn from(s: &str) -> Self {
        match s {
            "EXPONENTIAL" => GrowthType::Exponential,
            "LINEAR" => GrowthType::Linear,
            other => GrowthType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GrowthType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GrowthType::from(s))
    }
}
impl GrowthType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GrowthType::Exponential => "EXPONENTIAL",
            GrowthType::Linear => "LINEAR",
            GrowthType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXPONENTIAL", "LINEAR"]
    }
}
impl AsRef<str> for GrowthType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A validator provides a syntactic or semantic check to ensure the configuration that you want to deploy functions as intended. To validate your application configuration data, you provide a schema or an Amazon Web Services Lambda function that runs against the configuration. The configuration deployment or update can only proceed when the configuration data is valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Validator {
    /// <p>AppConfig supports validators of type <code>JSON_SCHEMA</code> and <code>LAMBDA</code> </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ValidatorType>,
    /// <p>Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
}
impl Validator {
    /// <p>AppConfig supports validators of type <code>JSON_SCHEMA</code> and <code>LAMBDA</code> </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ValidatorType> {
        self.r#type.as_ref()
    }
    /// <p>Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Validator");
        formatter.field("r#type", &self.r#type);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Validator`](crate::model::Validator).
pub mod validator {

    /// A builder for [`Validator`](crate::model::Validator).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ValidatorType>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>AppConfig supports validators of type <code>JSON_SCHEMA</code> and <code>LAMBDA</code> </p>
        pub fn r#type(mut self, input: crate::model::ValidatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>AppConfig supports validators of type <code>JSON_SCHEMA</code> and <code>LAMBDA</code> </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ValidatorType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`Validator`](crate::model::Validator).
        pub fn build(self) -> crate::model::Validator {
            crate::model::Validator {
                r#type: self.r#type,
                content: self.content,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("r#type", &self.r#type);
            formatter.field("content", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Validator {
    /// Creates a new builder-style object to manufacture [`Validator`](crate::model::Validator).
    pub fn builder() -> crate::model::validator::Builder {
        crate::model::validator::Builder::default()
    }
}

/// When writing a match expression against `ValidatorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validatortype = unimplemented!();
/// match validatortype {
///     ValidatorType::JsonSchema => { /* ... */ },
///     ValidatorType::Lambda => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validatortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidatorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidatorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidatorType::NewFeature` is defined.
/// Specifically, when `validatortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidatorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidatorType {
    #[allow(missing_docs)] // documentation missing in model
    JsonSchema,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidatorType {
    fn from(s: &str) -> Self {
        match s {
            "JSON_SCHEMA" => ValidatorType::JsonSchema,
            "LAMBDA" => ValidatorType::Lambda,
            other => ValidatorType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ValidatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidatorType::from(s))
    }
}
impl ValidatorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidatorType::JsonSchema => "JSON_SCHEMA",
            ValidatorType::Lambda => "LAMBDA",
            ValidatorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["JSON_SCHEMA", "LAMBDA"]
    }
}
impl AsRef<str> for ValidatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An extension that was invoked during a deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppliedExtension {
    /// <p>The system-generated ID of the extension.</p>
    #[doc(hidden)]
    pub extension_id: std::option::Option<std::string::String>,
    /// <p>The system-generated ID for the association.</p>
    #[doc(hidden)]
    pub extension_association_id: std::option::Option<std::string::String>,
    /// <p>The extension version number.</p>
    #[doc(hidden)]
    pub version_number: i32,
    /// <p>One or more parameters for the actions called by the extension.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl AppliedExtension {
    /// <p>The system-generated ID of the extension.</p>
    pub fn extension_id(&self) -> std::option::Option<&str> {
        self.extension_id.as_deref()
    }
    /// <p>The system-generated ID for the association.</p>
    pub fn extension_association_id(&self) -> std::option::Option<&str> {
        self.extension_association_id.as_deref()
    }
    /// <p>The extension version number.</p>
    pub fn version_number(&self) -> i32 {
        self.version_number
    }
    /// <p>One or more parameters for the actions called by the extension.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`AppliedExtension`](crate::model::AppliedExtension).
pub mod applied_extension {

    /// A builder for [`AppliedExtension`](crate::model::AppliedExtension).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) extension_id: std::option::Option<std::string::String>,
        pub(crate) extension_association_id: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i32>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The system-generated ID of the extension.</p>
        pub fn extension_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.extension_id = Some(input.into());
            self
        }
        /// <p>The system-generated ID of the extension.</p>
        pub fn set_extension_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.extension_id = input;
            self
        }
        /// <p>The system-generated ID for the association.</p>
        pub fn extension_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.extension_association_id = Some(input.into());
            self
        }
        /// <p>The system-generated ID for the association.</p>
        pub fn set_extension_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extension_association_id = input;
            self
        }
        /// <p>The extension version number.</p>
        pub fn version_number(mut self, input: i32) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The extension version number.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i32>) -> Self {
            self.version_number = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>One or more parameters for the actions called by the extension.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>One or more parameters for the actions called by the extension.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`AppliedExtension`](crate::model::AppliedExtension).
        pub fn build(self) -> crate::model::AppliedExtension {
            crate::model::AppliedExtension {
                extension_id: self.extension_id,
                extension_association_id: self.extension_association_id,
                version_number: self.version_number.unwrap_or_default(),
                parameters: self.parameters,
            }
        }
    }
}
impl AppliedExtension {
    /// Creates a new builder-style object to manufacture [`AppliedExtension`](crate::model::AppliedExtension).
    pub fn builder() -> crate::model::applied_extension::Builder {
        crate::model::applied_extension::Builder::default()
    }
}

/// <p>An object that describes a deployment event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentEvent {
    /// <p>The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.</p>
    #[doc(hidden)]
    pub event_type: std::option::Option<crate::model::DeploymentEventType>,
    /// <p>The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.</p>
    #[doc(hidden)]
    pub triggered_by: std::option::Option<crate::model::TriggeredBy>,
    /// <p>A description of the deployment event. Descriptions include, but are not limited to, the user account or the Amazon CloudWatch alarm ARN that initiated a rollback, the percentage of hosts that received the deployment, or in the case of an internal error, a recommendation to attempt a new deployment.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The list of extensions that were invoked as part of the deployment.</p>
    #[doc(hidden)]
    pub action_invocations: std::option::Option<std::vec::Vec<crate::model::ActionInvocation>>,
    /// <p>The date and time the event occurred.</p>
    #[doc(hidden)]
    pub occurred_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeploymentEvent {
    /// <p>The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.</p>
    pub fn event_type(&self) -> std::option::Option<&crate::model::DeploymentEventType> {
        self.event_type.as_ref()
    }
    /// <p>The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.</p>
    pub fn triggered_by(&self) -> std::option::Option<&crate::model::TriggeredBy> {
        self.triggered_by.as_ref()
    }
    /// <p>A description of the deployment event. Descriptions include, but are not limited to, the user account or the Amazon CloudWatch alarm ARN that initiated a rollback, the percentage of hosts that received the deployment, or in the case of an internal error, a recommendation to attempt a new deployment.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The list of extensions that were invoked as part of the deployment.</p>
    pub fn action_invocations(&self) -> std::option::Option<&[crate::model::ActionInvocation]> {
        self.action_invocations.as_deref()
    }
    /// <p>The date and time the event occurred.</p>
    pub fn occurred_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.occurred_at.as_ref()
    }
}
/// See [`DeploymentEvent`](crate::model::DeploymentEvent).
pub mod deployment_event {

    /// A builder for [`DeploymentEvent`](crate::model::DeploymentEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_type: std::option::Option<crate::model::DeploymentEventType>,
        pub(crate) triggered_by: std::option::Option<crate::model::TriggeredBy>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) action_invocations:
            std::option::Option<std::vec::Vec<crate::model::ActionInvocation>>,
        pub(crate) occurred_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.</p>
        pub fn event_type(mut self, input: crate::model::DeploymentEventType) -> Self {
            self.event_type = Some(input);
            self
        }
        /// <p>The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.</p>
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::DeploymentEventType>,
        ) -> Self {
            self.event_type = input;
            self
        }
        /// <p>The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.</p>
        pub fn triggered_by(mut self, input: crate::model::TriggeredBy) -> Self {
            self.triggered_by = Some(input);
            self
        }
        /// <p>The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.</p>
        pub fn set_triggered_by(
            mut self,
            input: std::option::Option<crate::model::TriggeredBy>,
        ) -> Self {
            self.triggered_by = input;
            self
        }
        /// <p>A description of the deployment event. Descriptions include, but are not limited to, the user account or the Amazon CloudWatch alarm ARN that initiated a rollback, the percentage of hosts that received the deployment, or in the case of an internal error, a recommendation to attempt a new deployment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the deployment event. Descriptions include, but are not limited to, the user account or the Amazon CloudWatch alarm ARN that initiated a rollback, the percentage of hosts that received the deployment, or in the case of an internal error, a recommendation to attempt a new deployment.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `action_invocations`.
        ///
        /// To override the contents of this collection use [`set_action_invocations`](Self::set_action_invocations).
        ///
        /// <p>The list of extensions that were invoked as part of the deployment.</p>
        pub fn action_invocations(mut self, input: crate::model::ActionInvocation) -> Self {
            let mut v = self.action_invocations.unwrap_or_default();
            v.push(input);
            self.action_invocations = Some(v);
            self
        }
        /// <p>The list of extensions that were invoked as part of the deployment.</p>
        pub fn set_action_invocations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActionInvocation>>,
        ) -> Self {
            self.action_invocations = input;
            self
        }
        /// <p>The date and time the event occurred.</p>
        pub fn occurred_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.occurred_at = Some(input);
            self
        }
        /// <p>The date and time the event occurred.</p>
        pub fn set_occurred_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.occurred_at = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentEvent`](crate::model::DeploymentEvent).
        pub fn build(self) -> crate::model::DeploymentEvent {
            crate::model::DeploymentEvent {
                event_type: self.event_type,
                triggered_by: self.triggered_by,
                description: self.description,
                action_invocations: self.action_invocations,
                occurred_at: self.occurred_at,
            }
        }
    }
}
impl DeploymentEvent {
    /// Creates a new builder-style object to manufacture [`DeploymentEvent`](crate::model::DeploymentEvent).
    pub fn builder() -> crate::model::deployment_event::Builder {
        crate::model::deployment_event::Builder::default()
    }
}

/// <p>An extension that was invoked as part of a deployment event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActionInvocation {
    /// <p>The name, the ID, or the Amazon Resource Name (ARN) of the extension.</p>
    #[doc(hidden)]
    pub extension_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the action.</p>
    #[doc(hidden)]
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The error message when an extension invocation fails.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The error code when an extension invocation fails.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>A system-generated ID for this invocation.</p>
    #[doc(hidden)]
    pub invocation_id: std::option::Option<std::string::String>,
}
impl ActionInvocation {
    /// <p>The name, the ID, or the Amazon Resource Name (ARN) of the extension.</p>
    pub fn extension_identifier(&self) -> std::option::Option<&str> {
        self.extension_identifier.as_deref()
    }
    /// <p>The name of the action.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
    /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The error message when an extension invocation fails.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The error code when an extension invocation fails.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>A system-generated ID for this invocation.</p>
    pub fn invocation_id(&self) -> std::option::Option<&str> {
        self.invocation_id.as_deref()
    }
}
/// See [`ActionInvocation`](crate::model::ActionInvocation).
pub mod action_invocation {

    /// A builder for [`ActionInvocation`](crate::model::ActionInvocation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) extension_identifier: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) invocation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name, the ID, or the Amazon Resource Name (ARN) of the extension.</p>
        pub fn extension_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.extension_identifier = Some(input.into());
            self
        }
        /// <p>The name, the ID, or the Amazon Resource Name (ARN) of the extension.</p>
        pub fn set_extension_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extension_identifier = input;
            self
        }
        /// <p>The name of the action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The name of the action.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>An Amazon Resource Name (ARN) for an Identity and Access Management assume role.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The error message when an extension invocation fails.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message when an extension invocation fails.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The error code when an extension invocation fails.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code when an extension invocation fails.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A system-generated ID for this invocation.</p>
        pub fn invocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invocation_id = Some(input.into());
            self
        }
        /// <p>A system-generated ID for this invocation.</p>
        pub fn set_invocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invocation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionInvocation`](crate::model::ActionInvocation).
        pub fn build(self) -> crate::model::ActionInvocation {
            crate::model::ActionInvocation {
                extension_identifier: self.extension_identifier,
                action_name: self.action_name,
                uri: self.uri,
                role_arn: self.role_arn,
                error_message: self.error_message,
                error_code: self.error_code,
                invocation_id: self.invocation_id,
            }
        }
    }
}
impl ActionInvocation {
    /// Creates a new builder-style object to manufacture [`ActionInvocation`](crate::model::ActionInvocation).
    pub fn builder() -> crate::model::action_invocation::Builder {
        crate::model::action_invocation::Builder::default()
    }
}

/// When writing a match expression against `TriggeredBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let triggeredby = unimplemented!();
/// match triggeredby {
///     TriggeredBy::Appconfig => { /* ... */ },
///     TriggeredBy::CloudwatchAlarm => { /* ... */ },
///     TriggeredBy::InternalError => { /* ... */ },
///     TriggeredBy::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `triggeredby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TriggeredBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TriggeredBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TriggeredBy::NewFeature` is defined.
/// Specifically, when `triggeredby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TriggeredBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TriggeredBy {
    #[allow(missing_docs)] // documentation missing in model
    Appconfig,
    #[allow(missing_docs)] // documentation missing in model
    CloudwatchAlarm,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TriggeredBy {
    fn from(s: &str) -> Self {
        match s {
            "APPCONFIG" => TriggeredBy::Appconfig,
            "CLOUDWATCH_ALARM" => TriggeredBy::CloudwatchAlarm,
            "INTERNAL_ERROR" => TriggeredBy::InternalError,
            "USER" => TriggeredBy::User,
            other => TriggeredBy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TriggeredBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TriggeredBy::from(s))
    }
}
impl TriggeredBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TriggeredBy::Appconfig => "APPCONFIG",
            TriggeredBy::CloudwatchAlarm => "CLOUDWATCH_ALARM",
            TriggeredBy::InternalError => "INTERNAL_ERROR",
            TriggeredBy::User => "USER",
            TriggeredBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPCONFIG", "CLOUDWATCH_ALARM", "INTERNAL_ERROR", "USER"]
    }
}
impl AsRef<str> for TriggeredBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DeploymentEventType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deploymenteventtype = unimplemented!();
/// match deploymenteventtype {
///     DeploymentEventType::BakeTimeStarted => { /* ... */ },
///     DeploymentEventType::DeploymentCompleted => { /* ... */ },
///     DeploymentEventType::DeploymentStarted => { /* ... */ },
///     DeploymentEventType::PercentageUpdated => { /* ... */ },
///     DeploymentEventType::RollbackCompleted => { /* ... */ },
///     DeploymentEventType::RollbackStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deploymenteventtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeploymentEventType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeploymentEventType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeploymentEventType::NewFeature` is defined.
/// Specifically, when `deploymenteventtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeploymentEventType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentEventType {
    #[allow(missing_docs)] // documentation missing in model
    BakeTimeStarted,
    #[allow(missing_docs)] // documentation missing in model
    DeploymentCompleted,
    #[allow(missing_docs)] // documentation missing in model
    DeploymentStarted,
    #[allow(missing_docs)] // documentation missing in model
    PercentageUpdated,
    #[allow(missing_docs)] // documentation missing in model
    RollbackCompleted,
    #[allow(missing_docs)] // documentation missing in model
    RollbackStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeploymentEventType {
    fn from(s: &str) -> Self {
        match s {
            "BAKE_TIME_STARTED" => DeploymentEventType::BakeTimeStarted,
            "DEPLOYMENT_COMPLETED" => DeploymentEventType::DeploymentCompleted,
            "DEPLOYMENT_STARTED" => DeploymentEventType::DeploymentStarted,
            "PERCENTAGE_UPDATED" => DeploymentEventType::PercentageUpdated,
            "ROLLBACK_COMPLETED" => DeploymentEventType::RollbackCompleted,
            "ROLLBACK_STARTED" => DeploymentEventType::RollbackStarted,
            other => {
                DeploymentEventType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DeploymentEventType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentEventType::from(s))
    }
}
impl DeploymentEventType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentEventType::BakeTimeStarted => "BAKE_TIME_STARTED",
            DeploymentEventType::DeploymentCompleted => "DEPLOYMENT_COMPLETED",
            DeploymentEventType::DeploymentStarted => "DEPLOYMENT_STARTED",
            DeploymentEventType::PercentageUpdated => "PERCENTAGE_UPDATED",
            DeploymentEventType::RollbackCompleted => "ROLLBACK_COMPLETED",
            DeploymentEventType::RollbackStarted => "ROLLBACK_STARTED",
            DeploymentEventType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BAKE_TIME_STARTED",
            "DEPLOYMENT_COMPLETED",
            "DEPLOYMENT_STARTED",
            "PERCENTAGE_UPDATED",
            "ROLLBACK_COMPLETED",
            "ROLLBACK_STARTED",
        ]
    }
}
impl AsRef<str> for DeploymentEventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DeploymentState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deploymentstate = unimplemented!();
/// match deploymentstate {
///     DeploymentState::Baking => { /* ... */ },
///     DeploymentState::Complete => { /* ... */ },
///     DeploymentState::Deploying => { /* ... */ },
///     DeploymentState::RolledBack => { /* ... */ },
///     DeploymentState::RollingBack => { /* ... */ },
///     DeploymentState::Validating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deploymentstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeploymentState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeploymentState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeploymentState::NewFeature` is defined.
/// Specifically, when `deploymentstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeploymentState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentState {
    #[allow(missing_docs)] // documentation missing in model
    Baking,
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Deploying,
    #[allow(missing_docs)] // documentation missing in model
    RolledBack,
    #[allow(missing_docs)] // documentation missing in model
    RollingBack,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeploymentState {
    fn from(s: &str) -> Self {
        match s {
            "BAKING" => DeploymentState::Baking,
            "COMPLETE" => DeploymentState::Complete,
            "DEPLOYING" => DeploymentState::Deploying,
            "ROLLED_BACK" => DeploymentState::RolledBack,
            "ROLLING_BACK" => DeploymentState::RollingBack,
            "VALIDATING" => DeploymentState::Validating,
            other => DeploymentState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeploymentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentState::from(s))
    }
}
impl DeploymentState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentState::Baking => "BAKING",
            DeploymentState::Complete => "COMPLETE",
            DeploymentState::Deploying => "DEPLOYING",
            DeploymentState::RolledBack => "ROLLED_BACK",
            DeploymentState::RollingBack => "ROLLING_BACK",
            DeploymentState::Validating => "VALIDATING",
            DeploymentState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BAKING",
            "COMPLETE",
            "DEPLOYING",
            "ROLLED_BACK",
            "ROLLING_BACK",
            "VALIDATING",
        ]
    }
}
impl AsRef<str> for DeploymentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HostedConfigurationVersionSummary {
    /// <p>The application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The configuration profile ID.</p>
    #[doc(hidden)]
    pub configuration_profile_id: std::option::Option<std::string::String>,
    /// <p>The configuration version.</p>
    #[doc(hidden)]
    pub version_number: i32,
    /// <p>A description of the configuration.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the configuration content. For more information, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
}
impl HostedConfigurationVersionSummary {
    /// <p>The application ID.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The configuration profile ID.</p>
    pub fn configuration_profile_id(&self) -> std::option::Option<&str> {
        self.configuration_profile_id.as_deref()
    }
    /// <p>The configuration version.</p>
    pub fn version_number(&self) -> i32 {
        self.version_number
    }
    /// <p>A description of the configuration.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A standard MIME type describing the format of the configuration content. For more information, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
}
/// See [`HostedConfigurationVersionSummary`](crate::model::HostedConfigurationVersionSummary).
pub mod hosted_configuration_version_summary {

    /// A builder for [`HostedConfigurationVersionSummary`](crate::model::HostedConfigurationVersionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) configuration_profile_id: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i32>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The application ID.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The configuration profile ID.</p>
        pub fn configuration_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_profile_id = Some(input.into());
            self
        }
        /// <p>The configuration profile ID.</p>
        pub fn set_configuration_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_profile_id = input;
            self
        }
        /// <p>The configuration version.</p>
        pub fn version_number(mut self, input: i32) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The configuration version.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i32>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>A description of the configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the configuration.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A standard MIME type describing the format of the configuration content. For more information, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>A standard MIME type describing the format of the configuration content. For more information, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`HostedConfigurationVersionSummary`](crate::model::HostedConfigurationVersionSummary).
        pub fn build(self) -> crate::model::HostedConfigurationVersionSummary {
            crate::model::HostedConfigurationVersionSummary {
                application_id: self.application_id,
                configuration_profile_id: self.configuration_profile_id,
                version_number: self.version_number.unwrap_or_default(),
                description: self.description,
                content_type: self.content_type,
            }
        }
    }
}
impl HostedConfigurationVersionSummary {
    /// Creates a new builder-style object to manufacture [`HostedConfigurationVersionSummary`](crate::model::HostedConfigurationVersionSummary).
    pub fn builder() -> crate::model::hosted_configuration_version_summary::Builder {
        crate::model::hosted_configuration_version_summary::Builder::default()
    }
}

/// <p>Information about an extension. Call <code>GetExtension</code> to get more information about an extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExtensionSummary {
    /// <p>The system-generated ID of the extension.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The extension name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The extension version number.</p>
    #[doc(hidden)]
    pub version_number: i32,
    /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Information about the extension.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl ExtensionSummary {
    /// <p>The system-generated ID of the extension.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The extension name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The extension version number.</p>
    pub fn version_number(&self) -> i32 {
        self.version_number
    }
    /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Information about the extension.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`ExtensionSummary`](crate::model::ExtensionSummary).
pub mod extension_summary {

    /// A builder for [`ExtensionSummary`](crate::model::ExtensionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i32>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The system-generated ID of the extension.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated ID of the extension.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The extension name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The extension name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The extension version number.</p>
        pub fn version_number(mut self, input: i32) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The extension version number.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i32>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Information about the extension.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Information about the extension.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ExtensionSummary`](crate::model::ExtensionSummary).
        pub fn build(self) -> crate::model::ExtensionSummary {
            crate::model::ExtensionSummary {
                id: self.id,
                name: self.name,
                version_number: self.version_number.unwrap_or_default(),
                arn: self.arn,
                description: self.description,
            }
        }
    }
}
impl ExtensionSummary {
    /// Creates a new builder-style object to manufacture [`ExtensionSummary`](crate::model::ExtensionSummary).
    pub fn builder() -> crate::model::extension_summary::Builder {
        crate::model::extension_summary::Builder::default()
    }
}

/// <p>Information about an association between an extension and an AppConfig resource such as an application, environment, or configuration profile. Call <code>GetExtensionAssociation</code> to get more information about an association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExtensionAssociationSummary {
    /// <p>The extension association ID. This ID is used to call other <code>ExtensionAssociation</code> API actions such as <code>GetExtensionAssociation</code> or <code>DeleteExtensionAssociation</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
    #[doc(hidden)]
    pub extension_arn: std::option::Option<std::string::String>,
    /// <p>The ARNs of applications, configuration profiles, or environments defined in the association.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ExtensionAssociationSummary {
    /// <p>The extension association ID. This ID is used to call other <code>ExtensionAssociation</code> API actions such as <code>GetExtensionAssociation</code> or <code>DeleteExtensionAssociation</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
    pub fn extension_arn(&self) -> std::option::Option<&str> {
        self.extension_arn.as_deref()
    }
    /// <p>The ARNs of applications, configuration profiles, or environments defined in the association.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
/// See [`ExtensionAssociationSummary`](crate::model::ExtensionAssociationSummary).
pub mod extension_association_summary {

    /// A builder for [`ExtensionAssociationSummary`](crate::model::ExtensionAssociationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) extension_arn: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The extension association ID. This ID is used to call other <code>ExtensionAssociation</code> API actions such as <code>GetExtensionAssociation</code> or <code>DeleteExtensionAssociation</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The extension association ID. This ID is used to call other <code>ExtensionAssociation</code> API actions such as <code>GetExtensionAssociation</code> or <code>DeleteExtensionAssociation</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
        pub fn extension_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.extension_arn = Some(input.into());
            self
        }
        /// <p>The system-generated Amazon Resource Name (ARN) for the extension.</p>
        pub fn set_extension_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extension_arn = input;
            self
        }
        /// <p>The ARNs of applications, configuration profiles, or environments defined in the association.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARNs of applications, configuration profiles, or environments defined in the association.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ExtensionAssociationSummary`](crate::model::ExtensionAssociationSummary).
        pub fn build(self) -> crate::model::ExtensionAssociationSummary {
            crate::model::ExtensionAssociationSummary {
                id: self.id,
                extension_arn: self.extension_arn,
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl ExtensionAssociationSummary {
    /// Creates a new builder-style object to manufacture [`ExtensionAssociationSummary`](crate::model::ExtensionAssociationSummary).
    pub fn builder() -> crate::model::extension_association_summary::Builder {
        crate::model::extension_association_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Environment {
    /// <p>The application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The environment ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the environment.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the environment.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of the environment. An environment can be in one of the following states: <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or <code>ROLLED_BACK</code> </p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::EnvironmentState>,
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    #[doc(hidden)]
    pub monitors: std::option::Option<std::vec::Vec<crate::model::Monitor>>,
}
impl Environment {
    /// <p>The application ID.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The environment ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the environment.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the environment.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of the environment. An environment can be in one of the following states: <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or <code>ROLLED_BACK</code> </p>
    pub fn state(&self) -> std::option::Option<&crate::model::EnvironmentState> {
        self.state.as_ref()
    }
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    pub fn monitors(&self) -> std::option::Option<&[crate::model::Monitor]> {
        self.monitors.as_deref()
    }
}
/// See [`Environment`](crate::model::Environment).
pub mod environment {

    /// A builder for [`Environment`](crate::model::Environment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::EnvironmentState>,
        pub(crate) monitors: std::option::Option<std::vec::Vec<crate::model::Monitor>>,
    }
    impl Builder {
        /// <p>The application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The application ID.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The environment ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The environment ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the environment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the environment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the environment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the environment.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of the environment. An environment can be in one of the following states: <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or <code>ROLLED_BACK</code> </p>
        pub fn state(mut self, input: crate::model::EnvironmentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the environment. An environment can be in one of the following states: <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or <code>ROLLED_BACK</code> </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::EnvironmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Appends an item to `monitors`.
        ///
        /// To override the contents of this collection use [`set_monitors`](Self::set_monitors).
        ///
        /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
        pub fn monitors(mut self, input: crate::model::Monitor) -> Self {
            let mut v = self.monitors.unwrap_or_default();
            v.push(input);
            self.monitors = Some(v);
            self
        }
        /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
        pub fn set_monitors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Monitor>>,
        ) -> Self {
            self.monitors = input;
            self
        }
        /// Consumes the builder and constructs a [`Environment`](crate::model::Environment).
        pub fn build(self) -> crate::model::Environment {
            crate::model::Environment {
                application_id: self.application_id,
                id: self.id,
                name: self.name,
                description: self.description,
                state: self.state,
                monitors: self.monitors,
            }
        }
    }
}
impl Environment {
    /// Creates a new builder-style object to manufacture [`Environment`](crate::model::Environment).
    pub fn builder() -> crate::model::environment::Builder {
        crate::model::environment::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentStrategy {
    /// <p>The deployment strategy ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the deployment strategy.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the deployment strategy.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Total amount of time the deployment lasted.</p>
    #[doc(hidden)]
    pub deployment_duration_in_minutes: i32,
    /// <p>The algorithm used to define how percentage grew over time.</p>
    #[doc(hidden)]
    pub growth_type: std::option::Option<crate::model::GrowthType>,
    /// <p>The percentage of targets that received a deployed configuration during each interval.</p>
    #[doc(hidden)]
    pub growth_factor: f32,
    /// <p>The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
    #[doc(hidden)]
    pub final_bake_time_in_minutes: i32,
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    #[doc(hidden)]
    pub replicate_to: std::option::Option<crate::model::ReplicateTo>,
}
impl DeploymentStrategy {
    /// <p>The deployment strategy ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the deployment strategy.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the deployment strategy.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Total amount of time the deployment lasted.</p>
    pub fn deployment_duration_in_minutes(&self) -> i32 {
        self.deployment_duration_in_minutes
    }
    /// <p>The algorithm used to define how percentage grew over time.</p>
    pub fn growth_type(&self) -> std::option::Option<&crate::model::GrowthType> {
        self.growth_type.as_ref()
    }
    /// <p>The percentage of targets that received a deployed configuration during each interval.</p>
    pub fn growth_factor(&self) -> f32 {
        self.growth_factor
    }
    /// <p>The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
    pub fn final_bake_time_in_minutes(&self) -> i32 {
        self.final_bake_time_in_minutes
    }
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    pub fn replicate_to(&self) -> std::option::Option<&crate::model::ReplicateTo> {
        self.replicate_to.as_ref()
    }
}
/// See [`DeploymentStrategy`](crate::model::DeploymentStrategy).
pub mod deployment_strategy {

    /// A builder for [`DeploymentStrategy`](crate::model::DeploymentStrategy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) deployment_duration_in_minutes: std::option::Option<i32>,
        pub(crate) growth_type: std::option::Option<crate::model::GrowthType>,
        pub(crate) growth_factor: std::option::Option<f32>,
        pub(crate) final_bake_time_in_minutes: std::option::Option<i32>,
        pub(crate) replicate_to: std::option::Option<crate::model::ReplicateTo>,
    }
    impl Builder {
        /// <p>The deployment strategy ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The deployment strategy ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the deployment strategy.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the deployment strategy.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the deployment strategy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the deployment strategy.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Total amount of time the deployment lasted.</p>
        pub fn deployment_duration_in_minutes(mut self, input: i32) -> Self {
            self.deployment_duration_in_minutes = Some(input);
            self
        }
        /// <p>Total amount of time the deployment lasted.</p>
        pub fn set_deployment_duration_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.deployment_duration_in_minutes = input;
            self
        }
        /// <p>The algorithm used to define how percentage grew over time.</p>
        pub fn growth_type(mut self, input: crate::model::GrowthType) -> Self {
            self.growth_type = Some(input);
            self
        }
        /// <p>The algorithm used to define how percentage grew over time.</p>
        pub fn set_growth_type(
            mut self,
            input: std::option::Option<crate::model::GrowthType>,
        ) -> Self {
            self.growth_type = input;
            self
        }
        /// <p>The percentage of targets that received a deployed configuration during each interval.</p>
        pub fn growth_factor(mut self, input: f32) -> Self {
            self.growth_factor = Some(input);
            self
        }
        /// <p>The percentage of targets that received a deployed configuration during each interval.</p>
        pub fn set_growth_factor(mut self, input: std::option::Option<f32>) -> Self {
            self.growth_factor = input;
            self
        }
        /// <p>The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
        pub fn final_bake_time_in_minutes(mut self, input: i32) -> Self {
            self.final_bake_time_in_minutes = Some(input);
            self
        }
        /// <p>The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
        pub fn set_final_bake_time_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.final_bake_time_in_minutes = input;
            self
        }
        /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
        pub fn replicate_to(mut self, input: crate::model::ReplicateTo) -> Self {
            self.replicate_to = Some(input);
            self
        }
        /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
        pub fn set_replicate_to(
            mut self,
            input: std::option::Option<crate::model::ReplicateTo>,
        ) -> Self {
            self.replicate_to = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentStrategy`](crate::model::DeploymentStrategy).
        pub fn build(self) -> crate::model::DeploymentStrategy {
            crate::model::DeploymentStrategy {
                id: self.id,
                name: self.name,
                description: self.description,
                deployment_duration_in_minutes: self
                    .deployment_duration_in_minutes
                    .unwrap_or_default(),
                growth_type: self.growth_type,
                growth_factor: self.growth_factor.unwrap_or_default(),
                final_bake_time_in_minutes: self.final_bake_time_in_minutes.unwrap_or_default(),
                replicate_to: self.replicate_to,
            }
        }
    }
}
impl DeploymentStrategy {
    /// Creates a new builder-style object to manufacture [`DeploymentStrategy`](crate::model::DeploymentStrategy).
    pub fn builder() -> crate::model::deployment_strategy::Builder {
        crate::model::deployment_strategy::Builder::default()
    }
}

/// <p>Information about the deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentSummary {
    /// <p>The sequence number of the deployment.</p>
    #[doc(hidden)]
    pub deployment_number: i32,
    /// <p>The name of the configuration.</p>
    #[doc(hidden)]
    pub configuration_name: std::option::Option<std::string::String>,
    /// <p>The version of the configuration.</p>
    #[doc(hidden)]
    pub configuration_version: std::option::Option<std::string::String>,
    /// <p>Total amount of time the deployment lasted.</p>
    #[doc(hidden)]
    pub deployment_duration_in_minutes: i32,
    /// <p>The algorithm used to define how percentage grows over time.</p>
    #[doc(hidden)]
    pub growth_type: std::option::Option<crate::model::GrowthType>,
    /// <p>The percentage of targets to receive a deployed configuration during each interval.</p>
    #[doc(hidden)]
    pub growth_factor: f32,
    /// <p>The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
    #[doc(hidden)]
    pub final_bake_time_in_minutes: i32,
    /// <p>The state of the deployment.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::DeploymentState>,
    /// <p>The percentage of targets for which the deployment is available.</p>
    #[doc(hidden)]
    pub percentage_complete: f32,
    /// <p>Time the deployment started.</p>
    #[doc(hidden)]
    pub started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Time the deployment completed.</p>
    #[doc(hidden)]
    pub completed_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeploymentSummary {
    /// <p>The sequence number of the deployment.</p>
    pub fn deployment_number(&self) -> i32 {
        self.deployment_number
    }
    /// <p>The name of the configuration.</p>
    pub fn configuration_name(&self) -> std::option::Option<&str> {
        self.configuration_name.as_deref()
    }
    /// <p>The version of the configuration.</p>
    pub fn configuration_version(&self) -> std::option::Option<&str> {
        self.configuration_version.as_deref()
    }
    /// <p>Total amount of time the deployment lasted.</p>
    pub fn deployment_duration_in_minutes(&self) -> i32 {
        self.deployment_duration_in_minutes
    }
    /// <p>The algorithm used to define how percentage grows over time.</p>
    pub fn growth_type(&self) -> std::option::Option<&crate::model::GrowthType> {
        self.growth_type.as_ref()
    }
    /// <p>The percentage of targets to receive a deployed configuration during each interval.</p>
    pub fn growth_factor(&self) -> f32 {
        self.growth_factor
    }
    /// <p>The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
    pub fn final_bake_time_in_minutes(&self) -> i32 {
        self.final_bake_time_in_minutes
    }
    /// <p>The state of the deployment.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::DeploymentState> {
        self.state.as_ref()
    }
    /// <p>The percentage of targets for which the deployment is available.</p>
    pub fn percentage_complete(&self) -> f32 {
        self.percentage_complete
    }
    /// <p>Time the deployment started.</p>
    pub fn started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_at.as_ref()
    }
    /// <p>Time the deployment completed.</p>
    pub fn completed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_at.as_ref()
    }
}
/// See [`DeploymentSummary`](crate::model::DeploymentSummary).
pub mod deployment_summary {

    /// A builder for [`DeploymentSummary`](crate::model::DeploymentSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_number: std::option::Option<i32>,
        pub(crate) configuration_name: std::option::Option<std::string::String>,
        pub(crate) configuration_version: std::option::Option<std::string::String>,
        pub(crate) deployment_duration_in_minutes: std::option::Option<i32>,
        pub(crate) growth_type: std::option::Option<crate::model::GrowthType>,
        pub(crate) growth_factor: std::option::Option<f32>,
        pub(crate) final_bake_time_in_minutes: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::DeploymentState>,
        pub(crate) percentage_complete: std::option::Option<f32>,
        pub(crate) started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The sequence number of the deployment.</p>
        pub fn deployment_number(mut self, input: i32) -> Self {
            self.deployment_number = Some(input);
            self
        }
        /// <p>The sequence number of the deployment.</p>
        pub fn set_deployment_number(mut self, input: std::option::Option<i32>) -> Self {
            self.deployment_number = input;
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn set_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_name = input;
            self
        }
        /// <p>The version of the configuration.</p>
        pub fn configuration_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_version = Some(input.into());
            self
        }
        /// <p>The version of the configuration.</p>
        pub fn set_configuration_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_version = input;
            self
        }
        /// <p>Total amount of time the deployment lasted.</p>
        pub fn deployment_duration_in_minutes(mut self, input: i32) -> Self {
            self.deployment_duration_in_minutes = Some(input);
            self
        }
        /// <p>Total amount of time the deployment lasted.</p>
        pub fn set_deployment_duration_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.deployment_duration_in_minutes = input;
            self
        }
        /// <p>The algorithm used to define how percentage grows over time.</p>
        pub fn growth_type(mut self, input: crate::model::GrowthType) -> Self {
            self.growth_type = Some(input);
            self
        }
        /// <p>The algorithm used to define how percentage grows over time.</p>
        pub fn set_growth_type(
            mut self,
            input: std::option::Option<crate::model::GrowthType>,
        ) -> Self {
            self.growth_type = input;
            self
        }
        /// <p>The percentage of targets to receive a deployed configuration during each interval.</p>
        pub fn growth_factor(mut self, input: f32) -> Self {
            self.growth_factor = Some(input);
            self
        }
        /// <p>The percentage of targets to receive a deployed configuration during each interval.</p>
        pub fn set_growth_factor(mut self, input: std::option::Option<f32>) -> Self {
            self.growth_factor = input;
            self
        }
        /// <p>The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
        pub fn final_bake_time_in_minutes(mut self, input: i32) -> Self {
            self.final_bake_time_in_minutes = Some(input);
            self
        }
        /// <p>The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.</p>
        pub fn set_final_bake_time_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.final_bake_time_in_minutes = input;
            self
        }
        /// <p>The state of the deployment.</p>
        pub fn state(mut self, input: crate::model::DeploymentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the deployment.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::DeploymentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The percentage of targets for which the deployment is available.</p>
        pub fn percentage_complete(mut self, input: f32) -> Self {
            self.percentage_complete = Some(input);
            self
        }
        /// <p>The percentage of targets for which the deployment is available.</p>
        pub fn set_percentage_complete(mut self, input: std::option::Option<f32>) -> Self {
            self.percentage_complete = input;
            self
        }
        /// <p>Time the deployment started.</p>
        pub fn started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_at = Some(input);
            self
        }
        /// <p>Time the deployment started.</p>
        pub fn set_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_at = input;
            self
        }
        /// <p>Time the deployment completed.</p>
        pub fn completed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_at = Some(input);
            self
        }
        /// <p>Time the deployment completed.</p>
        pub fn set_completed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_at = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentSummary`](crate::model::DeploymentSummary).
        pub fn build(self) -> crate::model::DeploymentSummary {
            crate::model::DeploymentSummary {
                deployment_number: self.deployment_number.unwrap_or_default(),
                configuration_name: self.configuration_name,
                configuration_version: self.configuration_version,
                deployment_duration_in_minutes: self
                    .deployment_duration_in_minutes
                    .unwrap_or_default(),
                growth_type: self.growth_type,
                growth_factor: self.growth_factor.unwrap_or_default(),
                final_bake_time_in_minutes: self.final_bake_time_in_minutes.unwrap_or_default(),
                state: self.state,
                percentage_complete: self.percentage_complete.unwrap_or_default(),
                started_at: self.started_at,
                completed_at: self.completed_at,
            }
        }
    }
}
impl DeploymentSummary {
    /// Creates a new builder-style object to manufacture [`DeploymentSummary`](crate::model::DeploymentSummary).
    pub fn builder() -> crate::model::deployment_summary::Builder {
        crate::model::deployment_summary::Builder::default()
    }
}

/// <p>A summary of a configuration profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationProfileSummary {
    /// <p>The application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the configuration profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the configuration profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The URI location of the configuration.</p>
    #[doc(hidden)]
    pub location_uri: std::option::Option<std::string::String>,
    /// <p>The types of validators in the configuration profile.</p>
    #[doc(hidden)]
    pub validator_types: std::option::Option<std::vec::Vec<crate::model::ValidatorType>>,
    /// <p>The type of configurations contained in the profile. AppConfig supports <code>feature flags</code> and <code>freeform</code> configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for <code>Type</code>:</p>
    /// <p> <code>AWS.AppConfig.FeatureFlags</code> </p>
    /// <p> <code>AWS.Freeform</code> </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl ConfigurationProfileSummary {
    /// <p>The application ID.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The ID of the configuration profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the configuration profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The URI location of the configuration.</p>
    pub fn location_uri(&self) -> std::option::Option<&str> {
        self.location_uri.as_deref()
    }
    /// <p>The types of validators in the configuration profile.</p>
    pub fn validator_types(&self) -> std::option::Option<&[crate::model::ValidatorType]> {
        self.validator_types.as_deref()
    }
    /// <p>The type of configurations contained in the profile. AppConfig supports <code>feature flags</code> and <code>freeform</code> configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for <code>Type</code>:</p>
    /// <p> <code>AWS.AppConfig.FeatureFlags</code> </p>
    /// <p> <code>AWS.Freeform</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`ConfigurationProfileSummary`](crate::model::ConfigurationProfileSummary).
pub mod configuration_profile_summary {

    /// A builder for [`ConfigurationProfileSummary`](crate::model::ConfigurationProfileSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) location_uri: std::option::Option<std::string::String>,
        pub(crate) validator_types: std::option::Option<std::vec::Vec<crate::model::ValidatorType>>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The application ID.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The ID of the configuration profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the configuration profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the configuration profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configuration profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The URI location of the configuration.</p>
        pub fn location_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.location_uri = Some(input.into());
            self
        }
        /// <p>The URI location of the configuration.</p>
        pub fn set_location_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location_uri = input;
            self
        }
        /// Appends an item to `validator_types`.
        ///
        /// To override the contents of this collection use [`set_validator_types`](Self::set_validator_types).
        ///
        /// <p>The types of validators in the configuration profile.</p>
        pub fn validator_types(mut self, input: crate::model::ValidatorType) -> Self {
            let mut v = self.validator_types.unwrap_or_default();
            v.push(input);
            self.validator_types = Some(v);
            self
        }
        /// <p>The types of validators in the configuration profile.</p>
        pub fn set_validator_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidatorType>>,
        ) -> Self {
            self.validator_types = input;
            self
        }
        /// <p>The type of configurations contained in the profile. AppConfig supports <code>feature flags</code> and <code>freeform</code> configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for <code>Type</code>:</p>
        /// <p> <code>AWS.AppConfig.FeatureFlags</code> </p>
        /// <p> <code>AWS.Freeform</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of configurations contained in the profile. AppConfig supports <code>feature flags</code> and <code>freeform</code> configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for <code>Type</code>:</p>
        /// <p> <code>AWS.AppConfig.FeatureFlags</code> </p>
        /// <p> <code>AWS.Freeform</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationProfileSummary`](crate::model::ConfigurationProfileSummary).
        pub fn build(self) -> crate::model::ConfigurationProfileSummary {
            crate::model::ConfigurationProfileSummary {
                application_id: self.application_id,
                id: self.id,
                name: self.name,
                location_uri: self.location_uri,
                validator_types: self.validator_types,
                r#type: self.r#type,
            }
        }
    }
}
impl ConfigurationProfileSummary {
    /// Creates a new builder-style object to manufacture [`ConfigurationProfileSummary`](crate::model::ConfigurationProfileSummary).
    pub fn builder() -> crate::model::configuration_profile_summary::Builder {
        crate::model::configuration_profile_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Application {
    /// <p>The application ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The application name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the application.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl Application {
    /// <p>The application ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The application name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the application.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`Application`](crate::model::Application).
pub mod application {

    /// A builder for [`Application`](crate::model::Application).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The application ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The application ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the application.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the application.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`Application`](crate::model::Application).
        pub fn build(self) -> crate::model::Application {
            crate::model::Application {
                id: self.id,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl Application {
    /// Creates a new builder-style object to manufacture [`Application`](crate::model::Application).
    pub fn builder() -> crate::model::application::Builder {
        crate::model::application::Builder::default()
    }
}

/// When writing a match expression against `BytesMeasure`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let bytesmeasure = unimplemented!();
/// match bytesmeasure {
///     BytesMeasure::Kilobytes => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `bytesmeasure` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BytesMeasure::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BytesMeasure::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BytesMeasure::NewFeature` is defined.
/// Specifically, when `bytesmeasure` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BytesMeasure::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BytesMeasure {
    #[allow(missing_docs)] // documentation missing in model
    Kilobytes,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BytesMeasure {
    fn from(s: &str) -> Self {
        match s {
            "KILOBYTES" => BytesMeasure::Kilobytes,
            other => BytesMeasure::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BytesMeasure {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BytesMeasure::from(s))
    }
}
impl BytesMeasure {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BytesMeasure::Kilobytes => "KILOBYTES",
            BytesMeasure::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KILOBYTES"]
    }
}
impl AsRef<str> for BytesMeasure {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
