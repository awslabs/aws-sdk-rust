// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object representing an Amazon EKS managed node group.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Nodegroup {
    /// <p>The name associated with an Amazon EKS managed node group.</p>
    pub nodegroup_name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
    pub nodegroup_arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of your cluster.</p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The Kubernetes version of the managed node group.</p>
    pub version: ::std::option::Option<::std::string::String>,
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.</p>
    pub release_version: ::std::option::Option<::std::string::String>,
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The current status of the managed node group.</p>
    pub status: ::std::option::Option<crate::types::NodegroupStatus>,
    /// <p>The capacity type of your managed node group.</p>
    pub capacity_type: ::std::option::Option<crate::types::CapacityTypes>,
    /// <p>The scaling configuration details for the Auto Scaling group that is associated with your node group.</p>
    pub scaling_config: ::std::option::Option<crate::types::NodegroupScalingConfig>,
    /// <p>If the node group wasn't deployed with a launch template, then this is the instance type that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The subnets that were specified for the Auto Scaling group that is associated with your node group.</p>
    pub subnets: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>If the node group wasn't deployed with a launch template, then this is the remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub remote_access: ::std::option::Option<crate::types::RemoteAccessConfig>,
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is <code>CUSTOM</code>. For node groups that weren't deployed using a launch template, this is the AMI type that was specified in the node group configuration.</p>
    pub ami_type: ::std::option::Option<crate::types::AmiTypes>,
    /// <p>The IAM role associated with your node group. The Amazon EKS node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies.</p>
    pub node_role: ::std::option::Option<::std::string::String>,
    /// <p>The Kubernetes <code>labels</code> applied to the nodes in the node group.</p><note>
    /// <p>Only <code>labels</code> that are applied with the Amazon EKS API are shown here. There may be other Kubernetes <code>labels</code> applied to the nodes in this group.</p>
    /// </note>
    pub labels: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub taints: ::std::option::Option<::std::vec::Vec<crate::types::Taint>>,
    /// <p>The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.</p>
    pub resources: ::std::option::Option<crate::types::NodegroupResources>,
    /// <p>If the node group wasn't deployed with a launch template, then this is the disk size in the node group configuration. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub disk_size: ::std::option::Option<i32>,
    /// <p>The health status of the node group. If there are issues with your node group's health, they are listed here.</p>
    pub health: ::std::option::Option<crate::types::NodegroupHealth>,
    /// <p>The node group update configuration.</p>
    pub update_config: ::std::option::Option<crate::types::NodegroupUpdateConfig>,
    /// <p>If a launch template was used to create the node group, then this is the launch template that was used.</p>
    pub launch_template: ::std::option::Option<crate::types::LaunchTemplateSpecification>,
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl Nodegroup {
    /// <p>The name associated with an Amazon EKS managed node group.</p>
    pub fn nodegroup_name(&self) -> ::std::option::Option<&str> {
        self.nodegroup_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
    pub fn nodegroup_arn(&self) -> ::std::option::Option<&str> {
        self.nodegroup_arn.as_deref()
    }
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The Kubernetes version of the managed node group.</p>
    pub fn version(&self) -> ::std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.</p>
    pub fn release_version(&self) -> ::std::option::Option<&str> {
        self.release_version.as_deref()
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn modified_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>The current status of the managed node group.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::NodegroupStatus> {
        self.status.as_ref()
    }
    /// <p>The capacity type of your managed node group.</p>
    pub fn capacity_type(&self) -> ::std::option::Option<&crate::types::CapacityTypes> {
        self.capacity_type.as_ref()
    }
    /// <p>The scaling configuration details for the Auto Scaling group that is associated with your node group.</p>
    pub fn scaling_config(&self) -> ::std::option::Option<&crate::types::NodegroupScalingConfig> {
        self.scaling_config.as_ref()
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the instance type that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.instance_types.is_none()`.
    pub fn instance_types(&self) -> &[::std::string::String] {
        self.instance_types.as_deref().unwrap_or_default()
    }
    /// <p>The subnets that were specified for the Auto Scaling group that is associated with your node group.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.subnets.is_none()`.
    pub fn subnets(&self) -> &[::std::string::String] {
        self.subnets.as_deref().unwrap_or_default()
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn remote_access(&self) -> ::std::option::Option<&crate::types::RemoteAccessConfig> {
        self.remote_access.as_ref()
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is <code>CUSTOM</code>. For node groups that weren't deployed using a launch template, this is the AMI type that was specified in the node group configuration.</p>
    pub fn ami_type(&self) -> ::std::option::Option<&crate::types::AmiTypes> {
        self.ami_type.as_ref()
    }
    /// <p>The IAM role associated with your node group. The Amazon EKS node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies.</p>
    pub fn node_role(&self) -> ::std::option::Option<&str> {
        self.node_role.as_deref()
    }
    /// <p>The Kubernetes <code>labels</code> applied to the nodes in the node group.</p><note>
    /// <p>Only <code>labels</code> that are applied with the Amazon EKS API are shown here. There may be other Kubernetes <code>labels</code> applied to the nodes in this group.</p>
    /// </note>
    pub fn labels(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.labels.as_ref()
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.taints.is_none()`.
    pub fn taints(&self) -> &[crate::types::Taint] {
        self.taints.as_deref().unwrap_or_default()
    }
    /// <p>The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.</p>
    pub fn resources(&self) -> ::std::option::Option<&crate::types::NodegroupResources> {
        self.resources.as_ref()
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the disk size in the node group configuration. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn disk_size(&self) -> ::std::option::Option<i32> {
        self.disk_size
    }
    /// <p>The health status of the node group. If there are issues with your node group's health, they are listed here.</p>
    pub fn health(&self) -> ::std::option::Option<&crate::types::NodegroupHealth> {
        self.health.as_ref()
    }
    /// <p>The node group update configuration.</p>
    pub fn update_config(&self) -> ::std::option::Option<&crate::types::NodegroupUpdateConfig> {
        self.update_config.as_ref()
    }
    /// <p>If a launch template was used to create the node group, then this is the launch template that was used.</p>
    pub fn launch_template(&self) -> ::std::option::Option<&crate::types::LaunchTemplateSpecification> {
        self.launch_template.as_ref()
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl Nodegroup {
    /// Creates a new builder-style object to manufacture [`Nodegroup`](crate::types::Nodegroup).
    pub fn builder() -> crate::types::builders::NodegroupBuilder {
        crate::types::builders::NodegroupBuilder::default()
    }
}

/// A builder for [`Nodegroup`](crate::types::Nodegroup).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct NodegroupBuilder {
    pub(crate) nodegroup_name: ::std::option::Option<::std::string::String>,
    pub(crate) nodegroup_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) version: ::std::option::Option<::std::string::String>,
    pub(crate) release_version: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) status: ::std::option::Option<crate::types::NodegroupStatus>,
    pub(crate) capacity_type: ::std::option::Option<crate::types::CapacityTypes>,
    pub(crate) scaling_config: ::std::option::Option<crate::types::NodegroupScalingConfig>,
    pub(crate) instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) subnets: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) remote_access: ::std::option::Option<crate::types::RemoteAccessConfig>,
    pub(crate) ami_type: ::std::option::Option<crate::types::AmiTypes>,
    pub(crate) node_role: ::std::option::Option<::std::string::String>,
    pub(crate) labels: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) taints: ::std::option::Option<::std::vec::Vec<crate::types::Taint>>,
    pub(crate) resources: ::std::option::Option<crate::types::NodegroupResources>,
    pub(crate) disk_size: ::std::option::Option<i32>,
    pub(crate) health: ::std::option::Option<crate::types::NodegroupHealth>,
    pub(crate) update_config: ::std::option::Option<crate::types::NodegroupUpdateConfig>,
    pub(crate) launch_template: ::std::option::Option<crate::types::LaunchTemplateSpecification>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl NodegroupBuilder {
    /// <p>The name associated with an Amazon EKS managed node group.</p>
    pub fn nodegroup_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.nodegroup_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name associated with an Amazon EKS managed node group.</p>
    pub fn set_nodegroup_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.nodegroup_name = input;
        self
    }
    /// <p>The name associated with an Amazon EKS managed node group.</p>
    pub fn get_nodegroup_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.nodegroup_name
    }
    /// <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
    pub fn nodegroup_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.nodegroup_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
    pub fn set_nodegroup_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.nodegroup_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
    pub fn get_nodegroup_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.nodegroup_arn
    }
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The Kubernetes version of the managed node group.</p>
    pub fn version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Kubernetes version of the managed node group.</p>
    pub fn set_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// <p>The Kubernetes version of the managed node group.</p>
    pub fn get_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.version
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.</p>
    pub fn release_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.release_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.</p>
    pub fn set_release_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.release_version = input;
        self
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.</p>
    pub fn get_release_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.release_version
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// <p>The current status of the managed node group.</p>
    pub fn status(mut self, input: crate::types::NodegroupStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the managed node group.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::NodegroupStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the managed node group.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::NodegroupStatus> {
        &self.status
    }
    /// <p>The capacity type of your managed node group.</p>
    pub fn capacity_type(mut self, input: crate::types::CapacityTypes) -> Self {
        self.capacity_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The capacity type of your managed node group.</p>
    pub fn set_capacity_type(mut self, input: ::std::option::Option<crate::types::CapacityTypes>) -> Self {
        self.capacity_type = input;
        self
    }
    /// <p>The capacity type of your managed node group.</p>
    pub fn get_capacity_type(&self) -> &::std::option::Option<crate::types::CapacityTypes> {
        &self.capacity_type
    }
    /// <p>The scaling configuration details for the Auto Scaling group that is associated with your node group.</p>
    pub fn scaling_config(mut self, input: crate::types::NodegroupScalingConfig) -> Self {
        self.scaling_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The scaling configuration details for the Auto Scaling group that is associated with your node group.</p>
    pub fn set_scaling_config(mut self, input: ::std::option::Option<crate::types::NodegroupScalingConfig>) -> Self {
        self.scaling_config = input;
        self
    }
    /// <p>The scaling configuration details for the Auto Scaling group that is associated with your node group.</p>
    pub fn get_scaling_config(&self) -> &::std::option::Option<crate::types::NodegroupScalingConfig> {
        &self.scaling_config
    }
    /// Appends an item to `instance_types`.
    ///
    /// To override the contents of this collection use [`set_instance_types`](Self::set_instance_types).
    ///
    /// <p>If the node group wasn't deployed with a launch template, then this is the instance type that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn instance_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.instance_types.unwrap_or_default();
        v.push(input.into());
        self.instance_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the instance type that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn set_instance_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.instance_types = input;
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the instance type that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn get_instance_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.instance_types
    }
    /// Appends an item to `subnets`.
    ///
    /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
    ///
    /// <p>The subnets that were specified for the Auto Scaling group that is associated with your node group.</p>
    pub fn subnets(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.subnets.unwrap_or_default();
        v.push(input.into());
        self.subnets = ::std::option::Option::Some(v);
        self
    }
    /// <p>The subnets that were specified for the Auto Scaling group that is associated with your node group.</p>
    pub fn set_subnets(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.subnets = input;
        self
    }
    /// <p>The subnets that were specified for the Auto Scaling group that is associated with your node group.</p>
    pub fn get_subnets(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.subnets
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn remote_access(mut self, input: crate::types::RemoteAccessConfig) -> Self {
        self.remote_access = ::std::option::Option::Some(input);
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn set_remote_access(mut self, input: ::std::option::Option<crate::types::RemoteAccessConfig>) -> Self {
        self.remote_access = input;
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn get_remote_access(&self) -> &::std::option::Option<crate::types::RemoteAccessConfig> {
        &self.remote_access
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is <code>CUSTOM</code>. For node groups that weren't deployed using a launch template, this is the AMI type that was specified in the node group configuration.</p>
    pub fn ami_type(mut self, input: crate::types::AmiTypes) -> Self {
        self.ami_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is <code>CUSTOM</code>. For node groups that weren't deployed using a launch template, this is the AMI type that was specified in the node group configuration.</p>
    pub fn set_ami_type(mut self, input: ::std::option::Option<crate::types::AmiTypes>) -> Self {
        self.ami_type = input;
        self
    }
    /// <p>If the node group was deployed using a launch template with a custom AMI, then this is <code>CUSTOM</code>. For node groups that weren't deployed using a launch template, this is the AMI type that was specified in the node group configuration.</p>
    pub fn get_ami_type(&self) -> &::std::option::Option<crate::types::AmiTypes> {
        &self.ami_type
    }
    /// <p>The IAM role associated with your node group. The Amazon EKS node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies.</p>
    pub fn node_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.node_role = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IAM role associated with your node group. The Amazon EKS node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies.</p>
    pub fn set_node_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.node_role = input;
        self
    }
    /// <p>The IAM role associated with your node group. The Amazon EKS node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies.</p>
    pub fn get_node_role(&self) -> &::std::option::Option<::std::string::String> {
        &self.node_role
    }
    /// Adds a key-value pair to `labels`.
    ///
    /// To override the contents of this collection use [`set_labels`](Self::set_labels).
    ///
    /// <p>The Kubernetes <code>labels</code> applied to the nodes in the node group.</p><note>
    /// <p>Only <code>labels</code> that are applied with the Amazon EKS API are shown here. There may be other Kubernetes <code>labels</code> applied to the nodes in this group.</p>
    /// </note>
    pub fn labels(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.labels.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.labels = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The Kubernetes <code>labels</code> applied to the nodes in the node group.</p><note>
    /// <p>Only <code>labels</code> that are applied with the Amazon EKS API are shown here. There may be other Kubernetes <code>labels</code> applied to the nodes in this group.</p>
    /// </note>
    pub fn set_labels(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.labels = input;
        self
    }
    /// <p>The Kubernetes <code>labels</code> applied to the nodes in the node group.</p><note>
    /// <p>Only <code>labels</code> that are applied with the Amazon EKS API are shown here. There may be other Kubernetes <code>labels</code> applied to the nodes in this group.</p>
    /// </note>
    pub fn get_labels(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.labels
    }
    /// Appends an item to `taints`.
    ///
    /// To override the contents of this collection use [`set_taints`](Self::set_taints).
    ///
    /// <p>The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn taints(mut self, input: crate::types::Taint) -> Self {
        let mut v = self.taints.unwrap_or_default();
        v.push(input);
        self.taints = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn set_taints(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Taint>>) -> Self {
        self.taints = input;
        self
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn get_taints(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Taint>> {
        &self.taints
    }
    /// <p>The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.</p>
    pub fn resources(mut self, input: crate::types::NodegroupResources) -> Self {
        self.resources = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.</p>
    pub fn set_resources(mut self, input: ::std::option::Option<crate::types::NodegroupResources>) -> Self {
        self.resources = input;
        self
    }
    /// <p>The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.</p>
    pub fn get_resources(&self) -> &::std::option::Option<crate::types::NodegroupResources> {
        &self.resources
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the disk size in the node group configuration. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn disk_size(mut self, input: i32) -> Self {
        self.disk_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the disk size in the node group configuration. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn set_disk_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.disk_size = input;
        self
    }
    /// <p>If the node group wasn't deployed with a launch template, then this is the disk size in the node group configuration. If the node group was deployed with a launch template, then this is <code>null</code>.</p>
    pub fn get_disk_size(&self) -> &::std::option::Option<i32> {
        &self.disk_size
    }
    /// <p>The health status of the node group. If there are issues with your node group's health, they are listed here.</p>
    pub fn health(mut self, input: crate::types::NodegroupHealth) -> Self {
        self.health = ::std::option::Option::Some(input);
        self
    }
    /// <p>The health status of the node group. If there are issues with your node group's health, they are listed here.</p>
    pub fn set_health(mut self, input: ::std::option::Option<crate::types::NodegroupHealth>) -> Self {
        self.health = input;
        self
    }
    /// <p>The health status of the node group. If there are issues with your node group's health, they are listed here.</p>
    pub fn get_health(&self) -> &::std::option::Option<crate::types::NodegroupHealth> {
        &self.health
    }
    /// <p>The node group update configuration.</p>
    pub fn update_config(mut self, input: crate::types::NodegroupUpdateConfig) -> Self {
        self.update_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The node group update configuration.</p>
    pub fn set_update_config(mut self, input: ::std::option::Option<crate::types::NodegroupUpdateConfig>) -> Self {
        self.update_config = input;
        self
    }
    /// <p>The node group update configuration.</p>
    pub fn get_update_config(&self) -> &::std::option::Option<crate::types::NodegroupUpdateConfig> {
        &self.update_config
    }
    /// <p>If a launch template was used to create the node group, then this is the launch template that was used.</p>
    pub fn launch_template(mut self, input: crate::types::LaunchTemplateSpecification) -> Self {
        self.launch_template = ::std::option::Option::Some(input);
        self
    }
    /// <p>If a launch template was used to create the node group, then this is the launch template that was used.</p>
    pub fn set_launch_template(mut self, input: ::std::option::Option<crate::types::LaunchTemplateSpecification>) -> Self {
        self.launch_template = input;
        self
    }
    /// <p>If a launch template was used to create the node group, then this is the launch template that was used.</p>
    pub fn get_launch_template(&self) -> &::std::option::Option<crate::types::LaunchTemplateSpecification> {
        &self.launch_template
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`Nodegroup`](crate::types::Nodegroup).
    pub fn build(self) -> crate::types::Nodegroup {
        crate::types::Nodegroup {
            nodegroup_name: self.nodegroup_name,
            nodegroup_arn: self.nodegroup_arn,
            cluster_name: self.cluster_name,
            version: self.version,
            release_version: self.release_version,
            created_at: self.created_at,
            modified_at: self.modified_at,
            status: self.status,
            capacity_type: self.capacity_type,
            scaling_config: self.scaling_config,
            instance_types: self.instance_types,
            subnets: self.subnets,
            remote_access: self.remote_access,
            ami_type: self.ami_type,
            node_role: self.node_role,
            labels: self.labels,
            taints: self.taints,
            resources: self.resources,
            disk_size: self.disk_size,
            health: self.health,
            update_config: self.update_config,
            launch_template: self.launch_template,
            tags: self.tags,
        }
    }
}
