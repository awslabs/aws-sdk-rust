// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object representing the configuration for an OpenID Connect (OIDC) identity provider. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OidcIdentityProviderConfig {
    /// <p>The name of the configuration.</p>
    #[doc(hidden)]
    pub identity_provider_config_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the configuration.</p>
    #[doc(hidden)]
    pub identity_provider_config_arn: std::option::Option<std::string::String>,
    /// <p>The cluster that the configuration is associated to.</p>
    #[doc(hidden)]
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    #[doc(hidden)]
    pub issuer_url: std::option::Option<std::string::String>,
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    #[doc(hidden)]
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    #[doc(hidden)]
    pub username_claim: std::option::Option<std::string::String>,
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code> </p>
    #[doc(hidden)]
    pub username_prefix: std::option::Option<std::string::String>,
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    #[doc(hidden)]
    pub groups_claim: std::option::Option<std::string::String>,
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code> </p>
    #[doc(hidden)]
    pub groups_prefix: std::option::Option<std::string::String>,
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    #[doc(hidden)]
    pub required_claims:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The metadata to apply to the provider configuration to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the OIDC identity provider.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::ConfigStatus>,
}
impl OidcIdentityProviderConfig {
    /// <p>The name of the configuration.</p>
    pub fn identity_provider_config_name(&self) -> std::option::Option<&str> {
        self.identity_provider_config_name.as_deref()
    }
    /// <p>The ARN of the configuration.</p>
    pub fn identity_provider_config_arn(&self) -> std::option::Option<&str> {
        self.identity_provider_config_arn.as_deref()
    }
    /// <p>The cluster that the configuration is associated to.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn issuer_url(&self) -> std::option::Option<&str> {
        self.issuer_url.as_deref()
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn username_claim(&self) -> std::option::Option<&str> {
        self.username_claim.as_deref()
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code> </p>
    pub fn username_prefix(&self) -> std::option::Option<&str> {
        self.username_prefix.as_deref()
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn groups_claim(&self) -> std::option::Option<&str> {
        self.groups_claim.as_deref()
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code> </p>
    pub fn groups_prefix(&self) -> std::option::Option<&str> {
        self.groups_prefix.as_deref()
    }
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn required_claims(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.required_claims.as_ref()
    }
    /// <p>The metadata to apply to the provider configuration to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn status(&self) -> std::option::Option<&crate::types::ConfigStatus> {
        self.status.as_ref()
    }
}
impl OidcIdentityProviderConfig {
    /// Creates a new builder-style object to manufacture [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
    pub fn builder() -> crate::types::builders::OidcIdentityProviderConfigBuilder {
        crate::types::builders::OidcIdentityProviderConfigBuilder::default()
    }
}

/// A builder for [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct OidcIdentityProviderConfigBuilder {
    pub(crate) identity_provider_config_name: std::option::Option<std::string::String>,
    pub(crate) identity_provider_config_arn: std::option::Option<std::string::String>,
    pub(crate) cluster_name: std::option::Option<std::string::String>,
    pub(crate) issuer_url: std::option::Option<std::string::String>,
    pub(crate) client_id: std::option::Option<std::string::String>,
    pub(crate) username_claim: std::option::Option<std::string::String>,
    pub(crate) username_prefix: std::option::Option<std::string::String>,
    pub(crate) groups_claim: std::option::Option<std::string::String>,
    pub(crate) groups_prefix: std::option::Option<std::string::String>,
    pub(crate) required_claims:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) status: std::option::Option<crate::types::ConfigStatus>,
}
impl OidcIdentityProviderConfigBuilder {
    /// <p>The name of the configuration.</p>
    pub fn identity_provider_config_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.identity_provider_config_name = Some(input.into());
        self
    }
    /// <p>The name of the configuration.</p>
    pub fn set_identity_provider_config_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.identity_provider_config_name = input;
        self
    }
    /// <p>The ARN of the configuration.</p>
    pub fn identity_provider_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.identity_provider_config_arn = Some(input.into());
        self
    }
    /// <p>The ARN of the configuration.</p>
    pub fn set_identity_provider_config_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.identity_provider_config_arn = input;
        self
    }
    /// <p>The cluster that the configuration is associated to.</p>
    pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.cluster_name = Some(input.into());
        self
    }
    /// <p>The cluster that the configuration is associated to.</p>
    pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn issuer_url(mut self, input: impl Into<std::string::String>) -> Self {
        self.issuer_url = Some(input.into());
        self
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn set_issuer_url(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.issuer_url = input;
        self
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.client_id = Some(input.into());
        self
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.client_id = input;
        self
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn username_claim(mut self, input: impl Into<std::string::String>) -> Self {
        self.username_claim = Some(input.into());
        self
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn set_username_claim(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.username_claim = input;
        self
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code> </p>
    pub fn username_prefix(mut self, input: impl Into<std::string::String>) -> Self {
        self.username_prefix = Some(input.into());
        self
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code> </p>
    pub fn set_username_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.username_prefix = input;
        self
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn groups_claim(mut self, input: impl Into<std::string::String>) -> Self {
        self.groups_claim = Some(input.into());
        self
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn set_groups_claim(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.groups_claim = input;
        self
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code> </p>
    pub fn groups_prefix(mut self, input: impl Into<std::string::String>) -> Self {
        self.groups_prefix = Some(input.into());
        self
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code> </p>
    pub fn set_groups_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.groups_prefix = input;
        self
    }
    /// Adds a key-value pair to `required_claims`.
    ///
    /// To override the contents of this collection use [`set_required_claims`](Self::set_required_claims).
    ///
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn required_claims(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.required_claims.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.required_claims = Some(hash_map);
        self
    }
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn set_required_claims(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.required_claims = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The metadata to apply to the provider configuration to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>The metadata to apply to the provider configuration to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn status(mut self, input: crate::types::ConfigStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn set_status(mut self, input: std::option::Option<crate::types::ConfigStatus>) -> Self {
        self.status = input;
        self
    }
    /// Consumes the builder and constructs a [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
    pub fn build(self) -> crate::types::OidcIdentityProviderConfig {
        crate::types::OidcIdentityProviderConfig {
            identity_provider_config_name: self.identity_provider_config_name,
            identity_provider_config_arn: self.identity_provider_config_arn,
            cluster_name: self.cluster_name,
            issuer_url: self.issuer_url,
            client_id: self.client_id,
            username_claim: self.username_claim,
            username_prefix: self.username_prefix,
            groups_claim: self.groups_claim,
            groups_prefix: self.groups_prefix,
            required_claims: self.required_claims,
            tags: self.tags,
            status: self.status,
        }
    }
}
