// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object representing the configuration for an OpenID Connect (OIDC) identity provider.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OidcIdentityProviderConfig {
    /// <p>The name of the configuration.</p>
    pub identity_provider_config_name: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the configuration.</p>
    pub identity_provider_config_arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of your cluster.</p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub issuer_url: ::std::option::Option<::std::string::String>,
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub client_id: ::std::option::Option<::std::string::String>,
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub username_claim: ::std::option::Option<::std::string::String>,
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code></p>
    pub username_prefix: ::std::option::Option<::std::string::String>,
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub groups_claim: ::std::option::Option<::std::string::String>,
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code></p>
    pub groups_prefix: ::std::option::Option<::std::string::String>,
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub required_claims: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The status of the OIDC identity provider.</p>
    pub status: ::std::option::Option<crate::types::ConfigStatus>,
}
impl OidcIdentityProviderConfig {
    /// <p>The name of the configuration.</p>
    pub fn identity_provider_config_name(&self) -> ::std::option::Option<&str> {
        self.identity_provider_config_name.as_deref()
    }
    /// <p>The ARN of the configuration.</p>
    pub fn identity_provider_config_arn(&self) -> ::std::option::Option<&str> {
        self.identity_provider_config_arn.as_deref()
    }
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn issuer_url(&self) -> ::std::option::Option<&str> {
        self.issuer_url.as_deref()
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn client_id(&self) -> ::std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn username_claim(&self) -> ::std::option::Option<&str> {
        self.username_claim.as_deref()
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code></p>
    pub fn username_prefix(&self) -> ::std::option::Option<&str> {
        self.username_prefix.as_deref()
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn groups_claim(&self) -> ::std::option::Option<&str> {
        self.groups_claim.as_deref()
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code></p>
    pub fn groups_prefix(&self) -> ::std::option::Option<&str> {
        self.groups_prefix.as_deref()
    }
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn required_claims(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.required_claims.as_ref()
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ConfigStatus> {
        self.status.as_ref()
    }
}
impl OidcIdentityProviderConfig {
    /// Creates a new builder-style object to manufacture [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
    pub fn builder() -> crate::types::builders::OidcIdentityProviderConfigBuilder {
        crate::types::builders::OidcIdentityProviderConfigBuilder::default()
    }
}

/// A builder for [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct OidcIdentityProviderConfigBuilder {
    pub(crate) identity_provider_config_name: ::std::option::Option<::std::string::String>,
    pub(crate) identity_provider_config_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) issuer_url: ::std::option::Option<::std::string::String>,
    pub(crate) client_id: ::std::option::Option<::std::string::String>,
    pub(crate) username_claim: ::std::option::Option<::std::string::String>,
    pub(crate) username_prefix: ::std::option::Option<::std::string::String>,
    pub(crate) groups_claim: ::std::option::Option<::std::string::String>,
    pub(crate) groups_prefix: ::std::option::Option<::std::string::String>,
    pub(crate) required_claims: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) status: ::std::option::Option<crate::types::ConfigStatus>,
}
impl OidcIdentityProviderConfigBuilder {
    /// <p>The name of the configuration.</p>
    pub fn identity_provider_config_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.identity_provider_config_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the configuration.</p>
    pub fn set_identity_provider_config_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.identity_provider_config_name = input;
        self
    }
    /// <p>The name of the configuration.</p>
    pub fn get_identity_provider_config_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.identity_provider_config_name
    }
    /// <p>The ARN of the configuration.</p>
    pub fn identity_provider_config_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.identity_provider_config_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the configuration.</p>
    pub fn set_identity_provider_config_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.identity_provider_config_arn = input;
        self
    }
    /// <p>The ARN of the configuration.</p>
    pub fn get_identity_provider_config_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.identity_provider_config_arn
    }
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn issuer_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.issuer_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn set_issuer_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.issuer_url = input;
        self
    }
    /// <p>The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.</p>
    pub fn get_issuer_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.issuer_url
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn client_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn set_client_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_id = input;
        self
    }
    /// <p>This is also known as <i>audience</i>. The ID of the client application that makes authentication requests to the OIDC identity provider.</p>
    pub fn get_client_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_id
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn username_claim(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.username_claim = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn set_username_claim(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.username_claim = input;
        self
    }
    /// <p>The JSON Web token (JWT) claim that is used as the username.</p>
    pub fn get_username_claim(&self) -> &::std::option::Option<::std::string::String> {
        &self.username_claim
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code></p>
    pub fn username_prefix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.username_prefix = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code></p>
    pub fn set_username_prefix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.username_prefix = input;
        self
    }
    /// <p>The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can't contain <code>system:</code></p>
    pub fn get_username_prefix(&self) -> &::std::option::Option<::std::string::String> {
        &self.username_prefix
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn groups_claim(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.groups_claim = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn set_groups_claim(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.groups_claim = input;
        self
    }
    /// <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
    pub fn get_groups_claim(&self) -> &::std::option::Option<::std::string::String> {
        &self.groups_claim
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code></p>
    pub fn groups_prefix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.groups_prefix = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code></p>
    pub fn set_groups_prefix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.groups_prefix = input;
        self
    }
    /// <p>The prefix that is prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix can't contain <code>system:</code></p>
    pub fn get_groups_prefix(&self) -> &::std::option::Option<::std::string::String> {
        &self.groups_prefix
    }
    /// Adds a key-value pair to `required_claims`.
    ///
    /// To override the contents of this collection use [`set_required_claims`](Self::set_required_claims).
    ///
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn required_claims(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.required_claims.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.required_claims = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn set_required_claims(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.required_claims = input;
        self
    }
    /// <p>The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.</p>
    pub fn get_required_claims(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.required_claims
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn status(mut self, input: crate::types::ConfigStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ConfigStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the OIDC identity provider.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ConfigStatus> {
        &self.status
    }
    /// Consumes the builder and constructs a [`OidcIdentityProviderConfig`](crate::types::OidcIdentityProviderConfig).
    pub fn build(self) -> crate::types::OidcIdentityProviderConfig {
        crate::types::OidcIdentityProviderConfig {
            identity_provider_config_name: self.identity_provider_config_name,
            identity_provider_config_arn: self.identity_provider_config_arn,
            cluster_name: self.cluster_name,
            issuer_url: self.issuer_url,
            client_id: self.client_id,
            username_claim: self.username_claim,
            username_prefix: self.username_prefix,
            groups_claim: self.groups_claim,
            groups_prefix: self.groups_prefix,
            required_claims: self.required_claims,
            tags: self.tags,
            status: self.status,
        }
    }
}
