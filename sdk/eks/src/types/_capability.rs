// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object representing a managed capability in an Amazon EKS cluster. This includes all configuration, status, and health information for the capability.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Capability {
    /// <p>The unique name of the capability within the cluster.</p>
    pub capability_name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the capability.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of the Amazon EKS cluster that contains this capability.</p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The type of capability. Valid values are <code>ACK</code>, <code>ARGOCD</code>, or <code>KRO</code>.</p>
    pub r#type: ::std::option::Option<crate::types::CapabilityType>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with Amazon Web Services services.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The current status of the capability. Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>CREATING</code> – The capability is being created.</p></li>
    /// <li>
    /// <p><code>ACTIVE</code> – The capability is running and available.</p></li>
    /// <li>
    /// <p><code>UPDATING</code> – The capability is being updated.</p></li>
    /// <li>
    /// <p><code>DELETING</code> – The capability is being deleted.</p></li>
    /// <li>
    /// <p><code>CREATE_FAILED</code> – The capability creation failed.</p></li>
    /// <li>
    /// <p><code>UPDATE_FAILED</code> – The capability update failed.</p></li>
    /// <li>
    /// <p><code>DELETE_FAILED</code> – The capability deletion failed.</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::CapabilityStatus>,
    /// <p>The version of the capability software that is currently running.</p>
    pub version: ::std::option::Option<::std::string::String>,
    /// <p>The configuration settings for the capability. The structure varies depending on the capability type.</p>
    pub configuration: ::std::option::Option<crate::types::CapabilityConfigurationResponse>,
    /// <p>The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value. You define them.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource – 50</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length – 128 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>Maximum value length – 256 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case-sensitive.</p></li>
    /// <li>
    /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Health information for the capability, including any issues that may be affecting its operation.</p>
    pub health: ::std::option::Option<crate::types::CapabilityHealth>,
    /// <p>The Unix epoch timestamp in seconds for when the capability was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Unix epoch timestamp in seconds for when the capability was last modified.</p>
    pub modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The delete propagation policy for the capability. Currently, the only supported value is <code>RETAIN</code>, which keeps all resources managed by the capability when the capability is deleted.</p>
    pub delete_propagation_policy: ::std::option::Option<crate::types::CapabilityDeletePropagationPolicy>,
}
impl Capability {
    /// <p>The unique name of the capability within the cluster.</p>
    pub fn capability_name(&self) -> ::std::option::Option<&str> {
        self.capability_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the capability.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the Amazon EKS cluster that contains this capability.</p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The type of capability. Valid values are <code>ACK</code>, <code>ARGOCD</code>, or <code>KRO</code>.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::CapabilityType> {
        self.r#type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with Amazon Web Services services.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The current status of the capability. Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>CREATING</code> – The capability is being created.</p></li>
    /// <li>
    /// <p><code>ACTIVE</code> – The capability is running and available.</p></li>
    /// <li>
    /// <p><code>UPDATING</code> – The capability is being updated.</p></li>
    /// <li>
    /// <p><code>DELETING</code> – The capability is being deleted.</p></li>
    /// <li>
    /// <p><code>CREATE_FAILED</code> – The capability creation failed.</p></li>
    /// <li>
    /// <p><code>UPDATE_FAILED</code> – The capability update failed.</p></li>
    /// <li>
    /// <p><code>DELETE_FAILED</code> – The capability deletion failed.</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::CapabilityStatus> {
        self.status.as_ref()
    }
    /// <p>The version of the capability software that is currently running.</p>
    pub fn version(&self) -> ::std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The configuration settings for the capability. The structure varies depending on the capability type.</p>
    pub fn configuration(&self) -> ::std::option::Option<&crate::types::CapabilityConfigurationResponse> {
        self.configuration.as_ref()
    }
    /// <p>The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value. You define them.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource – 50</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length – 128 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>Maximum value length – 256 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case-sensitive.</p></li>
    /// <li>
    /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Health information for the capability, including any issues that may be affecting its operation.</p>
    pub fn health(&self) -> ::std::option::Option<&crate::types::CapabilityHealth> {
        self.health.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was last modified.</p>
    pub fn modified_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>The delete propagation policy for the capability. Currently, the only supported value is <code>RETAIN</code>, which keeps all resources managed by the capability when the capability is deleted.</p>
    pub fn delete_propagation_policy(&self) -> ::std::option::Option<&crate::types::CapabilityDeletePropagationPolicy> {
        self.delete_propagation_policy.as_ref()
    }
}
impl Capability {
    /// Creates a new builder-style object to manufacture [`Capability`](crate::types::Capability).
    pub fn builder() -> crate::types::builders::CapabilityBuilder {
        crate::types::builders::CapabilityBuilder::default()
    }
}

/// A builder for [`Capability`](crate::types::Capability).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CapabilityBuilder {
    pub(crate) capability_name: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<crate::types::CapabilityType>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::CapabilityStatus>,
    pub(crate) version: ::std::option::Option<::std::string::String>,
    pub(crate) configuration: ::std::option::Option<crate::types::CapabilityConfigurationResponse>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) health: ::std::option::Option<crate::types::CapabilityHealth>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) delete_propagation_policy: ::std::option::Option<crate::types::CapabilityDeletePropagationPolicy>,
}
impl CapabilityBuilder {
    /// <p>The unique name of the capability within the cluster.</p>
    pub fn capability_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.capability_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique name of the capability within the cluster.</p>
    pub fn set_capability_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.capability_name = input;
        self
    }
    /// <p>The unique name of the capability within the cluster.</p>
    pub fn get_capability_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.capability_name
    }
    /// <p>The Amazon Resource Name (ARN) of the capability.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the capability.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the capability.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The name of the Amazon EKS cluster that contains this capability.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Amazon EKS cluster that contains this capability.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The name of the Amazon EKS cluster that contains this capability.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The type of capability. Valid values are <code>ACK</code>, <code>ARGOCD</code>, or <code>KRO</code>.</p>
    pub fn r#type(mut self, input: crate::types::CapabilityType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of capability. Valid values are <code>ACK</code>, <code>ARGOCD</code>, or <code>KRO</code>.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::CapabilityType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of capability. Valid values are <code>ACK</code>, <code>ARGOCD</code>, or <code>KRO</code>.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::CapabilityType> {
        &self.r#type
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with Amazon Web Services services.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with Amazon Web Services services.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with Amazon Web Services services.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>The current status of the capability. Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>CREATING</code> – The capability is being created.</p></li>
    /// <li>
    /// <p><code>ACTIVE</code> – The capability is running and available.</p></li>
    /// <li>
    /// <p><code>UPDATING</code> – The capability is being updated.</p></li>
    /// <li>
    /// <p><code>DELETING</code> – The capability is being deleted.</p></li>
    /// <li>
    /// <p><code>CREATE_FAILED</code> – The capability creation failed.</p></li>
    /// <li>
    /// <p><code>UPDATE_FAILED</code> – The capability update failed.</p></li>
    /// <li>
    /// <p><code>DELETE_FAILED</code> – The capability deletion failed.</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::CapabilityStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the capability. Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>CREATING</code> – The capability is being created.</p></li>
    /// <li>
    /// <p><code>ACTIVE</code> – The capability is running and available.</p></li>
    /// <li>
    /// <p><code>UPDATING</code> – The capability is being updated.</p></li>
    /// <li>
    /// <p><code>DELETING</code> – The capability is being deleted.</p></li>
    /// <li>
    /// <p><code>CREATE_FAILED</code> – The capability creation failed.</p></li>
    /// <li>
    /// <p><code>UPDATE_FAILED</code> – The capability update failed.</p></li>
    /// <li>
    /// <p><code>DELETE_FAILED</code> – The capability deletion failed.</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::CapabilityStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the capability. Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>CREATING</code> – The capability is being created.</p></li>
    /// <li>
    /// <p><code>ACTIVE</code> – The capability is running and available.</p></li>
    /// <li>
    /// <p><code>UPDATING</code> – The capability is being updated.</p></li>
    /// <li>
    /// <p><code>DELETING</code> – The capability is being deleted.</p></li>
    /// <li>
    /// <p><code>CREATE_FAILED</code> – The capability creation failed.</p></li>
    /// <li>
    /// <p><code>UPDATE_FAILED</code> – The capability update failed.</p></li>
    /// <li>
    /// <p><code>DELETE_FAILED</code> – The capability deletion failed.</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::CapabilityStatus> {
        &self.status
    }
    /// <p>The version of the capability software that is currently running.</p>
    pub fn version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version of the capability software that is currently running.</p>
    pub fn set_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// <p>The version of the capability software that is currently running.</p>
    pub fn get_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.version
    }
    /// <p>The configuration settings for the capability. The structure varies depending on the capability type.</p>
    pub fn configuration(mut self, input: crate::types::CapabilityConfigurationResponse) -> Self {
        self.configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration settings for the capability. The structure varies depending on the capability type.</p>
    pub fn set_configuration(mut self, input: ::std::option::Option<crate::types::CapabilityConfigurationResponse>) -> Self {
        self.configuration = input;
        self
    }
    /// <p>The configuration settings for the capability. The structure varies depending on the capability type.</p>
    pub fn get_configuration(&self) -> &::std::option::Option<crate::types::CapabilityConfigurationResponse> {
        &self.configuration
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value. You define them.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource – 50</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length – 128 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>Maximum value length – 256 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case-sensitive.</p></li>
    /// <li>
    /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value. You define them.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource – 50</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length – 128 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>Maximum value length – 256 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case-sensitive.</p></li>
    /// <li>
    /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value. You define them.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource – 50</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length – 128 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>Maximum value length – 256 Unicode characters in UTF-8</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case-sensitive.</p></li>
    /// <li>
    /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>Health information for the capability, including any issues that may be affecting its operation.</p>
    pub fn health(mut self, input: crate::types::CapabilityHealth) -> Self {
        self.health = ::std::option::Option::Some(input);
        self
    }
    /// <p>Health information for the capability, including any issues that may be affecting its operation.</p>
    pub fn set_health(mut self, input: ::std::option::Option<crate::types::CapabilityHealth>) -> Self {
        self.health = input;
        self
    }
    /// <p>Health information for the capability, including any issues that may be affecting its operation.</p>
    pub fn get_health(&self) -> &::std::option::Option<crate::types::CapabilityHealth> {
        &self.health
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was last modified.</p>
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was last modified.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The Unix epoch timestamp in seconds for when the capability was last modified.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// <p>The delete propagation policy for the capability. Currently, the only supported value is <code>RETAIN</code>, which keeps all resources managed by the capability when the capability is deleted.</p>
    pub fn delete_propagation_policy(mut self, input: crate::types::CapabilityDeletePropagationPolicy) -> Self {
        self.delete_propagation_policy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The delete propagation policy for the capability. Currently, the only supported value is <code>RETAIN</code>, which keeps all resources managed by the capability when the capability is deleted.</p>
    pub fn set_delete_propagation_policy(mut self, input: ::std::option::Option<crate::types::CapabilityDeletePropagationPolicy>) -> Self {
        self.delete_propagation_policy = input;
        self
    }
    /// <p>The delete propagation policy for the capability. Currently, the only supported value is <code>RETAIN</code>, which keeps all resources managed by the capability when the capability is deleted.</p>
    pub fn get_delete_propagation_policy(&self) -> &::std::option::Option<crate::types::CapabilityDeletePropagationPolicy> {
        &self.delete_propagation_policy
    }
    /// Consumes the builder and constructs a [`Capability`](crate::types::Capability).
    pub fn build(self) -> crate::types::Capability {
        crate::types::Capability {
            capability_name: self.capability_name,
            arn: self.arn,
            cluster_name: self.cluster_name,
            r#type: self.r#type,
            role_arn: self.role_arn,
            status: self.status,
            version: self.version,
            configuration: self.configuration,
            tags: self.tags,
            health: self.health,
            created_at: self.created_at,
            modified_at: self.modified_at,
            delete_propagation_policy: self.delete_propagation_policy,
        }
    }
}
