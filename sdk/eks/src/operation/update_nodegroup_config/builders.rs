// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_nodegroup_config::_update_nodegroup_config_output::UpdateNodegroupConfigOutputBuilder;

pub use crate::operation::update_nodegroup_config::_update_nodegroup_config_input::UpdateNodegroupConfigInputBuilder;

impl UpdateNodegroupConfigInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_nodegroup_config::UpdateNodegroupConfigError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_nodegroup_config();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateNodegroupConfig`.
///
/// <p>Updates an Amazon EKS managed node group configuration. Your node group continues to function during the update. The response output includes an update ID that you can use to track the status of your node group update with the <code>DescribeUpdate</code> API operation. Currently you can update the Kubernetes labels for a node group or the scaling configuration.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateNodegroupConfigFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_nodegroup_config::builders::UpdateNodegroupConfigInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigOutput,
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigError,
    > for UpdateNodegroupConfigFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_nodegroup_config::UpdateNodegroupConfigOutput,
            crate::operation::update_nodegroup_config::UpdateNodegroupConfigError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateNodegroupConfigFluentBuilder {
    /// Creates a new `UpdateNodegroupConfig`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateNodegroupConfig as a reference.
    pub fn as_input(&self) -> &crate::operation::update_nodegroup_config::builders::UpdateNodegroupConfigInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_nodegroup_config::UpdateNodegroupConfigError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_nodegroup_config::UpdateNodegroupConfig::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_nodegroup_config::UpdateNodegroupConfig::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigOutput,
        crate::operation::update_nodegroup_config::UpdateNodegroupConfigError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the Amazon EKS cluster that the managed node group resides in.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.cluster_name(input.into());
        self
    }
    /// <p>The name of the Amazon EKS cluster that the managed node group resides in.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_cluster_name(input);
        self
    }
    /// <p>The name of the Amazon EKS cluster that the managed node group resides in.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_cluster_name()
    }
    /// <p>The name of the managed node group to update.</p>
    pub fn nodegroup_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.nodegroup_name(input.into());
        self
    }
    /// <p>The name of the managed node group to update.</p>
    pub fn set_nodegroup_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_nodegroup_name(input);
        self
    }
    /// <p>The name of the managed node group to update.</p>
    pub fn get_nodegroup_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_nodegroup_name()
    }
    /// <p>The Kubernetes labels to be applied to the nodes in the node group after the update.</p>
    pub fn labels(mut self, input: crate::types::UpdateLabelsPayload) -> Self {
        self.inner = self.inner.labels(input);
        self
    }
    /// <p>The Kubernetes labels to be applied to the nodes in the node group after the update.</p>
    pub fn set_labels(mut self, input: ::std::option::Option<crate::types::UpdateLabelsPayload>) -> Self {
        self.inner = self.inner.set_labels(input);
        self
    }
    /// <p>The Kubernetes labels to be applied to the nodes in the node group after the update.</p>
    pub fn get_labels(&self) -> &::std::option::Option<crate::types::UpdateLabelsPayload> {
        self.inner.get_labels()
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group after the update. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn taints(mut self, input: crate::types::UpdateTaintsPayload) -> Self {
        self.inner = self.inner.taints(input);
        self
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group after the update. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn set_taints(mut self, input: ::std::option::Option<crate::types::UpdateTaintsPayload>) -> Self {
        self.inner = self.inner.set_taints(input);
        self
    }
    /// <p>The Kubernetes taints to be applied to the nodes in the node group after the update. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
    pub fn get_taints(&self) -> &::std::option::Option<crate::types::UpdateTaintsPayload> {
        self.inner.get_taints()
    }
    /// <p>The scaling configuration details for the Auto Scaling group after the update.</p>
    pub fn scaling_config(mut self, input: crate::types::NodegroupScalingConfig) -> Self {
        self.inner = self.inner.scaling_config(input);
        self
    }
    /// <p>The scaling configuration details for the Auto Scaling group after the update.</p>
    pub fn set_scaling_config(mut self, input: ::std::option::Option<crate::types::NodegroupScalingConfig>) -> Self {
        self.inner = self.inner.set_scaling_config(input);
        self
    }
    /// <p>The scaling configuration details for the Auto Scaling group after the update.</p>
    pub fn get_scaling_config(&self) -> &::std::option::Option<crate::types::NodegroupScalingConfig> {
        self.inner.get_scaling_config()
    }
    /// <p>The node group update configuration.</p>
    pub fn update_config(mut self, input: crate::types::NodegroupUpdateConfig) -> Self {
        self.inner = self.inner.update_config(input);
        self
    }
    /// <p>The node group update configuration.</p>
    pub fn set_update_config(mut self, input: ::std::option::Option<crate::types::NodegroupUpdateConfig>) -> Self {
        self.inner = self.inner.set_update_config(input);
        self
    }
    /// <p>The node group update configuration.</p>
    pub fn get_update_config(&self) -> &::std::option::Option<crate::types::NodegroupUpdateConfig> {
        self.inner.get_update_config()
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_request_token()
    }
}
