// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associate encryption configuration to an existing cluster.</p>
/// <p>You can use this API to enable encryption on existing clusters which do not have
/// encryption already enabled. This allows you to implement a defense-in-depth security
/// strategy without migrating applications to new Amazon EKS clusters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateEncryptionConfig {
    _private: (),
}
impl AssociateEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`AssociateEncryptionConfigInput`](crate::input::AssociateEncryptionConfigInput)
    pub fn builder() -> crate::input::associate_encryption_config_input::Builder {
        crate::input::associate_encryption_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateEncryptionConfig {
    type Output = std::result::Result<
        crate::output::AssociateEncryptionConfigOutput,
        crate::error::AssociateEncryptionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_encryption_config_error(response)
        } else {
            crate::operation_deser::parse_associate_encryption_config_response(response)
        }
    }
}

/// <p>Associate an identity provider configuration to a cluster.</p>
/// <p>If you want to authenticate identities using an identity provider, you can create an
/// identity provider configuration and associate it to your cluster. After configuring
/// authentication to your cluster you can create Kubernetes <code>roles</code> and
/// <code>clusterroles</code> to assign permissions to the roles, and then bind the
/// roles to the identities using Kubernetes <code>rolebindings</code> and
/// <code>clusterrolebindings</code>. For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC
/// Authorization</a> in the Kubernetes documentation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateIdentityProviderConfig {
    _private: (),
}
impl AssociateIdentityProviderConfig {
    /// Creates a new builder-style object to manufacture [`AssociateIdentityProviderConfigInput`](crate::input::AssociateIdentityProviderConfigInput)
    pub fn builder() -> crate::input::associate_identity_provider_config_input::Builder {
        crate::input::associate_identity_provider_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateIdentityProviderConfig {
    type Output = std::result::Result<
        crate::output::AssociateIdentityProviderConfigOutput,
        crate::error::AssociateIdentityProviderConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_identity_provider_config_error(response)
        } else {
            crate::operation_deser::parse_associate_identity_provider_config_response(response)
        }
    }
}

/// <p>Creates an Amazon EKS add-on.</p>
/// <p>Amazon EKS add-ons help to automate the provisioning and lifecycle management of common
/// operational software for Amazon EKS clusters. Amazon EKS add-ons can only be used with Amazon EKS
/// clusters running version 1.18 with platform version <code>eks.3</code> or later because
/// add-ons rely on the Server-side Apply Kubernetes feature, which is only available in
/// Kubernetes 1.18 and later.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAddon {
    _private: (),
}
impl CreateAddon {
    /// Creates a new builder-style object to manufacture [`CreateAddonInput`](crate::input::CreateAddonInput)
    pub fn builder() -> crate::input::create_addon_input::Builder {
        crate::input::create_addon_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAddon {
    type Output =
        std::result::Result<crate::output::CreateAddonOutput, crate::error::CreateAddonError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_addon_error(response)
        } else {
            crate::operation_deser::parse_create_addon_response(response)
        }
    }
}

/// <p>Creates an Amazon EKS control plane. </p>
/// <p>The Amazon EKS control plane consists of control plane instances that run the Kubernetes
/// software, such as <code>etcd</code> and the API server. The control plane runs in an
/// account managed by Amazon Web Services, and the Kubernetes API is exposed via the Amazon EKS API server
/// endpoint. Each Amazon EKS cluster control plane is single-tenant and unique and runs on its
/// own set of Amazon EC2 instances.</p>
/// <p>The cluster control plane is provisioned across multiple Availability Zones and
/// fronted by an Elastic Load Balancing Network Load Balancer. Amazon EKS also provisions elastic network interfaces in your VPC
/// subnets to provide connectivity from the control plane instances to the nodes (for
/// example, to support <code>kubectl exec</code>, <code>logs</code>, and <code>proxy</code>
/// data flows).</p>
/// <p>Amazon EKS nodes run in your Amazon Web Services account and connect to your cluster's control plane via
/// the Kubernetes API server endpoint and a certificate file that is created for your
/// cluster.</p>
/// <p>Cluster creation typically takes several minutes. After you create an Amazon EKS cluster,
/// you must configure your Kubernetes tooling to communicate with the API server and launch
/// nodes into your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html">Managing Cluster
/// Authentication</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html">Launching Amazon EKS nodes</a> in the <i>Amazon EKS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCluster {
    _private: (),
}
impl CreateCluster {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::input::CreateClusterInput)
    pub fn builder() -> crate::input::create_cluster_input::Builder {
        crate::input::create_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCluster {
    type Output =
        std::result::Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_cluster_error(response)
        } else {
            crate::operation_deser::parse_create_cluster_response(response)
        }
    }
}

/// <p>Creates an Fargate profile for your Amazon EKS cluster. You must have at least one Fargate
/// profile in a cluster to be able to run pods on Fargate.</p>
/// <p>The Fargate profile allows an administrator to declare which pods run on Fargate and specify
/// which pods run on which Fargate profile. This declaration is done through the profileâ€™s
/// selectors. Each profile can have up to five selectors that contain a namespace and
/// labels. A namespace is required for every selector. The label field consists of multiple
/// optional key-value pairs. Pods that match the selectors are scheduled on Fargate. If a
/// to-be-scheduled pod matches any of the selectors in the Fargate profile, then that pod is
/// run on Fargate.</p>
/// <p>When you create a Fargate profile, you must specify a pod execution role to use with the
/// pods that are scheduled with the profile. This role is added to the cluster's Kubernetes
/// <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role Based Access
/// Control</a> (RBAC) for authorization so that the <code>kubelet</code> that is
/// running on the Fargate infrastructure can register with your Amazon EKS cluster so that it can
/// appear in your cluster as a node. The pod execution role also provides IAM permissions
/// to the Fargate infrastructure to allow read access to Amazon ECR image repositories. For more
/// information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
/// <p>Fargate profiles are immutable. However, you can create a new updated profile to replace
/// an existing profile and then delete the original after the updated profile has finished
/// creating.</p>
/// <p>If any Fargate profiles in a cluster are in the <code>DELETING</code> status, you must
/// wait for that Fargate profile to finish deleting before you can create any other profiles
/// in that cluster.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html">Fargate Profile</a> in the <i>Amazon EKS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFargateProfile {
    _private: (),
}
impl CreateFargateProfile {
    /// Creates a new builder-style object to manufacture [`CreateFargateProfileInput`](crate::input::CreateFargateProfileInput)
    pub fn builder() -> crate::input::create_fargate_profile_input::Builder {
        crate::input::create_fargate_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFargateProfile {
    type Output = std::result::Result<
        crate::output::CreateFargateProfileOutput,
        crate::error::CreateFargateProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_fargate_profile_error(response)
        } else {
            crate::operation_deser::parse_create_fargate_profile_response(response)
        }
    }
}

/// <p>Creates a managed node group for an Amazon EKS cluster. You can only create a node group
/// for your cluster that is equal to the current Kubernetes version for the cluster. All
/// node groups are created with the latest AMI release version for the respective minor
/// Kubernetes version of the cluster, unless you deploy a custom AMI using a launch
/// template. For more information about using launch templates, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch
/// template support</a>.</p>
/// <p>An Amazon EKS managed node group is an Amazon EC2 Auto Scaling group and associated Amazon EC2 instances that
/// are managed by Amazon Web Services for an Amazon EKS cluster. Each node group uses a version of the Amazon EKS
/// optimized Amazon Linux 2 AMI. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html">Managed
/// Node Groups</a> in the <i>Amazon EKS User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateNodegroup {
    _private: (),
}
impl CreateNodegroup {
    /// Creates a new builder-style object to manufacture [`CreateNodegroupInput`](crate::input::CreateNodegroupInput)
    pub fn builder() -> crate::input::create_nodegroup_input::Builder {
        crate::input::create_nodegroup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateNodegroup {
    type Output = std::result::Result<
        crate::output::CreateNodegroupOutput,
        crate::error::CreateNodegroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_nodegroup_error(response)
        } else {
            crate::operation_deser::parse_create_nodegroup_response(response)
        }
    }
}

/// <p>Delete an Amazon EKS add-on.</p>
/// <p>When you remove the add-on, it will also be deleted from the cluster. You can always
/// manually start an add-on on the cluster using the Kubernetes API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAddon {
    _private: (),
}
impl DeleteAddon {
    /// Creates a new builder-style object to manufacture [`DeleteAddonInput`](crate::input::DeleteAddonInput)
    pub fn builder() -> crate::input::delete_addon_input::Builder {
        crate::input::delete_addon_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAddon {
    type Output =
        std::result::Result<crate::output::DeleteAddonOutput, crate::error::DeleteAddonError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_addon_error(response)
        } else {
            crate::operation_deser::parse_delete_addon_response(response)
        }
    }
}

/// <p>Deletes the Amazon EKS cluster control plane.</p>
/// <p>If you have active services in your cluster that are associated with a load balancer,
/// you must delete those services before deleting the cluster so that the load balancers
/// are deleted properly. Otherwise, you can have orphaned resources in your VPC that
/// prevent you from being able to delete the VPC. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html">Deleting a
/// Cluster</a> in the <i>Amazon EKS User Guide</i>.</p>
/// <p>If you have managed node groups or Fargate profiles attached to the cluster, you must
/// delete them first. For more information, see <a>DeleteNodegroup</a> and <a>DeleteFargateProfile</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCluster {
    _private: (),
}
impl DeleteCluster {
    /// Creates a new builder-style object to manufacture [`DeleteClusterInput`](crate::input::DeleteClusterInput)
    pub fn builder() -> crate::input::delete_cluster_input::Builder {
        crate::input::delete_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCluster {
    type Output =
        std::result::Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_cluster_error(response)
        } else {
            crate::operation_deser::parse_delete_cluster_response(response)
        }
    }
}

/// <p>Deletes an Fargate profile.</p>
/// <p>When you delete a Fargate profile, any pods running on Fargate that were created with the
/// profile are deleted. If those pods match another Fargate profile, then they are scheduled
/// on Fargate with that profile. If they no longer match any Fargate profiles, then they are not
/// scheduled on Fargate and they may remain in a pending state.</p>
/// <p>Only one Fargate profile in a cluster can be in the <code>DELETING</code> status at a
/// time. You must wait for a Fargate profile to finish deleting before you can delete any
/// other profiles in that cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFargateProfile {
    _private: (),
}
impl DeleteFargateProfile {
    /// Creates a new builder-style object to manufacture [`DeleteFargateProfileInput`](crate::input::DeleteFargateProfileInput)
    pub fn builder() -> crate::input::delete_fargate_profile_input::Builder {
        crate::input::delete_fargate_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFargateProfile {
    type Output = std::result::Result<
        crate::output::DeleteFargateProfileOutput,
        crate::error::DeleteFargateProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_fargate_profile_error(response)
        } else {
            crate::operation_deser::parse_delete_fargate_profile_response(response)
        }
    }
}

/// <p>Deletes an Amazon EKS node group for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteNodegroup {
    _private: (),
}
impl DeleteNodegroup {
    /// Creates a new builder-style object to manufacture [`DeleteNodegroupInput`](crate::input::DeleteNodegroupInput)
    pub fn builder() -> crate::input::delete_nodegroup_input::Builder {
        crate::input::delete_nodegroup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteNodegroup {
    type Output = std::result::Result<
        crate::output::DeleteNodegroupOutput,
        crate::error::DeleteNodegroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_nodegroup_error(response)
        } else {
            crate::operation_deser::parse_delete_nodegroup_response(response)
        }
    }
}

/// <p>Deregisters a connected cluster to remove it from the Amazon EKS control plane.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterCluster {
    _private: (),
}
impl DeregisterCluster {
    /// Creates a new builder-style object to manufacture [`DeregisterClusterInput`](crate::input::DeregisterClusterInput)
    pub fn builder() -> crate::input::deregister_cluster_input::Builder {
        crate::input::deregister_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterCluster {
    type Output = std::result::Result<
        crate::output::DeregisterClusterOutput,
        crate::error::DeregisterClusterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_cluster_error(response)
        } else {
            crate::operation_deser::parse_deregister_cluster_response(response)
        }
    }
}

/// <p>Describes an Amazon EKS add-on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAddon {
    _private: (),
}
impl DescribeAddon {
    /// Creates a new builder-style object to manufacture [`DescribeAddonInput`](crate::input::DescribeAddonInput)
    pub fn builder() -> crate::input::describe_addon_input::Builder {
        crate::input::describe_addon_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAddon {
    type Output =
        std::result::Result<crate::output::DescribeAddonOutput, crate::error::DescribeAddonError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_addon_error(response)
        } else {
            crate::operation_deser::parse_describe_addon_response(response)
        }
    }
}

/// <p>Describes the Kubernetes versions that the add-on can be used with.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAddonVersions {
    _private: (),
}
impl DescribeAddonVersions {
    /// Creates a new builder-style object to manufacture [`DescribeAddonVersionsInput`](crate::input::DescribeAddonVersionsInput)
    pub fn builder() -> crate::input::describe_addon_versions_input::Builder {
        crate::input::describe_addon_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAddonVersions {
    type Output = std::result::Result<
        crate::output::DescribeAddonVersionsOutput,
        crate::error::DescribeAddonVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_addon_versions_error(response)
        } else {
            crate::operation_deser::parse_describe_addon_versions_response(response)
        }
    }
}

/// <p>Returns descriptive information about an Amazon EKS cluster.</p>
/// <p>The API server endpoint and certificate authority data returned by this operation are
/// required for <code>kubelet</code> and <code>kubectl</code> to communicate with your
/// Kubernetes API server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html">Create a
/// kubeconfig for Amazon EKS</a>.</p>
/// <note>
/// <p>The API server endpoint and certificate authority data aren't available until the
/// cluster reaches the <code>ACTIVE</code> state.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCluster {
    _private: (),
}
impl DescribeCluster {
    /// Creates a new builder-style object to manufacture [`DescribeClusterInput`](crate::input::DescribeClusterInput)
    pub fn builder() -> crate::input::describe_cluster_input::Builder {
        crate::input::describe_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCluster {
    type Output = std::result::Result<
        crate::output::DescribeClusterOutput,
        crate::error::DescribeClusterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_cluster_error(response)
        } else {
            crate::operation_deser::parse_describe_cluster_response(response)
        }
    }
}

/// <p>Returns descriptive information about an Fargate profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFargateProfile {
    _private: (),
}
impl DescribeFargateProfile {
    /// Creates a new builder-style object to manufacture [`DescribeFargateProfileInput`](crate::input::DescribeFargateProfileInput)
    pub fn builder() -> crate::input::describe_fargate_profile_input::Builder {
        crate::input::describe_fargate_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFargateProfile {
    type Output = std::result::Result<
        crate::output::DescribeFargateProfileOutput,
        crate::error::DescribeFargateProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_fargate_profile_error(response)
        } else {
            crate::operation_deser::parse_describe_fargate_profile_response(response)
        }
    }
}

/// <p>Returns descriptive information about an identity provider configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIdentityProviderConfig {
    _private: (),
}
impl DescribeIdentityProviderConfig {
    /// Creates a new builder-style object to manufacture [`DescribeIdentityProviderConfigInput`](crate::input::DescribeIdentityProviderConfigInput)
    pub fn builder() -> crate::input::describe_identity_provider_config_input::Builder {
        crate::input::describe_identity_provider_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIdentityProviderConfig {
    type Output = std::result::Result<
        crate::output::DescribeIdentityProviderConfigOutput,
        crate::error::DescribeIdentityProviderConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_identity_provider_config_error(response)
        } else {
            crate::operation_deser::parse_describe_identity_provider_config_response(response)
        }
    }
}

/// <p>Returns descriptive information about an Amazon EKS node group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeNodegroup {
    _private: (),
}
impl DescribeNodegroup {
    /// Creates a new builder-style object to manufacture [`DescribeNodegroupInput`](crate::input::DescribeNodegroupInput)
    pub fn builder() -> crate::input::describe_nodegroup_input::Builder {
        crate::input::describe_nodegroup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeNodegroup {
    type Output = std::result::Result<
        crate::output::DescribeNodegroupOutput,
        crate::error::DescribeNodegroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_nodegroup_error(response)
        } else {
            crate::operation_deser::parse_describe_nodegroup_response(response)
        }
    }
}

/// <p>Returns descriptive information about an update against your Amazon EKS cluster or
/// associated managed node group.</p>
/// <p>When the status of the update is <code>Succeeded</code>, the update is complete. If an
/// update fails, the status is <code>Failed</code>, and an error detail explains the reason
/// for the failure.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUpdate {
    _private: (),
}
impl DescribeUpdate {
    /// Creates a new builder-style object to manufacture [`DescribeUpdateInput`](crate::input::DescribeUpdateInput)
    pub fn builder() -> crate::input::describe_update_input::Builder {
        crate::input::describe_update_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUpdate {
    type Output =
        std::result::Result<crate::output::DescribeUpdateOutput, crate::error::DescribeUpdateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_update_error(response)
        } else {
            crate::operation_deser::parse_describe_update_response(response)
        }
    }
}

/// <p>Disassociates an identity provider configuration from a cluster. If you disassociate
/// an identity provider from your cluster, users included in the provider can no longer
/// access the cluster. However, you can still access the cluster with Amazon Web Services IAM
/// users.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateIdentityProviderConfig {
    _private: (),
}
impl DisassociateIdentityProviderConfig {
    /// Creates a new builder-style object to manufacture [`DisassociateIdentityProviderConfigInput`](crate::input::DisassociateIdentityProviderConfigInput)
    pub fn builder() -> crate::input::disassociate_identity_provider_config_input::Builder {
        crate::input::disassociate_identity_provider_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateIdentityProviderConfig {
    type Output = std::result::Result<
        crate::output::DisassociateIdentityProviderConfigOutput,
        crate::error::DisassociateIdentityProviderConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_identity_provider_config_error(response)
        } else {
            crate::operation_deser::parse_disassociate_identity_provider_config_response(response)
        }
    }
}

/// <p>Lists the available add-ons.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAddons {
    _private: (),
}
impl ListAddons {
    /// Creates a new builder-style object to manufacture [`ListAddonsInput`](crate::input::ListAddonsInput)
    pub fn builder() -> crate::input::list_addons_input::Builder {
        crate::input::list_addons_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAddons {
    type Output =
        std::result::Result<crate::output::ListAddonsOutput, crate::error::ListAddonsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_addons_error(response)
        } else {
            crate::operation_deser::parse_list_addons_response(response)
        }
    }
}

/// <p>Lists the Amazon EKS clusters in your Amazon Web Services account in the specified Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClusters {
    _private: (),
}
impl ListClusters {
    /// Creates a new builder-style object to manufacture [`ListClustersInput`](crate::input::ListClustersInput)
    pub fn builder() -> crate::input::list_clusters_input::Builder {
        crate::input::list_clusters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClusters {
    type Output =
        std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_clusters_error(response)
        } else {
            crate::operation_deser::parse_list_clusters_response(response)
        }
    }
}

/// <p>Lists the Fargate profiles associated with the specified cluster in your Amazon Web Services
/// account in the specified Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFargateProfiles {
    _private: (),
}
impl ListFargateProfiles {
    /// Creates a new builder-style object to manufacture [`ListFargateProfilesInput`](crate::input::ListFargateProfilesInput)
    pub fn builder() -> crate::input::list_fargate_profiles_input::Builder {
        crate::input::list_fargate_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFargateProfiles {
    type Output = std::result::Result<
        crate::output::ListFargateProfilesOutput,
        crate::error::ListFargateProfilesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_fargate_profiles_error(response)
        } else {
            crate::operation_deser::parse_list_fargate_profiles_response(response)
        }
    }
}

/// <p>A list of identity provider configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIdentityProviderConfigs {
    _private: (),
}
impl ListIdentityProviderConfigs {
    /// Creates a new builder-style object to manufacture [`ListIdentityProviderConfigsInput`](crate::input::ListIdentityProviderConfigsInput)
    pub fn builder() -> crate::input::list_identity_provider_configs_input::Builder {
        crate::input::list_identity_provider_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIdentityProviderConfigs {
    type Output = std::result::Result<
        crate::output::ListIdentityProviderConfigsOutput,
        crate::error::ListIdentityProviderConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_identity_provider_configs_error(response)
        } else {
            crate::operation_deser::parse_list_identity_provider_configs_response(response)
        }
    }
}

/// <p>Lists the Amazon EKS managed node groups associated with the specified cluster in your
/// Amazon Web Services account in the specified Region. Self-managed node groups are not listed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListNodegroups {
    _private: (),
}
impl ListNodegroups {
    /// Creates a new builder-style object to manufacture [`ListNodegroupsInput`](crate::input::ListNodegroupsInput)
    pub fn builder() -> crate::input::list_nodegroups_input::Builder {
        crate::input::list_nodegroups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListNodegroups {
    type Output =
        std::result::Result<crate::output::ListNodegroupsOutput, crate::error::ListNodegroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_nodegroups_error(response)
        } else {
            crate::operation_deser::parse_list_nodegroups_response(response)
        }
    }
}

/// <p>List the tags for an Amazon EKS resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists the updates associated with an Amazon EKS cluster or managed node group in your Amazon Web Services
/// account, in the specified Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUpdates {
    _private: (),
}
impl ListUpdates {
    /// Creates a new builder-style object to manufacture [`ListUpdatesInput`](crate::input::ListUpdatesInput)
    pub fn builder() -> crate::input::list_updates_input::Builder {
        crate::input::list_updates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUpdates {
    type Output =
        std::result::Result<crate::output::ListUpdatesOutput, crate::error::ListUpdatesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_updates_error(response)
        } else {
            crate::operation_deser::parse_list_updates_response(response)
        }
    }
}

/// <p>Connects a Kubernetes cluster to the Amazon EKS control plane. </p>
/// <p>Any Kubernetes cluster can be connected to the Amazon EKS control plane to view current information about the cluster and its nodes.
/// </p>
/// <p>Cluster connection requires two steps. First, send a <code>
/// <a>RegisterClusterRequest</a>
/// </code> to add it to the Amazon EKS control plane.</p>
/// <p>Second, a <a href="https://amazon-eks.s3.us-west-2.amazonaws.com/eks-connector/manifests/eks-connector/latest/eks-connector.yaml">Manifest</a> containing the <code>activationID</code> and <code>activationCode</code> must be applied to the Kubernetes cluster through it's native provider to provide visibility.</p>
/// <p>After the Manifest is updated and applied, then the connected cluster is visible to the Amazon EKS control plane. If the Manifest is not applied within a set amount of time,
/// then the connected cluster will no longer be visible and must be deregistered. See <a>DeregisterCluster</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterCluster {
    _private: (),
}
impl RegisterCluster {
    /// Creates a new builder-style object to manufacture [`RegisterClusterInput`](crate::input::RegisterClusterInput)
    pub fn builder() -> crate::input::register_cluster_input::Builder {
        crate::input::register_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterCluster {
    type Output = std::result::Result<
        crate::output::RegisterClusterOutput,
        crate::error::RegisterClusterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_cluster_error(response)
        } else {
            crate::operation_deser::parse_register_cluster_response(response)
        }
    }
}

/// <p>Associates the specified tags to a resource with the specified
/// <code>resourceArn</code>. If existing tags on a resource are not specified in the
/// request parameters, they are not changed. When a resource is deleted, the tags
/// associated with that resource are deleted as well. Tags that you create for Amazon EKS
/// resources do not propagate to any other resources associated with the cluster. For
/// example, if you tag a cluster with this operation, that tag does not automatically
/// propagate to the subnets and nodes associated with the cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Deletes specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an Amazon EKS add-on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAddon {
    _private: (),
}
impl UpdateAddon {
    /// Creates a new builder-style object to manufacture [`UpdateAddonInput`](crate::input::UpdateAddonInput)
    pub fn builder() -> crate::input::update_addon_input::Builder {
        crate::input::update_addon_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAddon {
    type Output =
        std::result::Result<crate::output::UpdateAddonOutput, crate::error::UpdateAddonError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_addon_error(response)
        } else {
            crate::operation_deser::parse_update_addon_response(response)
        }
    }
}

/// <p>Updates an Amazon EKS cluster configuration. Your cluster continues to function during the
/// update. The response output includes an update ID that you can use to track the status
/// of your cluster update with the <a>DescribeUpdate</a> API operation.</p>
/// <p>You can use this API operation to enable or disable exporting the Kubernetes control
/// plane logs for your cluster to CloudWatch Logs. By default, cluster control plane logs aren't
/// exported to CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS
/// Cluster Control Plane Logs</a> in the
/// <i>
/// <i>Amazon EKS User Guide</i>
/// </i>.</p>
/// <note>
/// <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported
/// control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">CloudWatch Pricing</a>.</p>
/// </note>
/// <p>You can also use this API operation to enable or disable public and private access to
/// your cluster's Kubernetes API server endpoint. By default, public access is enabled, and
/// private access is disabled. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster
/// endpoint access control</a> in the <i>
/// <i>Amazon EKS User Guide</i>
/// </i>. </p>
/// <important>
/// <p>You can't update the subnets or security group IDs for an existing cluster.</p>
/// </important>
/// <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
/// an update, the cluster status moves to <code>UPDATING</code> (this status transition is
/// eventually consistent). When the update is complete (either <code>Failed</code> or
/// <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateClusterConfig {
    _private: (),
}
impl UpdateClusterConfig {
    /// Creates a new builder-style object to manufacture [`UpdateClusterConfigInput`](crate::input::UpdateClusterConfigInput)
    pub fn builder() -> crate::input::update_cluster_config_input::Builder {
        crate::input::update_cluster_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateClusterConfig {
    type Output = std::result::Result<
        crate::output::UpdateClusterConfigOutput,
        crate::error::UpdateClusterConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_cluster_config_error(response)
        } else {
            crate::operation_deser::parse_update_cluster_config_response(response)
        }
    }
}

/// <p>Updates an Amazon EKS cluster to the specified Kubernetes version. Your cluster continues
/// to function during the update. The response output includes an update ID that you can
/// use to track the status of your cluster update with the <a>DescribeUpdate</a>
/// API operation.</p>
/// <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
/// an update, the cluster status moves to <code>UPDATING</code> (this status transition is
/// eventually consistent). When the update is complete (either <code>Failed</code> or
/// <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
/// <p>If your cluster has managed node groups attached to it, all of your node groupsâ€™
/// Kubernetes versions must match the clusterâ€™s Kubernetes version in order to update the
/// cluster to a new Kubernetes version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateClusterVersion {
    _private: (),
}
impl UpdateClusterVersion {
    /// Creates a new builder-style object to manufacture [`UpdateClusterVersionInput`](crate::input::UpdateClusterVersionInput)
    pub fn builder() -> crate::input::update_cluster_version_input::Builder {
        crate::input::update_cluster_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateClusterVersion {
    type Output = std::result::Result<
        crate::output::UpdateClusterVersionOutput,
        crate::error::UpdateClusterVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_cluster_version_error(response)
        } else {
            crate::operation_deser::parse_update_cluster_version_response(response)
        }
    }
}

/// <p>Updates an Amazon EKS managed node group configuration. Your node group continues to
/// function during the update. The response output includes an update ID that you can use
/// to track the status of your node group update with the <a>DescribeUpdate</a>
/// API operation. Currently you can update the Kubernetes labels for a node group or the
/// scaling configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateNodegroupConfig {
    _private: (),
}
impl UpdateNodegroupConfig {
    /// Creates a new builder-style object to manufacture [`UpdateNodegroupConfigInput`](crate::input::UpdateNodegroupConfigInput)
    pub fn builder() -> crate::input::update_nodegroup_config_input::Builder {
        crate::input::update_nodegroup_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateNodegroupConfig {
    type Output = std::result::Result<
        crate::output::UpdateNodegroupConfigOutput,
        crate::error::UpdateNodegroupConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_nodegroup_config_error(response)
        } else {
            crate::operation_deser::parse_update_nodegroup_config_response(response)
        }
    }
}

/// <p>Updates the Kubernetes version or AMI version of an Amazon EKS managed node group.</p>
/// <p>You can update a node group using a launch template only if the node group was
/// originally deployed with a launch template. If you need to update a custom AMI in a node
/// group that was deployed with a launch template, then update your custom AMI, specify the
/// new ID in a new version of the launch template, and then update the node group to the
/// new version of the launch template.</p>
/// <p>If you update without a launch template, then you can update to the latest available
/// AMI version of a node group's current Kubernetes version by not specifying a Kubernetes
/// version in the request. You can update to the latest AMI version of your cluster's
/// current Kubernetes version by specifying your cluster's Kubernetes version in the
/// request. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS
/// optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p>
/// <p>You cannot roll back a node group to an earlier Kubernetes version or AMI
/// version.</p>
/// <p>When a node in a managed node group is terminated due to a scaling action or update,
/// the pods in that node are drained first. Amazon EKS attempts to drain the nodes gracefully
/// and will fail if it is unable to do so. You can <code>force</code> the update if Amazon EKS
/// is unable to drain the nodes as a result of a pod disruption budget issue.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateNodegroupVersion {
    _private: (),
}
impl UpdateNodegroupVersion {
    /// Creates a new builder-style object to manufacture [`UpdateNodegroupVersionInput`](crate::input::UpdateNodegroupVersionInput)
    pub fn builder() -> crate::input::update_nodegroup_version_input::Builder {
        crate::input::update_nodegroup_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateNodegroupVersion {
    type Output = std::result::Result<
        crate::output::UpdateNodegroupVersionOutput,
        crate::error::UpdateNodegroupVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_nodegroup_version_error(response)
        } else {
            crate::operation_deser::parse_update_nodegroup_version_response(response)
        }
    }
}
