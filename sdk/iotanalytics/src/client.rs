// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_put_message(&self) -> fluent_builders::BatchPutMessage<C> {
        fluent_builders::BatchPutMessage::new(self.handle.clone())
    }
    pub fn cancel_pipeline_reprocessing(&self) -> fluent_builders::CancelPipelineReprocessing<C> {
        fluent_builders::CancelPipelineReprocessing::new(self.handle.clone())
    }
    pub fn create_channel(&self) -> fluent_builders::CreateChannel<C> {
        fluent_builders::CreateChannel::new(self.handle.clone())
    }
    pub fn create_dataset(&self) -> fluent_builders::CreateDataset<C> {
        fluent_builders::CreateDataset::new(self.handle.clone())
    }
    pub fn create_dataset_content(&self) -> fluent_builders::CreateDatasetContent<C> {
        fluent_builders::CreateDatasetContent::new(self.handle.clone())
    }
    pub fn create_datastore(&self) -> fluent_builders::CreateDatastore<C> {
        fluent_builders::CreateDatastore::new(self.handle.clone())
    }
    pub fn create_pipeline(&self) -> fluent_builders::CreatePipeline<C> {
        fluent_builders::CreatePipeline::new(self.handle.clone())
    }
    pub fn delete_channel(&self) -> fluent_builders::DeleteChannel<C> {
        fluent_builders::DeleteChannel::new(self.handle.clone())
    }
    pub fn delete_dataset(&self) -> fluent_builders::DeleteDataset<C> {
        fluent_builders::DeleteDataset::new(self.handle.clone())
    }
    pub fn delete_dataset_content(&self) -> fluent_builders::DeleteDatasetContent<C> {
        fluent_builders::DeleteDatasetContent::new(self.handle.clone())
    }
    pub fn delete_datastore(&self) -> fluent_builders::DeleteDatastore<C> {
        fluent_builders::DeleteDatastore::new(self.handle.clone())
    }
    pub fn delete_pipeline(&self) -> fluent_builders::DeletePipeline<C> {
        fluent_builders::DeletePipeline::new(self.handle.clone())
    }
    pub fn describe_channel(&self) -> fluent_builders::DescribeChannel<C> {
        fluent_builders::DescribeChannel::new(self.handle.clone())
    }
    pub fn describe_dataset(&self) -> fluent_builders::DescribeDataset<C> {
        fluent_builders::DescribeDataset::new(self.handle.clone())
    }
    pub fn describe_datastore(&self) -> fluent_builders::DescribeDatastore<C> {
        fluent_builders::DescribeDatastore::new(self.handle.clone())
    }
    pub fn describe_logging_options(&self) -> fluent_builders::DescribeLoggingOptions<C> {
        fluent_builders::DescribeLoggingOptions::new(self.handle.clone())
    }
    pub fn describe_pipeline(&self) -> fluent_builders::DescribePipeline<C> {
        fluent_builders::DescribePipeline::new(self.handle.clone())
    }
    pub fn get_dataset_content(&self) -> fluent_builders::GetDatasetContent<C> {
        fluent_builders::GetDatasetContent::new(self.handle.clone())
    }
    pub fn list_channels(&self) -> fluent_builders::ListChannels<C> {
        fluent_builders::ListChannels::new(self.handle.clone())
    }
    pub fn list_dataset_contents(&self) -> fluent_builders::ListDatasetContents<C> {
        fluent_builders::ListDatasetContents::new(self.handle.clone())
    }
    pub fn list_datasets(&self) -> fluent_builders::ListDatasets<C> {
        fluent_builders::ListDatasets::new(self.handle.clone())
    }
    pub fn list_datastores(&self) -> fluent_builders::ListDatastores<C> {
        fluent_builders::ListDatastores::new(self.handle.clone())
    }
    pub fn list_pipelines(&self) -> fluent_builders::ListPipelines<C> {
        fluent_builders::ListPipelines::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_logging_options(&self) -> fluent_builders::PutLoggingOptions<C> {
        fluent_builders::PutLoggingOptions::new(self.handle.clone())
    }
    pub fn run_pipeline_activity(&self) -> fluent_builders::RunPipelineActivity<C> {
        fluent_builders::RunPipelineActivity::new(self.handle.clone())
    }
    pub fn sample_channel_data(&self) -> fluent_builders::SampleChannelData<C> {
        fluent_builders::SampleChannelData::new(self.handle.clone())
    }
    pub fn start_pipeline_reprocessing(&self) -> fluent_builders::StartPipelineReprocessing<C> {
        fluent_builders::StartPipelineReprocessing::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_channel(&self) -> fluent_builders::UpdateChannel<C> {
        fluent_builders::UpdateChannel::new(self.handle.clone())
    }
    pub fn update_dataset(&self) -> fluent_builders::UpdateDataset<C> {
        fluent_builders::UpdateDataset::new(self.handle.clone())
    }
    pub fn update_datastore(&self) -> fluent_builders::UpdateDatastore<C> {
        fluent_builders::UpdateDatastore::new(self.handle.clone())
    }
    pub fn update_pipeline(&self) -> fluent_builders::UpdatePipeline<C> {
        fluent_builders::UpdatePipeline::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchPutMessage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_put_message_input::Builder,
    }
    impl<C> BatchPutMessage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchPutMessageOutput,
            smithy_http::result::SdkError<crate::error::BatchPutMessageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel where the messages are sent.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The list of messages to be sent. Each message has the format: { "messageId": "string",
        /// "payload": "string"}.</p>
        /// <p>The field names of message payloads (data) that you send to AWS IoT Analytics:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain only alphanumeric characters and undescores (_). No other special characters are
        /// allowed.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with an alphabetic character or single underscore (_).</p>
        /// </li>
        /// <li>
        /// <p>Cannot contain hyphens (-).</p>
        /// </li>
        /// <li>
        /// <p>In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$".
        /// </p>
        /// </li>
        /// <li>
        /// <p>Cannot be more than 255 characters.</p>
        /// </li>
        /// <li>
        /// <p>Are case insensitive. (Fields named foo and FOO in the same payload are considered
        /// duplicates.)</p>
        /// </li>
        /// </ul>
        /// <p>For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29},
        /// {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads.  </p>
        pub fn messages(mut self, inp: impl Into<crate::model::Message>) -> Self {
            self.inner = self.inner.messages(inp);
            self
        }
        pub fn set_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Message>>,
        ) -> Self {
            self.inner = self.inner.set_messages(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelPipelineReprocessing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_pipeline_reprocessing_input::Builder,
    }
    impl<C> CancelPipelineReprocessing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelPipelineReprocessingOutput,
            smithy_http::result::SdkError<crate::error::CancelPipelineReprocessingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of pipeline for which data reprocessing is canceled.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The ID of the reprocessing task (returned by
        /// <code>StartPipelineReprocessing</code>).</p>
        pub fn reprocessing_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reprocessing_id(input);
            self
        }
        pub fn set_reprocessing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reprocessing_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_channel_input::Builder,
    }
    impl<C> CreateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateChannelOutput,
            smithy_http::result::SdkError<crate::error::CreateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
        /// <code>customerManagedS3</code> storage. If not specified, the default is
        /// <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
        /// created.</p>
        pub fn channel_storage(mut self, input: crate::model::ChannelStorage) -> Self {
            self.inner = self.inner.channel_storage(input);
            self
        }
        pub fn set_channel_storage(
            mut self,
            input: std::option::Option<crate::model::ChannelStorage>,
        ) -> Self {
            self.inner = self.inner.set_channel_storage(input);
            self
        }
        /// <p>How long, in days, message data is kept for the channel. When
        /// <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
        /// <p>Metadata which can be used to manage the channel.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDataset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dataset_input::Builder,
    }
    impl<C> CreateDataset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDatasetOutput,
            smithy_http::result::SdkError<crate::error::CreateDatasetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>A list of actions that create the data set contents.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::DatasetAction>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetAction>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>A list of triggers. A trigger causes data set contents to be populated at a specified time
        /// interval or when another data set's contents are created. The list of triggers can be empty or
        /// contain up to five <code>DataSetTrigger</code> objects.</p>
        pub fn triggers(mut self, inp: impl Into<crate::model::DatasetTrigger>) -> Self {
            self.inner = self.inner.triggers(inp);
            self
        }
        pub fn set_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetTrigger>>,
        ) -> Self {
            self.inner = self.inner.set_triggers(input);
            self
        }
        /// <p>When dataset contents are created, they are delivered to destinations specified
        /// here.</p>
        pub fn content_delivery_rules(
            mut self,
            inp: impl Into<crate::model::DatasetContentDeliveryRule>,
        ) -> Self {
            self.inner = self.inner.content_delivery_rules(inp);
            self
        }
        pub fn set_content_delivery_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetContentDeliveryRule>>,
        ) -> Self {
            self.inner = self.inner.set_content_delivery_rules(input);
            self
        }
        /// <p>Optional. How long, in days, versions of dataset contents are kept for the dataset. If not
        /// specified or set to <code>null</code>, versions of dataset contents are retained for at most
        /// 90 days. The number of versions of dataset contents retained is determined by the
        /// <code>versioningConfiguration</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
        /// Analytics User Guide</i>.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
        /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
        /// only the latest version plus the latest succeeded version (if they are different) are kept for
        /// the time period specified by the <code>retentionPeriod</code> parameter. For more information,
        /// see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
        /// Analytics User Guide</i>.</p>
        pub fn versioning_configuration(
            mut self,
            input: crate::model::VersioningConfiguration,
        ) -> Self {
            self.inner = self.inner.versioning_configuration(input);
            self
        }
        pub fn set_versioning_configuration(
            mut self,
            input: std::option::Option<crate::model::VersioningConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_versioning_configuration(input);
            self
        }
        /// <p>Metadata which can be used to manage the data set.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
        /// specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
        /// filter.</p>
        pub fn late_data_rules(mut self, inp: impl Into<crate::model::LateDataRule>) -> Self {
            self.inner = self.inner.late_data_rules(inp);
            self
        }
        pub fn set_late_data_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LateDataRule>>,
        ) -> Self {
            self.inner = self.inner.set_late_data_rules(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDatasetContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dataset_content_input::Builder,
    }
    impl<C> CreateDatasetContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDatasetContentOutput,
            smithy_http::result::SdkError<crate::error::CreateDatasetContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dataset.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>The version ID of the dataset content. To specify <code>versionId</code> for a dataset
        /// content, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDatastore<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_datastore_input::Builder,
    }
    impl<C> CreateDatastore<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDatastoreOutput,
            smithy_http::result::SdkError<crate::error::CreateDatastoreError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data store.</p>
        pub fn datastore_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.datastore_name(input);
            self
        }
        pub fn set_datastore_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_datastore_name(input);
            self
        }
        /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
        /// <code>customerManagedS3</code> storage. If not specified, the default is
        /// <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
        /// created.</p>
        pub fn datastore_storage(mut self, input: crate::model::DatastoreStorage) -> Self {
            self.inner = self.inner.datastore_storage(input);
            self
        }
        pub fn set_datastore_storage(
            mut self,
            input: std::option::Option<crate::model::DatastoreStorage>,
        ) -> Self {
            self.inner = self.inner.set_datastore_storage(input);
            self
        }
        /// <p>How long, in days, message data is kept for the data store. When
        /// <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
        /// <p>Metadata which can be used to manage the data store.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
        /// and <a href="https://parquet.apache.org/">Parquet</a>.</p>
        /// <p>The default file format is JSON. You can specify only one format.</p>
        /// <p>You can't change the file format after you create the data store.</p>
        pub fn file_format_configuration(
            mut self,
            input: crate::model::FileFormatConfiguration,
        ) -> Self {
            self.inner = self.inner.file_format_configuration(input);
            self
        }
        pub fn set_file_format_configuration(
            mut self,
            input: std::option::Option<crate::model::FileFormatConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_file_format_configuration(input);
            self
        }
        /// <p>
        /// Contains information about the partitions in a data store.
        /// </p>
        pub fn datastore_partitions(mut self, input: crate::model::DatastorePartitions) -> Self {
            self.inner = self.inner.datastore_partitions(input);
            self
        }
        pub fn set_datastore_partitions(
            mut self,
            input: std::option::Option<crate::model::DatastorePartitions>,
        ) -> Self {
            self.inner = self.inner.set_datastore_partitions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pipeline_input::Builder,
    }
    impl<C> CreatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePipelineOutput,
            smithy_http::result::SdkError<crate::error::CreatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
        /// your messages, such as removing, renaming or adding message attributes; filtering messages
        /// based on attribute values; invoking your Lambda functions on messages for advanced processing;
        /// or performing mathematical transformations to normalize device data.</p>
        /// <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
        /// <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
        /// contain only one activity. For example:</p>
        /// <p>
        /// <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
        /// ]</code>
        /// </p>
        pub fn pipeline_activities(
            mut self,
            inp: impl Into<crate::model::PipelineActivity>,
        ) -> Self {
            self.inner = self.inner.pipeline_activities(inp);
            self
        }
        pub fn set_pipeline_activities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PipelineActivity>>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_activities(input);
            self
        }
        /// <p>Metadata which can be used to manage the pipeline.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_channel_input::Builder,
    }
    impl<C> DeleteChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteChannelOutput,
            smithy_http::result::SdkError<crate::error::DeleteChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel to delete.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDataset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dataset_input::Builder,
    }
    impl<C> DeleteDataset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDatasetOutput,
            smithy_http::result::SdkError<crate::error::DeleteDatasetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set to delete.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDatasetContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dataset_content_input::Builder,
    }
    impl<C> DeleteDatasetContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDatasetContentOutput,
            smithy_http::result::SdkError<crate::error::DeleteDatasetContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dataset whose content is deleted.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>The version of the dataset whose content is deleted. You can also use the strings
        /// "$LATEST" or "$LATEST_SUCCEEDED" to delete the latest or latest successfully completed data
        /// set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDatastore<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_datastore_input::Builder,
    }
    impl<C> DeleteDatastore<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDatastoreOutput,
            smithy_http::result::SdkError<crate::error::DeleteDatastoreError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data store to delete.</p>
        pub fn datastore_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.datastore_name(input);
            self
        }
        pub fn set_datastore_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_datastore_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_pipeline_input::Builder,
    }
    impl<C> DeletePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeletePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to delete.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_channel_input::Builder,
    }
    impl<C> DescribeChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeChannelOutput,
            smithy_http::result::SdkError<crate::error::DescribeChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel whose information is retrieved.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>If true, additional statistical information about the channel is included in the response.
        /// This feature cannot be used with a channel whose S3 storage is customer-managed.</p>
        pub fn include_statistics(mut self, input: bool) -> Self {
            self.inner = self.inner.include_statistics(input);
            self
        }
        pub fn set_include_statistics(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDataset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_dataset_input::Builder,
    }
    impl<C> DescribeDataset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDatasetOutput,
            smithy_http::result::SdkError<crate::error::DescribeDatasetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set whose information is retrieved.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDatastore<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_datastore_input::Builder,
    }
    impl<C> DescribeDatastore<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDatastoreOutput,
            smithy_http::result::SdkError<crate::error::DescribeDatastoreError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data store</p>
        pub fn datastore_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.datastore_name(input);
            self
        }
        pub fn set_datastore_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_datastore_name(input);
            self
        }
        /// <p>If true, additional statistical information about the data store is included in the
        /// response. This feature cannot be used with a data store whose S3 storage is
        /// customer-managed.</p>
        pub fn include_statistics(mut self, input: bool) -> Self {
            self.inner = self.inner.include_statistics(input);
            self
        }
        pub fn set_include_statistics(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_logging_options_input::Builder,
    }
    impl<C> DescribeLoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_pipeline_input::Builder,
    }
    impl<C> DescribePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePipelineOutput,
            smithy_http::result::SdkError<crate::error::DescribePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline whose information is retrieved.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDatasetContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dataset_content_input::Builder,
    }
    impl<C> GetDatasetContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDatasetContentOutput,
            smithy_http::result::SdkError<crate::error::GetDatasetContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set whose contents are retrieved.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>The version of the data set whose contents are retrieved. You can also use the strings
        /// "$LATEST" or "$LATEST_SUCCEEDED" to retrieve the contents of the latest or latest successfully
        /// completed data set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListChannels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_channels_input::Builder,
    }
    impl<C> ListChannels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListChannelsOutput,
            smithy_http::result::SdkError<crate::error::ListChannelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        /// <p>The default value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDatasetContents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_dataset_contents_input::Builder,
    }
    impl<C> ListDatasetContents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDatasetContentsOutput,
            smithy_http::result::SdkError<crate::error::ListDatasetContentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set whose contents information you want to list.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A filter to limit results to those data set contents whose creation is scheduled on or
        /// after the given time. See the field <code>triggers.schedule</code> in the
        /// <code>CreateDataset</code> request. (timestamp)</p>
        pub fn scheduled_on_or_after(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.scheduled_on_or_after(input);
            self
        }
        pub fn set_scheduled_on_or_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_on_or_after(input);
            self
        }
        /// <p>A filter to limit results to those data set contents whose creation is scheduled before
        /// the given time. See the field <code>triggers.schedule</code> in the <code>CreateDataset</code>
        /// request. (timestamp)</p>
        pub fn scheduled_before(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.scheduled_before(input);
            self
        }
        pub fn set_scheduled_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_before(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDatasets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_datasets_input::Builder,
    }
    impl<C> ListDatasets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDatasetsOutput,
            smithy_http::result::SdkError<crate::error::ListDatasetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        /// <p>The default value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDatastores<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_datastores_input::Builder,
    }
    impl<C> ListDatastores<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDatastoresOutput,
            smithy_http::result::SdkError<crate::error::ListDatastoresError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        /// <p>The default value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pipelines_input::Builder,
    }
    impl<C> ListPipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPipelinesOutput,
            smithy_http::result::SdkError<crate::error::ListPipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        /// <p>The default value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource whose tags you want to list.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_logging_options_input::Builder,
    }
    impl<C> PutLoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::PutLoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The new values of the AWS IoT Analytics logging options.</p>
        pub fn logging_options(mut self, input: crate::model::LoggingOptions) -> Self {
            self.inner = self.inner.logging_options(input);
            self
        }
        pub fn set_logging_options(
            mut self,
            input: std::option::Option<crate::model::LoggingOptions>,
        ) -> Self {
            self.inner = self.inner.set_logging_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RunPipelineActivity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::run_pipeline_activity_input::Builder,
    }
    impl<C> RunPipelineActivity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RunPipelineActivityOutput,
            smithy_http::result::SdkError<crate::error::RunPipelineActivityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The pipeline activity that is run. This must not be a channel activity or a datastore
        /// activity because these activities are used in a pipeline only to load the original message and
        /// to store the (possibly) transformed message. If a lambda activity is specified, only
        /// short-running Lambda functions (those with a timeout of less than 30 seconds or less) can be
        /// used.</p>
        pub fn pipeline_activity(mut self, input: crate::model::PipelineActivity) -> Self {
            self.inner = self.inner.pipeline_activity(input);
            self
        }
        pub fn set_pipeline_activity(
            mut self,
            input: std::option::Option<crate::model::PipelineActivity>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_activity(input);
            self
        }
        /// <p>The sample message payloads on which the pipeline activity is run.</p>
        pub fn payloads(mut self, inp: impl Into<smithy_types::Blob>) -> Self {
            self.inner = self.inner.payloads(inp);
            self
        }
        pub fn set_payloads(
            mut self,
            input: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
        ) -> Self {
            self.inner = self.inner.set_payloads(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SampleChannelData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::sample_channel_data_input::Builder,
    }
    impl<C> SampleChannelData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SampleChannelDataOutput,
            smithy_http::result::SdkError<crate::error::SampleChannelDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel whose message samples are retrieved.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The number of sample messages to be retrieved. The limit is 10. The default is also
        /// 10.</p>
        pub fn max_messages(mut self, input: i32) -> Self {
            self.inner = self.inner.max_messages(input);
            self
        }
        pub fn set_max_messages(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_messages(input);
            self
        }
        /// <p>The start of the time window from which sample messages are retrieved.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time window from which sample messages are retrieved.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartPipelineReprocessing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_pipeline_reprocessing_input::Builder,
    }
    impl<C> StartPipelineReprocessing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartPipelineReprocessingOutput,
            smithy_http::result::SdkError<crate::error::StartPipelineReprocessingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline on which to start reprocessing.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The start time (inclusive) of raw message data that is reprocessed.</p>
        /// <p>If you specify a value for the <code>startTime</code> parameter, you must not use the
        /// <code>channelMessages</code> object.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time (exclusive) of raw message data that is reprocessed.</p>
        /// <p>If you specify a value for the <code>endTime</code> parameter, you must not use the
        /// <code>channelMessages</code> object.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>Specifies one or more sets of channel messages that you want to reprocess.</p>
        /// <p>If you use the <code>channelMessages</code> object, you must not specify a value for
        /// <code>startTime</code> and <code>endTime</code>.</p>
        pub fn channel_messages(mut self, input: crate::model::ChannelMessages) -> Self {
            self.inner = self.inner.channel_messages(input);
            self
        }
        pub fn set_channel_messages(
            mut self,
            input: std::option::Option<crate::model::ChannelMessages>,
        ) -> Self {
            self.inner = self.inner.set_channel_messages(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource whose tags you want to modify.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The new or modified tags for the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource whose tags you want to remove.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The keys of those tags which you want to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_channel_input::Builder,
    }
    impl<C> UpdateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateChannelOutput,
            smithy_http::result::SdkError<crate::error::UpdateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the channel to be updated.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
        /// <code>customerManagedS3</code> storage. If not specified, the default is
        /// <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
        /// created.</p>
        pub fn channel_storage(mut self, input: crate::model::ChannelStorage) -> Self {
            self.inner = self.inner.channel_storage(input);
            self
        }
        pub fn set_channel_storage(
            mut self,
            input: std::option::Option<crate::model::ChannelStorage>,
        ) -> Self {
            self.inner = self.inner.set_channel_storage(input);
            self
        }
        /// <p>How long, in days, message data is kept for the channel. The retention period cannot be
        /// updated if the channel's S3 storage is customer-managed.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDataset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_dataset_input::Builder,
    }
    impl<C> UpdateDataset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDatasetOutput,
            smithy_http::result::SdkError<crate::error::UpdateDatasetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data set to update.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dataset_name(input);
            self
        }
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dataset_name(input);
            self
        }
        /// <p>A list of <code>DatasetAction</code> objects.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::DatasetAction>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetAction>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>A list of <code>DatasetTrigger</code> objects. The list can be empty or can contain up to
        /// five <code>DatasetTrigger</code> objects.</p>
        pub fn triggers(mut self, inp: impl Into<crate::model::DatasetTrigger>) -> Self {
            self.inner = self.inner.triggers(inp);
            self
        }
        pub fn set_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetTrigger>>,
        ) -> Self {
            self.inner = self.inner.set_triggers(input);
            self
        }
        /// <p>When dataset contents are created, they are delivered to destinations specified
        /// here.</p>
        pub fn content_delivery_rules(
            mut self,
            inp: impl Into<crate::model::DatasetContentDeliveryRule>,
        ) -> Self {
            self.inner = self.inner.content_delivery_rules(inp);
            self
        }
        pub fn set_content_delivery_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetContentDeliveryRule>>,
        ) -> Self {
            self.inner = self.inner.set_content_delivery_rules(input);
            self
        }
        /// <p>How long, in days, dataset contents are kept for the dataset.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
        /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
        /// only the latest version plus the latest succeeded version (if they are different) are kept for
        /// the time period specified by the <code>retentionPeriod</code> parameter. For more information,
        /// see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
        /// Analytics User Guide</i>.</p>
        pub fn versioning_configuration(
            mut self,
            input: crate::model::VersioningConfiguration,
        ) -> Self {
            self.inner = self.inner.versioning_configuration(input);
            self
        }
        pub fn set_versioning_configuration(
            mut self,
            input: std::option::Option<crate::model::VersioningConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_versioning_configuration(input);
            self
        }
        /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
        /// specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
        /// filter.</p>
        pub fn late_data_rules(mut self, inp: impl Into<crate::model::LateDataRule>) -> Self {
            self.inner = self.inner.late_data_rules(inp);
            self
        }
        pub fn set_late_data_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LateDataRule>>,
        ) -> Self {
            self.inner = self.inner.set_late_data_rules(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDatastore<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_datastore_input::Builder,
    }
    impl<C> UpdateDatastore<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDatastoreOutput,
            smithy_http::result::SdkError<crate::error::UpdateDatastoreError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data store to be updated.</p>
        pub fn datastore_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.datastore_name(input);
            self
        }
        pub fn set_datastore_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_datastore_name(input);
            self
        }
        /// <p>How long, in days, message data is kept for the data store. The retention period cannot be
        /// updated if the data store's S3 storage is customer-managed.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.inner = self.inner.retention_period(input);
            self
        }
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.inner = self.inner.set_retention_period(input);
            self
        }
        /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
        /// <code>customerManagedS3</code> storage. If not specified, the default
        /// is<code>serviceManagedS3</code>. You cannot change this storage option after the data store
        /// is created.</p>
        pub fn datastore_storage(mut self, input: crate::model::DatastoreStorage) -> Self {
            self.inner = self.inner.datastore_storage(input);
            self
        }
        pub fn set_datastore_storage(
            mut self,
            input: std::option::Option<crate::model::DatastoreStorage>,
        ) -> Self {
            self.inner = self.inner.set_datastore_storage(input);
            self
        }
        /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
        /// and <a href="https://parquet.apache.org/">Parquet</a>.</p>
        /// <p>The default file format is JSON. You can specify only one format.</p>
        /// <p>You can't change the file format after you create the data store.</p>
        pub fn file_format_configuration(
            mut self,
            input: crate::model::FileFormatConfiguration,
        ) -> Self {
            self.inner = self.inner.file_format_configuration(input);
            self
        }
        pub fn set_file_format_configuration(
            mut self,
            input: std::option::Option<crate::model::FileFormatConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_file_format_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pipeline_input::Builder,
    }
    impl<C> UpdatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePipelineOutput,
            smithy_http::result::SdkError<crate::error::UpdatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to update.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
        /// your messages, such as removing, renaming or adding message attributes; filtering messages
        /// based on attribute values; invoking your Lambda functions on messages for advanced processing;
        /// or performing mathematical transformations to normalize device data.</p>
        /// <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
        /// <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
        /// contain only one activity. For example:</p>
        /// <p>
        /// <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
        /// ]</code>
        /// </p>
        pub fn pipeline_activities(
            mut self,
            inp: impl Into<crate::model::PipelineActivity>,
        ) -> Self {
            self.inner = self.inner.pipeline_activities(inp);
            self
        }
        pub fn set_pipeline_activities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PipelineActivity>>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_activities(input);
            self
        }
    }
}
