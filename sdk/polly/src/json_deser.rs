// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, serde_json::Error> {
    let body =
        serde_json::from_slice(response.body().as_ref()).unwrap_or_else(|_| serde_json::json!({}));
    Ok(crate::aws_json_errors::parse_generic_error(
        &response, &body,
    ))
}

pub fn lexicon_not_found_exception(
    input: &[u8],
    mut builder: crate::error::lexicon_not_found_error::Builder,
) -> std::result::Result<crate::error::lexicon_not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::LexiconNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn service_failure_exception(
    input: &[u8],
    mut builder: crate::error::service_failure_error::Builder,
) -> std::result::Result<crate::error::service_failure_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ServiceFailureError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_next_token_exception(
    input: &[u8],
    mut builder: crate::error::invalid_next_token_error::Builder,
) -> std::result::Result<crate::error::invalid_next_token_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidNextTokenError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn describe_voices_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_voices_output::Builder,
) -> std::result::Result<crate::output::describe_voices_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeVoicesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_voices(parsed_body.voices);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_lexicon_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_lexicon_output::Builder,
) -> std::result::Result<crate::output::get_lexicon_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetLexiconOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_lexicon(parsed_body.lexicon);
    builder = builder.set_lexicon_attributes(parsed_body.lexicon_attributes);
    Ok(builder)
}

pub fn invalid_task_id_exception(
    input: &[u8],
    mut builder: crate::error::invalid_task_id_error::Builder,
) -> std::result::Result<crate::error::invalid_task_id_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidTaskIdError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn synthesis_task_not_found_exception(
    input: &[u8],
    mut builder: crate::error::synthesis_task_not_found_error::Builder,
) -> std::result::Result<crate::error::synthesis_task_not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::SynthesisTaskNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn get_speech_synthesis_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_speech_synthesis_task_output::Builder,
) -> std::result::Result<crate::output::get_speech_synthesis_task_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetSpeechSynthesisTaskOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_synthesis_task(parsed_body.synthesis_task);
    Ok(builder)
}

pub fn list_lexicons_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_lexicons_output::Builder,
) -> std::result::Result<crate::output::list_lexicons_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListLexiconsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_lexicons(parsed_body.lexicons);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_speech_synthesis_tasks_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_speech_synthesis_tasks_output::Builder,
) -> std::result::Result<
    crate::output::list_speech_synthesis_tasks_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListSpeechSynthesisTasksOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_synthesis_tasks(parsed_body.synthesis_tasks);
    Ok(builder)
}

pub fn invalid_lexicon_exception(
    input: &[u8],
    mut builder: crate::error::invalid_lexicon_error::Builder,
) -> std::result::Result<crate::error::invalid_lexicon_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidLexiconError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn lexicon_size_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::lexicon_size_exceeded_error::Builder,
) -> std::result::Result<crate::error::lexicon_size_exceeded_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::LexiconSizeExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn max_lexeme_length_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::max_lexeme_length_exceeded_error::Builder,
) -> std::result::Result<crate::error::max_lexeme_length_exceeded_error::Builder, serde_json::Error>
{
    let parsed_body: crate::error::MaxLexemeLengthExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn max_lexicons_number_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::max_lexicons_number_exceeded_error::Builder,
) -> std::result::Result<crate::error::max_lexicons_number_exceeded_error::Builder, serde_json::Error>
{
    let parsed_body: crate::error::MaxLexiconsNumberExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn unsupported_pls_alphabet_exception(
    input: &[u8],
    mut builder: crate::error::unsupported_pls_alphabet_error::Builder,
) -> std::result::Result<crate::error::unsupported_pls_alphabet_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::UnsupportedPlsAlphabetError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn unsupported_pls_language_exception(
    input: &[u8],
    mut builder: crate::error::unsupported_pls_language_error::Builder,
) -> std::result::Result<crate::error::unsupported_pls_language_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::UnsupportedPlsLanguageError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn engine_not_supported_exception(
    input: &[u8],
    mut builder: crate::error::engine_not_supported_error::Builder,
) -> std::result::Result<crate::error::engine_not_supported_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EngineNotSupportedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_s3_bucket_exception(
    input: &[u8],
    mut builder: crate::error::invalid_s3_bucket_error::Builder,
) -> std::result::Result<crate::error::invalid_s3_bucket_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidS3BucketError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_s3_key_exception(
    input: &[u8],
    mut builder: crate::error::invalid_s3_key_error::Builder,
) -> std::result::Result<crate::error::invalid_s3_key_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidS3KeyError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_sample_rate_exception(
    input: &[u8],
    mut builder: crate::error::invalid_sample_rate_error::Builder,
) -> std::result::Result<crate::error::invalid_sample_rate_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidSampleRateError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_sns_topic_arn_exception(
    input: &[u8],
    mut builder: crate::error::invalid_sns_topic_arn_error::Builder,
) -> std::result::Result<crate::error::invalid_sns_topic_arn_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidSnsTopicArnError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_ssml_exception(
    input: &[u8],
    mut builder: crate::error::invalid_ssml_error::Builder,
) -> std::result::Result<crate::error::invalid_ssml_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidSsmlError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn language_not_supported_exception(
    input: &[u8],
    mut builder: crate::error::language_not_supported_error::Builder,
) -> std::result::Result<crate::error::language_not_supported_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::LanguageNotSupportedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn marks_not_supported_for_format_exception(
    input: &[u8],
    mut builder: crate::error::marks_not_supported_for_format_error::Builder,
) -> std::result::Result<
    crate::error::marks_not_supported_for_format_error::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::error::MarksNotSupportedForFormatError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn ssml_marks_not_supported_for_text_type_exception(
    input: &[u8],
    mut builder: crate::error::ssml_marks_not_supported_for_text_type_error::Builder,
) -> std::result::Result<
    crate::error::ssml_marks_not_supported_for_text_type_error::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::error::SsmlMarksNotSupportedForTextTypeError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn text_length_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::text_length_exceeded_error::Builder,
) -> std::result::Result<crate::error::text_length_exceeded_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::TextLengthExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn start_speech_synthesis_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_speech_synthesis_task_output::Builder,
) -> std::result::Result<
    crate::output::start_speech_synthesis_task_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::StartSpeechSynthesisTaskOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_synthesis_task(parsed_body.synthesis_task);
    Ok(builder)
}
