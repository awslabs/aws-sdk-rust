// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VoiceId {
    Aditi,
    Amy,
    Astrid,
    Bianca,
    Brian,
    Camila,
    Carla,
    Carmen,
    Celine,
    Chantal,
    Conchita,
    Cristiano,
    Dora,
    Emma,
    Enrique,
    Ewa,
    Filiz,
    Gabrielle,
    Geraint,
    Giorgio,
    Gwyneth,
    Hans,
    Ines,
    Ivy,
    Jacek,
    Jan,
    Joanna,
    Joey,
    Justin,
    Karl,
    Kendra,
    Kevin,
    Kimberly,
    Lea,
    Liv,
    Lotte,
    Lucia,
    Lupe,
    Mads,
    Maja,
    Marlene,
    Mathieu,
    Matthew,
    Maxim,
    Mia,
    Miguel,
    Mizuki,
    Naja,
    Nicole,
    Olivia,
    Penelope,
    Raveena,
    Ricardo,
    Ruben,
    Russell,
    Salli,
    Seoyeon,
    Takumi,
    Tatyana,
    Vicki,
    Vitoria,
    Zeina,
    Zhiyu,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VoiceId {
    fn from(s: &str) -> Self {
        match s {
            "Aditi" => VoiceId::Aditi,
            "Amy" => VoiceId::Amy,
            "Astrid" => VoiceId::Astrid,
            "Bianca" => VoiceId::Bianca,
            "Brian" => VoiceId::Brian,
            "Camila" => VoiceId::Camila,
            "Carla" => VoiceId::Carla,
            "Carmen" => VoiceId::Carmen,
            "Celine" => VoiceId::Celine,
            "Chantal" => VoiceId::Chantal,
            "Conchita" => VoiceId::Conchita,
            "Cristiano" => VoiceId::Cristiano,
            "Dora" => VoiceId::Dora,
            "Emma" => VoiceId::Emma,
            "Enrique" => VoiceId::Enrique,
            "Ewa" => VoiceId::Ewa,
            "Filiz" => VoiceId::Filiz,
            "Gabrielle" => VoiceId::Gabrielle,
            "Geraint" => VoiceId::Geraint,
            "Giorgio" => VoiceId::Giorgio,
            "Gwyneth" => VoiceId::Gwyneth,
            "Hans" => VoiceId::Hans,
            "Ines" => VoiceId::Ines,
            "Ivy" => VoiceId::Ivy,
            "Jacek" => VoiceId::Jacek,
            "Jan" => VoiceId::Jan,
            "Joanna" => VoiceId::Joanna,
            "Joey" => VoiceId::Joey,
            "Justin" => VoiceId::Justin,
            "Karl" => VoiceId::Karl,
            "Kendra" => VoiceId::Kendra,
            "Kevin" => VoiceId::Kevin,
            "Kimberly" => VoiceId::Kimberly,
            "Lea" => VoiceId::Lea,
            "Liv" => VoiceId::Liv,
            "Lotte" => VoiceId::Lotte,
            "Lucia" => VoiceId::Lucia,
            "Lupe" => VoiceId::Lupe,
            "Mads" => VoiceId::Mads,
            "Maja" => VoiceId::Maja,
            "Marlene" => VoiceId::Marlene,
            "Mathieu" => VoiceId::Mathieu,
            "Matthew" => VoiceId::Matthew,
            "Maxim" => VoiceId::Maxim,
            "Mia" => VoiceId::Mia,
            "Miguel" => VoiceId::Miguel,
            "Mizuki" => VoiceId::Mizuki,
            "Naja" => VoiceId::Naja,
            "Nicole" => VoiceId::Nicole,
            "Olivia" => VoiceId::Olivia,
            "Penelope" => VoiceId::Penelope,
            "Raveena" => VoiceId::Raveena,
            "Ricardo" => VoiceId::Ricardo,
            "Ruben" => VoiceId::Ruben,
            "Russell" => VoiceId::Russell,
            "Salli" => VoiceId::Salli,
            "Seoyeon" => VoiceId::Seoyeon,
            "Takumi" => VoiceId::Takumi,
            "Tatyana" => VoiceId::Tatyana,
            "Vicki" => VoiceId::Vicki,
            "Vitoria" => VoiceId::Vitoria,
            "Zeina" => VoiceId::Zeina,
            "Zhiyu" => VoiceId::Zhiyu,
            other => VoiceId::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VoiceId {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(VoiceId::from(s))
    }
}
impl VoiceId {
    pub fn as_str(&self) -> &str {
        match self {
            VoiceId::Aditi => "Aditi",
            VoiceId::Amy => "Amy",
            VoiceId::Astrid => "Astrid",
            VoiceId::Bianca => "Bianca",
            VoiceId::Brian => "Brian",
            VoiceId::Camila => "Camila",
            VoiceId::Carla => "Carla",
            VoiceId::Carmen => "Carmen",
            VoiceId::Celine => "Celine",
            VoiceId::Chantal => "Chantal",
            VoiceId::Conchita => "Conchita",
            VoiceId::Cristiano => "Cristiano",
            VoiceId::Dora => "Dora",
            VoiceId::Emma => "Emma",
            VoiceId::Enrique => "Enrique",
            VoiceId::Ewa => "Ewa",
            VoiceId::Filiz => "Filiz",
            VoiceId::Gabrielle => "Gabrielle",
            VoiceId::Geraint => "Geraint",
            VoiceId::Giorgio => "Giorgio",
            VoiceId::Gwyneth => "Gwyneth",
            VoiceId::Hans => "Hans",
            VoiceId::Ines => "Ines",
            VoiceId::Ivy => "Ivy",
            VoiceId::Jacek => "Jacek",
            VoiceId::Jan => "Jan",
            VoiceId::Joanna => "Joanna",
            VoiceId::Joey => "Joey",
            VoiceId::Justin => "Justin",
            VoiceId::Karl => "Karl",
            VoiceId::Kendra => "Kendra",
            VoiceId::Kevin => "Kevin",
            VoiceId::Kimberly => "Kimberly",
            VoiceId::Lea => "Lea",
            VoiceId::Liv => "Liv",
            VoiceId::Lotte => "Lotte",
            VoiceId::Lucia => "Lucia",
            VoiceId::Lupe => "Lupe",
            VoiceId::Mads => "Mads",
            VoiceId::Maja => "Maja",
            VoiceId::Marlene => "Marlene",
            VoiceId::Mathieu => "Mathieu",
            VoiceId::Matthew => "Matthew",
            VoiceId::Maxim => "Maxim",
            VoiceId::Mia => "Mia",
            VoiceId::Miguel => "Miguel",
            VoiceId::Mizuki => "Mizuki",
            VoiceId::Naja => "Naja",
            VoiceId::Nicole => "Nicole",
            VoiceId::Olivia => "Olivia",
            VoiceId::Penelope => "Penelope",
            VoiceId::Raveena => "Raveena",
            VoiceId::Ricardo => "Ricardo",
            VoiceId::Ruben => "Ruben",
            VoiceId::Russell => "Russell",
            VoiceId::Salli => "Salli",
            VoiceId::Seoyeon => "Seoyeon",
            VoiceId::Takumi => "Takumi",
            VoiceId::Tatyana => "Tatyana",
            VoiceId::Vicki => "Vicki",
            VoiceId::Vitoria => "Vitoria",
            VoiceId::Zeina => "Zeina",
            VoiceId::Zhiyu => "Zhiyu",
            VoiceId::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for VoiceId {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for VoiceId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TextType {
    Ssml,
    Text,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TextType {
    fn from(s: &str) -> Self {
        match s {
            "ssml" => TextType::Ssml,
            "text" => TextType::Text,
            other => TextType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TextType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TextType::from(s))
    }
}
impl TextType {
    pub fn as_str(&self) -> &str {
        match self {
            TextType::Ssml => "ssml",
            TextType::Text => "text",
            TextType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TextType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpeechMarkType {
    Sentence,
    Ssml,
    Viseme,
    Word,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpeechMarkType {
    fn from(s: &str) -> Self {
        match s {
            "sentence" => SpeechMarkType::Sentence,
            "ssml" => SpeechMarkType::Ssml,
            "viseme" => SpeechMarkType::Viseme,
            "word" => SpeechMarkType::Word,
            other => SpeechMarkType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpeechMarkType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SpeechMarkType::from(s))
    }
}
impl SpeechMarkType {
    pub fn as_str(&self) -> &str {
        match self {
            SpeechMarkType::Sentence => "sentence",
            SpeechMarkType::Ssml => "ssml",
            SpeechMarkType::Viseme => "viseme",
            SpeechMarkType::Word => "word",
            SpeechMarkType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SpeechMarkType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SpeechMarkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputFormat {
    Json,
    Mp3,
    OggVorbis,
    Pcm,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OutputFormat {
    fn from(s: &str) -> Self {
        match s {
            "json" => OutputFormat::Json,
            "mp3" => OutputFormat::Mp3,
            "ogg_vorbis" => OutputFormat::OggVorbis,
            "pcm" => OutputFormat::Pcm,
            other => OutputFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OutputFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OutputFormat::from(s))
    }
}
impl OutputFormat {
    pub fn as_str(&self) -> &str {
        match self {
            OutputFormat::Json => "json",
            OutputFormat::Mp3 => "mp3",
            OutputFormat::OggVorbis => "ogg_vorbis",
            OutputFormat::Pcm => "pcm",
            OutputFormat::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OutputFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OutputFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    Arb,
    CmnCn,
    CyGb,
    DaDk,
    DeDe,
    EnAu,
    EnGb,
    EnGbWls,
    EnIn,
    EnUs,
    EsEs,
    EsMx,
    EsUs,
    FrCa,
    FrFr,
    HiIn,
    IsIs,
    ItIt,
    JaJp,
    KoKr,
    NbNo,
    NlNl,
    PlPl,
    PtBr,
    PtPt,
    RoRo,
    RuRu,
    SvSe,
    TrTr,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "arb" => LanguageCode::Arb,
            "cmn-CN" => LanguageCode::CmnCn,
            "cy-GB" => LanguageCode::CyGb,
            "da-DK" => LanguageCode::DaDk,
            "de-DE" => LanguageCode::DeDe,
            "en-AU" => LanguageCode::EnAu,
            "en-GB" => LanguageCode::EnGb,
            "en-GB-WLS" => LanguageCode::EnGbWls,
            "en-IN" => LanguageCode::EnIn,
            "en-US" => LanguageCode::EnUs,
            "es-ES" => LanguageCode::EsEs,
            "es-MX" => LanguageCode::EsMx,
            "es-US" => LanguageCode::EsUs,
            "fr-CA" => LanguageCode::FrCa,
            "fr-FR" => LanguageCode::FrFr,
            "hi-IN" => LanguageCode::HiIn,
            "is-IS" => LanguageCode::IsIs,
            "it-IT" => LanguageCode::ItIt,
            "ja-JP" => LanguageCode::JaJp,
            "ko-KR" => LanguageCode::KoKr,
            "nb-NO" => LanguageCode::NbNo,
            "nl-NL" => LanguageCode::NlNl,
            "pl-PL" => LanguageCode::PlPl,
            "pt-BR" => LanguageCode::PtBr,
            "pt-PT" => LanguageCode::PtPt,
            "ro-RO" => LanguageCode::RoRo,
            "ru-RU" => LanguageCode::RuRu,
            "sv-SE" => LanguageCode::SvSe,
            "tr-TR" => LanguageCode::TrTr,
            other => LanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::Arb => "arb",
            LanguageCode::CmnCn => "cmn-CN",
            LanguageCode::CyGb => "cy-GB",
            LanguageCode::DaDk => "da-DK",
            LanguageCode::DeDe => "de-DE",
            LanguageCode::EnAu => "en-AU",
            LanguageCode::EnGb => "en-GB",
            LanguageCode::EnGbWls => "en-GB-WLS",
            LanguageCode::EnIn => "en-IN",
            LanguageCode::EnUs => "en-US",
            LanguageCode::EsEs => "es-ES",
            LanguageCode::EsMx => "es-MX",
            LanguageCode::EsUs => "es-US",
            LanguageCode::FrCa => "fr-CA",
            LanguageCode::FrFr => "fr-FR",
            LanguageCode::HiIn => "hi-IN",
            LanguageCode::IsIs => "is-IS",
            LanguageCode::ItIt => "it-IT",
            LanguageCode::JaJp => "ja-JP",
            LanguageCode::KoKr => "ko-KR",
            LanguageCode::NbNo => "nb-NO",
            LanguageCode::NlNl => "nl-NL",
            LanguageCode::PlPl => "pl-PL",
            LanguageCode::PtBr => "pt-BR",
            LanguageCode::PtPt => "pt-PT",
            LanguageCode::RoRo => "ro-RO",
            LanguageCode::RuRu => "ru-RU",
            LanguageCode::SvSe => "sv-SE",
            LanguageCode::TrTr => "tr-TR",
            LanguageCode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for LanguageCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Engine {
    Neural,
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Engine {
    fn from(s: &str) -> Self {
        match s {
            "neural" => Engine::Neural,
            "standard" => Engine::Standard,
            other => Engine::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Engine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Engine::from(s))
    }
}
impl Engine {
    pub fn as_str(&self) -> &str {
        match self {
            Engine::Neural => "neural",
            Engine::Standard => "standard",
            Engine::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Engine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Engine {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>SynthesisTask object that provides information about a speech synthesis task.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SynthesisTask {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to
    /// use when processing input text for speech synthesis. Using a voice that is not supported for
    /// the engine selected will result in an error.</p>
    #[serde(rename = "Engine")]
    #[serde(default)]
    pub engine: std::option::Option<crate::model::Engine>,
    /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
    #[serde(rename = "TaskId")]
    #[serde(default)]
    pub task_id: std::option::Option<std::string::String>,
    /// <p>Current status of the individual speech synthesis task.</p>
    #[serde(rename = "TaskStatus")]
    #[serde(default)]
    pub task_status: std::option::Option<crate::model::TaskStatus>,
    /// <p>Reason for the current status of a specific speech synthesis task, including errors if the
    /// task has failed.</p>
    #[serde(rename = "TaskStatusReason")]
    #[serde(default)]
    pub task_status_reason: std::option::Option<std::string::String>,
    /// <p>Pathway for the output speech file.</p>
    #[serde(rename = "OutputUri")]
    #[serde(default)]
    pub output_uri: std::option::Option<std::string::String>,
    /// <p>Timestamp for the time the synthesis task was started.</p>
    #[serde(rename = "CreationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Number of billable characters synthesized.</p>
    #[serde(rename = "RequestCharacters")]
    #[serde(default)]
    pub request_characters: i32,
    /// <p>ARN for the SNS topic optionally used for providing status notification for a speech
    /// synthesis task.</p>
    #[serde(rename = "SnsTopicArn")]
    #[serde(default)]
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during
    /// synthesis. Lexicons are applied only if the language of the lexicon is the same as the
    /// language of the voice. </p>
    #[serde(rename = "LexiconNames")]
    #[serde(default)]
    pub lexicon_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The format in which the returned output will be encoded. For audio stream, this will be
    /// mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    #[serde(rename = "OutputFormat")]
    #[serde(default)]
    pub output_format: std::option::Option<crate::model::OutputFormat>,
    /// <p>The audio frequency specified in Hz.</p>
    /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The
    /// default value for standard voices is "22050". The default value for neural voices is
    /// "24000".</p>
    /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    #[serde(rename = "SampleRate")]
    #[serde(default)]
    pub sample_rate: std::option::Option<std::string::String>,
    /// <p>The type of speech marks returned for the input text.</p>
    #[serde(rename = "SpeechMarkTypes")]
    #[serde(default)]
    pub speech_mark_types: std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
    /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text.
    /// </p>
    #[serde(rename = "TextType")]
    #[serde(default)]
    pub text_type: std::option::Option<crate::model::TextType>,
    /// <p>Voice ID to use for the synthesis. </p>
    #[serde(rename = "VoiceId")]
    #[serde(default)]
    pub voice_id: std::option::Option<crate::model::VoiceId>,
    /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual
    /// voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
    /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly will use the
    /// default language of the bilingual voice. The default language for any voice is the one
    /// returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example,
    /// if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    #[serde(rename = "LanguageCode")]
    #[serde(default)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
}
impl std::fmt::Debug for SynthesisTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SynthesisTask");
        formatter.field("engine", &self.engine);
        formatter.field("task_id", &self.task_id);
        formatter.field("task_status", &self.task_status);
        formatter.field("task_status_reason", &self.task_status_reason);
        formatter.field("output_uri", &self.output_uri);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("request_characters", &self.request_characters);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("lexicon_names", &self.lexicon_names);
        formatter.field("output_format", &self.output_format);
        formatter.field("sample_rate", &self.sample_rate);
        formatter.field("speech_mark_types", &self.speech_mark_types);
        formatter.field("text_type", &self.text_type);
        formatter.field("voice_id", &self.voice_id);
        formatter.field("language_code", &self.language_code);
        formatter.finish()
    }
}
/// See [`SynthesisTask`](crate::model::SynthesisTask)
pub mod synthesis_task {
    /// A builder for [`SynthesisTask`](crate::model::SynthesisTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine: std::option::Option<crate::model::Engine>,
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) task_status: std::option::Option<crate::model::TaskStatus>,
        pub(crate) task_status_reason: std::option::Option<std::string::String>,
        pub(crate) output_uri: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) request_characters: std::option::Option<i32>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) lexicon_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) output_format: std::option::Option<crate::model::OutputFormat>,
        pub(crate) sample_rate: std::option::Option<std::string::String>,
        pub(crate) speech_mark_types:
            std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
        pub(crate) text_type: std::option::Option<crate::model::TextType>,
        pub(crate) voice_id: std::option::Option<crate::model::VoiceId>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
    }
    impl Builder {
        /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to
        /// use when processing input text for speech synthesis. Using a voice that is not supported for
        /// the engine selected will result in an error.</p>
        pub fn engine(mut self, inp: crate::model::Engine) -> Self {
            self.engine = Some(inp);
            self
        }
        pub fn set_engine(mut self, inp: std::option::Option<crate::model::Engine>) -> Self {
            self.engine = inp;
            self
        }
        /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.task_id = Some(inp.into());
            self
        }
        pub fn set_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.task_id = inp;
            self
        }
        /// <p>Current status of the individual speech synthesis task.</p>
        pub fn task_status(mut self, inp: crate::model::TaskStatus) -> Self {
            self.task_status = Some(inp);
            self
        }
        pub fn set_task_status(
            mut self,
            inp: std::option::Option<crate::model::TaskStatus>,
        ) -> Self {
            self.task_status = inp;
            self
        }
        /// <p>Reason for the current status of a specific speech synthesis task, including errors if the
        /// task has failed.</p>
        pub fn task_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.task_status_reason = Some(inp.into());
            self
        }
        pub fn set_task_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_status_reason = inp;
            self
        }
        /// <p>Pathway for the output speech file.</p>
        pub fn output_uri(mut self, inp: impl Into<std::string::String>) -> Self {
            self.output_uri = Some(inp.into());
            self
        }
        pub fn set_output_uri(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.output_uri = inp;
            self
        }
        /// <p>Timestamp for the time the synthesis task was started.</p>
        pub fn creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_time = Some(inp);
            self
        }
        pub fn set_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = inp;
            self
        }
        /// <p>Number of billable characters synthesized.</p>
        pub fn request_characters(mut self, inp: i32) -> Self {
            self.request_characters = Some(inp);
            self
        }
        pub fn set_request_characters(mut self, inp: i32) -> Self {
            self.request_characters = Some(inp);
            self
        }
        /// <p>ARN for the SNS topic optionally used for providing status notification for a speech
        /// synthesis task.</p>
        pub fn sns_topic_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(inp.into());
            self
        }
        pub fn set_sns_topic_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.sns_topic_arn = inp;
            self
        }
        pub fn lexicon_names(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.lexicon_names.unwrap_or_default();
            v.push(inp.into());
            self.lexicon_names = Some(v);
            self
        }
        pub fn set_lexicon_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lexicon_names = inp;
            self
        }
        /// <p>The format in which the returned output will be encoded. For audio stream, this will be
        /// mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
        pub fn output_format(mut self, inp: crate::model::OutputFormat) -> Self {
            self.output_format = Some(inp);
            self
        }
        pub fn set_output_format(
            mut self,
            inp: std::option::Option<crate::model::OutputFormat>,
        ) -> Self {
            self.output_format = inp;
            self
        }
        /// <p>The audio frequency specified in Hz.</p>
        /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The
        /// default value for standard voices is "22050". The default value for neural voices is
        /// "24000".</p>
        /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
        pub fn sample_rate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.sample_rate = Some(inp.into());
            self
        }
        pub fn set_sample_rate(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.sample_rate = inp;
            self
        }
        pub fn speech_mark_types(mut self, inp: impl Into<crate::model::SpeechMarkType>) -> Self {
            let mut v = self.speech_mark_types.unwrap_or_default();
            v.push(inp.into());
            self.speech_mark_types = Some(v);
            self
        }
        pub fn set_speech_mark_types(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
        ) -> Self {
            self.speech_mark_types = inp;
            self
        }
        /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text.
        /// </p>
        pub fn text_type(mut self, inp: crate::model::TextType) -> Self {
            self.text_type = Some(inp);
            self
        }
        pub fn set_text_type(mut self, inp: std::option::Option<crate::model::TextType>) -> Self {
            self.text_type = inp;
            self
        }
        /// <p>Voice ID to use for the synthesis. </p>
        pub fn voice_id(mut self, inp: crate::model::VoiceId) -> Self {
            self.voice_id = Some(inp);
            self
        }
        pub fn set_voice_id(mut self, inp: std::option::Option<crate::model::VoiceId>) -> Self {
            self.voice_id = inp;
            self
        }
        /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual
        /// voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
        /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly will use the
        /// default language of the bilingual voice. The default language for any voice is the one
        /// returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example,
        /// if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
        pub fn language_code(mut self, inp: crate::model::LanguageCode) -> Self {
            self.language_code = Some(inp);
            self
        }
        pub fn set_language_code(
            mut self,
            inp: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = inp;
            self
        }
        /// Consumes the builder and constructs a [`SynthesisTask`](crate::model::SynthesisTask)
        pub fn build(self) -> crate::model::SynthesisTask {
            crate::model::SynthesisTask {
                engine: self.engine,
                task_id: self.task_id,
                task_status: self.task_status,
                task_status_reason: self.task_status_reason,
                output_uri: self.output_uri,
                creation_time: self.creation_time,
                request_characters: self.request_characters.unwrap_or_default(),
                sns_topic_arn: self.sns_topic_arn,
                lexicon_names: self.lexicon_names,
                output_format: self.output_format,
                sample_rate: self.sample_rate,
                speech_mark_types: self.speech_mark_types,
                text_type: self.text_type,
                voice_id: self.voice_id,
                language_code: self.language_code,
            }
        }
    }
}
impl SynthesisTask {
    /// Creates a new builder-style object to manufacture [`SynthesisTask`](crate::model::SynthesisTask)
    pub fn builder() -> crate::model::synthesis_task::Builder {
        crate::model::synthesis_task::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskStatus {
    Completed,
    Failed,
    InProgress,
    Scheduled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "completed" => TaskStatus::Completed,
            "failed" => TaskStatus::Failed,
            "inProgress" => TaskStatus::InProgress,
            "scheduled" => TaskStatus::Scheduled,
            other => TaskStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TaskStatus::from(s))
    }
}
impl TaskStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TaskStatus::Completed => "completed",
            TaskStatus::Failed => "failed",
            TaskStatus::InProgress => "inProgress",
            TaskStatus::Scheduled => "scheduled",
            TaskStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TaskStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes the content of the lexicon.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconDescription {
    /// <p>Name of the lexicon.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Provides lexicon metadata.</p>
    #[serde(rename = "Attributes")]
    #[serde(default)]
    pub attributes: std::option::Option<crate::model::LexiconAttributes>,
}
impl std::fmt::Debug for LexiconDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconDescription");
        formatter.field("name", &self.name);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`LexiconDescription`](crate::model::LexiconDescription)
pub mod lexicon_description {
    /// A builder for [`LexiconDescription`](crate::model::LexiconDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<crate::model::LexiconAttributes>,
    }
    impl Builder {
        /// <p>Name of the lexicon.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>Provides lexicon metadata.</p>
        pub fn attributes(mut self, inp: crate::model::LexiconAttributes) -> Self {
            self.attributes = Some(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            inp: std::option::Option<crate::model::LexiconAttributes>,
        ) -> Self {
            self.attributes = inp;
            self
        }
        /// Consumes the builder and constructs a [`LexiconDescription`](crate::model::LexiconDescription)
        pub fn build(self) -> crate::model::LexiconDescription {
            crate::model::LexiconDescription {
                name: self.name,
                attributes: self.attributes,
            }
        }
    }
}
impl LexiconDescription {
    /// Creates a new builder-style object to manufacture [`LexiconDescription`](crate::model::LexiconDescription)
    pub fn builder() -> crate::model::lexicon_description::Builder {
        crate::model::lexicon_description::Builder::default()
    }
}

/// <p>Contains metadata describing the lexicon such as the number of lexemes, language code,
/// and so on. For more information, see <a href="https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html">Managing
/// Lexicons</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconAttributes {
    /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and
    /// <code>x-sampa</code>.</p>
    #[serde(rename = "Alphabet")]
    #[serde(default)]
    pub alphabet: std::option::Option<std::string::String>,
    /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en"
    /// would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
    #[serde(rename = "LanguageCode")]
    #[serde(default)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>Date lexicon was last modified (a timestamp value).</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
    #[serde(rename = "LexiconArn")]
    #[serde(default)]
    pub lexicon_arn: std::option::Option<std::string::String>,
    /// <p>Number of lexemes in the lexicon.</p>
    #[serde(rename = "LexemesCount")]
    #[serde(default)]
    pub lexemes_count: i32,
    /// <p>Total size of the lexicon, in characters.</p>
    #[serde(rename = "Size")]
    #[serde(default)]
    pub size: i32,
}
impl std::fmt::Debug for LexiconAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconAttributes");
        formatter.field("alphabet", &self.alphabet);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("lexicon_arn", &self.lexicon_arn);
        formatter.field("lexemes_count", &self.lexemes_count);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`LexiconAttributes`](crate::model::LexiconAttributes)
pub mod lexicon_attributes {
    /// A builder for [`LexiconAttributes`](crate::model::LexiconAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alphabet: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified: std::option::Option<smithy_types::Instant>,
        pub(crate) lexicon_arn: std::option::Option<std::string::String>,
        pub(crate) lexemes_count: std::option::Option<i32>,
        pub(crate) size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and
        /// <code>x-sampa</code>.</p>
        pub fn alphabet(mut self, inp: impl Into<std::string::String>) -> Self {
            self.alphabet = Some(inp.into());
            self
        }
        pub fn set_alphabet(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.alphabet = inp;
            self
        }
        /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en"
        /// would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
        pub fn language_code(mut self, inp: crate::model::LanguageCode) -> Self {
            self.language_code = Some(inp);
            self
        }
        pub fn set_language_code(
            mut self,
            inp: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = inp;
            self
        }
        /// <p>Date lexicon was last modified (a timestamp value).</p>
        pub fn last_modified(mut self, inp: smithy_types::Instant) -> Self {
            self.last_modified = Some(inp);
            self
        }
        pub fn set_last_modified(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified = inp;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
        pub fn lexicon_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.lexicon_arn = Some(inp.into());
            self
        }
        pub fn set_lexicon_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.lexicon_arn = inp;
            self
        }
        /// <p>Number of lexemes in the lexicon.</p>
        pub fn lexemes_count(mut self, inp: i32) -> Self {
            self.lexemes_count = Some(inp);
            self
        }
        pub fn set_lexemes_count(mut self, inp: i32) -> Self {
            self.lexemes_count = Some(inp);
            self
        }
        /// <p>Total size of the lexicon, in characters.</p>
        pub fn size(mut self, inp: i32) -> Self {
            self.size = Some(inp);
            self
        }
        pub fn set_size(mut self, inp: i32) -> Self {
            self.size = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`LexiconAttributes`](crate::model::LexiconAttributes)
        pub fn build(self) -> crate::model::LexiconAttributes {
            crate::model::LexiconAttributes {
                alphabet: self.alphabet,
                language_code: self.language_code,
                last_modified: self.last_modified,
                lexicon_arn: self.lexicon_arn,
                lexemes_count: self.lexemes_count.unwrap_or_default(),
                size: self.size.unwrap_or_default(),
            }
        }
    }
}
impl LexiconAttributes {
    /// Creates a new builder-style object to manufacture [`LexiconAttributes`](crate::model::LexiconAttributes)
    pub fn builder() -> crate::model::lexicon_attributes::Builder {
        crate::model::lexicon_attributes::Builder::default()
    }
}

/// <p>Provides lexicon name and lexicon content in string format. For more information, see
/// <a href="https://www.w3.org/TR/pronunciation-lexicon/">Pronunciation Lexicon
/// Specification (PLS) Version 1.0</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Lexicon {
    /// <p>Lexicon content in string format. The content of a lexicon must be in PLS
    /// format.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<std::string::String>,
    /// <p>Name of the lexicon.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Lexicon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Lexicon");
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`Lexicon`](crate::model::Lexicon)
pub mod lexicon {
    /// A builder for [`Lexicon`](crate::model::Lexicon)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Lexicon content in string format. The content of a lexicon must be in PLS
        /// format.</p>
        pub fn content(mut self, inp: impl Into<std::string::String>) -> Self {
            self.content = Some(inp.into());
            self
        }
        pub fn set_content(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.content = inp;
            self
        }
        /// <p>Name of the lexicon.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// Consumes the builder and constructs a [`Lexicon`](crate::model::Lexicon)
        pub fn build(self) -> crate::model::Lexicon {
            crate::model::Lexicon {
                content: self.content,
                name: self.name,
            }
        }
    }
}
impl Lexicon {
    /// Creates a new builder-style object to manufacture [`Lexicon`](crate::model::Lexicon)
    pub fn builder() -> crate::model::lexicon::Builder {
        crate::model::lexicon::Builder::default()
    }
}

/// <p>Description of the voice.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Voice {
    /// <p>Gender of the voice.</p>
    #[serde(rename = "Gender")]
    #[serde(default)]
    pub gender: std::option::Option<crate::model::Gender>,
    /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the
    /// <code>SynthesizeSpeech</code> operation.</p>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<crate::model::VoiceId>,
    /// <p>Language code of the voice.</p>
    #[serde(rename = "LanguageCode")]
    #[serde(default)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>Human readable name of the language in English.</p>
    #[serde(rename = "LanguageName")]
    #[serde(default)]
    pub language_name: std::option::Option<std::string::String>,
    /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable
    /// voice name that you might display in your application.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Additional codes for languages available for the specified voice in addition to its
    /// default language. </p>
    /// <p>For example, the default language for Aditi is Indian English (en-IN) because it was first
    /// used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi,
    /// this parameter would show the code <code>hi-IN</code>.</p>
    #[serde(rename = "AdditionalLanguageCodes")]
    #[serde(default)]
    pub additional_language_codes: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported
    /// by a given voice.</p>
    #[serde(rename = "SupportedEngines")]
    #[serde(default)]
    pub supported_engines: std::option::Option<std::vec::Vec<crate::model::Engine>>,
}
impl std::fmt::Debug for Voice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Voice");
        formatter.field("gender", &self.gender);
        formatter.field("id", &self.id);
        formatter.field("language_code", &self.language_code);
        formatter.field("language_name", &self.language_name);
        formatter.field("name", &self.name);
        formatter.field("additional_language_codes", &self.additional_language_codes);
        formatter.field("supported_engines", &self.supported_engines);
        formatter.finish()
    }
}
/// See [`Voice`](crate::model::Voice)
pub mod voice {
    /// A builder for [`Voice`](crate::model::Voice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gender: std::option::Option<crate::model::Gender>,
        pub(crate) id: std::option::Option<crate::model::VoiceId>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) language_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) additional_language_codes:
            std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) supported_engines: std::option::Option<std::vec::Vec<crate::model::Engine>>,
    }
    impl Builder {
        /// <p>Gender of the voice.</p>
        pub fn gender(mut self, inp: crate::model::Gender) -> Self {
            self.gender = Some(inp);
            self
        }
        pub fn set_gender(mut self, inp: std::option::Option<crate::model::Gender>) -> Self {
            self.gender = inp;
            self
        }
        /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the
        /// <code>SynthesizeSpeech</code> operation.</p>
        pub fn id(mut self, inp: crate::model::VoiceId) -> Self {
            self.id = Some(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<crate::model::VoiceId>) -> Self {
            self.id = inp;
            self
        }
        /// <p>Language code of the voice.</p>
        pub fn language_code(mut self, inp: crate::model::LanguageCode) -> Self {
            self.language_code = Some(inp);
            self
        }
        pub fn set_language_code(
            mut self,
            inp: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = inp;
            self
        }
        /// <p>Human readable name of the language in English.</p>
        pub fn language_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.language_name = Some(inp.into());
            self
        }
        pub fn set_language_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.language_name = inp;
            self
        }
        /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable
        /// voice name that you might display in your application.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        pub fn additional_language_codes(
            mut self,
            inp: impl Into<crate::model::LanguageCode>,
        ) -> Self {
            let mut v = self.additional_language_codes.unwrap_or_default();
            v.push(inp.into());
            self.additional_language_codes = Some(v);
            self
        }
        pub fn set_additional_language_codes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.additional_language_codes = inp;
            self
        }
        pub fn supported_engines(mut self, inp: impl Into<crate::model::Engine>) -> Self {
            let mut v = self.supported_engines.unwrap_or_default();
            v.push(inp.into());
            self.supported_engines = Some(v);
            self
        }
        pub fn set_supported_engines(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Engine>>,
        ) -> Self {
            self.supported_engines = inp;
            self
        }
        /// Consumes the builder and constructs a [`Voice`](crate::model::Voice)
        pub fn build(self) -> crate::model::Voice {
            crate::model::Voice {
                gender: self.gender,
                id: self.id,
                language_code: self.language_code,
                language_name: self.language_name,
                name: self.name,
                additional_language_codes: self.additional_language_codes,
                supported_engines: self.supported_engines,
            }
        }
    }
}
impl Voice {
    /// Creates a new builder-style object to manufacture [`Voice`](crate::model::Voice)
    pub fn builder() -> crate::model::voice::Builder {
        crate::model::voice::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Gender {
    Female,
    Male,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Gender {
    fn from(s: &str) -> Self {
        match s {
            "Female" => Gender::Female,
            "Male" => Gender::Male,
            other => Gender::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Gender {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Gender::from(s))
    }
}
impl Gender {
    pub fn as_str(&self) -> &str {
        match self {
            Gender::Female => "Female",
            Gender::Male => "Male",
            Gender::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Gender {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Gender {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}
