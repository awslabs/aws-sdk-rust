// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VoiceId {
    #[allow(missing_docs)] // documentation missing in model
    Aditi,
    #[allow(missing_docs)] // documentation missing in model
    Amy,
    #[allow(missing_docs)] // documentation missing in model
    Aria,
    #[allow(missing_docs)] // documentation missing in model
    Arlet,
    #[allow(missing_docs)] // documentation missing in model
    Astrid,
    #[allow(missing_docs)] // documentation missing in model
    Ayanda,
    #[allow(missing_docs)] // documentation missing in model
    Bianca,
    #[allow(missing_docs)] // documentation missing in model
    Brian,
    #[allow(missing_docs)] // documentation missing in model
    Camila,
    #[allow(missing_docs)] // documentation missing in model
    Carla,
    #[allow(missing_docs)] // documentation missing in model
    Carmen,
    #[allow(missing_docs)] // documentation missing in model
    Celine,
    #[allow(missing_docs)] // documentation missing in model
    Chantal,
    #[allow(missing_docs)] // documentation missing in model
    Conchita,
    #[allow(missing_docs)] // documentation missing in model
    Cristiano,
    #[allow(missing_docs)] // documentation missing in model
    Dora,
    #[allow(missing_docs)] // documentation missing in model
    Emma,
    #[allow(missing_docs)] // documentation missing in model
    Enrique,
    #[allow(missing_docs)] // documentation missing in model
    Ewa,
    #[allow(missing_docs)] // documentation missing in model
    Filiz,
    #[allow(missing_docs)] // documentation missing in model
    Gabrielle,
    #[allow(missing_docs)] // documentation missing in model
    Geraint,
    #[allow(missing_docs)] // documentation missing in model
    Giorgio,
    #[allow(missing_docs)] // documentation missing in model
    Gwyneth,
    #[allow(missing_docs)] // documentation missing in model
    Hans,
    #[allow(missing_docs)] // documentation missing in model
    Ines,
    #[allow(missing_docs)] // documentation missing in model
    Ivy,
    #[allow(missing_docs)] // documentation missing in model
    Jacek,
    #[allow(missing_docs)] // documentation missing in model
    Jan,
    #[allow(missing_docs)] // documentation missing in model
    Joanna,
    #[allow(missing_docs)] // documentation missing in model
    Joey,
    #[allow(missing_docs)] // documentation missing in model
    Justin,
    #[allow(missing_docs)] // documentation missing in model
    Karl,
    #[allow(missing_docs)] // documentation missing in model
    Kendra,
    #[allow(missing_docs)] // documentation missing in model
    Kevin,
    #[allow(missing_docs)] // documentation missing in model
    Kimberly,
    #[allow(missing_docs)] // documentation missing in model
    Lea,
    #[allow(missing_docs)] // documentation missing in model
    Liv,
    #[allow(missing_docs)] // documentation missing in model
    Lotte,
    #[allow(missing_docs)] // documentation missing in model
    Lucia,
    #[allow(missing_docs)] // documentation missing in model
    Lupe,
    #[allow(missing_docs)] // documentation missing in model
    Mads,
    #[allow(missing_docs)] // documentation missing in model
    Maja,
    #[allow(missing_docs)] // documentation missing in model
    Marlene,
    #[allow(missing_docs)] // documentation missing in model
    Mathieu,
    #[allow(missing_docs)] // documentation missing in model
    Matthew,
    #[allow(missing_docs)] // documentation missing in model
    Maxim,
    #[allow(missing_docs)] // documentation missing in model
    Mia,
    #[allow(missing_docs)] // documentation missing in model
    Miguel,
    #[allow(missing_docs)] // documentation missing in model
    Mizuki,
    #[allow(missing_docs)] // documentation missing in model
    Naja,
    #[allow(missing_docs)] // documentation missing in model
    Nicole,
    #[allow(missing_docs)] // documentation missing in model
    Olivia,
    #[allow(missing_docs)] // documentation missing in model
    Penelope,
    #[allow(missing_docs)] // documentation missing in model
    Raveena,
    #[allow(missing_docs)] // documentation missing in model
    Ricardo,
    #[allow(missing_docs)] // documentation missing in model
    Ruben,
    #[allow(missing_docs)] // documentation missing in model
    Russell,
    #[allow(missing_docs)] // documentation missing in model
    Salli,
    #[allow(missing_docs)] // documentation missing in model
    Seoyeon,
    #[allow(missing_docs)] // documentation missing in model
    Takumi,
    #[allow(missing_docs)] // documentation missing in model
    Tatyana,
    #[allow(missing_docs)] // documentation missing in model
    Vicki,
    #[allow(missing_docs)] // documentation missing in model
    Vitoria,
    #[allow(missing_docs)] // documentation missing in model
    Zeina,
    #[allow(missing_docs)] // documentation missing in model
    Zhiyu,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VoiceId {
    fn from(s: &str) -> Self {
        match s {
            "Aditi" => VoiceId::Aditi,
            "Amy" => VoiceId::Amy,
            "Aria" => VoiceId::Aria,
            "Arlet" => VoiceId::Arlet,
            "Astrid" => VoiceId::Astrid,
            "Ayanda" => VoiceId::Ayanda,
            "Bianca" => VoiceId::Bianca,
            "Brian" => VoiceId::Brian,
            "Camila" => VoiceId::Camila,
            "Carla" => VoiceId::Carla,
            "Carmen" => VoiceId::Carmen,
            "Celine" => VoiceId::Celine,
            "Chantal" => VoiceId::Chantal,
            "Conchita" => VoiceId::Conchita,
            "Cristiano" => VoiceId::Cristiano,
            "Dora" => VoiceId::Dora,
            "Emma" => VoiceId::Emma,
            "Enrique" => VoiceId::Enrique,
            "Ewa" => VoiceId::Ewa,
            "Filiz" => VoiceId::Filiz,
            "Gabrielle" => VoiceId::Gabrielle,
            "Geraint" => VoiceId::Geraint,
            "Giorgio" => VoiceId::Giorgio,
            "Gwyneth" => VoiceId::Gwyneth,
            "Hans" => VoiceId::Hans,
            "Ines" => VoiceId::Ines,
            "Ivy" => VoiceId::Ivy,
            "Jacek" => VoiceId::Jacek,
            "Jan" => VoiceId::Jan,
            "Joanna" => VoiceId::Joanna,
            "Joey" => VoiceId::Joey,
            "Justin" => VoiceId::Justin,
            "Karl" => VoiceId::Karl,
            "Kendra" => VoiceId::Kendra,
            "Kevin" => VoiceId::Kevin,
            "Kimberly" => VoiceId::Kimberly,
            "Lea" => VoiceId::Lea,
            "Liv" => VoiceId::Liv,
            "Lotte" => VoiceId::Lotte,
            "Lucia" => VoiceId::Lucia,
            "Lupe" => VoiceId::Lupe,
            "Mads" => VoiceId::Mads,
            "Maja" => VoiceId::Maja,
            "Marlene" => VoiceId::Marlene,
            "Mathieu" => VoiceId::Mathieu,
            "Matthew" => VoiceId::Matthew,
            "Maxim" => VoiceId::Maxim,
            "Mia" => VoiceId::Mia,
            "Miguel" => VoiceId::Miguel,
            "Mizuki" => VoiceId::Mizuki,
            "Naja" => VoiceId::Naja,
            "Nicole" => VoiceId::Nicole,
            "Olivia" => VoiceId::Olivia,
            "Penelope" => VoiceId::Penelope,
            "Raveena" => VoiceId::Raveena,
            "Ricardo" => VoiceId::Ricardo,
            "Ruben" => VoiceId::Ruben,
            "Russell" => VoiceId::Russell,
            "Salli" => VoiceId::Salli,
            "Seoyeon" => VoiceId::Seoyeon,
            "Takumi" => VoiceId::Takumi,
            "Tatyana" => VoiceId::Tatyana,
            "Vicki" => VoiceId::Vicki,
            "Vitoria" => VoiceId::Vitoria,
            "Zeina" => VoiceId::Zeina,
            "Zhiyu" => VoiceId::Zhiyu,
            other => VoiceId::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VoiceId {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VoiceId::from(s))
    }
}
impl VoiceId {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VoiceId::Aditi => "Aditi",
            VoiceId::Amy => "Amy",
            VoiceId::Aria => "Aria",
            VoiceId::Arlet => "Arlet",
            VoiceId::Astrid => "Astrid",
            VoiceId::Ayanda => "Ayanda",
            VoiceId::Bianca => "Bianca",
            VoiceId::Brian => "Brian",
            VoiceId::Camila => "Camila",
            VoiceId::Carla => "Carla",
            VoiceId::Carmen => "Carmen",
            VoiceId::Celine => "Celine",
            VoiceId::Chantal => "Chantal",
            VoiceId::Conchita => "Conchita",
            VoiceId::Cristiano => "Cristiano",
            VoiceId::Dora => "Dora",
            VoiceId::Emma => "Emma",
            VoiceId::Enrique => "Enrique",
            VoiceId::Ewa => "Ewa",
            VoiceId::Filiz => "Filiz",
            VoiceId::Gabrielle => "Gabrielle",
            VoiceId::Geraint => "Geraint",
            VoiceId::Giorgio => "Giorgio",
            VoiceId::Gwyneth => "Gwyneth",
            VoiceId::Hans => "Hans",
            VoiceId::Ines => "Ines",
            VoiceId::Ivy => "Ivy",
            VoiceId::Jacek => "Jacek",
            VoiceId::Jan => "Jan",
            VoiceId::Joanna => "Joanna",
            VoiceId::Joey => "Joey",
            VoiceId::Justin => "Justin",
            VoiceId::Karl => "Karl",
            VoiceId::Kendra => "Kendra",
            VoiceId::Kevin => "Kevin",
            VoiceId::Kimberly => "Kimberly",
            VoiceId::Lea => "Lea",
            VoiceId::Liv => "Liv",
            VoiceId::Lotte => "Lotte",
            VoiceId::Lucia => "Lucia",
            VoiceId::Lupe => "Lupe",
            VoiceId::Mads => "Mads",
            VoiceId::Maja => "Maja",
            VoiceId::Marlene => "Marlene",
            VoiceId::Mathieu => "Mathieu",
            VoiceId::Matthew => "Matthew",
            VoiceId::Maxim => "Maxim",
            VoiceId::Mia => "Mia",
            VoiceId::Miguel => "Miguel",
            VoiceId::Mizuki => "Mizuki",
            VoiceId::Naja => "Naja",
            VoiceId::Nicole => "Nicole",
            VoiceId::Olivia => "Olivia",
            VoiceId::Penelope => "Penelope",
            VoiceId::Raveena => "Raveena",
            VoiceId::Ricardo => "Ricardo",
            VoiceId::Ruben => "Ruben",
            VoiceId::Russell => "Russell",
            VoiceId::Salli => "Salli",
            VoiceId::Seoyeon => "Seoyeon",
            VoiceId::Takumi => "Takumi",
            VoiceId::Tatyana => "Tatyana",
            VoiceId::Vicki => "Vicki",
            VoiceId::Vitoria => "Vitoria",
            VoiceId::Zeina => "Zeina",
            VoiceId::Zhiyu => "Zhiyu",
            VoiceId::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Aditi",
            "Amy",
            "Aria",
            "Arlet",
            "Astrid",
            "Ayanda",
            "Bianca",
            "Brian",
            "Camila",
            "Carla",
            "Carmen",
            "Celine",
            "Chantal",
            "Conchita",
            "Cristiano",
            "Dora",
            "Emma",
            "Enrique",
            "Ewa",
            "Filiz",
            "Gabrielle",
            "Geraint",
            "Giorgio",
            "Gwyneth",
            "Hans",
            "Ines",
            "Ivy",
            "Jacek",
            "Jan",
            "Joanna",
            "Joey",
            "Justin",
            "Karl",
            "Kendra",
            "Kevin",
            "Kimberly",
            "Lea",
            "Liv",
            "Lotte",
            "Lucia",
            "Lupe",
            "Mads",
            "Maja",
            "Marlene",
            "Mathieu",
            "Matthew",
            "Maxim",
            "Mia",
            "Miguel",
            "Mizuki",
            "Naja",
            "Nicole",
            "Olivia",
            "Penelope",
            "Raveena",
            "Ricardo",
            "Ruben",
            "Russell",
            "Salli",
            "Seoyeon",
            "Takumi",
            "Tatyana",
            "Vicki",
            "Vitoria",
            "Zeina",
            "Zhiyu",
        ]
    }
}
impl AsRef<str> for VoiceId {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TextType {
    #[allow(missing_docs)] // documentation missing in model
    Ssml,
    #[allow(missing_docs)] // documentation missing in model
    Text,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TextType {
    fn from(s: &str) -> Self {
        match s {
            "ssml" => TextType::Ssml,
            "text" => TextType::Text,
            other => TextType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TextType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TextType::from(s))
    }
}
impl TextType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TextType::Ssml => "ssml",
            TextType::Text => "text",
            TextType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ssml", "text"]
    }
}
impl AsRef<str> for TextType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpeechMarkType {
    #[allow(missing_docs)] // documentation missing in model
    Sentence,
    #[allow(missing_docs)] // documentation missing in model
    Ssml,
    #[allow(missing_docs)] // documentation missing in model
    Viseme,
    #[allow(missing_docs)] // documentation missing in model
    Word,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpeechMarkType {
    fn from(s: &str) -> Self {
        match s {
            "sentence" => SpeechMarkType::Sentence,
            "ssml" => SpeechMarkType::Ssml,
            "viseme" => SpeechMarkType::Viseme,
            "word" => SpeechMarkType::Word,
            other => SpeechMarkType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpeechMarkType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpeechMarkType::from(s))
    }
}
impl SpeechMarkType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SpeechMarkType::Sentence => "sentence",
            SpeechMarkType::Ssml => "ssml",
            SpeechMarkType::Viseme => "viseme",
            SpeechMarkType::Word => "word",
            SpeechMarkType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["sentence", "ssml", "viseme", "word"]
    }
}
impl AsRef<str> for SpeechMarkType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputFormat {
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Mp3,
    #[allow(missing_docs)] // documentation missing in model
    OggVorbis,
    #[allow(missing_docs)] // documentation missing in model
    Pcm,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OutputFormat {
    fn from(s: &str) -> Self {
        match s {
            "json" => OutputFormat::Json,
            "mp3" => OutputFormat::Mp3,
            "ogg_vorbis" => OutputFormat::OggVorbis,
            "pcm" => OutputFormat::Pcm,
            other => OutputFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OutputFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutputFormat::from(s))
    }
}
impl OutputFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutputFormat::Json => "json",
            OutputFormat::Mp3 => "mp3",
            OutputFormat::OggVorbis => "ogg_vorbis",
            OutputFormat::Pcm => "pcm",
            OutputFormat::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["json", "mp3", "ogg_vorbis", "pcm"]
    }
}
impl AsRef<str> for OutputFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    Arb,
    #[allow(missing_docs)] // documentation missing in model
    CaEs,
    #[allow(missing_docs)] // documentation missing in model
    CmnCn,
    #[allow(missing_docs)] // documentation missing in model
    CyGb,
    #[allow(missing_docs)] // documentation missing in model
    DaDk,
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnGbWls,
    #[allow(missing_docs)] // documentation missing in model
    EnIn,
    #[allow(missing_docs)] // documentation missing in model
    EnNz,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EnZa,
    #[allow(missing_docs)] // documentation missing in model
    EsEs,
    #[allow(missing_docs)] // documentation missing in model
    EsMx,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    #[allow(missing_docs)] // documentation missing in model
    IsIs,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    JaJp,
    #[allow(missing_docs)] // documentation missing in model
    KoKr,
    #[allow(missing_docs)] // documentation missing in model
    NbNo,
    #[allow(missing_docs)] // documentation missing in model
    NlNl,
    #[allow(missing_docs)] // documentation missing in model
    PlPl,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    #[allow(missing_docs)] // documentation missing in model
    PtPt,
    #[allow(missing_docs)] // documentation missing in model
    RoRo,
    #[allow(missing_docs)] // documentation missing in model
    RuRu,
    #[allow(missing_docs)] // documentation missing in model
    SvSe,
    #[allow(missing_docs)] // documentation missing in model
    TrTr,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "arb" => LanguageCode::Arb,
            "ca-ES" => LanguageCode::CaEs,
            "cmn-CN" => LanguageCode::CmnCn,
            "cy-GB" => LanguageCode::CyGb,
            "da-DK" => LanguageCode::DaDk,
            "de-DE" => LanguageCode::DeDe,
            "en-AU" => LanguageCode::EnAu,
            "en-GB" => LanguageCode::EnGb,
            "en-GB-WLS" => LanguageCode::EnGbWls,
            "en-IN" => LanguageCode::EnIn,
            "en-NZ" => LanguageCode::EnNz,
            "en-US" => LanguageCode::EnUs,
            "en-ZA" => LanguageCode::EnZa,
            "es-ES" => LanguageCode::EsEs,
            "es-MX" => LanguageCode::EsMx,
            "es-US" => LanguageCode::EsUs,
            "fr-CA" => LanguageCode::FrCa,
            "fr-FR" => LanguageCode::FrFr,
            "hi-IN" => LanguageCode::HiIn,
            "is-IS" => LanguageCode::IsIs,
            "it-IT" => LanguageCode::ItIt,
            "ja-JP" => LanguageCode::JaJp,
            "ko-KR" => LanguageCode::KoKr,
            "nb-NO" => LanguageCode::NbNo,
            "nl-NL" => LanguageCode::NlNl,
            "pl-PL" => LanguageCode::PlPl,
            "pt-BR" => LanguageCode::PtBr,
            "pt-PT" => LanguageCode::PtPt,
            "ro-RO" => LanguageCode::RoRo,
            "ru-RU" => LanguageCode::RuRu,
            "sv-SE" => LanguageCode::SvSe,
            "tr-TR" => LanguageCode::TrTr,
            other => LanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::Arb => "arb",
            LanguageCode::CaEs => "ca-ES",
            LanguageCode::CmnCn => "cmn-CN",
            LanguageCode::CyGb => "cy-GB",
            LanguageCode::DaDk => "da-DK",
            LanguageCode::DeDe => "de-DE",
            LanguageCode::EnAu => "en-AU",
            LanguageCode::EnGb => "en-GB",
            LanguageCode::EnGbWls => "en-GB-WLS",
            LanguageCode::EnIn => "en-IN",
            LanguageCode::EnNz => "en-NZ",
            LanguageCode::EnUs => "en-US",
            LanguageCode::EnZa => "en-ZA",
            LanguageCode::EsEs => "es-ES",
            LanguageCode::EsMx => "es-MX",
            LanguageCode::EsUs => "es-US",
            LanguageCode::FrCa => "fr-CA",
            LanguageCode::FrFr => "fr-FR",
            LanguageCode::HiIn => "hi-IN",
            LanguageCode::IsIs => "is-IS",
            LanguageCode::ItIt => "it-IT",
            LanguageCode::JaJp => "ja-JP",
            LanguageCode::KoKr => "ko-KR",
            LanguageCode::NbNo => "nb-NO",
            LanguageCode::NlNl => "nl-NL",
            LanguageCode::PlPl => "pl-PL",
            LanguageCode::PtBr => "pt-BR",
            LanguageCode::PtPt => "pt-PT",
            LanguageCode::RoRo => "ro-RO",
            LanguageCode::RuRu => "ru-RU",
            LanguageCode::SvSe => "sv-SE",
            LanguageCode::TrTr => "tr-TR",
            LanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "arb",
            "ca-ES",
            "cmn-CN",
            "cy-GB",
            "da-DK",
            "de-DE",
            "en-AU",
            "en-GB",
            "en-GB-WLS",
            "en-IN",
            "en-NZ",
            "en-US",
            "en-ZA",
            "es-ES",
            "es-MX",
            "es-US",
            "fr-CA",
            "fr-FR",
            "hi-IN",
            "is-IS",
            "it-IT",
            "ja-JP",
            "ko-KR",
            "nb-NO",
            "nl-NL",
            "pl-PL",
            "pt-BR",
            "pt-PT",
            "ro-RO",
            "ru-RU",
            "sv-SE",
            "tr-TR",
        ]
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Engine {
    #[allow(missing_docs)] // documentation missing in model
    Neural,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Engine {
    fn from(s: &str) -> Self {
        match s {
            "neural" => Engine::Neural,
            "standard" => Engine::Standard,
            other => Engine::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Engine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Engine::from(s))
    }
}
impl Engine {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Engine::Neural => "neural",
            Engine::Standard => "standard",
            Engine::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["neural", "standard"]
    }
}
impl AsRef<str> for Engine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>SynthesisTask object that provides information about a speech synthesis task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SynthesisTask {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.</p>
    pub engine: std::option::Option<crate::model::Engine>,
    /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>Current status of the individual speech synthesis task.</p>
    pub task_status: std::option::Option<crate::model::TaskStatus>,
    /// <p>Reason for the current status of a specific speech synthesis task, including errors if the task has failed.</p>
    pub task_status_reason: std::option::Option<std::string::String>,
    /// <p>Pathway for the output speech file.</p>
    pub output_uri: std::option::Option<std::string::String>,
    /// <p>Timestamp for the time the synthesis task was started.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Number of billable characters synthesized.</p>
    pub request_characters: i32,
    /// <p>ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. </p>
    pub lexicon_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    pub output_format: std::option::Option<crate::model::OutputFormat>,
    /// <p>The audio frequency specified in Hz.</p>
    /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000".</p>
    /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    pub sample_rate: std::option::Option<std::string::String>,
    /// <p>The type of speech marks returned for the input text.</p>
    pub speech_mark_types: std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
    /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text. </p>
    pub text_type: std::option::Option<crate::model::TextType>,
    /// <p>Voice ID to use for the synthesis. </p>
    pub voice_id: std::option::Option<crate::model::VoiceId>,
    /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
    /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
}
impl SynthesisTask {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.</p>
    pub fn engine(&self) -> std::option::Option<&crate::model::Engine> {
        self.engine.as_ref()
    }
    /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>Current status of the individual speech synthesis task.</p>
    pub fn task_status(&self) -> std::option::Option<&crate::model::TaskStatus> {
        self.task_status.as_ref()
    }
    /// <p>Reason for the current status of a specific speech synthesis task, including errors if the task has failed.</p>
    pub fn task_status_reason(&self) -> std::option::Option<&str> {
        self.task_status_reason.as_deref()
    }
    /// <p>Pathway for the output speech file.</p>
    pub fn output_uri(&self) -> std::option::Option<&str> {
        self.output_uri.as_deref()
    }
    /// <p>Timestamp for the time the synthesis task was started.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Number of billable characters synthesized.</p>
    pub fn request_characters(&self) -> i32 {
        self.request_characters
    }
    /// <p>ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. </p>
    pub fn lexicon_names(&self) -> std::option::Option<&[std::string::String]> {
        self.lexicon_names.as_deref()
    }
    /// <p>The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    pub fn output_format(&self) -> std::option::Option<&crate::model::OutputFormat> {
        self.output_format.as_ref()
    }
    /// <p>The audio frequency specified in Hz.</p>
    /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000".</p>
    /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    pub fn sample_rate(&self) -> std::option::Option<&str> {
        self.sample_rate.as_deref()
    }
    /// <p>The type of speech marks returned for the input text.</p>
    pub fn speech_mark_types(&self) -> std::option::Option<&[crate::model::SpeechMarkType]> {
        self.speech_mark_types.as_deref()
    }
    /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text. </p>
    pub fn text_type(&self) -> std::option::Option<&crate::model::TextType> {
        self.text_type.as_ref()
    }
    /// <p>Voice ID to use for the synthesis. </p>
    pub fn voice_id(&self) -> std::option::Option<&crate::model::VoiceId> {
        self.voice_id.as_ref()
    }
    /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
    /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
}
impl std::fmt::Debug for SynthesisTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SynthesisTask");
        formatter.field("engine", &self.engine);
        formatter.field("task_id", &self.task_id);
        formatter.field("task_status", &self.task_status);
        formatter.field("task_status_reason", &self.task_status_reason);
        formatter.field("output_uri", &self.output_uri);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("request_characters", &self.request_characters);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("lexicon_names", &self.lexicon_names);
        formatter.field("output_format", &self.output_format);
        formatter.field("sample_rate", &self.sample_rate);
        formatter.field("speech_mark_types", &self.speech_mark_types);
        formatter.field("text_type", &self.text_type);
        formatter.field("voice_id", &self.voice_id);
        formatter.field("language_code", &self.language_code);
        formatter.finish()
    }
}
/// See [`SynthesisTask`](crate::model::SynthesisTask)
pub mod synthesis_task {
    /// A builder for [`SynthesisTask`](crate::model::SynthesisTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine: std::option::Option<crate::model::Engine>,
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) task_status: std::option::Option<crate::model::TaskStatus>,
        pub(crate) task_status_reason: std::option::Option<std::string::String>,
        pub(crate) output_uri: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) request_characters: std::option::Option<i32>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) lexicon_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) output_format: std::option::Option<crate::model::OutputFormat>,
        pub(crate) sample_rate: std::option::Option<std::string::String>,
        pub(crate) speech_mark_types:
            std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
        pub(crate) text_type: std::option::Option<crate::model::TextType>,
        pub(crate) voice_id: std::option::Option<crate::model::VoiceId>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
    }
    impl Builder {
        /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.</p>
        pub fn engine(mut self, input: crate::model::Engine) -> Self {
            self.engine = Some(input);
            self
        }
        /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.</p>
        pub fn set_engine(mut self, input: std::option::Option<crate::model::Engine>) -> Self {
            self.engine = input;
            self
        }
        /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>Current status of the individual speech synthesis task.</p>
        pub fn task_status(mut self, input: crate::model::TaskStatus) -> Self {
            self.task_status = Some(input);
            self
        }
        /// <p>Current status of the individual speech synthesis task.</p>
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatus>,
        ) -> Self {
            self.task_status = input;
            self
        }
        /// <p>Reason for the current status of a specific speech synthesis task, including errors if the task has failed.</p>
        pub fn task_status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_status_reason = Some(input.into());
            self
        }
        /// <p>Reason for the current status of a specific speech synthesis task, including errors if the task has failed.</p>
        pub fn set_task_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_status_reason = input;
            self
        }
        /// <p>Pathway for the output speech file.</p>
        pub fn output_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_uri = Some(input.into());
            self
        }
        /// <p>Pathway for the output speech file.</p>
        pub fn set_output_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_uri = input;
            self
        }
        /// <p>Timestamp for the time the synthesis task was started.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>Timestamp for the time the synthesis task was started.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Number of billable characters synthesized.</p>
        pub fn request_characters(mut self, input: i32) -> Self {
            self.request_characters = Some(input);
            self
        }
        /// <p>Number of billable characters synthesized.</p>
        pub fn set_request_characters(mut self, input: std::option::Option<i32>) -> Self {
            self.request_characters = input;
            self
        }
        /// <p>ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Appends an item to `lexicon_names`.
        ///
        /// To override the contents of this collection use [`set_lexicon_names`](Self::set_lexicon_names).
        ///
        /// <p>List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. </p>
        pub fn lexicon_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lexicon_names.unwrap_or_default();
            v.push(input.into());
            self.lexicon_names = Some(v);
            self
        }
        /// <p>List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. </p>
        pub fn set_lexicon_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lexicon_names = input;
            self
        }
        /// <p>The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
        pub fn output_format(mut self, input: crate::model::OutputFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        /// <p>The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::OutputFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p>The audio frequency specified in Hz.</p>
        /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000".</p>
        /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
        pub fn sample_rate(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_rate = Some(input.into());
            self
        }
        /// <p>The audio frequency specified in Hz.</p>
        /// <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000".</p>
        /// <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
        pub fn set_sample_rate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sample_rate = input;
            self
        }
        /// Appends an item to `speech_mark_types`.
        ///
        /// To override the contents of this collection use [`set_speech_mark_types`](Self::set_speech_mark_types).
        ///
        /// <p>The type of speech marks returned for the input text.</p>
        pub fn speech_mark_types(mut self, input: crate::model::SpeechMarkType) -> Self {
            let mut v = self.speech_mark_types.unwrap_or_default();
            v.push(input);
            self.speech_mark_types = Some(v);
            self
        }
        /// <p>The type of speech marks returned for the input text.</p>
        pub fn set_speech_mark_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SpeechMarkType>>,
        ) -> Self {
            self.speech_mark_types = input;
            self
        }
        /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text. </p>
        pub fn text_type(mut self, input: crate::model::TextType) -> Self {
            self.text_type = Some(input);
            self
        }
        /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text. </p>
        pub fn set_text_type(mut self, input: std::option::Option<crate::model::TextType>) -> Self {
            self.text_type = input;
            self
        }
        /// <p>Voice ID to use for the synthesis. </p>
        pub fn voice_id(mut self, input: crate::model::VoiceId) -> Self {
            self.voice_id = Some(input);
            self
        }
        /// <p>Voice ID to use for the synthesis. </p>
        pub fn set_voice_id(mut self, input: std::option::Option<crate::model::VoiceId>) -> Self {
            self.voice_id = input;
            self
        }
        /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
        /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
        /// <p>If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Consumes the builder and constructs a [`SynthesisTask`](crate::model::SynthesisTask)
        pub fn build(self) -> crate::model::SynthesisTask {
            crate::model::SynthesisTask {
                engine: self.engine,
                task_id: self.task_id,
                task_status: self.task_status,
                task_status_reason: self.task_status_reason,
                output_uri: self.output_uri,
                creation_time: self.creation_time,
                request_characters: self.request_characters.unwrap_or_default(),
                sns_topic_arn: self.sns_topic_arn,
                lexicon_names: self.lexicon_names,
                output_format: self.output_format,
                sample_rate: self.sample_rate,
                speech_mark_types: self.speech_mark_types,
                text_type: self.text_type,
                voice_id: self.voice_id,
                language_code: self.language_code,
            }
        }
    }
}
impl SynthesisTask {
    /// Creates a new builder-style object to manufacture [`SynthesisTask`](crate::model::SynthesisTask)
    pub fn builder() -> crate::model::synthesis_task::Builder {
        crate::model::synthesis_task::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "completed" => TaskStatus::Completed,
            "failed" => TaskStatus::Failed,
            "inProgress" => TaskStatus::InProgress,
            "scheduled" => TaskStatus::Scheduled,
            other => TaskStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskStatus::from(s))
    }
}
impl TaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskStatus::Completed => "completed",
            TaskStatus::Failed => "failed",
            TaskStatus::InProgress => "inProgress",
            TaskStatus::Scheduled => "scheduled",
            TaskStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["completed", "failed", "inProgress", "scheduled"]
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the content of the lexicon.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconDescription {
    /// <p>Name of the lexicon.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Provides lexicon metadata.</p>
    pub attributes: std::option::Option<crate::model::LexiconAttributes>,
}
impl LexiconDescription {
    /// <p>Name of the lexicon.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Provides lexicon metadata.</p>
    pub fn attributes(&self) -> std::option::Option<&crate::model::LexiconAttributes> {
        self.attributes.as_ref()
    }
}
impl std::fmt::Debug for LexiconDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconDescription");
        formatter.field("name", &self.name);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`LexiconDescription`](crate::model::LexiconDescription)
pub mod lexicon_description {
    /// A builder for [`LexiconDescription`](crate::model::LexiconDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<crate::model::LexiconAttributes>,
    }
    impl Builder {
        /// <p>Name of the lexicon.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the lexicon.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Provides lexicon metadata.</p>
        pub fn attributes(mut self, input: crate::model::LexiconAttributes) -> Self {
            self.attributes = Some(input);
            self
        }
        /// <p>Provides lexicon metadata.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<crate::model::LexiconAttributes>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`LexiconDescription`](crate::model::LexiconDescription)
        pub fn build(self) -> crate::model::LexiconDescription {
            crate::model::LexiconDescription {
                name: self.name,
                attributes: self.attributes,
            }
        }
    }
}
impl LexiconDescription {
    /// Creates a new builder-style object to manufacture [`LexiconDescription`](crate::model::LexiconDescription)
    pub fn builder() -> crate::model::lexicon_description::Builder {
        crate::model::lexicon_description::Builder::default()
    }
}

/// <p>Contains metadata describing the lexicon such as the number of lexemes, language code, and so on. For more information, see <a href="https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html">Managing Lexicons</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconAttributes {
    /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and <code>x-sampa</code>.</p>
    pub alphabet: std::option::Option<std::string::String>,
    /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>Date lexicon was last modified (a timestamp value).</p>
    pub last_modified: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
    pub lexicon_arn: std::option::Option<std::string::String>,
    /// <p>Number of lexemes in the lexicon.</p>
    pub lexemes_count: i32,
    /// <p>Total size of the lexicon, in characters.</p>
    pub size: i32,
}
impl LexiconAttributes {
    /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and <code>x-sampa</code>.</p>
    pub fn alphabet(&self) -> std::option::Option<&str> {
        self.alphabet.as_deref()
    }
    /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>Date lexicon was last modified (a timestamp value).</p>
    pub fn last_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified.as_ref()
    }
    /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
    pub fn lexicon_arn(&self) -> std::option::Option<&str> {
        self.lexicon_arn.as_deref()
    }
    /// <p>Number of lexemes in the lexicon.</p>
    pub fn lexemes_count(&self) -> i32 {
        self.lexemes_count
    }
    /// <p>Total size of the lexicon, in characters.</p>
    pub fn size(&self) -> i32 {
        self.size
    }
}
impl std::fmt::Debug for LexiconAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconAttributes");
        formatter.field("alphabet", &self.alphabet);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("lexicon_arn", &self.lexicon_arn);
        formatter.field("lexemes_count", &self.lexemes_count);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`LexiconAttributes`](crate::model::LexiconAttributes)
pub mod lexicon_attributes {
    /// A builder for [`LexiconAttributes`](crate::model::LexiconAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alphabet: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) lexicon_arn: std::option::Option<std::string::String>,
        pub(crate) lexemes_count: std::option::Option<i32>,
        pub(crate) size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and <code>x-sampa</code>.</p>
        pub fn alphabet(mut self, input: impl Into<std::string::String>) -> Self {
            self.alphabet = Some(input.into());
            self
        }
        /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and <code>x-sampa</code>.</p>
        pub fn set_alphabet(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alphabet = input;
            self
        }
        /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>Date lexicon was last modified (a timestamp value).</p>
        pub fn last_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified = Some(input);
            self
        }
        /// <p>Date lexicon was last modified (a timestamp value).</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
        pub fn lexicon_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lexicon_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
        pub fn set_lexicon_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lexicon_arn = input;
            self
        }
        /// <p>Number of lexemes in the lexicon.</p>
        pub fn lexemes_count(mut self, input: i32) -> Self {
            self.lexemes_count = Some(input);
            self
        }
        /// <p>Number of lexemes in the lexicon.</p>
        pub fn set_lexemes_count(mut self, input: std::option::Option<i32>) -> Self {
            self.lexemes_count = input;
            self
        }
        /// <p>Total size of the lexicon, in characters.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>Total size of the lexicon, in characters.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`LexiconAttributes`](crate::model::LexiconAttributes)
        pub fn build(self) -> crate::model::LexiconAttributes {
            crate::model::LexiconAttributes {
                alphabet: self.alphabet,
                language_code: self.language_code,
                last_modified: self.last_modified,
                lexicon_arn: self.lexicon_arn,
                lexemes_count: self.lexemes_count.unwrap_or_default(),
                size: self.size.unwrap_or_default(),
            }
        }
    }
}
impl LexiconAttributes {
    /// Creates a new builder-style object to manufacture [`LexiconAttributes`](crate::model::LexiconAttributes)
    pub fn builder() -> crate::model::lexicon_attributes::Builder {
        crate::model::lexicon_attributes::Builder::default()
    }
}

/// <p>Provides lexicon name and lexicon content in string format. For more information, see <a href="https://www.w3.org/TR/pronunciation-lexicon/">Pronunciation Lexicon Specification (PLS) Version 1.0</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Lexicon {
    /// <p>Lexicon content in string format. The content of a lexicon must be in PLS format.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>Name of the lexicon.</p>
    pub name: std::option::Option<std::string::String>,
}
impl Lexicon {
    /// <p>Lexicon content in string format. The content of a lexicon must be in PLS format.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>Name of the lexicon.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for Lexicon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Lexicon");
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`Lexicon`](crate::model::Lexicon)
pub mod lexicon {
    /// A builder for [`Lexicon`](crate::model::Lexicon)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Lexicon content in string format. The content of a lexicon must be in PLS format.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>Lexicon content in string format. The content of a lexicon must be in PLS format.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>Name of the lexicon.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the lexicon.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`Lexicon`](crate::model::Lexicon)
        pub fn build(self) -> crate::model::Lexicon {
            crate::model::Lexicon {
                content: self.content,
                name: self.name,
            }
        }
    }
}
impl Lexicon {
    /// Creates a new builder-style object to manufacture [`Lexicon`](crate::model::Lexicon)
    pub fn builder() -> crate::model::lexicon::Builder {
        crate::model::lexicon::Builder::default()
    }
}

/// <p>Description of the voice.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Voice {
    /// <p>Gender of the voice.</p>
    pub gender: std::option::Option<crate::model::Gender>,
    /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the <code>SynthesizeSpeech</code> operation.</p>
    pub id: std::option::Option<crate::model::VoiceId>,
    /// <p>Language code of the voice.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>Human readable name of the language in English.</p>
    pub language_name: std::option::Option<std::string::String>,
    /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Additional codes for languages available for the specified voice in addition to its default language. </p>
    /// <p>For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code <code>hi-IN</code>.</p>
    pub additional_language_codes: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported by a given voice.</p>
    pub supported_engines: std::option::Option<std::vec::Vec<crate::model::Engine>>,
}
impl Voice {
    /// <p>Gender of the voice.</p>
    pub fn gender(&self) -> std::option::Option<&crate::model::Gender> {
        self.gender.as_ref()
    }
    /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the <code>SynthesizeSpeech</code> operation.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::VoiceId> {
        self.id.as_ref()
    }
    /// <p>Language code of the voice.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>Human readable name of the language in English.</p>
    pub fn language_name(&self) -> std::option::Option<&str> {
        self.language_name.as_deref()
    }
    /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Additional codes for languages available for the specified voice in addition to its default language. </p>
    /// <p>For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code <code>hi-IN</code>.</p>
    pub fn additional_language_codes(&self) -> std::option::Option<&[crate::model::LanguageCode]> {
        self.additional_language_codes.as_deref()
    }
    /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported by a given voice.</p>
    pub fn supported_engines(&self) -> std::option::Option<&[crate::model::Engine]> {
        self.supported_engines.as_deref()
    }
}
impl std::fmt::Debug for Voice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Voice");
        formatter.field("gender", &self.gender);
        formatter.field("id", &self.id);
        formatter.field("language_code", &self.language_code);
        formatter.field("language_name", &self.language_name);
        formatter.field("name", &self.name);
        formatter.field("additional_language_codes", &self.additional_language_codes);
        formatter.field("supported_engines", &self.supported_engines);
        formatter.finish()
    }
}
/// See [`Voice`](crate::model::Voice)
pub mod voice {
    /// A builder for [`Voice`](crate::model::Voice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gender: std::option::Option<crate::model::Gender>,
        pub(crate) id: std::option::Option<crate::model::VoiceId>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) language_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) additional_language_codes:
            std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) supported_engines: std::option::Option<std::vec::Vec<crate::model::Engine>>,
    }
    impl Builder {
        /// <p>Gender of the voice.</p>
        pub fn gender(mut self, input: crate::model::Gender) -> Self {
            self.gender = Some(input);
            self
        }
        /// <p>Gender of the voice.</p>
        pub fn set_gender(mut self, input: std::option::Option<crate::model::Gender>) -> Self {
            self.gender = input;
            self
        }
        /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the <code>SynthesizeSpeech</code> operation.</p>
        pub fn id(mut self, input: crate::model::VoiceId) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the <code>SynthesizeSpeech</code> operation.</p>
        pub fn set_id(mut self, input: std::option::Option<crate::model::VoiceId>) -> Self {
            self.id = input;
            self
        }
        /// <p>Language code of the voice.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>Language code of the voice.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>Human readable name of the language in English.</p>
        pub fn language_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_name = Some(input.into());
            self
        }
        /// <p>Human readable name of the language in English.</p>
        pub fn set_language_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_name = input;
            self
        }
        /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `additional_language_codes`.
        ///
        /// To override the contents of this collection use [`set_additional_language_codes`](Self::set_additional_language_codes).
        ///
        /// <p>Additional codes for languages available for the specified voice in addition to its default language. </p>
        /// <p>For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code <code>hi-IN</code>.</p>
        pub fn additional_language_codes(mut self, input: crate::model::LanguageCode) -> Self {
            let mut v = self.additional_language_codes.unwrap_or_default();
            v.push(input);
            self.additional_language_codes = Some(v);
            self
        }
        /// <p>Additional codes for languages available for the specified voice in addition to its default language. </p>
        /// <p>For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code <code>hi-IN</code>.</p>
        pub fn set_additional_language_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.additional_language_codes = input;
            self
        }
        /// Appends an item to `supported_engines`.
        ///
        /// To override the contents of this collection use [`set_supported_engines`](Self::set_supported_engines).
        ///
        /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported by a given voice.</p>
        pub fn supported_engines(mut self, input: crate::model::Engine) -> Self {
            let mut v = self.supported_engines.unwrap_or_default();
            v.push(input);
            self.supported_engines = Some(v);
            self
        }
        /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported by a given voice.</p>
        pub fn set_supported_engines(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Engine>>,
        ) -> Self {
            self.supported_engines = input;
            self
        }
        /// Consumes the builder and constructs a [`Voice`](crate::model::Voice)
        pub fn build(self) -> crate::model::Voice {
            crate::model::Voice {
                gender: self.gender,
                id: self.id,
                language_code: self.language_code,
                language_name: self.language_name,
                name: self.name,
                additional_language_codes: self.additional_language_codes,
                supported_engines: self.supported_engines,
            }
        }
    }
}
impl Voice {
    /// Creates a new builder-style object to manufacture [`Voice`](crate::model::Voice)
    pub fn builder() -> crate::model::voice::Builder {
        crate::model::voice::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Gender {
    #[allow(missing_docs)] // documentation missing in model
    Female,
    #[allow(missing_docs)] // documentation missing in model
    Male,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Gender {
    fn from(s: &str) -> Self {
        match s {
            "Female" => Gender::Female,
            "Male" => Gender::Male,
            other => Gender::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Gender {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Gender::from(s))
    }
}
impl Gender {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Gender::Female => "Female",
            Gender::Male => "Male",
            Gender::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Female", "Male"]
    }
}
impl AsRef<str> for Gender {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
