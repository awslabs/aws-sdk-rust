// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLexiconError {
    pub kind: DeleteLexiconErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLexiconErrorKind {
    LexiconNotFoundError(crate::error::LexiconNotFoundError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLexiconError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLexiconErrorKind::LexiconNotFoundError(_inner) => _inner.fmt(f),
            DeleteLexiconErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteLexiconErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLexiconError {
    fn code(&self) -> Option<&str> {
        DeleteLexiconError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLexiconError {
    pub fn new(kind: DeleteLexiconErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLexiconErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLexiconErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteLexiconError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLexiconErrorKind::LexiconNotFoundError(_inner) => Some(_inner),
            DeleteLexiconErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteLexiconErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVoicesError {
    pub kind: DescribeVoicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVoicesErrorKind {
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVoicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVoicesErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            DescribeVoicesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DescribeVoicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVoicesError {
    fn code(&self) -> Option<&str> {
        DescribeVoicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVoicesError {
    pub fn new(kind: DescribeVoicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVoicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVoicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeVoicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVoicesErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            DescribeVoicesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DescribeVoicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLexiconError {
    pub kind: GetLexiconErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLexiconErrorKind {
    LexiconNotFoundError(crate::error::LexiconNotFoundError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLexiconError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLexiconErrorKind::LexiconNotFoundError(_inner) => _inner.fmt(f),
            GetLexiconErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetLexiconErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLexiconError {
    fn code(&self) -> Option<&str> {
        GetLexiconError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLexiconError {
    pub fn new(kind: GetLexiconErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLexiconErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLexiconErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetLexiconError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLexiconErrorKind::LexiconNotFoundError(_inner) => Some(_inner),
            GetLexiconErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetLexiconErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSpeechSynthesisTaskError {
    pub kind: GetSpeechSynthesisTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSpeechSynthesisTaskErrorKind {
    InvalidTaskIdError(crate::error::InvalidTaskIdError),
    ServiceFailureError(crate::error::ServiceFailureError),
    SynthesisTaskNotFoundError(crate::error::SynthesisTaskNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSpeechSynthesisTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSpeechSynthesisTaskErrorKind::InvalidTaskIdError(_inner) => _inner.fmt(f),
            GetSpeechSynthesisTaskErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetSpeechSynthesisTaskErrorKind::SynthesisTaskNotFoundError(_inner) => _inner.fmt(f),
            GetSpeechSynthesisTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSpeechSynthesisTaskError {
    fn code(&self) -> Option<&str> {
        GetSpeechSynthesisTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSpeechSynthesisTaskError {
    pub fn new(kind: GetSpeechSynthesisTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSpeechSynthesisTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSpeechSynthesisTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetSpeechSynthesisTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSpeechSynthesisTaskErrorKind::InvalidTaskIdError(_inner) => Some(_inner),
            GetSpeechSynthesisTaskErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetSpeechSynthesisTaskErrorKind::SynthesisTaskNotFoundError(_inner) => Some(_inner),
            GetSpeechSynthesisTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLexiconsError {
    pub kind: ListLexiconsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLexiconsErrorKind {
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLexiconsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLexiconsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListLexiconsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListLexiconsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLexiconsError {
    fn code(&self) -> Option<&str> {
        ListLexiconsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLexiconsError {
    pub fn new(kind: ListLexiconsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLexiconsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLexiconsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListLexiconsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLexiconsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListLexiconsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListLexiconsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSpeechSynthesisTasksError {
    pub kind: ListSpeechSynthesisTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSpeechSynthesisTasksErrorKind {
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSpeechSynthesisTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSpeechSynthesisTasksErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSpeechSynthesisTasksErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListSpeechSynthesisTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSpeechSynthesisTasksError {
    fn code(&self) -> Option<&str> {
        ListSpeechSynthesisTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSpeechSynthesisTasksError {
    pub fn new(kind: ListSpeechSynthesisTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSpeechSynthesisTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSpeechSynthesisTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListSpeechSynthesisTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSpeechSynthesisTasksErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSpeechSynthesisTasksErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListSpeechSynthesisTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutLexiconError {
    pub kind: PutLexiconErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLexiconErrorKind {
    InvalidLexiconError(crate::error::InvalidLexiconError),
    LexiconSizeExceededError(crate::error::LexiconSizeExceededError),
    MaxLexemeLengthExceededError(crate::error::MaxLexemeLengthExceededError),
    MaxLexiconsNumberExceededError(crate::error::MaxLexiconsNumberExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnsupportedPlsAlphabetError(crate::error::UnsupportedPlsAlphabetError),
    UnsupportedPlsLanguageError(crate::error::UnsupportedPlsLanguageError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutLexiconError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutLexiconErrorKind::InvalidLexiconError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::LexiconSizeExceededError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::MaxLexemeLengthExceededError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::MaxLexiconsNumberExceededError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::UnsupportedPlsAlphabetError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::UnsupportedPlsLanguageError(_inner) => _inner.fmt(f),
            PutLexiconErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutLexiconError {
    fn code(&self) -> Option<&str> {
        PutLexiconError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLexiconError {
    pub fn new(kind: PutLexiconErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutLexiconErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutLexiconErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for PutLexiconError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutLexiconErrorKind::InvalidLexiconError(_inner) => Some(_inner),
            PutLexiconErrorKind::LexiconSizeExceededError(_inner) => Some(_inner),
            PutLexiconErrorKind::MaxLexemeLengthExceededError(_inner) => Some(_inner),
            PutLexiconErrorKind::MaxLexiconsNumberExceededError(_inner) => Some(_inner),
            PutLexiconErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutLexiconErrorKind::UnsupportedPlsAlphabetError(_inner) => Some(_inner),
            PutLexiconErrorKind::UnsupportedPlsLanguageError(_inner) => Some(_inner),
            PutLexiconErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSpeechSynthesisTaskError {
    pub kind: StartSpeechSynthesisTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSpeechSynthesisTaskErrorKind {
    EngineNotSupportedError(crate::error::EngineNotSupportedError),
    InvalidS3BucketError(crate::error::InvalidS3BucketError),
    InvalidS3KeyError(crate::error::InvalidS3KeyError),
    InvalidSampleRateError(crate::error::InvalidSampleRateError),
    InvalidSnsTopicArnError(crate::error::InvalidSnsTopicArnError),
    InvalidSsmlError(crate::error::InvalidSsmlError),
    LanguageNotSupportedError(crate::error::LanguageNotSupportedError),
    LexiconNotFoundError(crate::error::LexiconNotFoundError),
    MarksNotSupportedForFormatError(crate::error::MarksNotSupportedForFormatError),
    ServiceFailureError(crate::error::ServiceFailureError),
    SsmlMarksNotSupportedForTextTypeError(crate::error::SsmlMarksNotSupportedForTextTypeError),
    TextLengthExceededError(crate::error::TextLengthExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSpeechSynthesisTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSpeechSynthesisTaskErrorKind::EngineNotSupportedError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::InvalidS3BucketError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::InvalidS3KeyError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::InvalidSampleRateError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::InvalidSnsTopicArnError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::InvalidSsmlError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::LanguageNotSupportedError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::LexiconNotFoundError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::MarksNotSupportedForFormatError(_inner) => {
                _inner.fmt(f)
            }
            StartSpeechSynthesisTaskErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::SsmlMarksNotSupportedForTextTypeError(_inner) => {
                _inner.fmt(f)
            }
            StartSpeechSynthesisTaskErrorKind::TextLengthExceededError(_inner) => _inner.fmt(f),
            StartSpeechSynthesisTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartSpeechSynthesisTaskError {
    fn code(&self) -> Option<&str> {
        StartSpeechSynthesisTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSpeechSynthesisTaskError {
    pub fn new(kind: StartSpeechSynthesisTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSpeechSynthesisTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSpeechSynthesisTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for StartSpeechSynthesisTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSpeechSynthesisTaskErrorKind::EngineNotSupportedError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::InvalidS3BucketError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::InvalidS3KeyError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::InvalidSampleRateError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::InvalidSnsTopicArnError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::InvalidSsmlError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::LanguageNotSupportedError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::LexiconNotFoundError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::MarksNotSupportedForFormatError(_inner) => {
                Some(_inner)
            }
            StartSpeechSynthesisTaskErrorKind::ServiceFailureError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::SsmlMarksNotSupportedForTextTypeError(_inner) => {
                Some(_inner)
            }
            StartSpeechSynthesisTaskErrorKind::TextLengthExceededError(_inner) => Some(_inner),
            StartSpeechSynthesisTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SynthesizeSpeechError {
    pub kind: SynthesizeSpeechErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SynthesizeSpeechErrorKind {
    EngineNotSupportedError(crate::error::EngineNotSupportedError),
    InvalidSampleRateError(crate::error::InvalidSampleRateError),
    InvalidSsmlError(crate::error::InvalidSsmlError),
    LanguageNotSupportedError(crate::error::LanguageNotSupportedError),
    LexiconNotFoundError(crate::error::LexiconNotFoundError),
    MarksNotSupportedForFormatError(crate::error::MarksNotSupportedForFormatError),
    ServiceFailureError(crate::error::ServiceFailureError),
    SsmlMarksNotSupportedForTextTypeError(crate::error::SsmlMarksNotSupportedForTextTypeError),
    TextLengthExceededError(crate::error::TextLengthExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SynthesizeSpeechError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SynthesizeSpeechErrorKind::EngineNotSupportedError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::InvalidSampleRateError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::InvalidSsmlError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::LanguageNotSupportedError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::LexiconNotFoundError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::MarksNotSupportedForFormatError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::SsmlMarksNotSupportedForTextTypeError(_inner) => {
                _inner.fmt(f)
            }
            SynthesizeSpeechErrorKind::TextLengthExceededError(_inner) => _inner.fmt(f),
            SynthesizeSpeechErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SynthesizeSpeechError {
    fn code(&self) -> Option<&str> {
        SynthesizeSpeechError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SynthesizeSpeechError {
    pub fn new(kind: SynthesizeSpeechErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SynthesizeSpeechErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SynthesizeSpeechErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SynthesizeSpeechError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SynthesizeSpeechErrorKind::EngineNotSupportedError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::InvalidSampleRateError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::InvalidSsmlError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::LanguageNotSupportedError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::LexiconNotFoundError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::MarksNotSupportedForFormatError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::ServiceFailureError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::SsmlMarksNotSupportedForTextTypeError(_inner) => {
                Some(_inner)
            }
            SynthesizeSpeechErrorKind::TextLengthExceededError(_inner) => Some(_inner),
            SynthesizeSpeechErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The value of the "Text" parameter is longer than the accepted limits. For the
/// <code>SynthesizeSpeech</code> API, the limit for input text is a maximum of 6000 characters
/// total, of which no more than 3000 can be billed characters. For the
/// <code>StartSpeechSynthesisTask</code> API, the maximum is 200,000 characters, of which no
/// more than 100,000 can be billed characters. SSML tags are not counted as billed
/// characters.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TextLengthExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TextLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TextLengthExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TextLengthExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TextLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TextLengthExceededError [TextLengthExceededException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TextLengthExceededError {}
/// See [`TextLengthExceededError`](crate::error::TextLengthExceededError)
pub mod text_length_exceeded_error {
    /// A builder for [`TextLengthExceededError`](crate::error::TextLengthExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TextLengthExceededError`](crate::error::TextLengthExceededError)
        pub fn build(self) -> crate::error::TextLengthExceededError {
            crate::error::TextLengthExceededError {
                message: self.message,
            }
        }
    }
}
impl TextLengthExceededError {
    /// Creates a new builder-style object to manufacture [`TextLengthExceededError`](crate::error::TextLengthExceededError)
    pub fn builder() -> crate::error::text_length_exceeded_error::Builder {
        crate::error::text_length_exceeded_error::Builder::default()
    }
}

/// <p>SSML speech marks are not supported for plain text-type input.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SsmlMarksNotSupportedForTextTypeError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SsmlMarksNotSupportedForTextTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SsmlMarksNotSupportedForTextTypeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SsmlMarksNotSupportedForTextTypeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SsmlMarksNotSupportedForTextTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SsmlMarksNotSupportedForTextTypeError [SsmlMarksNotSupportedForTextTypeException]"
        )?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for SsmlMarksNotSupportedForTextTypeError {}
/// See [`SsmlMarksNotSupportedForTextTypeError`](crate::error::SsmlMarksNotSupportedForTextTypeError)
pub mod ssml_marks_not_supported_for_text_type_error {
    /// A builder for [`SsmlMarksNotSupportedForTextTypeError`](crate::error::SsmlMarksNotSupportedForTextTypeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`SsmlMarksNotSupportedForTextTypeError`](crate::error::SsmlMarksNotSupportedForTextTypeError)
        pub fn build(self) -> crate::error::SsmlMarksNotSupportedForTextTypeError {
            crate::error::SsmlMarksNotSupportedForTextTypeError {
                message: self.message,
            }
        }
    }
}
impl SsmlMarksNotSupportedForTextTypeError {
    /// Creates a new builder-style object to manufacture [`SsmlMarksNotSupportedForTextTypeError`](crate::error::SsmlMarksNotSupportedForTextTypeError)
    pub fn builder() -> crate::error::ssml_marks_not_supported_for_text_type_error::Builder {
        crate::error::ssml_marks_not_supported_for_text_type_error::Builder::default()
    }
}

/// <p>An unknown condition has caused a service failure.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureError [ServiceFailureException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureError {}
/// See [`ServiceFailureError`](crate::error::ServiceFailureError)
pub mod service_failure_error {
    /// A builder for [`ServiceFailureError`](crate::error::ServiceFailureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureError`](crate::error::ServiceFailureError)
        pub fn build(self) -> crate::error::ServiceFailureError {
            crate::error::ServiceFailureError {
                message: self.message,
            }
        }
    }
}
impl ServiceFailureError {
    /// Creates a new builder-style object to manufacture [`ServiceFailureError`](crate::error::ServiceFailureError)
    pub fn builder() -> crate::error::service_failure_error::Builder {
        crate::error::service_failure_error::Builder::default()
    }
}

/// <p>Speech marks are not supported for the <code>OutputFormat</code> selected. Speech marks
/// are only available for content in <code>json</code> format.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MarksNotSupportedForFormatError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MarksNotSupportedForFormatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MarksNotSupportedForFormatError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MarksNotSupportedForFormatError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MarksNotSupportedForFormatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MarksNotSupportedForFormatError [MarksNotSupportedForFormatException]"
        )?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for MarksNotSupportedForFormatError {}
/// See [`MarksNotSupportedForFormatError`](crate::error::MarksNotSupportedForFormatError)
pub mod marks_not_supported_for_format_error {
    /// A builder for [`MarksNotSupportedForFormatError`](crate::error::MarksNotSupportedForFormatError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`MarksNotSupportedForFormatError`](crate::error::MarksNotSupportedForFormatError)
        pub fn build(self) -> crate::error::MarksNotSupportedForFormatError {
            crate::error::MarksNotSupportedForFormatError {
                message: self.message,
            }
        }
    }
}
impl MarksNotSupportedForFormatError {
    /// Creates a new builder-style object to manufacture [`MarksNotSupportedForFormatError`](crate::error::MarksNotSupportedForFormatError)
    pub fn builder() -> crate::error::marks_not_supported_for_format_error::Builder {
        crate::error::marks_not_supported_for_format_error::Builder::default()
    }
}

/// <p>Amazon Polly can't find the specified lexicon. This could be caused by a lexicon that
/// is missing, its name is misspelled or specifying a lexicon that is in a different
/// region.</p>
/// <p>Verify that the lexicon exists, is in the region (see <a>ListLexicons</a>)
/// and that you spelled its name is spelled correctly. Then try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LexiconNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LexiconNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LexiconNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LexiconNotFoundError [LexiconNotFoundException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LexiconNotFoundError {}
/// See [`LexiconNotFoundError`](crate::error::LexiconNotFoundError)
pub mod lexicon_not_found_error {
    /// A builder for [`LexiconNotFoundError`](crate::error::LexiconNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LexiconNotFoundError`](crate::error::LexiconNotFoundError)
        pub fn build(self) -> crate::error::LexiconNotFoundError {
            crate::error::LexiconNotFoundError {
                message: self.message,
            }
        }
    }
}
impl LexiconNotFoundError {
    /// Creates a new builder-style object to manufacture [`LexiconNotFoundError`](crate::error::LexiconNotFoundError)
    pub fn builder() -> crate::error::lexicon_not_found_error::Builder {
        crate::error::lexicon_not_found_error::Builder::default()
    }
}

/// <p>The language specified is not currently supported by Amazon Polly in this capacity.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LanguageNotSupportedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LanguageNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LanguageNotSupportedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LanguageNotSupportedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LanguageNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "LanguageNotSupportedError [LanguageNotSupportedException]"
        )?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LanguageNotSupportedError {}
/// See [`LanguageNotSupportedError`](crate::error::LanguageNotSupportedError)
pub mod language_not_supported_error {
    /// A builder for [`LanguageNotSupportedError`](crate::error::LanguageNotSupportedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LanguageNotSupportedError`](crate::error::LanguageNotSupportedError)
        pub fn build(self) -> crate::error::LanguageNotSupportedError {
            crate::error::LanguageNotSupportedError {
                message: self.message,
            }
        }
    }
}
impl LanguageNotSupportedError {
    /// Creates a new builder-style object to manufacture [`LanguageNotSupportedError`](crate::error::LanguageNotSupportedError)
    pub fn builder() -> crate::error::language_not_supported_error::Builder {
        crate::error::language_not_supported_error::Builder::default()
    }
}

/// <p>The SSML you provided is invalid. Verify the SSML syntax, spelling of tags and values,
/// and then try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSsmlError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSsmlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSsmlError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSsmlError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSsmlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSsmlError [InvalidSsmlException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSsmlError {}
/// See [`InvalidSsmlError`](crate::error::InvalidSsmlError)
pub mod invalid_ssml_error {
    /// A builder for [`InvalidSsmlError`](crate::error::InvalidSsmlError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSsmlError`](crate::error::InvalidSsmlError)
        pub fn build(self) -> crate::error::InvalidSsmlError {
            crate::error::InvalidSsmlError {
                message: self.message,
            }
        }
    }
}
impl InvalidSsmlError {
    /// Creates a new builder-style object to manufacture [`InvalidSsmlError`](crate::error::InvalidSsmlError)
    pub fn builder() -> crate::error::invalid_ssml_error::Builder {
        crate::error::invalid_ssml_error::Builder::default()
    }
}

/// <p>The specified sample rate is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSampleRateError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSampleRateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSampleRateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSampleRateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSampleRateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSampleRateError [InvalidSampleRateException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSampleRateError {}
/// See [`InvalidSampleRateError`](crate::error::InvalidSampleRateError)
pub mod invalid_sample_rate_error {
    /// A builder for [`InvalidSampleRateError`](crate::error::InvalidSampleRateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSampleRateError`](crate::error::InvalidSampleRateError)
        pub fn build(self) -> crate::error::InvalidSampleRateError {
            crate::error::InvalidSampleRateError {
                message: self.message,
            }
        }
    }
}
impl InvalidSampleRateError {
    /// Creates a new builder-style object to manufacture [`InvalidSampleRateError`](crate::error::InvalidSampleRateError)
    pub fn builder() -> crate::error::invalid_sample_rate_error::Builder {
        crate::error::invalid_sample_rate_error::Builder::default()
    }
}

/// <p>This engine is not compatible with the voice that you have designated. Choose a new voice
/// that is compatible with the engine or change the engine and restart the operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EngineNotSupportedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EngineNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EngineNotSupportedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EngineNotSupportedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EngineNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EngineNotSupportedError [EngineNotSupportedException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EngineNotSupportedError {}
/// See [`EngineNotSupportedError`](crate::error::EngineNotSupportedError)
pub mod engine_not_supported_error {
    /// A builder for [`EngineNotSupportedError`](crate::error::EngineNotSupportedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EngineNotSupportedError`](crate::error::EngineNotSupportedError)
        pub fn build(self) -> crate::error::EngineNotSupportedError {
            crate::error::EngineNotSupportedError {
                message: self.message,
            }
        }
    }
}
impl EngineNotSupportedError {
    /// Creates a new builder-style object to manufacture [`EngineNotSupportedError`](crate::error::EngineNotSupportedError)
    pub fn builder() -> crate::error::engine_not_supported_error::Builder {
        crate::error::engine_not_supported_error::Builder::default()
    }
}

/// <p>The provided SNS topic ARN is invalid. Please provide a valid SNS topic ARN and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSnsTopicArnError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSnsTopicArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSnsTopicArnError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSnsTopicArnError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnsTopicArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSnsTopicArnError [InvalidSnsTopicArnException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnsTopicArnError {}
/// See [`InvalidSnsTopicArnError`](crate::error::InvalidSnsTopicArnError)
pub mod invalid_sns_topic_arn_error {
    /// A builder for [`InvalidSnsTopicArnError`](crate::error::InvalidSnsTopicArnError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnsTopicArnError`](crate::error::InvalidSnsTopicArnError)
        pub fn build(self) -> crate::error::InvalidSnsTopicArnError {
            crate::error::InvalidSnsTopicArnError {
                message: self.message,
            }
        }
    }
}
impl InvalidSnsTopicArnError {
    /// Creates a new builder-style object to manufacture [`InvalidSnsTopicArnError`](crate::error::InvalidSnsTopicArnError)
    pub fn builder() -> crate::error::invalid_sns_topic_arn_error::Builder {
        crate::error::invalid_sns_topic_arn_error::Builder::default()
    }
}

/// <p>The provided Amazon S3 key prefix is invalid. Please provide a valid S3 object key
/// name.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3KeyError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3KeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3KeyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3KeyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3KeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3KeyError [InvalidS3KeyException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3KeyError {}
/// See [`InvalidS3KeyError`](crate::error::InvalidS3KeyError)
pub mod invalid_s3_key_error {
    /// A builder for [`InvalidS3KeyError`](crate::error::InvalidS3KeyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3KeyError`](crate::error::InvalidS3KeyError)
        pub fn build(self) -> crate::error::InvalidS3KeyError {
            crate::error::InvalidS3KeyError {
                message: self.message,
            }
        }
    }
}
impl InvalidS3KeyError {
    /// Creates a new builder-style object to manufacture [`InvalidS3KeyError`](crate::error::InvalidS3KeyError)
    pub fn builder() -> crate::error::invalid_s3_key_error::Builder {
        crate::error::invalid_s3_key_error::Builder::default()
    }
}

/// <p>The provided Amazon S3 bucket name is invalid. Please check your input with S3 bucket
/// naming requirements and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3BucketError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3BucketError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3BucketError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3BucketError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3BucketError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3BucketError [InvalidS3BucketException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3BucketError {}
/// See [`InvalidS3BucketError`](crate::error::InvalidS3BucketError)
pub mod invalid_s3_bucket_error {
    /// A builder for [`InvalidS3BucketError`](crate::error::InvalidS3BucketError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3BucketError`](crate::error::InvalidS3BucketError)
        pub fn build(self) -> crate::error::InvalidS3BucketError {
            crate::error::InvalidS3BucketError {
                message: self.message,
            }
        }
    }
}
impl InvalidS3BucketError {
    /// Creates a new builder-style object to manufacture [`InvalidS3BucketError`](crate::error::InvalidS3BucketError)
    pub fn builder() -> crate::error::invalid_s3_bucket_error::Builder {
        crate::error::invalid_s3_bucket_error::Builder::default()
    }
}

/// <p>The language specified in the lexicon is unsupported. For a list of supported
/// languages, see <a href="https://docs.aws.amazon.com/polly/latest/dg/API_LexiconAttributes.html">Lexicon
/// Attributes</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedPlsLanguageError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedPlsLanguageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedPlsLanguageError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedPlsLanguageError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedPlsLanguageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedPlsLanguageError [UnsupportedPlsLanguageException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedPlsLanguageError {}
/// See [`UnsupportedPlsLanguageError`](crate::error::UnsupportedPlsLanguageError)
pub mod unsupported_pls_language_error {
    /// A builder for [`UnsupportedPlsLanguageError`](crate::error::UnsupportedPlsLanguageError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedPlsLanguageError`](crate::error::UnsupportedPlsLanguageError)
        pub fn build(self) -> crate::error::UnsupportedPlsLanguageError {
            crate::error::UnsupportedPlsLanguageError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedPlsLanguageError {
    /// Creates a new builder-style object to manufacture [`UnsupportedPlsLanguageError`](crate::error::UnsupportedPlsLanguageError)
    pub fn builder() -> crate::error::unsupported_pls_language_error::Builder {
        crate::error::unsupported_pls_language_error::Builder::default()
    }
}

/// <p>The alphabet specified by the lexicon is not a supported alphabet. Valid values are
/// <code>x-sampa</code> and <code>ipa</code>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedPlsAlphabetError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedPlsAlphabetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedPlsAlphabetError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedPlsAlphabetError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedPlsAlphabetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedPlsAlphabetError [UnsupportedPlsAlphabetException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedPlsAlphabetError {}
/// See [`UnsupportedPlsAlphabetError`](crate::error::UnsupportedPlsAlphabetError)
pub mod unsupported_pls_alphabet_error {
    /// A builder for [`UnsupportedPlsAlphabetError`](crate::error::UnsupportedPlsAlphabetError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedPlsAlphabetError`](crate::error::UnsupportedPlsAlphabetError)
        pub fn build(self) -> crate::error::UnsupportedPlsAlphabetError {
            crate::error::UnsupportedPlsAlphabetError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedPlsAlphabetError {
    /// Creates a new builder-style object to manufacture [`UnsupportedPlsAlphabetError`](crate::error::UnsupportedPlsAlphabetError)
    pub fn builder() -> crate::error::unsupported_pls_alphabet_error::Builder {
        crate::error::unsupported_pls_alphabet_error::Builder::default()
    }
}

/// <p>The maximum number of lexicons would be exceeded by this operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxLexiconsNumberExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxLexiconsNumberExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxLexiconsNumberExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxLexiconsNumberExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxLexiconsNumberExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MaxLexiconsNumberExceededError [MaxLexiconsNumberExceededException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxLexiconsNumberExceededError {}
/// See [`MaxLexiconsNumberExceededError`](crate::error::MaxLexiconsNumberExceededError)
pub mod max_lexicons_number_exceeded_error {
    /// A builder for [`MaxLexiconsNumberExceededError`](crate::error::MaxLexiconsNumberExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`MaxLexiconsNumberExceededError`](crate::error::MaxLexiconsNumberExceededError)
        pub fn build(self) -> crate::error::MaxLexiconsNumberExceededError {
            crate::error::MaxLexiconsNumberExceededError {
                message: self.message,
            }
        }
    }
}
impl MaxLexiconsNumberExceededError {
    /// Creates a new builder-style object to manufacture [`MaxLexiconsNumberExceededError`](crate::error::MaxLexiconsNumberExceededError)
    pub fn builder() -> crate::error::max_lexicons_number_exceeded_error::Builder {
        crate::error::max_lexicons_number_exceeded_error::Builder::default()
    }
}

/// <p>The maximum size of the lexeme would be exceeded by this operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxLexemeLengthExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxLexemeLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxLexemeLengthExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxLexemeLengthExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxLexemeLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MaxLexemeLengthExceededError [MaxLexemeLengthExceededException]"
        )?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxLexemeLengthExceededError {}
/// See [`MaxLexemeLengthExceededError`](crate::error::MaxLexemeLengthExceededError)
pub mod max_lexeme_length_exceeded_error {
    /// A builder for [`MaxLexemeLengthExceededError`](crate::error::MaxLexemeLengthExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`MaxLexemeLengthExceededError`](crate::error::MaxLexemeLengthExceededError)
        pub fn build(self) -> crate::error::MaxLexemeLengthExceededError {
            crate::error::MaxLexemeLengthExceededError {
                message: self.message,
            }
        }
    }
}
impl MaxLexemeLengthExceededError {
    /// Creates a new builder-style object to manufacture [`MaxLexemeLengthExceededError`](crate::error::MaxLexemeLengthExceededError)
    pub fn builder() -> crate::error::max_lexeme_length_exceeded_error::Builder {
        crate::error::max_lexeme_length_exceeded_error::Builder::default()
    }
}

/// <p>The maximum size of the specified lexicon would be exceeded by this
/// operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LexiconSizeExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LexiconSizeExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexiconSizeExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LexiconSizeExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LexiconSizeExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LexiconSizeExceededError [LexiconSizeExceededException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for LexiconSizeExceededError {}
/// See [`LexiconSizeExceededError`](crate::error::LexiconSizeExceededError)
pub mod lexicon_size_exceeded_error {
    /// A builder for [`LexiconSizeExceededError`](crate::error::LexiconSizeExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LexiconSizeExceededError`](crate::error::LexiconSizeExceededError)
        pub fn build(self) -> crate::error::LexiconSizeExceededError {
            crate::error::LexiconSizeExceededError {
                message: self.message,
            }
        }
    }
}
impl LexiconSizeExceededError {
    /// Creates a new builder-style object to manufacture [`LexiconSizeExceededError`](crate::error::LexiconSizeExceededError)
    pub fn builder() -> crate::error::lexicon_size_exceeded_error::Builder {
        crate::error::lexicon_size_exceeded_error::Builder::default()
    }
}

/// <p>Amazon Polly can't find the specified lexicon. Verify that the lexicon's name is
/// spelled correctly, and then try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidLexiconError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidLexiconError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidLexiconError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidLexiconError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLexiconError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLexiconError [InvalidLexiconException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLexiconError {}
/// See [`InvalidLexiconError`](crate::error::InvalidLexiconError)
pub mod invalid_lexicon_error {
    /// A builder for [`InvalidLexiconError`](crate::error::InvalidLexiconError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLexiconError`](crate::error::InvalidLexiconError)
        pub fn build(self) -> crate::error::InvalidLexiconError {
            crate::error::InvalidLexiconError {
                message: self.message,
            }
        }
    }
}
impl InvalidLexiconError {
    /// Creates a new builder-style object to manufacture [`InvalidLexiconError`](crate::error::InvalidLexiconError)
    pub fn builder() -> crate::error::invalid_lexicon_error::Builder {
        crate::error::invalid_lexicon_error::Builder::default()
    }
}

/// <p>The NextToken is invalid. Verify that it's spelled correctly, and then try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenError [InvalidNextTokenException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenError {}
/// See [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
pub mod invalid_next_token_error {
    /// A builder for [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
        pub fn build(self) -> crate::error::InvalidNextTokenError {
            crate::error::InvalidNextTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    pub fn builder() -> crate::error::invalid_next_token_error::Builder {
        crate::error::invalid_next_token_error::Builder::default()
    }
}

/// <p>The Speech Synthesis task with requested Task ID cannot be found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SynthesisTaskNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SynthesisTaskNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SynthesisTaskNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SynthesisTaskNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SynthesisTaskNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SynthesisTaskNotFoundError [SynthesisTaskNotFoundException]"
        )?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for SynthesisTaskNotFoundError {}
/// See [`SynthesisTaskNotFoundError`](crate::error::SynthesisTaskNotFoundError)
pub mod synthesis_task_not_found_error {
    /// A builder for [`SynthesisTaskNotFoundError`](crate::error::SynthesisTaskNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`SynthesisTaskNotFoundError`](crate::error::SynthesisTaskNotFoundError)
        pub fn build(self) -> crate::error::SynthesisTaskNotFoundError {
            crate::error::SynthesisTaskNotFoundError {
                message: self.message,
            }
        }
    }
}
impl SynthesisTaskNotFoundError {
    /// Creates a new builder-style object to manufacture [`SynthesisTaskNotFoundError`](crate::error::SynthesisTaskNotFoundError)
    pub fn builder() -> crate::error::synthesis_task_not_found_error::Builder {
        crate::error::synthesis_task_not_found_error::Builder::default()
    }
}

/// <p>The provided Task ID is not valid. Please provide a valid Task ID and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTaskIdError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTaskIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTaskIdError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTaskIdError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTaskIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTaskIdError [InvalidTaskIdException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTaskIdError {}
/// See [`InvalidTaskIdError`](crate::error::InvalidTaskIdError)
pub mod invalid_task_id_error {
    /// A builder for [`InvalidTaskIdError`](crate::error::InvalidTaskIdError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTaskIdError`](crate::error::InvalidTaskIdError)
        pub fn build(self) -> crate::error::InvalidTaskIdError {
            crate::error::InvalidTaskIdError {
                message: self.message,
            }
        }
    }
}
impl InvalidTaskIdError {
    /// Creates a new builder-style object to manufacture [`InvalidTaskIdError`](crate::error::InvalidTaskIdError)
    pub fn builder() -> crate::error::invalid_task_id_error::Builder {
        crate::error::invalid_task_id_error::Builder::default()
    }
}
