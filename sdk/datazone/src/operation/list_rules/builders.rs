// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::list_rules::_list_rules_input::ListRulesInputBuilder;

pub use crate::operation::list_rules::_list_rules_output::ListRulesOutputBuilder;

impl crate::operation::list_rules::builders::ListRulesInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::list_rules::ListRulesOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_rules::ListRulesError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.list_rules();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ListRules`.
///
/// <p>Lists existing rules. In Amazon DataZone, a rule is a formal agreement that enforces specific requirements across user workflows (e.g., publishing assets to the catalog, requesting subscriptions, creating projects) within the Amazon DataZone data portal. These rules help maintain consistency, ensure compliance, and uphold governance standards in data management processes. For instance, a metadata enforcement rule can specify the required information for creating a subscription request or publishing a data asset to the catalog, ensuring alignment with organizational standards.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ListRulesFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::list_rules::builders::ListRulesInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl crate::client::customize::internal::CustomizableSend<crate::operation::list_rules::ListRulesOutput, crate::operation::list_rules::ListRulesError>
    for ListRulesFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<crate::operation::list_rules::ListRulesOutput, crate::operation::list_rules::ListRulesError>,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ListRulesFluentBuilder {
    /// Creates a new `ListRulesFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ListRules as a reference.
    pub fn as_input(&self) -> &crate::operation::list_rules::builders::ListRulesInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_rules::ListRulesOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_rules::ListRulesError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::list_rules::ListRules::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::list_rules::ListRules::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::list_rules::ListRulesOutput,
        crate::operation::list_rules::ListRulesError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::list_rules::paginator::ListRulesPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::list_rules::paginator::ListRulesPaginator {
        crate::operation::list_rules::paginator::ListRulesPaginator::new(self.handle, self.inner)
    }
    /// <p>The ID of the domain in which the rules are to be listed.</p>
    pub fn domain_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain_identifier(input.into());
        self
    }
    /// <p>The ID of the domain in which the rules are to be listed.</p>
    pub fn set_domain_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain_identifier(input);
        self
    }
    /// <p>The ID of the domain in which the rules are to be listed.</p>
    pub fn get_domain_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain_identifier()
    }
    /// <p>The target type of the rule.</p>
    pub fn target_type(mut self, input: crate::types::RuleTargetType) -> Self {
        self.inner = self.inner.target_type(input);
        self
    }
    /// <p>The target type of the rule.</p>
    pub fn set_target_type(mut self, input: ::std::option::Option<crate::types::RuleTargetType>) -> Self {
        self.inner = self.inner.set_target_type(input);
        self
    }
    /// <p>The target type of the rule.</p>
    pub fn get_target_type(&self) -> &::std::option::Option<crate::types::RuleTargetType> {
        self.inner.get_target_type()
    }
    /// <p>The target ID of the rule.</p>
    pub fn target_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.target_identifier(input.into());
        self
    }
    /// <p>The target ID of the rule.</p>
    pub fn set_target_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_target_identifier(input);
        self
    }
    /// <p>The target ID of the rule.</p>
    pub fn get_target_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_target_identifier()
    }
    /// <p>The type of the rule.</p>
    pub fn rule_type(mut self, input: crate::types::RuleType) -> Self {
        self.inner = self.inner.rule_type(input);
        self
    }
    /// <p>The type of the rule.</p>
    pub fn set_rule_type(mut self, input: ::std::option::Option<crate::types::RuleType>) -> Self {
        self.inner = self.inner.set_rule_type(input);
        self
    }
    /// <p>The type of the rule.</p>
    pub fn get_rule_type(&self) -> &::std::option::Option<crate::types::RuleType> {
        self.inner.get_rule_type()
    }
    /// <p>The action of the rule.</p>
    pub fn action(mut self, input: crate::types::RuleAction) -> Self {
        self.inner = self.inner.action(input);
        self
    }
    /// <p>The action of the rule.</p>
    pub fn set_action(mut self, input: ::std::option::Option<crate::types::RuleAction>) -> Self {
        self.inner = self.inner.set_action(input);
        self
    }
    /// <p>The action of the rule.</p>
    pub fn get_action(&self) -> &::std::option::Option<crate::types::RuleAction> {
        self.inner.get_action()
    }
    ///
    /// Appends an item to `projectIds`.
    ///
    /// To override the contents of this collection use [`set_project_ids`](Self::set_project_ids).
    ///
    /// <p>The IDs of projects in which rules are to be listed.</p>
    pub fn project_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.project_ids(input.into());
        self
    }
    /// <p>The IDs of projects in which rules are to be listed.</p>
    pub fn set_project_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_project_ids(input);
        self
    }
    /// <p>The IDs of projects in which rules are to be listed.</p>
    pub fn get_project_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_project_ids()
    }
    ///
    /// Appends an item to `assetTypes`.
    ///
    /// To override the contents of this collection use [`set_asset_types`](Self::set_asset_types).
    ///
    /// <p>The asset types of the rule.</p>
    pub fn asset_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.asset_types(input.into());
        self
    }
    /// <p>The asset types of the rule.</p>
    pub fn set_asset_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_asset_types(input);
        self
    }
    /// <p>The asset types of the rule.</p>
    pub fn get_asset_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_asset_types()
    }
    /// <p>The data product of the rule.</p>
    pub fn data_product(mut self, input: bool) -> Self {
        self.inner = self.inner.data_product(input);
        self
    }
    /// <p>The data product of the rule.</p>
    pub fn set_data_product(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_data_product(input);
        self
    }
    /// <p>The data product of the rule.</p>
    pub fn get_data_product(&self) -> &::std::option::Option<bool> {
        self.inner.get_data_product()
    }
    /// <p>Specifies whether to include cascading rules in the results.</p>
    pub fn include_cascaded(mut self, input: bool) -> Self {
        self.inner = self.inner.include_cascaded(input);
        self
    }
    /// <p>Specifies whether to include cascading rules in the results.</p>
    pub fn set_include_cascaded(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_include_cascaded(input);
        self
    }
    /// <p>Specifies whether to include cascading rules in the results.</p>
    pub fn get_include_cascaded(&self) -> &::std::option::Option<bool> {
        self.inner.get_include_cascaded()
    }
    /// <p>The maximum number of rules to return in a single call to <code>ListRules</code>. When the number of rules to be listed is greater than the value of <code>MaxResults</code>, the response contains a <code>NextToken</code> value that you can use in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of rules to return in a single call to <code>ListRules</code>. When the number of rules to be listed is greater than the value of <code>MaxResults</code>, the response contains a <code>NextToken</code> value that you can use in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>The maximum number of rules to return in a single call to <code>ListRules</code>. When the number of rules to be listed is greater than the value of <code>MaxResults</code>, the response contains a <code>NextToken</code> value that you can use in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    /// <p>When the number of rules is greater than the default value for the <code>MaxResults</code> parameter, or if you explicitly specify a value for <code>MaxResults</code> that is less than the number of rules, the response includes a pagination token named <code>NextToken</code>. You can specify this <code>NextToken</code> value in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>When the number of rules is greater than the default value for the <code>MaxResults</code> parameter, or if you explicitly specify a value for <code>MaxResults</code> that is less than the number of rules, the response includes a pagination token named <code>NextToken</code>. You can specify this <code>NextToken</code> value in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>When the number of rules is greater than the default value for the <code>MaxResults</code> parameter, or if you explicitly specify a value for <code>MaxResults</code> that is less than the number of rules, the response includes a pagination token named <code>NextToken</code>. You can specify this <code>NextToken</code> value in a subsequent call to <code>ListRules</code> to list the next set of rules.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_next_token()
    }
}
