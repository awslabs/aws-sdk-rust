// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the details for an Amazon RDS DB shard group.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ModifyDbShardGroupOutput {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the DB shard group.</p>
    pub db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub db_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub max_acu: ::std::option::Option<f64>,
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub min_acu: ::std::option::Option<f64>,
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub compute_redundancy: ::std::option::Option<i32>,
    /// <p>The status of the DB shard group.</p>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>The connection endpoint for the DB shard group.</p>
    pub endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub db_shard_group_arn: ::std::option::Option<::std::string::String>,
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub tag_list: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    _request_id: Option<String>,
}
impl ModifyDbShardGroupOutput {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_resource_id.as_deref()
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_identifier.as_deref()
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(&self) -> ::std::option::Option<f64> {
        self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(&self) -> ::std::option::Option<f64> {
        self.min_acu
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(&self) -> ::std::option::Option<i32> {
        self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(&self) -> ::std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn db_shard_group_arn(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_arn.as_deref()
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tag_list.is_none()`.
    pub fn tag_list(&self) -> &[crate::types::Tag] {
        self.tag_list.as_deref().unwrap_or_default()
    }
}
impl ::aws_types::request_id::RequestId for ModifyDbShardGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ModifyDbShardGroupOutput {
    /// Creates a new builder-style object to manufacture [`ModifyDbShardGroupOutput`](crate::operation::modify_db_shard_group::ModifyDbShardGroupOutput).
    pub fn builder() -> crate::operation::modify_db_shard_group::builders::ModifyDbShardGroupOutputBuilder {
        crate::operation::modify_db_shard_group::builders::ModifyDbShardGroupOutputBuilder::default()
    }
}

/// A builder for [`ModifyDbShardGroupOutput`](crate::operation::modify_db_shard_group::ModifyDbShardGroupOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ModifyDbShardGroupOutputBuilder {
    pub(crate) db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    pub(crate) db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) db_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) max_acu: ::std::option::Option<f64>,
    pub(crate) min_acu: ::std::option::Option<f64>,
    pub(crate) compute_redundancy: ::std::option::Option<i32>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) db_shard_group_arn: ::std::option::Option<::std::string::String>,
    pub(crate) tag_list: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    _request_id: Option<String>,
}
impl ModifyDbShardGroupOutputBuilder {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn set_db_shard_group_resource_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = input;
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn get_db_shard_group_resource_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_resource_id
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn set_db_shard_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_identifier = input;
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn get_db_shard_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_identifier
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_cluster_identifier = input;
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_cluster_identifier
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(mut self, input: f64) -> Self {
        self.max_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_max_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_acu = input;
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_max_acu(&self) -> &::std::option::Option<f64> {
        &self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(mut self, input: f64) -> Self {
        self.min_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_min_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.min_acu = input;
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_min_acu(&self) -> &::std::option::Option<f64> {
        &self.min_acu
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(mut self, input: i32) -> Self {
        self.compute_redundancy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn set_compute_redundancy(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_redundancy = input;
        self
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn get_compute_redundancy(&self) -> &::std::option::Option<i32> {
        &self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn set_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn get_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.endpoint
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn db_shard_group_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn set_db_shard_group_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn get_db_shard_group_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_arn
    }
    /// Appends an item to `tag_list`.
    ///
    /// To override the contents of this collection use [`set_tag_list`](Self::set_tag_list).
    ///
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn tag_list(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tag_list.unwrap_or_default();
        v.push(input);
        self.tag_list = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn set_tag_list(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tag_list = input;
        self
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn get_tag_list(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tag_list
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`ModifyDbShardGroupOutput`](crate::operation::modify_db_shard_group::ModifyDbShardGroupOutput).
    pub fn build(self) -> crate::operation::modify_db_shard_group::ModifyDbShardGroupOutput {
        crate::operation::modify_db_shard_group::ModifyDbShardGroupOutput {
            db_shard_group_resource_id: self.db_shard_group_resource_id,
            db_shard_group_identifier: self.db_shard_group_identifier,
            db_cluster_identifier: self.db_cluster_identifier,
            max_acu: self.max_acu,
            min_acu: self.min_acu,
            compute_redundancy: self.compute_redundancy,
            status: self.status,
            publicly_accessible: self.publicly_accessible,
            endpoint: self.endpoint,
            db_shard_group_arn: self.db_shard_group_arn,
            tag_list: self.tag_list,
            _request_id: self._request_id,
        }
    }
}
