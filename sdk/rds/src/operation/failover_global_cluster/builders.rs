// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::failover_global_cluster::_failover_global_cluster_output::FailoverGlobalClusterOutputBuilder;

pub use crate::operation::failover_global_cluster::_failover_global_cluster_input::FailoverGlobalClusterInputBuilder;

impl FailoverGlobalClusterInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::failover_global_cluster::FailoverGlobalClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::failover_global_cluster::FailoverGlobalClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.failover_global_cluster();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `FailoverGlobalCluster`.
///
/// <p>Promotes the specified secondary DB cluster to be the primary DB cluster in the global database cluster to fail over or switch over a global database. Switchover operations were previously called "managed planned failovers."</p><note>
/// <p>Although this operation can be used either to fail over or to switch over a global database cluster, its intended use is for global database failover. To switch over a global database cluster, we recommend that you use the <code>SwitchoverGlobalCluster</code> operation instead.</p>
/// </note>
/// <p>How you use this operation depends on whether you are failing over or switching over your global database cluster:</p>
/// <ul>
/// <li>
/// <p>Failing over - Specify the <code>AllowDataLoss</code> parameter and don't specify the <code>Switchover</code> parameter.</p></li>
/// <li>
/// <p>Switching over - Specify the <code>Switchover</code> parameter or omit it, but don't specify the <code>AllowDataLoss</code> parameter.</p></li>
/// </ul>
/// <p><b>About failing over and switching over</b></p>
/// <p>While failing over and switching over a global database cluster both change the primary DB cluster, you use these operations for different reasons:</p>
/// <ul>
/// <li>
/// <p><i>Failing over</i> - Use this operation to respond to an unplanned event, such as a Regional disaster in the primary Region. Failing over can result in a loss of write transaction data that wasn't replicated to the chosen secondary before the failover event occurred. However, the recovery process that promotes a DB instance on the chosen seconday DB cluster to be the primary writer DB instance guarantees that the data is in a transactionally consistent state.</p>
/// <p>For more information about failing over an Amazon Aurora global database, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database-disaster-recovery.html#aurora-global-database-failover.managed-unplanned">Performing managed failovers for Aurora global databases</a> in the <i>Amazon Aurora User Guide</i>.</p></li>
/// <li>
/// <p><i>Switching over</i> - Use this operation on a healthy global database cluster for planned events, such as Regional rotation or to fail back to the original primary DB cluster after a failover operation. With this operation, there is no data loss.</p>
/// <p>For more information about switching over an Amazon Aurora global database, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database-disaster-recovery.html#aurora-global-database-disaster-recovery.managed-failover">Performing switchovers for Aurora global databases</a> in the <i>Amazon Aurora User Guide</i>.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct FailoverGlobalClusterFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::failover_global_cluster::builders::FailoverGlobalClusterInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::failover_global_cluster::FailoverGlobalClusterOutput,
        crate::operation::failover_global_cluster::FailoverGlobalClusterError,
    > for FailoverGlobalClusterFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::failover_global_cluster::FailoverGlobalClusterOutput,
            crate::operation::failover_global_cluster::FailoverGlobalClusterError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl FailoverGlobalClusterFluentBuilder {
    /// Creates a new `FailoverGlobalCluster`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the FailoverGlobalCluster as a reference.
    pub fn as_input(&self) -> &crate::operation::failover_global_cluster::builders::FailoverGlobalClusterInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::failover_global_cluster::FailoverGlobalClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::failover_global_cluster::FailoverGlobalClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::failover_global_cluster::FailoverGlobalCluster::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::failover_global_cluster::FailoverGlobalCluster::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::failover_global_cluster::FailoverGlobalClusterOutput,
        crate::operation::failover_global_cluster::FailoverGlobalClusterError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The identifier of the global database cluster (Aurora global database) this operation should apply to. The identifier is the unique key assigned by the user when the Aurora global database is created. In other words, it's the name of the Aurora global database.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing global database cluster.</p></li>
    /// </ul>
    pub fn global_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.global_cluster_identifier(input.into());
        self
    }
    /// <p>The identifier of the global database cluster (Aurora global database) this operation should apply to. The identifier is the unique key assigned by the user when the Aurora global database is created. In other words, it's the name of the Aurora global database.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing global database cluster.</p></li>
    /// </ul>
    pub fn set_global_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_global_cluster_identifier(input);
        self
    }
    /// <p>The identifier of the global database cluster (Aurora global database) this operation should apply to. The identifier is the unique key assigned by the user when the Aurora global database is created. In other words, it's the name of the Aurora global database.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing global database cluster.</p></li>
    /// </ul>
    pub fn get_global_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_global_cluster_identifier()
    }
    /// <p>The identifier of the secondary Aurora DB cluster that you want to promote to the primary for the global database cluster. Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.</p>
    pub fn target_db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.target_db_cluster_identifier(input.into());
        self
    }
    /// <p>The identifier of the secondary Aurora DB cluster that you want to promote to the primary for the global database cluster. Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.</p>
    pub fn set_target_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_target_db_cluster_identifier(input);
        self
    }
    /// <p>The identifier of the secondary Aurora DB cluster that you want to promote to the primary for the global database cluster. Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.</p>
    pub fn get_target_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_target_db_cluster_identifier()
    }
    /// <p>Specifies whether to allow data loss for this global database cluster operation. Allowing data loss triggers a global failover operation.</p>
    /// <p>If you don't specify <code>AllowDataLoss</code>, the global database cluster operation defaults to a switchover.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>Switchover</code> parameter.</p></li>
    /// </ul>
    pub fn allow_data_loss(mut self, input: bool) -> Self {
        self.inner = self.inner.allow_data_loss(input);
        self
    }
    /// <p>Specifies whether to allow data loss for this global database cluster operation. Allowing data loss triggers a global failover operation.</p>
    /// <p>If you don't specify <code>AllowDataLoss</code>, the global database cluster operation defaults to a switchover.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>Switchover</code> parameter.</p></li>
    /// </ul>
    pub fn set_allow_data_loss(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_allow_data_loss(input);
        self
    }
    /// <p>Specifies whether to allow data loss for this global database cluster operation. Allowing data loss triggers a global failover operation.</p>
    /// <p>If you don't specify <code>AllowDataLoss</code>, the global database cluster operation defaults to a switchover.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>Switchover</code> parameter.</p></li>
    /// </ul>
    pub fn get_allow_data_loss(&self) -> &::std::option::Option<bool> {
        self.inner.get_allow_data_loss()
    }
    /// <p>Specifies whether to switch over this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>AllowDataLoss</code> parameter.</p></li>
    /// </ul>
    pub fn switchover(mut self, input: bool) -> Self {
        self.inner = self.inner.switchover(input);
        self
    }
    /// <p>Specifies whether to switch over this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>AllowDataLoss</code> parameter.</p></li>
    /// </ul>
    pub fn set_switchover(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_switchover(input);
        self
    }
    /// <p>Specifies whether to switch over this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified together with the <code>AllowDataLoss</code> parameter.</p></li>
    /// </ul>
    pub fn get_switchover(&self) -> &::std::option::Option<bool> {
        self.inner.get_switchover()
    }
}
