// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::modify_current_db_cluster_capacity::_modify_current_db_cluster_capacity_output::ModifyCurrentDbClusterCapacityOutputBuilder;

pub use crate::operation::modify_current_db_cluster_capacity::_modify_current_db_cluster_capacity_input::ModifyCurrentDbClusterCapacityInputBuilder;

impl crate::operation::modify_current_db_cluster_capacity::builders::ModifyCurrentDbClusterCapacityInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDbClusterCapacityOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacityError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.modify_current_db_cluster_capacity();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ModifyCurrentDBClusterCapacity`.
///
/// <p>Set the capacity of an Aurora Serverless v1 DB cluster to a specific value.</p>
/// <p>Aurora Serverless v1 scales seamlessly based on the workload on the DB cluster. In some cases, the capacity might not scale fast enough to meet a sudden change in workload, such as a large number of new transactions. Call <code>ModifyCurrentDBClusterCapacity</code> to set the capacity explicitly.</p>
/// <p>After this call sets the DB cluster capacity, Aurora Serverless v1 can automatically scale the DB cluster based on the cooldown period for scaling up and the cooldown period for scaling down.</p>
/// <p>For more information about Aurora Serverless v1, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless v1</a> in the <i>Amazon Aurora User Guide</i>.</p><important>
/// <p>If you call <code>ModifyCurrentDBClusterCapacity</code> with the default <code>TimeoutAction</code>, connections that prevent Aurora Serverless v1 from finding a scaling point might be dropped. For more information about scaling points, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling"> Autoscaling for Aurora Serverless v1</a> in the <i>Amazon Aurora User Guide</i>.</p>
/// </important> <note>
/// <p>This operation only applies to Aurora Serverless v1 DB clusters.</p>
/// </note>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ModifyCurrentDBClusterCapacityFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::modify_current_db_cluster_capacity::builders::ModifyCurrentDbClusterCapacityInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDbClusterCapacityOutput,
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacityError,
    > for ModifyCurrentDBClusterCapacityFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDbClusterCapacityOutput,
            crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacityError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ModifyCurrentDBClusterCapacityFluentBuilder {
    /// Creates a new `ModifyCurrentDBClusterCapacity`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ModifyCurrentDBClusterCapacity as a reference.
    pub fn as_input(&self) -> &crate::operation::modify_current_db_cluster_capacity::builders::ModifyCurrentDbClusterCapacityInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDbClusterCapacityOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacityError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacity::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacity::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDbClusterCapacityOutput,
        crate::operation::modify_current_db_cluster_capacity::ModifyCurrentDBClusterCapacityError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing DB cluster.</p></li>
    /// </ul>
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.db_cluster_identifier(input.into());
        self
    }
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing DB cluster.</p></li>
    /// </ul>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_db_cluster_identifier(input);
        self
    }
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must match the identifier of an existing DB cluster.</p></li>
    /// </ul>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_db_cluster_identifier()
    }
    /// <p>The DB cluster capacity.</p>
    /// <p>When you change the capacity of a paused Aurora Serverless v1 DB cluster, it automatically resumes.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p></li>
    /// <li>
    /// <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p></li>
    /// </ul>
    pub fn capacity(mut self, input: i32) -> Self {
        self.inner = self.inner.capacity(input);
        self
    }
    /// <p>The DB cluster capacity.</p>
    /// <p>When you change the capacity of a paused Aurora Serverless v1 DB cluster, it automatically resumes.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p></li>
    /// <li>
    /// <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p></li>
    /// </ul>
    pub fn set_capacity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_capacity(input);
        self
    }
    /// <p>The DB cluster capacity.</p>
    /// <p>When you change the capacity of a paused Aurora Serverless v1 DB cluster, it automatically resumes.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p></li>
    /// <li>
    /// <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p></li>
    /// </ul>
    pub fn get_capacity(&self) -> &::std::option::Option<i32> {
        self.inner.get_capacity()
    }
    /// <p>The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300.</p>
    /// <p>Specify a value between 10 and 600 seconds.</p>
    pub fn seconds_before_timeout(mut self, input: i32) -> Self {
        self.inner = self.inner.seconds_before_timeout(input);
        self
    }
    /// <p>The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300.</p>
    /// <p>Specify a value between 10 and 600 seconds.</p>
    pub fn set_seconds_before_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_seconds_before_timeout(input);
        self
    }
    /// <p>The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300.</p>
    /// <p>Specify a value between 10 and 600 seconds.</p>
    pub fn get_seconds_before_timeout(&self) -> &::std::option::Option<i32> {
        self.inner.get_seconds_before_timeout()
    }
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    /// <p><code>ForceApplyCapacityChange</code>, the default, sets the capacity to the specified value as soon as possible.</p>
    /// <p><code>RollbackCapacityChange</code> ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    pub fn timeout_action(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.timeout_action(input.into());
        self
    }
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    /// <p><code>ForceApplyCapacityChange</code>, the default, sets the capacity to the specified value as soon as possible.</p>
    /// <p><code>RollbackCapacityChange</code> ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    pub fn set_timeout_action(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_timeout_action(input);
        self
    }
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    /// <p><code>ForceApplyCapacityChange</code>, the default, sets the capacity to the specified value as soon as possible.</p>
    /// <p><code>RollbackCapacityChange</code> ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    pub fn get_timeout_action(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_timeout_action()
    }
}
