// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateGlobalClusterInput {
    /// <p>The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.</p>
    pub global_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) to use as the primary cluster of the global database.</p>
    /// <p>If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:</p>
    /// <ul>
    /// <li>
    /// <p><code>DatabaseName</code></p></li>
    /// <li>
    /// <p><code>Engine</code></p></li>
    /// <li>
    /// <p><code>EngineVersion</code></p></li>
    /// <li>
    /// <p><code>StorageEncrypted</code></p></li>
    /// </ul>
    pub source_db_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The database engine to use for this global database cluster.</p>
    /// <p>Valid Values: <code>aurora-mysql | aurora-postgresql</code></p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.</p></li>
    /// </ul>
    pub engine: ::std::option::Option<::std::string::String>,
    /// <p>The engine version to use for this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.</p></li>
    /// </ul>
    pub engine_version: ::std::option::Option<::std::string::String>,
    /// <p>The life cycle type for this global database cluster.</p><note>
    /// <p>By default, this value is set to <code>open-source-rds-extended-support</code>, which enrolls your global cluster into Amazon RDS Extended Support. At the end of standard support, you can avoid charges for Extended Support by setting the value to <code>open-source-rds-extended-support-disabled</code>. In this case, creating the global cluster will fail if the DB major version is past its end of standard support date.</p>
    /// </note>
    /// <p>This setting only applies to Aurora PostgreSQL-based global databases.</p>
    /// <p>You can use this setting to enroll your global cluster into Amazon RDS Extended Support. With RDS Extended Support, you can run the selected major engine version on your global cluster past the end of standard support for that engine version. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/extended-support.html">Using Amazon RDS Extended Support</a> in the <i>Amazon Aurora User Guide</i>.</p>
    /// <p>Valid Values: <code>open-source-rds-extended-support | open-source-rds-extended-support-disabled</code></p>
    /// <p>Default: <code>open-source-rds-extended-support</code></p>
    pub engine_lifecycle_support: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.</p>
    pub deletion_protection: ::std::option::Option<bool>,
    /// <p>The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.</p></li>
    /// </ul>
    pub database_name: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether to enable storage encryption for the new global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.</p></li>
    /// </ul>
    pub storage_encrypted: ::std::option::Option<bool>,
}
impl CreateGlobalClusterInput {
    /// <p>The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.</p>
    pub fn global_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.global_cluster_identifier.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) to use as the primary cluster of the global database.</p>
    /// <p>If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:</p>
    /// <ul>
    /// <li>
    /// <p><code>DatabaseName</code></p></li>
    /// <li>
    /// <p><code>Engine</code></p></li>
    /// <li>
    /// <p><code>EngineVersion</code></p></li>
    /// <li>
    /// <p><code>StorageEncrypted</code></p></li>
    /// </ul>
    pub fn source_db_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.source_db_cluster_identifier.as_deref()
    }
    /// <p>The database engine to use for this global database cluster.</p>
    /// <p>Valid Values: <code>aurora-mysql | aurora-postgresql</code></p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.</p></li>
    /// </ul>
    pub fn engine(&self) -> ::std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>The engine version to use for this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.</p></li>
    /// </ul>
    pub fn engine_version(&self) -> ::std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The life cycle type for this global database cluster.</p><note>
    /// <p>By default, this value is set to <code>open-source-rds-extended-support</code>, which enrolls your global cluster into Amazon RDS Extended Support. At the end of standard support, you can avoid charges for Extended Support by setting the value to <code>open-source-rds-extended-support-disabled</code>. In this case, creating the global cluster will fail if the DB major version is past its end of standard support date.</p>
    /// </note>
    /// <p>This setting only applies to Aurora PostgreSQL-based global databases.</p>
    /// <p>You can use this setting to enroll your global cluster into Amazon RDS Extended Support. With RDS Extended Support, you can run the selected major engine version on your global cluster past the end of standard support for that engine version. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/extended-support.html">Using Amazon RDS Extended Support</a> in the <i>Amazon Aurora User Guide</i>.</p>
    /// <p>Valid Values: <code>open-source-rds-extended-support | open-source-rds-extended-support-disabled</code></p>
    /// <p>Default: <code>open-source-rds-extended-support</code></p>
    pub fn engine_lifecycle_support(&self) -> ::std::option::Option<&str> {
        self.engine_lifecycle_support.as_deref()
    }
    /// <p>Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.</p>
    pub fn deletion_protection(&self) -> ::std::option::Option<bool> {
        self.deletion_protection
    }
    /// <p>The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.</p></li>
    /// </ul>
    pub fn database_name(&self) -> ::std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>Specifies whether to enable storage encryption for the new global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.</p></li>
    /// </ul>
    pub fn storage_encrypted(&self) -> ::std::option::Option<bool> {
        self.storage_encrypted
    }
}
impl CreateGlobalClusterInput {
    /// Creates a new builder-style object to manufacture [`CreateGlobalClusterInput`](crate::operation::create_global_cluster::CreateGlobalClusterInput).
    pub fn builder() -> crate::operation::create_global_cluster::builders::CreateGlobalClusterInputBuilder {
        crate::operation::create_global_cluster::builders::CreateGlobalClusterInputBuilder::default()
    }
}

/// A builder for [`CreateGlobalClusterInput`](crate::operation::create_global_cluster::CreateGlobalClusterInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateGlobalClusterInputBuilder {
    pub(crate) global_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) source_db_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) engine: ::std::option::Option<::std::string::String>,
    pub(crate) engine_version: ::std::option::Option<::std::string::String>,
    pub(crate) engine_lifecycle_support: ::std::option::Option<::std::string::String>,
    pub(crate) deletion_protection: ::std::option::Option<bool>,
    pub(crate) database_name: ::std::option::Option<::std::string::String>,
    pub(crate) storage_encrypted: ::std::option::Option<bool>,
}
impl CreateGlobalClusterInputBuilder {
    /// <p>The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.</p>
    pub fn global_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.global_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.</p>
    pub fn set_global_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.global_cluster_identifier = input;
        self
    }
    /// <p>The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.</p>
    pub fn get_global_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.global_cluster_identifier
    }
    /// <p>The Amazon Resource Name (ARN) to use as the primary cluster of the global database.</p>
    /// <p>If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:</p>
    /// <ul>
    /// <li>
    /// <p><code>DatabaseName</code></p></li>
    /// <li>
    /// <p><code>Engine</code></p></li>
    /// <li>
    /// <p><code>EngineVersion</code></p></li>
    /// <li>
    /// <p><code>StorageEncrypted</code></p></li>
    /// </ul>
    pub fn source_db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_db_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) to use as the primary cluster of the global database.</p>
    /// <p>If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:</p>
    /// <ul>
    /// <li>
    /// <p><code>DatabaseName</code></p></li>
    /// <li>
    /// <p><code>Engine</code></p></li>
    /// <li>
    /// <p><code>EngineVersion</code></p></li>
    /// <li>
    /// <p><code>StorageEncrypted</code></p></li>
    /// </ul>
    pub fn set_source_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_db_cluster_identifier = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) to use as the primary cluster of the global database.</p>
    /// <p>If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:</p>
    /// <ul>
    /// <li>
    /// <p><code>DatabaseName</code></p></li>
    /// <li>
    /// <p><code>Engine</code></p></li>
    /// <li>
    /// <p><code>EngineVersion</code></p></li>
    /// <li>
    /// <p><code>StorageEncrypted</code></p></li>
    /// </ul>
    pub fn get_source_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_db_cluster_identifier
    }
    /// <p>The database engine to use for this global database cluster.</p>
    /// <p>Valid Values: <code>aurora-mysql | aurora-postgresql</code></p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.</p></li>
    /// </ul>
    pub fn engine(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.engine = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The database engine to use for this global database cluster.</p>
    /// <p>Valid Values: <code>aurora-mysql | aurora-postgresql</code></p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.</p></li>
    /// </ul>
    pub fn set_engine(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.engine = input;
        self
    }
    /// <p>The database engine to use for this global database cluster.</p>
    /// <p>Valid Values: <code>aurora-mysql | aurora-postgresql</code></p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.</p></li>
    /// </ul>
    pub fn get_engine(&self) -> &::std::option::Option<::std::string::String> {
        &self.engine
    }
    /// <p>The engine version to use for this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.</p></li>
    /// </ul>
    pub fn engine_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.engine_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The engine version to use for this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.</p></li>
    /// </ul>
    pub fn set_engine_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.engine_version = input;
        self
    }
    /// <p>The engine version to use for this global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.</p></li>
    /// </ul>
    pub fn get_engine_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.engine_version
    }
    /// <p>The life cycle type for this global database cluster.</p><note>
    /// <p>By default, this value is set to <code>open-source-rds-extended-support</code>, which enrolls your global cluster into Amazon RDS Extended Support. At the end of standard support, you can avoid charges for Extended Support by setting the value to <code>open-source-rds-extended-support-disabled</code>. In this case, creating the global cluster will fail if the DB major version is past its end of standard support date.</p>
    /// </note>
    /// <p>This setting only applies to Aurora PostgreSQL-based global databases.</p>
    /// <p>You can use this setting to enroll your global cluster into Amazon RDS Extended Support. With RDS Extended Support, you can run the selected major engine version on your global cluster past the end of standard support for that engine version. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/extended-support.html">Using Amazon RDS Extended Support</a> in the <i>Amazon Aurora User Guide</i>.</p>
    /// <p>Valid Values: <code>open-source-rds-extended-support | open-source-rds-extended-support-disabled</code></p>
    /// <p>Default: <code>open-source-rds-extended-support</code></p>
    pub fn engine_lifecycle_support(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.engine_lifecycle_support = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The life cycle type for this global database cluster.</p><note>
    /// <p>By default, this value is set to <code>open-source-rds-extended-support</code>, which enrolls your global cluster into Amazon RDS Extended Support. At the end of standard support, you can avoid charges for Extended Support by setting the value to <code>open-source-rds-extended-support-disabled</code>. In this case, creating the global cluster will fail if the DB major version is past its end of standard support date.</p>
    /// </note>
    /// <p>This setting only applies to Aurora PostgreSQL-based global databases.</p>
    /// <p>You can use this setting to enroll your global cluster into Amazon RDS Extended Support. With RDS Extended Support, you can run the selected major engine version on your global cluster past the end of standard support for that engine version. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/extended-support.html">Using Amazon RDS Extended Support</a> in the <i>Amazon Aurora User Guide</i>.</p>
    /// <p>Valid Values: <code>open-source-rds-extended-support | open-source-rds-extended-support-disabled</code></p>
    /// <p>Default: <code>open-source-rds-extended-support</code></p>
    pub fn set_engine_lifecycle_support(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.engine_lifecycle_support = input;
        self
    }
    /// <p>The life cycle type for this global database cluster.</p><note>
    /// <p>By default, this value is set to <code>open-source-rds-extended-support</code>, which enrolls your global cluster into Amazon RDS Extended Support. At the end of standard support, you can avoid charges for Extended Support by setting the value to <code>open-source-rds-extended-support-disabled</code>. In this case, creating the global cluster will fail if the DB major version is past its end of standard support date.</p>
    /// </note>
    /// <p>This setting only applies to Aurora PostgreSQL-based global databases.</p>
    /// <p>You can use this setting to enroll your global cluster into Amazon RDS Extended Support. With RDS Extended Support, you can run the selected major engine version on your global cluster past the end of standard support for that engine version. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/extended-support.html">Using Amazon RDS Extended Support</a> in the <i>Amazon Aurora User Guide</i>.</p>
    /// <p>Valid Values: <code>open-source-rds-extended-support | open-source-rds-extended-support-disabled</code></p>
    /// <p>Default: <code>open-source-rds-extended-support</code></p>
    pub fn get_engine_lifecycle_support(&self) -> &::std::option::Option<::std::string::String> {
        &self.engine_lifecycle_support
    }
    /// <p>Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.</p>
    pub fn deletion_protection(mut self, input: bool) -> Self {
        self.deletion_protection = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.</p>
    pub fn set_deletion_protection(mut self, input: ::std::option::Option<bool>) -> Self {
        self.deletion_protection = input;
        self
    }
    /// <p>Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.</p>
    pub fn get_deletion_protection(&self) -> &::std::option::Option<bool> {
        &self.deletion_protection
    }
    /// <p>The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.</p></li>
    /// </ul>
    pub fn database_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.</p></li>
    /// </ul>
    pub fn set_database_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database_name = input;
        self
    }
    /// <p>The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.</p></li>
    /// </ul>
    pub fn get_database_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.database_name
    }
    /// <p>Specifies whether to enable storage encryption for the new global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.</p></li>
    /// </ul>
    pub fn storage_encrypted(mut self, input: bool) -> Self {
        self.storage_encrypted = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to enable storage encryption for the new global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.</p></li>
    /// </ul>
    pub fn set_storage_encrypted(mut self, input: ::std::option::Option<bool>) -> Self {
        self.storage_encrypted = input;
        self
    }
    /// <p>Specifies whether to enable storage encryption for the new global database cluster.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can't be specified if <code>SourceDBClusterIdentifier</code> is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.</p></li>
    /// </ul>
    pub fn get_storage_encrypted(&self) -> &::std::option::Option<bool> {
        &self.storage_encrypted
    }
    /// Consumes the builder and constructs a [`CreateGlobalClusterInput`](crate::operation::create_global_cluster::CreateGlobalClusterInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_global_cluster::CreateGlobalClusterInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_global_cluster::CreateGlobalClusterInput {
            global_cluster_identifier: self.global_cluster_identifier,
            source_db_cluster_identifier: self.source_db_cluster_identifier,
            engine: self.engine,
            engine_version: self.engine_version,
            engine_lifecycle_support: self.engine_lifecycle_support,
            deletion_protection: self.deletion_protection,
            database_name: self.database_name,
            storage_encrypted: self.storage_encrypted,
        })
    }
}
