// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DeleteDbShardGroupOutput {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the DB shard group.</p>
    pub db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub db_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub max_acu: ::std::option::Option<f64>,
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub min_acu: ::std::option::Option<f64>,
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub compute_redundancy: ::std::option::Option<i32>,
    /// <p>The status of the DB shard group.</p>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>The connection endpoint for the DB shard group.</p>
    pub endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub db_shard_group_arn: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DeleteDbShardGroupOutput {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_resource_id.as_deref()
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_identifier.as_deref()
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(&self) -> ::std::option::Option<f64> {
        self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(&self) -> ::std::option::Option<f64> {
        self.min_acu
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(&self) -> ::std::option::Option<i32> {
        self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(&self) -> ::std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn db_shard_group_arn(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_arn.as_deref()
    }
}
impl ::aws_types::request_id::RequestId for DeleteDbShardGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DeleteDbShardGroupOutput {
    /// Creates a new builder-style object to manufacture [`DeleteDbShardGroupOutput`](crate::operation::delete_db_shard_group::DeleteDbShardGroupOutput).
    pub fn builder() -> crate::operation::delete_db_shard_group::builders::DeleteDbShardGroupOutputBuilder {
        crate::operation::delete_db_shard_group::builders::DeleteDbShardGroupOutputBuilder::default()
    }
}

/// A builder for [`DeleteDbShardGroupOutput`](crate::operation::delete_db_shard_group::DeleteDbShardGroupOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct DeleteDbShardGroupOutputBuilder {
    pub(crate) db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    pub(crate) db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) db_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) max_acu: ::std::option::Option<f64>,
    pub(crate) min_acu: ::std::option::Option<f64>,
    pub(crate) compute_redundancy: ::std::option::Option<i32>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) db_shard_group_arn: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DeleteDbShardGroupOutputBuilder {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn set_db_shard_group_resource_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = input;
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn get_db_shard_group_resource_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_resource_id
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn set_db_shard_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_identifier = input;
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn get_db_shard_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_identifier
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_cluster_identifier = input;
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_cluster_identifier
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(mut self, input: f64) -> Self {
        self.max_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_max_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_acu = input;
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_max_acu(&self) -> &::std::option::Option<f64> {
        &self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(mut self, input: f64) -> Self {
        self.min_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_min_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.min_acu = input;
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_min_acu(&self) -> &::std::option::Option<f64> {
        &self.min_acu
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(mut self, input: i32) -> Self {
        self.compute_redundancy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn set_compute_redundancy(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_redundancy = input;
        self
    }
    /// <p>Specifies whether to create standby DB shard groups for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB shard group. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB shard group in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB shard groups in two different AZs.</p></li>
    /// </ul>
    pub fn get_compute_redundancy(&self) -> &::std::option::Option<i32> {
        &self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn set_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn get_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.endpoint
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn db_shard_group_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn set_db_shard_group_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the DB shard group.</p>
    pub fn get_db_shard_group_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_arn
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DeleteDbShardGroupOutput`](crate::operation::delete_db_shard_group::DeleteDbShardGroupOutput).
    pub fn build(self) -> crate::operation::delete_db_shard_group::DeleteDbShardGroupOutput {
        crate::operation::delete_db_shard_group::DeleteDbShardGroupOutput {
            db_shard_group_resource_id: self.db_shard_group_resource_id,
            db_shard_group_identifier: self.db_shard_group_identifier,
            db_cluster_identifier: self.db_cluster_identifier,
            max_acu: self.max_acu,
            min_acu: self.min_acu,
            compute_redundancy: self.compute_redundancy,
            status: self.status,
            publicly_accessible: self.publicly_accessible,
            endpoint: self.endpoint,
            db_shard_group_arn: self.db_shard_group_arn,
            _request_id: self._request_id,
        }
    }
}
