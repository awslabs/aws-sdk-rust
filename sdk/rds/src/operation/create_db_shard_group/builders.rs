// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_db_shard_group::_create_db_shard_group_output::CreateDbShardGroupOutputBuilder;

pub use crate::operation::create_db_shard_group::_create_db_shard_group_input::CreateDbShardGroupInputBuilder;

impl CreateDbShardGroupInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_db_shard_group::CreateDbShardGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_db_shard_group::CreateDBShardGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_db_shard_group();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateDBShardGroup`.
///
/// <p>Creates a new DB shard group for Aurora Limitless Database. You must enable Aurora Limitless Database to create a DB shard group.</p>
/// <p>Valid for: Aurora DB clusters only</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateDBShardGroupFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_db_shard_group::builders::CreateDbShardGroupInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_db_shard_group::CreateDbShardGroupOutput,
        crate::operation::create_db_shard_group::CreateDBShardGroupError,
    > for CreateDBShardGroupFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_db_shard_group::CreateDbShardGroupOutput,
            crate::operation::create_db_shard_group::CreateDBShardGroupError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateDBShardGroupFluentBuilder {
    /// Creates a new `CreateDBShardGroup`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateDBShardGroup as a reference.
    pub fn as_input(&self) -> &crate::operation::create_db_shard_group::builders::CreateDbShardGroupInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_db_shard_group::CreateDbShardGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_db_shard_group::CreateDBShardGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_db_shard_group::CreateDBShardGroup::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_db_shard_group::CreateDBShardGroup::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_db_shard_group::CreateDbShardGroupOutput,
        crate::operation::create_db_shard_group::CreateDBShardGroupError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.db_shard_group_identifier(input.into());
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn set_db_shard_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_db_shard_group_identifier(input);
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn get_db_shard_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_db_shard_group_identifier()
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.db_cluster_identifier(input.into());
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_db_cluster_identifier(input);
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_db_cluster_identifier()
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn compute_redundancy(mut self, input: i32) -> Self {
        self.inner = self.inner.compute_redundancy(input);
        self
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn set_compute_redundancy(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_compute_redundancy(input);
        self
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn get_compute_redundancy(&self) -> &::std::option::Option<i32> {
        self.inner.get_compute_redundancy()
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(mut self, input: f64) -> Self {
        self.inner = self.inner.max_acu(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_max_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.inner = self.inner.set_max_acu(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_max_acu(&self) -> &::std::option::Option<f64> {
        self.inner.get_max_acu()
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.inner = self.inner.publicly_accessible(input);
        self
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_publicly_accessible(input);
        self
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        self.inner.get_publicly_accessible()
    }
}
