// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDBClusterOutput,
    crate::error::AddRoleToDBClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddRoleToDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterRoleAlreadyExistsFault" => {
            crate::error::AddRoleToDBClusterError {
                meta: generic,
                kind: crate::error::AddRoleToDBClusterErrorKind::DBClusterRoleAlreadyExistsFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_role_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_cluster_role_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBClusterRoleQuotaExceededFault" => {
            crate::error::AddRoleToDBClusterError {
                meta: generic,
                kind: crate::error::AddRoleToDBClusterErrorKind::DBClusterRoleQuotaExceededFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_role_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_cluster_role_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidDBClusterStateFault" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddRoleToDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDBClusterOutput,
    crate::error::AddRoleToDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_db_cluster_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDBInstanceOutput,
    crate::error::AddRoleToDBInstanceError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddRoleToDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceRoleAlreadyExistsFault" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DBInstanceRoleAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_instance_role_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_role_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceRoleQuotaExceededFault" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DBInstanceRoleQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_instance_role_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_role_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddRoleToDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDBInstanceOutput,
    crate::error::AddRoleToDBInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled(generic))
        }
    };
    Err(match error_code {
        "SourceNotFoundFault" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind: crate::error::AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::source_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_source_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SubscriptionNotFoundFault" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind:
                crate::error::AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_not_found_fault::Builder::default();
                        let _ = response;
                        output =
                            crate::xml_deser::deser_structure_subscription_not_found_fault_xml_err(
                                response.body().as_ref(),
                                output,
                            )
                            .map_err(
                                crate::error::AddSourceIdentifierToSubscriptionError::unhandled,
                            )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::AddSourceIdentifierToSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::add_source_identifier_to_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_add_source_identifier_to_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddTagsToResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddTagsToResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddTagsToResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddTagsToResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DBProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddTagsToResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddTagsToResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ApplyPendingMaintenanceActionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidDBClusterStateFault" => {
            crate::error::ApplyPendingMaintenanceActionError {
                meta: generic,
                kind:
                    crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDBClusterStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_db_cluster_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        "InvalidDBInstanceStateFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDBInstanceStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceNotFoundFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_resource_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ApplyPendingMaintenanceActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::apply_pending_maintenance_action_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_apply_pending_maintenance_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_db_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDBSecurityGroupIngressOutput,
    crate::error::AuthorizeDBSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationAlreadyExistsFault" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::authorization_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_authorization_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        "AuthorizationQuotaExceededFault" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::authorization_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_authorization_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        "DBSecurityGroupNotFoundFault" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        "InvalidDBSecurityGroupStateFault" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_security_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        _ => crate::error::AuthorizeDBSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_db_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDBSecurityGroupIngressOutput,
    crate::error::AuthorizeDBSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::authorize_db_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_authorize_db_security_group_ingress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_backtrack_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BacktrackDBClusterOutput,
    crate::error::BacktrackDBClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BacktrackDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::BacktrackDBClusterError {
            meta: generic,
            kind: crate::error::BacktrackDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::BacktrackDBClusterError {
            meta: generic,
            kind: crate::error::BacktrackDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::BacktrackDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_backtrack_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BacktrackDBClusterOutput,
    crate::error::BacktrackDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::backtrack_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_backtrack_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CancelExportTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelExportTaskError::unhandled(generic)),
    };
    Err(match error_code {
        "ExportTaskNotFoundFault" => crate::error::CancelExportTaskError {
            meta: generic,
            kind: crate::error::CancelExportTaskErrorKind::ExportTaskNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::export_task_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_export_task_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CancelExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "InvalidExportTaskStateFault" => crate::error::CancelExportTaskError {
            meta: generic,
            kind: crate::error::CancelExportTaskErrorKind::InvalidExportTaskStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_export_task_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_export_task_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CancelExportTaskError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CancelExportTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_export_task_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_cancel_export_task(response.body().as_ref(), output)
                .map_err(crate::error::CancelExportTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CopyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupAlreadyExistsFault" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupNotFoundFault" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupQuotaExceededFault" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::CopyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_copy_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBClusterSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBClusterSnapshotNotFoundFault" => {
            crate::error::CopyDBClusterSnapshotError {
                meta: generic,
                kind: crate::error::CopyDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBClusterSnapshotStateFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                },
            ),
        },
        "InvalidDBClusterStateFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CopyDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_copy_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBParameterGroupOutput,
    crate::error::CopyDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBParameterGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBParameterGroupAlreadyExistsFault" => crate::error::CopyDBParameterGroupError {
            meta: generic,
            kind: crate::error::CopyDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBParameterGroupNotFoundFault" => {
            crate::error::CopyDBParameterGroupError {
                meta: generic,
                kind: crate::error::CopyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBParameterGroupQuotaExceededFault" => crate::error::CopyDBParameterGroupError {
            meta: generic,
            kind: crate::error::CopyDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::CopyDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDBParameterGroupOutput,
    crate::error::CopyDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_copy_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDBSnapshotOutput, crate::error::CopyDBSnapshotError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "CustomAvailabilityZoneNotFoundFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::custom_availability_zone_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotAlreadyExistsFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_snapshot_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotNotFoundFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSnapshotStateFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::InvalidDBSnapshotStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CopyDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDBSnapshotOutput, crate::error::CopyDBSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_copy_db_snapshot(response.body().as_ref(), output)
                .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyOptionGroupOutput, crate::error::CopyOptionGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyOptionGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "OptionGroupAlreadyExistsFault" => {
            crate::error::CopyOptionGroupError {
                meta: generic,
                kind: crate::error::CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_option_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyOptionGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        "OptionGroupNotFoundFault" => crate::error::CopyOptionGroupError {
            meta: generic,
            kind: crate::error::CopyOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyOptionGroupError::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupQuotaExceededFault" => {
            crate::error::CopyOptionGroupError {
                meta: generic,
                kind: crate::error::CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_option_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyOptionGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        _ => crate::error::CopyOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyOptionGroupOutput, crate::error::CopyOptionGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_option_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_copy_option_group(response.body().as_ref(), output)
                .map_err(crate::error::CopyOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_availability_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomAvailabilityZoneOutput,
    crate::error::CreateCustomAvailabilityZoneError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateCustomAvailabilityZoneError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "CustomAvailabilityZoneAlreadyExistsFault" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_custom_availability_zone_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
            output.build()
        })},
        "CustomAvailabilityZoneQuotaExceededFault" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_custom_availability_zone_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
            output.build()
        })},
        _ => crate::error::CreateCustomAvailabilityZoneError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_availability_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomAvailabilityZoneOutput,
    crate::error::CreateCustomAvailabilityZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_custom_availability_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_custom_availability_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBClusterOutput, crate::error::CreateDBClusterError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_already_exists_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterParameterGroupNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterQuotaExceededFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DomainNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::domain_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InsufficientStorageClusterCapacityFault" => {
            crate::error::CreateDBClusterError {
                meta: generic,
                kind:
                    crate::error::CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(
                        {
                            #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSubnetGroupStateFault" => {
            crate::error::CreateDBClusterError {
                meta: generic,
                kind: crate::error::CreateDBClusterErrorKind::InvalidDBSubnetGroupStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidGlobalClusterStateFault" => {
            crate::error::CreateDBClusterError {
                meta: generic,
                kind: crate::error::CreateDBClusterErrorKind::InvalidGlobalClusterStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidSubnet" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "StorageQuotaExceededFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBClusterOutput, crate::error::CreateDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::CreateDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterEndpointOutput,
    crate::error::CreateDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterEndpointAlreadyExistsFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterEndpointErrorKind::DBClusterEndpointAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_cluster_endpoint_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_cluster_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBClusterEndpointQuotaExceededFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterEndpointErrorKind::DBClusterEndpointQuotaExceededFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_cluster_endpoint_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterEndpointOutput,
    crate::error::CreateDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupAlreadyExistsFault" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupQuotaExceededFault" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::CreateDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBInstanceOutput, crate::error::CreateDBInstanceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::authorization_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_backup_policy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceAlreadyExistsFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DBInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBParameterGroupNotFoundFault" => {
            crate::error::CreateDBInstanceError {
                meta: generic,
                kind: crate::error::CreateDBInstanceErrorKind::DBParameterGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBSecurityGroupNotFoundFault" => {
            crate::error::CreateDBInstanceError {
                meta: generic,
                kind: crate::error::CreateDBInstanceErrorKind::DBSecurityGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DomainNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::domain_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InstanceQuotaExceededFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InstanceQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_instance_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InsufficientDBInstanceCapacityFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InsufficientDBInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "StorageQuotaExceededFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "StorageTypeNotSupportedFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBInstanceOutput, crate::error::CreateDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::CreateDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_read_replica_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBInstanceReadReplicaOutput,
    crate::error::CreateDBInstanceReadReplicaError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBInstanceReadReplicaError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBInstanceAlreadyExistsFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBInstanceNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBInstanceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBSecurityGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotAllowedFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotAllowedFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_allowed_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_allowed_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InstanceQuotaExceededFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InsufficientDBInstanceCapacityFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InsufficientDBInstanceCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceStateFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidDBInstanceStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InvalidDBSubnetGroupFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidDBSubnetGroupFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_subnet_group_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_subnet_group_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "OptionGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAZFault({
            #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        "StorageTypeNotSupportedFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
            output.build()
        })},
        _ => crate::error::CreateDBInstanceReadReplicaError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_read_replica_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBInstanceReadReplicaOutput,
    crate::error::CreateDBInstanceReadReplicaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_instance_read_replica_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_instance_read_replica(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBParameterGroupOutput,
    crate::error::CreateDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupAlreadyExistsFault" => crate::error::CreateDBParameterGroupError {
            meta: generic,
            kind: crate::error::CreateDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBParameterGroupQuotaExceededFault" => crate::error::CreateDBParameterGroupError {
            meta: generic,
            kind: crate::error::CreateDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::CreateDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBParameterGroupOutput,
    crate::error::CreateDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBProxyOutput, crate::error::CreateDBProxyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBProxyError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyAlreadyExistsFault" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::DBProxyAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_already_exists_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyQuotaExceededFault" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::DBProxyQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBProxyOutput, crate::error::CreateDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_proxy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_db_proxy(response.body().as_ref(), output)
                .map_err(crate::error::CreateDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBProxyEndpointOutput,
    crate::error::CreateDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBProxyEndpointError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyEndpointAlreadyExistsFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBProxyEndpointQuotaExceededFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::DBProxyEndpointQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_endpoint_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBProxyNotFoundFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBProxyEndpointOutput,
    crate::error::CreateDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBSecurityGroupOutput,
    crate::error::CreateDBSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSecurityGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSecurityGroupAlreadyExistsFault" => crate::error::CreateDBSecurityGroupError {
            meta: generic,
            kind: crate::error::CreateDBSecurityGroupErrorKind::DBSecurityGroupAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_security_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBSecurityGroupNotSupportedFault" => crate::error::CreateDBSecurityGroupError {
            meta: generic,
            kind: crate::error::CreateDBSecurityGroupErrorKind::DBSecurityGroupNotSupportedFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_security_group_not_supported_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_security_group_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                output.build()
            }),
        },
        "DBSecurityGroupQuotaExceededFault" => crate::error::CreateDBSecurityGroupError {
            meta: generic,
            kind: crate::error::CreateDBSecurityGroupErrorKind::DBSecurityGroupQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_security_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::CreateDBSecurityGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBSecurityGroupOutput,
    crate::error::CreateDBSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_security_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_security_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBSnapshotOutput, crate::error::CreateDBSnapshotError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotAlreadyExistsFault" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_snapshot_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDBSnapshotOutput, crate::error::CreateDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_db_snapshot(response.body().as_ref(), output)
                .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSubnetGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSubnetGroupAlreadyExistsFault" => {
            crate::error::CreateDBSubnetGroupError {
                meta: generic,
                kind: crate::error::CreateDBSubnetGroupErrorKind::DBSubnetGroupAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_subnet_group_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_subnet_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupQuotaExceededFault" => {
            crate::error::CreateDBSubnetGroupError {
                meta: generic,
                kind: crate::error::CreateDBSubnetGroupErrorKind::DBSubnetGroupQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_subnet_group_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_subnet_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBSubnetQuotaExceededFault" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDBSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "EventSubscriptionQuotaExceededFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::event_subscription_quota_exceeded_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "SNSInvalidTopicFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SNSInvalidTopicFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_invalid_topic_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SNSNoAuthorizationFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SNSNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_no_authorization_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SNSTopicArnNotFoundFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SNSTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_topic_arn_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_topic_arn_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SourceNotFoundFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::source_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_source_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SubscriptionAlreadyExistFault" => {
            crate::error::CreateEventSubscriptionError {
                meta: generic,
                kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_already_exist_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_subscription_already_exist_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "SubscriptionCategoryNotFoundFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::subscription_category_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::CreateEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGlobalClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "GlobalClusterAlreadyExistsFault" => {
            crate::error::CreateGlobalClusterError {
                meta: generic,
                kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::global_cluster_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_global_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "GlobalClusterQuotaExceededFault" => {
            crate::error::CreateGlobalClusterError {
                meta: generic,
                kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::global_cluster_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_global_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBClusterStateFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOptionGroupOutput, crate::error::CreateOptionGroupError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOptionGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "OptionGroupAlreadyExistsFault" => {
            crate::error::CreateOptionGroupError {
                meta: generic,
                kind: crate::error::CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_option_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOptionGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        "OptionGroupQuotaExceededFault" => {
            crate::error::CreateOptionGroupError {
                meta: generic,
                kind: crate::error::CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_option_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOptionGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        _ => crate::error::CreateOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOptionGroupOutput, crate::error::CreateOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_option_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_option_group(response.body().as_ref(), output)
                .map_err(crate::error::CreateOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_availability_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomAvailabilityZoneOutput,
    crate::error::DeleteCustomAvailabilityZoneError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteCustomAvailabilityZoneError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "CustomAvailabilityZoneNotFoundFault" => crate::error::DeleteCustomAvailabilityZoneError { meta: generic, kind: crate::error::DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::DeleteCustomAvailabilityZoneError { meta: generic, kind: crate::error::DeleteCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DeleteCustomAvailabilityZoneError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_availability_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomAvailabilityZoneOutput,
    crate::error::DeleteCustomAvailabilityZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_custom_availability_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_custom_availability_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBClusterOutput, crate::error::DeleteDBClusterError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DBClusterSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDBClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBClusterOutput, crate::error::DeleteDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_delete_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::DeleteDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterEndpointOutput,
    crate::error::DeleteDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterEndpointNotFoundFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_endpoint_not_found_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_cluster_endpoint_not_found_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterEndpointStateFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::DeleteDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_db_cluster_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBClusterEndpointErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterEndpointOutput,
    crate::error::DeleteDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "InvalidDBParameterGroupStateFault" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DeleteDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::DeleteDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::DeleteDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBInstanceOutput, crate::error::DeleteDBInstanceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceAutomatedBackupQuotaExceededFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind:
                crate::error::DeleteDBInstanceErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_instance_automated_backup_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBInstanceNotFoundFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotAlreadyExistsFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DBSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_snapshot_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBInstanceOutput, crate::error::DeleteDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_delete_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_automated_backup_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBInstanceAutomatedBackupOutput,
    crate::error::DeleteDBInstanceAutomatedBackupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceAutomatedBackupNotFoundFault" => crate::error::DeleteDBInstanceAutomatedBackupError { meta: generic, kind: crate::error::DeleteDBInstanceAutomatedBackupErrorKind::DBInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceAutomatedBackupStateFault" => crate::error::DeleteDBInstanceAutomatedBackupError { meta: generic, kind: crate::error::DeleteDBInstanceAutomatedBackupErrorKind::InvalidDBInstanceAutomatedBackupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_automated_backup_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_automated_backup_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DeleteDBInstanceAutomatedBackupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_automated_backup_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBInstanceAutomatedBackupOutput,
    crate::error::DeleteDBInstanceAutomatedBackupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_db_instance_automated_backup_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_db_instance_automated_backup(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBParameterGroupOutput,
    crate::error::DeleteDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => {
            crate::error::DeleteDBParameterGroupError {
                meta: generic,
                kind: crate::error::DeleteDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBParameterGroupStateFault" => crate::error::DeleteDBParameterGroupError {
            meta: generic,
            kind: crate::error::DeleteDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DeleteDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBParameterGroupOutput,
    crate::error::DeleteDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBProxyOutput, crate::error::DeleteDBProxyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBProxyError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DeleteDBProxyError {
            meta: generic,
            kind: crate::error::DeleteDBProxyErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBProxyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DeleteDBProxyError {
            meta: generic,
            kind: crate::error::DeleteDBProxyErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBProxyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBProxyOutput, crate::error::DeleteDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_proxy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_delete_db_proxy(response.body().as_ref(), output)
                .map_err(crate::error::DeleteDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBProxyEndpointOutput,
    crate::error::DeleteDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBProxyEndpointError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyEndpointNotFoundFault" => {
            crate::error::DeleteDBProxyEndpointError {
                meta: generic,
                kind: crate::error::DeleteDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidDBProxyEndpointStateFault" => crate::error::DeleteDBProxyEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBProxyEndpointOutput,
    crate::error::DeleteDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBSecurityGroupOutput,
    crate::error::DeleteDBSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSecurityGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSecurityGroupNotFoundFault" => {
            crate::error::DeleteDBSecurityGroupError {
                meta: generic,
                kind: crate::error::DeleteDBSecurityGroupErrorKind::DBSecurityGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidDBSecurityGroupStateFault" => crate::error::DeleteDBSecurityGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSecurityGroupErrorKind::InvalidDBSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_security_group_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBSecurityGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBSecurityGroupOutput,
    crate::error::DeleteDBSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_security_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBSnapshotOutput, crate::error::DeleteDBSnapshotError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSnapshotNotFoundFault" => crate::error::DeleteDBSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBSnapshotErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSnapshotStateFault" => crate::error::DeleteDBSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBSnapshotErrorKind::InvalidDBSnapshotStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDBSnapshotOutput, crate::error::DeleteDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_delete_db_snapshot(response.body().as_ref(), output)
                .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSubnetGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSubnetGroupStateFault" => {
            crate::error::DeleteDBSubnetGroupError {
                meta: generic,
                kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDBSubnetGroupStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidDBSubnetStateFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDBSubnetStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_subnet_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_subnet_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDBSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_subnet_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidEventSubscriptionStateFault" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_event_subscription_state_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_event_subscription_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "SubscriptionNotFoundFault" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind: crate::error::DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::subscription_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_subscription_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGlobalClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DeleteGlobalClusterError {
            meta: generic,
            kind: crate::error::DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidGlobalClusterStateFault" => {
            crate::error::DeleteGlobalClusterError {
                meta: generic,
                kind: crate::error::DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        _ => crate::error::DeleteGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstallationMediaOutput,
    crate::error::DeleteInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteInstallationMediaError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InstallationMediaNotFoundFault" => crate::error::DeleteInstallationMediaError {
            meta: generic,
            kind: crate::error::DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::installation_media_not_found_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_installation_media_not_found_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstallationMediaOutput,
    crate::error::DeleteInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOptionGroupOutput, crate::error::DeleteOptionGroupError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteOptionGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidOptionGroupStateFault" => crate::error::DeleteOptionGroupError {
            meta: generic,
            kind: crate::error::DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_option_group_state_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_invalid_option_group_state_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteOptionGroupError::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::DeleteOptionGroupError {
            meta: generic,
            kind: crate::error::DeleteOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOptionGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOptionGroupOutput, crate::error::DeleteOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_option_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterDBProxyTargetsOutput,
    crate::error::DeregisterDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBProxyTargetNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_target_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeregisterDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterDBProxyTargetsOutput,
    crate::error::DeregisterDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_db_proxy_targets_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
    Err(crate::error::DescribeAccountAttributesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_account_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCertificatesError::unhandled(generic)),
    };
    Err(match error_code {
        "CertificateNotFoundFault" => crate::error::DescribeCertificatesError {
            meta: generic,
            kind: crate::error::DescribeCertificatesErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::certificate_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_certificate_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeCertificatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_custom_availability_zones_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomAvailabilityZonesOutput,
    crate::error::DescribeCustomAvailabilityZonesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCustomAvailabilityZonesError::unhandled(generic)),
    };
    Err(match error_code {
        "CustomAvailabilityZoneNotFoundFault" => crate::error::DescribeCustomAvailabilityZonesError { meta: generic, kind: crate::error::DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeCustomAvailabilityZonesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_custom_availability_zones_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomAvailabilityZonesOutput,
    crate::error::DescribeCustomAvailabilityZonesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_custom_availability_zones_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_custom_availability_zones(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_backtracks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterBacktracksOutput,
    crate::error::DescribeDBClusterBacktracksError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterBacktracksError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterBacktrackNotFoundFault" => crate::error::DescribeDBClusterBacktracksError {
            meta: generic,
            kind:
                crate::error::DescribeDBClusterBacktracksErrorKind::DBClusterBacktrackNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_cluster_backtrack_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_cluster_backtrack_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBClusterNotFoundFault" => crate::error::DescribeDBClusterBacktracksError {
            meta: generic,
            kind: crate::error::DescribeDBClusterBacktracksErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBClusterBacktracksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_backtracks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterBacktracksOutput,
    crate::error::DescribeDBClusterBacktracksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_backtracks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_backtracks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterEndpointsOutput,
    crate::error::DescribeDBClusterEndpointsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterEndpointsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DescribeDBClusterEndpointsError {
            meta: generic,
            kind: crate::error::DescribeDBClusterEndpointsErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBClusterEndpointsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterEndpointsOutput,
    crate::error::DescribeDBClusterEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParameterGroupsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::DescribeDBClusterParameterGroupsError { meta: generic, kind: crate::error::DescribeDBClusterParameterGroupsErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeDBClusterParameterGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_parameter_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_parameter_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParametersError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::DescribeDBClusterParametersError {
            meta: generic,
            kind: crate::error::DescribeDBClusterParametersErrorKind::DBParameterGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DescribeDBClusterParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBClustersError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DescribeDBClustersError {
            meta: generic,
            kind: crate::error::DescribeDBClustersErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBClustersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled(generic))
        }
    };
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotAttributesError { meta: generic, kind: crate::error::DescribeDBClusterSnapshotAttributesErrorKind::DBClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeDBClusterSnapshotAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_snapshot_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_snapshot_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeDBClusterSnapshotsErrorKind::DBClusterSnapshotNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DescribeDBClusterSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
    Err(crate::error::DescribeDBEngineVersionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_engine_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_engine_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instance_automated_backups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBInstanceAutomatedBackupsOutput,
    crate::error::DescribeDBInstanceAutomatedBackupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "DBInstanceAutomatedBackupNotFoundFault" => crate::error::DescribeDBInstanceAutomatedBackupsError { meta: generic, kind: crate::error::DescribeDBInstanceAutomatedBackupsErrorKind::DBInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeDBInstanceAutomatedBackupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instance_automated_backups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBInstanceAutomatedBackupsOutput,
    crate::error::DescribeDBInstanceAutomatedBackupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_instance_automated_backups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_instance_automated_backups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBInstancesError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::DescribeDBInstancesError {
            meta: generic,
            kind: crate::error::DescribeDBInstancesErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_log_files_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBLogFilesOutput,
    crate::error::DescribeDBLogFilesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBLogFilesError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::DescribeDBLogFilesError {
            meta: generic,
            kind: crate::error::DescribeDBLogFilesErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBLogFilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_log_files_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBLogFilesOutput,
    crate::error::DescribeDBLogFilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_log_files_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_log_files(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBParameterGroupsOutput,
    crate::error::DescribeDBParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBParameterGroupsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::DescribeDBParameterGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBParameterGroupsErrorKind::DBParameterGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DescribeDBParameterGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBParameterGroupsOutput,
    crate::error::DescribeDBParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_parameter_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_parameter_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBParametersOutput,
    crate::error::DescribeDBParametersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBParametersError::unhandled(generic)),
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => {
            crate::error::DescribeDBParametersError {
                meta: generic,
                kind: crate::error::DescribeDBParametersErrorKind::DBParameterGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBParametersError::unhandled)?;
                    output.build()
                }),
            }
        }
        _ => crate::error::DescribeDBParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBParametersOutput,
    crate::error::DescribeDBParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDBProxiesOutput, crate::error::DescribeDBProxiesError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBProxiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBProxiesError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxiesError {
            meta: generic,
            kind: crate::error::DescribeDBProxiesErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxiesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBProxiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDBProxiesOutput, crate::error::DescribeDBProxiesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxies_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_describe_db_proxies(response.body().as_ref(), output)
                .map_err(crate::error::DescribeDBProxiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyEndpointsOutput,
    crate::error::DescribeDBProxyEndpointsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyEndpointsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBProxyEndpointNotFoundFault" => {
            crate::error::DescribeDBProxyEndpointsError {
                meta: generic,
                kind: crate::error::DescribeDBProxyEndpointsErrorKind::DBProxyEndpointNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyEndpointsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyEndpointsErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBProxyEndpointsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyEndpointsOutput,
    crate::error::DescribeDBProxyEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_proxy_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_target_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyTargetGroupsOutput,
    crate::error::DescribeDBProxyTargetGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyTargetGroupsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetGroupsErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind:
                crate::error::DescribeDBProxyTargetGroupsErrorKind::DBProxyTargetGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBProxyStateFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetGroupsErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBProxyTargetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_target_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyTargetGroupsOutput,
    crate::error::DescribeDBProxyTargetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_target_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_proxy_target_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyTargetsOutput,
    crate::error::DescribeDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_target_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBProxyTargetsOutput,
    crate::error::DescribeDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_proxy_targets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_security_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSecurityGroupsOutput,
    crate::error::DescribeDBSecurityGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSecurityGroupsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBSecurityGroupNotFoundFault" => {
            crate::error::DescribeDBSecurityGroupsError {
                meta: generic,
                kind: crate::error::DescribeDBSecurityGroupsErrorKind::DBSecurityGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_security_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        _ => crate::error::DescribeDBSecurityGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_security_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSecurityGroupsOutput,
    crate::error::DescribeDBSecurityGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_security_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshot_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSnapshotAttributesOutput,
    crate::error::DescribeDBSnapshotAttributesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSnapshotAttributesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBSnapshotNotFoundFault" => crate::error::DescribeDBSnapshotAttributesError {
            meta: generic,
            kind: crate::error::DescribeDBSnapshotAttributesErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBSnapshotAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshot_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSnapshotAttributesOutput,
    crate::error::DescribeDBSnapshotAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_snapshot_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_snapshot_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSnapshotsOutput,
    crate::error::DescribeDBSnapshotsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBSnapshotsError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSnapshotNotFoundFault" => crate::error::DescribeDBSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeDBSnapshotsErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSnapshotsOutput,
    crate::error::DescribeDBSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSubnetGroupsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DescribeDBSubnetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBSubnetGroupsErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeDBSubnetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDBSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_subnet_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_db_subnet_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
    Err(crate::error::DescribeEngineDefaultClusterParametersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_engine_default_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_engine_default_cluster_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultParametersOutput,
    crate::error::DescribeEngineDefaultParametersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeEngineDefaultParametersError::unhandled)?;
    Err(crate::error::DescribeEngineDefaultParametersError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultParametersOutput,
    crate::error::DescribeEngineDefaultParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_engine_default_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_engine_default_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEngineDefaultParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
    Err(crate::error::DescribeEventCategoriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_categories_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_event_categories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeEventsError::unhandled)?;
    Err(crate::error::DescribeEventsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_events_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_describe_events(response.body().as_ref(), output)
                .map_err(crate::error::DescribeEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEventSubscriptionsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "SubscriptionNotFoundFault" => crate::error::DescribeEventSubscriptionsError {
            meta: generic,
            kind: crate::error::DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::subscription_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_subscription_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeEventSubscriptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_event_subscriptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeExportTasksError::unhandled(generic)),
    };
    Err(match error_code {
        "ExportTaskNotFoundFault" => crate::error::DescribeExportTasksError {
            meta: generic,
            kind: crate::error::DescribeExportTasksErrorKind::ExportTaskNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::export_task_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_export_task_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeExportTasksError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeExportTasksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_export_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeGlobalClustersError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DescribeGlobalClustersError {
            meta: generic,
            kind: crate::error::DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeGlobalClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_global_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_global_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstallationMediaOutput,
    crate::error::DescribeInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstallationMediaError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InstallationMediaNotFoundFault" => crate::error::DescribeInstallationMediaError {
            meta: generic,
            kind: crate::error::DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::installation_media_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_installation_media_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DescribeInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstallationMediaOutput,
    crate::error::DescribeInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_group_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupOptionsOutput,
    crate::error::DescribeOptionGroupOptionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeOptionGroupOptionsError::unhandled)?;
    Err(crate::error::DescribeOptionGroupOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_group_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupOptionsOutput,
    crate::error::DescribeOptionGroupOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_option_group_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_option_group_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOptionGroupOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupsOutput,
    crate::error::DescribeOptionGroupsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeOptionGroupsError::unhandled(generic)),
    };
    Err(match error_code {
        "OptionGroupNotFoundFault" => crate::error::DescribeOptionGroupsError {
            meta: generic,
            kind: crate::error::DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DescribeOptionGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupsOutput,
    crate::error::DescribeOptionGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_option_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_option_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDBInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
    Err(crate::error::DescribeOrderableDBInstanceOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDBInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_orderable_db_instance_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_orderable_db_instance_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePendingMaintenanceActionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "ResourceNotFoundFault" => crate::error::DescribePendingMaintenanceActionsError {
            meta: generic,
            kind: crate::error::DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_resource_not_found_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::DescribePendingMaintenanceActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_pending_maintenance_actions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_pending_maintenance_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDBInstancesOutput,
    crate::error::DescribeReservedDBInstancesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReservedDBInstancesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ReservedDBInstanceNotFoundFault" => crate::error::DescribeReservedDBInstancesError {
            meta: generic,
            kind:
                crate::error::DescribeReservedDBInstancesErrorKind::ReservedDBInstanceNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::reserved_db_instance_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_reserved_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::DescribeReservedDBInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDBInstancesOutput,
    crate::error::DescribeReservedDBInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_db_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_reserved_db_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDBInstancesOfferingsOutput,
    crate::error::DescribeReservedDBInstancesOfferingsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "ReservedDBInstancesOfferingNotFoundFault" => crate::error::DescribeReservedDBInstancesOfferingsError { meta: generic, kind: crate::error::DescribeReservedDBInstancesOfferingsErrorKind::ReservedDBInstancesOfferingNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::reserved_db_instances_offering_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_reserved_db_instances_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeReservedDBInstancesOfferingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDBInstancesOfferingsOutput,
    crate::error::DescribeReservedDBInstancesOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_reserved_db_instances_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_reserved_db_instances_offerings(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_regions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceRegionsOutput,
    crate::error::DescribeSourceRegionsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeSourceRegionsError::unhandled)?;
    Err(crate::error::DescribeSourceRegionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_regions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceRegionsOutput,
    crate::error::DescribeSourceRegionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_source_regions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_source_regions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSourceRegionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_valid_db_instance_modifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeValidDBInstanceModificationsOutput,
    crate::error::DescribeValidDBInstanceModificationsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeValidDBInstanceModificationsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::DescribeValidDBInstanceModificationsError { meta: generic, kind: crate::error::DescribeValidDBInstanceModificationsErrorKind::DBInstanceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceStateFault" => crate::error::DescribeValidDBInstanceModificationsError { meta: generic, kind: crate::error::DescribeValidDBInstanceModificationsErrorKind::InvalidDBInstanceStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
            output.build()
        })},
        _ => crate::error::DescribeValidDBInstanceModificationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_valid_db_instance_modifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeValidDBInstanceModificationsOutput,
    crate::error::DescribeValidDBInstanceModificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_valid_db_instance_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_describe_valid_db_instance_modifications(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_download_db_log_file_portion_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DownloadDBLogFilePortionOutput,
    crate::error::DownloadDBLogFilePortionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DownloadDBLogFilePortionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::DownloadDBLogFilePortionError {
            meta: generic,
            kind: crate::error::DownloadDBLogFilePortionErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
                output.build()
            }),
        },
        "DBLogFileNotFoundFault" => crate::error::DownloadDBLogFilePortionError {
            meta: generic,
            kind: crate::error::DownloadDBLogFilePortionErrorKind::DBLogFileNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_log_file_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_log_file_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DownloadDBLogFilePortionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_download_db_log_file_portion_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DownloadDBLogFilePortionOutput,
    crate::error::DownloadDBLogFilePortionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::download_db_log_file_portion_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_download_db_log_file_portion(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDBClusterOutput, crate::error::FailoverDBClusterError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::FailoverDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FailoverDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::FailoverDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDBClusterOutput, crate::error::FailoverDBClusterError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::failover_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_failover_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::FailoverDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FailoverGlobalClusterOutput,
    crate::error::FailoverGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FailoverGlobalClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidGlobalClusterStateFault" => {
            crate::error::FailoverGlobalClusterError {
                meta: generic,
                kind: crate::error::FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_global_cluster_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        _ => crate::error::FailoverGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FailoverGlobalClusterOutput,
    crate::error::FailoverGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::failover_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_failover_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportInstallationMediaOutput,
    crate::error::ImportInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ImportInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ImportInstallationMediaError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "CustomAvailabilityZoneNotFoundFault" => crate::error::ImportInstallationMediaError {
            meta: generic,
            kind:
                crate::error::ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportInstallationMediaError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InstallationMediaAlreadyExistsFault" => crate::error::ImportInstallationMediaError {
            meta: generic,
            kind:
                crate::error::ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::installation_media_already_exists_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_installation_media_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportInstallationMediaError::unhandled)?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::ImportInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportInstallationMediaOutput,
    crate::error::ImportInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_import_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DBProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCertificatesOutput,
    crate::error::ModifyCertificatesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyCertificatesError::unhandled(generic)),
    };
    Err(match error_code {
        "CertificateNotFoundFault" => crate::error::ModifyCertificatesError {
            meta: generic,
            kind: crate::error::ModifyCertificatesErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::certificate_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_certificate_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyCertificatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCertificatesOutput,
    crate::error::ModifyCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_certificates_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_certificates(response.body().as_ref(), output)
                .map_err(crate::error::ModifyCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_current_db_cluster_capacity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCurrentDBClusterCapacityOutput,
    crate::error::ModifyCurrentDBClusterCapacityError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind: crate::error::ModifyCurrentDBClusterCapacityErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterCapacityFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind:
                crate::error::ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterCapacityFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_capacity_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind: crate::error::ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::ModifyCurrentDBClusterCapacityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_current_db_cluster_capacity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCurrentDBClusterCapacityOutput,
    crate::error::ModifyCurrentDBClusterCapacityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_current_db_cluster_capacity_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_current_db_cluster_capacity(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBClusterOutput, crate::error::ModifyDBClusterError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DBClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_already_exists_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterParameterGroupNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DBClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DomainNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::domain_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSecurityGroupStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDBSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_security_group_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSubnetGroupStateFault" => {
            crate::error::ModifyDBClusterError {
                meta: generic,
                kind: crate::error::ModifyDBClusterErrorKind::InvalidDBSubnetGroupStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidSubnet" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "StorageQuotaExceededFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBClusterOutput, crate::error::ModifyDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::ModifyDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterEndpointOutput,
    crate::error::ModifyDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterEndpointNotFoundFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_cluster_endpoint_not_found_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_cluster_endpoint_not_found_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterEndpointStateFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::ModifyDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_db_cluster_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterEndpointOutput,
    crate::error::ModifyDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "InvalidDBParameterGroupStateFault" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::ModifyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled(generic))
        }
    };
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::DBClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
            output.build()
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::InvalidDBClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
            output.build()
        })},
        "SharedSnapshotQuotaExceededFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::shared_snapshot_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_shared_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
            output.build()
        })},
        _ => crate::error::ModifyDBClusterSnapshotAttributeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_snapshot_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_cluster_snapshot_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBInstanceOutput, crate::error::ModifyDBInstanceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::authorization_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_backup_policy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "CertificateNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::certificate_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_certificate_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceAlreadyExistsFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DBInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBParameterGroupNotFoundFault" => {
            crate::error::ModifyDBInstanceError {
                meta: generic,
                kind: crate::error::ModifyDBInstanceErrorKind::DBParameterGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBSecurityGroupNotFoundFault" => {
            crate::error::ModifyDBInstanceError {
                meta: generic,
                kind: crate::error::ModifyDBInstanceErrorKind::DBSecurityGroupNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBUpgradeDependencyFailureFault" => {
            crate::error::ModifyDBInstanceError {
                meta: generic,
                kind: crate::error::ModifyDBInstanceErrorKind::DBUpgradeDependencyFailureFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_upgrade_dependency_failure_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_upgrade_dependency_failure_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DomainNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::domain_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InsufficientDBInstanceCapacityFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InsufficientDBInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSecurityGroupStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDBSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_security_group_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "StorageQuotaExceededFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "StorageTypeNotSupportedFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBInstanceOutput, crate::error::ModifyDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBParameterGroupOutput,
    crate::error::ModifyDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => {
            crate::error::ModifyDBParameterGroupError {
                meta: generic,
                kind: crate::error::ModifyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBParameterGroupStateFault" => crate::error::ModifyDBParameterGroupError {
            meta: generic,
            kind: crate::error::ModifyDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::ModifyDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBParameterGroupOutput,
    crate::error::ModifyDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBProxyOutput, crate::error::ModifyDBProxyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBProxyError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyAlreadyExistsFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::DBProxyAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_already_exists_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_already_exists_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyNotFoundFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBProxyOutput, crate::error::ModifyDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_db_proxy(response.body().as_ref(), output)
                .map_err(crate::error::ModifyDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBProxyEndpointOutput,
    crate::error::ModifyDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBProxyEndpointError::unhandled(generic)),
    };
    Err(match error_code {
        "DBProxyEndpointAlreadyExistsFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                    output.build()
                },
            ),
        },
        "DBProxyEndpointNotFoundFault" => {
            crate::error::ModifyDBProxyEndpointError {
                meta: generic,
                kind: crate::error::ModifyDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidDBProxyEndpointStateFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBProxyEndpointOutput,
    crate::error::ModifyDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_target_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBProxyTargetGroupOutput,
    crate::error::ModifyDBProxyTargetGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBProxyTargetGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::DBProxyTargetGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBProxyTargetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_target_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBProxyTargetGroupOutput,
    crate::error::ModifyDBProxyTargetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_target_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_proxy_target_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBSnapshotOutput, crate::error::ModifyDBSnapshotError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSnapshotNotFoundFault" => crate::error::ModifyDBSnapshotError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDBSnapshotOutput, crate::error::ModifyDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_db_snapshot(response.body().as_ref(), output)
                .map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBSnapshotAttributeOutput,
    crate::error::ModifyDBSnapshotAttributeError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBSnapshotAttributeError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBSnapshotNotFoundFault" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotAttributeErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBSnapshotStateFault" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotAttributeErrorKind::InvalidDBSnapshotStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                output.build()
            }),
        },
        "SharedSnapshotQuotaExceededFault" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind:
                crate::error::ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::shared_snapshot_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_shared_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::ModifyDBSnapshotAttributeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBSnapshotAttributeOutput,
    crate::error::ModifyDBSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_snapshot_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_snapshot_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBSubnetGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetQuotaExceededFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        "SubnetAlreadyInUse" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse({
                #[allow(unused_mut)]
                let mut output = crate::error::subnet_already_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_subnet_already_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDBSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "EventSubscriptionQuotaExceededFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::event_subscription_quota_exceeded_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "SNSInvalidTopicFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SNSInvalidTopicFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_invalid_topic_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SNSNoAuthorizationFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SNSNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_no_authorization_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SNSTopicArnNotFoundFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SNSTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::sns_topic_arn_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_sns_topic_arn_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        "SubscriptionCategoryNotFoundFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::subscription_category_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                },
            ),
        },
        "SubscriptionNotFoundFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::subscription_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_subscription_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyGlobalClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidGlobalClusterStateFault" => {
            crate::error::ModifyGlobalClusterError {
                meta: generic,
                kind: crate::error::ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                }),
            }
        }
        _ => crate::error::ModifyGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_modify_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyOptionGroupOutput, crate::error::ModifyOptionGroupError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyOptionGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidOptionGroupStateFault" => crate::error::ModifyOptionGroupError {
            meta: generic,
            kind: crate::error::ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_option_group_state_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_invalid_option_group_state_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::ModifyOptionGroupError {
            meta: generic,
            kind: crate::error::ModifyOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ModifyOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyOptionGroupOutput, crate::error::ModifyOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_option_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_modify_option_group(response.body().as_ref(), output)
                .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaOutput,
    crate::error::PromoteReadReplicaError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PromoteReadReplicaError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::PromoteReadReplicaError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::PromoteReadReplicaError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PromoteReadReplicaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaOutput,
    crate::error::PromoteReadReplicaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::promote_read_replica_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_promote_read_replica(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaDBClusterOutput,
    crate::error::PromoteReadReplicaDBClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PromoteReadReplicaDBClusterError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::PromoteReadReplicaDBClusterError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::PromoteReadReplicaDBClusterError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PromoteReadReplicaDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaDBClusterOutput,
    crate::error::PromoteReadReplicaDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::promote_read_replica_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_promote_read_replica_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_db_instances_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedDBInstancesOfferingOutput,
    crate::error::PurchaseReservedDBInstancesOfferingError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled(generic))
        }
    };
    Err(match error_code {
        "ReservedDBInstanceAlreadyExistsFault" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::reserved_db_instance_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_reserved_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
            output.build()
        })},
        "ReservedDBInstanceQuotaExceededFault" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::reserved_db_instance_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_reserved_db_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
            output.build()
        })},
        "ReservedDBInstancesOfferingNotFoundFault" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstancesOfferingNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::reserved_db_instances_offering_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_reserved_db_instances_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
            output.build()
        })},
        _ => crate::error::PurchaseReservedDBInstancesOfferingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_db_instances_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedDBInstancesOfferingOutput,
    crate::error::PurchaseReservedDBInstancesOfferingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::purchase_reserved_db_instances_offering_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_purchase_reserved_db_instances_offering(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDBInstanceOutput, crate::error::RebootDBInstanceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RebootDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RebootDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RebootDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RebootDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RebootDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDBInstanceOutput, crate::error::RebootDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_reboot_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::RebootDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDBProxyTargetsOutput,
    crate::error::RegisterDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetAlreadyRegisteredFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind:
                crate::error::RegisterDBProxyTargetsErrorKind::DBProxyTargetAlreadyRegisteredFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_proxy_target_already_registered_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_proxy_target_already_registered_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "InsufficientAvailableIPsInSubnetFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind:
                crate::error::RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::insufficient_available_i_ps_in_subnet_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_insufficient_available_i_ps_in_subnet_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_proxy_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RegisterDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDBProxyTargetsOutput,
    crate::error::RegisterDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_db_proxy_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_register_db_proxy_targets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveFromGlobalClusterError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::global_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_global_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::invalid_global_cluster_state_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_invalid_global_cluster_state_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveFromGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_from_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_remove_from_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDBClusterOutput,
    crate::error::RemoveRoleFromDBClusterError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromDBClusterError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterRoleNotFoundFault" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::DBClusterRoleNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_role_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_role_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveRoleFromDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDBClusterOutput,
    crate::error::RemoveRoleFromDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_role_from_db_cluster_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDBInstanceOutput,
    crate::error::RemoveRoleFromDBInstanceError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromDBInstanceError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::RemoveRoleFromDBInstanceError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceRoleNotFoundFault" => {
            crate::error::RemoveRoleFromDBInstanceError {
                meta: generic,
                kind: crate::error::RemoveRoleFromDBInstanceErrorKind::DBInstanceRoleNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_instance_role_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_instance_role_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBInstanceStateFault" => crate::error::RemoveRoleFromDBInstanceError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveRoleFromDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDBInstanceOutput,
    crate::error::RemoveRoleFromDBInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_role_from_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "SourceNotFoundFault" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::source_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
            output.build()
        })},
        "SubscriptionNotFoundFault" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::subscription_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RemoveSourceIdentifierFromSubscriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_source_identifier_from_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_remove_source_identifier_from_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DBProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DBProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveTagsFromResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDBClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ResetDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        "InvalidDBParameterGroupStateFault" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
            output.build()
        })},
        _ => crate::error::ResetDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDBClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_reset_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDBParameterGroupOutput,
    crate::error::ResetDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetDBParameterGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DBParameterGroupNotFoundFault" => {
            crate::error::ResetDBParameterGroupError {
                meta: generic,
                kind: crate::error::ResetDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "InvalidDBParameterGroupStateFault" => crate::error::ResetDBParameterGroupError {
            meta: generic,
            kind: crate::error::ResetDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::ResetDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDBParameterGroupOutput,
    crate::error::ResetDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_reset_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_s3_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterFromS3Output,
    crate::error::RestoreDBClusterFromS3Error,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterFromS3Error::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DBClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "DBClusterNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DBClusterNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "DBClusterParameterGroupNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DBClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DBClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InsufficientStorageClusterCapacityFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InvalidDBClusterStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidDBClusterStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InvalidDBSubnetGroupStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidDBSubnetGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_subnet_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InvalidS3BucketFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_s3_bucket_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
            output.build()
        })},
        _ => crate::error::RestoreDBClusterFromS3Error::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_s3_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterFromS3Output,
    crate::error::RestoreDBClusterFromS3Error,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_cluster_from_s3_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_cluster_from_s3(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterFromSnapshotError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DBClusterParameterGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSnapshotNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientDBClusterCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InsufficientStorageClusterCapacityFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDBClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidDBSnapshotStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDBSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RestoreDBClusterFromSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_cluster_from_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_cluster_from_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterToPointInTimeError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBClusterNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBClusterNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBClusterParameterGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientDBClusterCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InsufficientStorageClusterCapacityFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidDBClusterStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidDBSnapshotStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDBSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RestoreDBClusterToPointInTimeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_cluster_to_point_in_time_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_cluster_to_point_in_time(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceFromDBSnapshotOutput,
    crate::error::RestoreDBInstanceFromDBSnapshotError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBInstanceAlreadyExistsFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSecurityGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSnapshotNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InstanceQuotaExceededFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InsufficientDBInstanceCapacityFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDBInstanceCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidDBSnapshotStateFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDBSnapshotStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAZFault({
            #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        "StorageTypeNotSupportedFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RestoreDBInstanceFromDBSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceFromDBSnapshotOutput,
    crate::error::RestoreDBInstanceFromDBSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_instance_from_db_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_instance_from_db_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_s3_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceFromS3Output,
    crate::error::RestoreDBInstanceFromS3Error,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBInstanceFromS3Error::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::authorization_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_backup_policy_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceAlreadyExistsFault" => {
            crate::error::RestoreDBInstanceFromS3Error {
                meta: generic,
                kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DBInstanceAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_instance_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBParameterGroupNotFoundFault" => {
            crate::error::RestoreDBInstanceFromS3Error {
                meta: generic,
                kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DBParameterGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBSecurityGroupNotFoundFault" => {
            crate::error::RestoreDBInstanceFromS3Error {
                meta: generic,
                kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DBSecurityGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_security_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "InstanceQuotaExceededFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_instance_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "InsufficientDBInstanceCapacityFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::InsufficientDBInstanceCapacityFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::insufficient_db_instance_capacity_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidS3BucketFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_s3_bucket_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::option_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAZFault(
                    {
                        #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
        },
        "StorageQuotaExceededFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                output.build()
            }),
        },
        "StorageTypeNotSupportedFault" => {
            crate::error::RestoreDBInstanceFromS3Error {
                meta: generic,
                kind: crate::error::RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::storage_type_not_supported_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        _ => crate::error::RestoreDBInstanceFromS3Error::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_s3_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceFromS3Output,
    crate::error::RestoreDBInstanceFromS3Error,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_instance_from_s3_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_instance_from_s3(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_to_point_in_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceToPointInTimeOutput,
    crate::error::RestoreDBInstanceToPointInTimeError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBInstanceAlreadyExistsFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBInstanceAutomatedBackupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBInstanceNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBInstanceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBParameterGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBSecurityGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InstanceQuotaExceededFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InsufficientDBInstanceCapacityFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InsufficientDBInstanceCapacityFault({
            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceStateFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidDBInstanceStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidSubnet" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidVPCNetworkStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "PointInTimeRestoreNotEnabledFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault({
            #[allow(unused_mut)]let mut output = crate::error::point_in_time_restore_not_enabled_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_point_in_time_restore_not_enabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAZFault({
            #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "StorageQuotaExceededFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        "StorageTypeNotSupportedFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RestoreDBInstanceToPointInTimeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_to_point_in_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDBInstanceToPointInTimeOutput,
    crate::error::RestoreDBInstanceToPointInTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_instance_to_point_in_time_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_restore_db_instance_to_point_in_time(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_db_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeDBSecurityGroupIngressOutput,
    crate::error::RevokeDBSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RevokeDBSecurityGroupIngressError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        "DBSecurityGroupNotFoundFault" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        "InvalidDBSecurityGroupStateFault" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_security_group_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
            output.build()
        })},
        _ => crate::error::RevokeDBSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_db_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeDBSecurityGroupIngressOutput,
    crate::error::RevokeDBSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_db_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_revoke_db_security_group_ingress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_activity_stream_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartActivityStreamOutput,
    crate::error::StartActivityStreamError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StartActivityStreamError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartActivityStreamError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_resource_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StartActivityStreamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_activity_stream_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartActivityStreamOutput,
    crate::error::StartActivityStreamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_activity_stream_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_start_activity_stream(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartActivityStreamError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDBClusterOutput, crate::error::StartDBClusterError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StartDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StartDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDBClusterOutput, crate::error::StartDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_start_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::StartDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDBInstanceOutput, crate::error::StartDBInstanceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StartDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "AuthorizationNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::authorization_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_authorization_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBClusterNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DBSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_subnet_group_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InsufficientDBInstanceCapacityFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InsufficientDBInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnet" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_subnet_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidVPCNetworkStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_vpc_network_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StartDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDBInstanceOutput, crate::error::StartDBInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_start_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::StartDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_automated_backups_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartDBInstanceAutomatedBackupsReplicationOutput,
    crate::error::StartDBInstanceAutomatedBackupsReplicationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "DBInstanceAutomatedBackupQuotaExceededFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceAutomatedBackupQuotaExceededFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_automated_backup_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        "DBInstanceNotFoundFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceStateFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        "KMSKeyNotAccessibleFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::KMSKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        "StorageTypeNotSupportedFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        _ => crate::error::StartDBInstanceAutomatedBackupsReplicationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_automated_backups_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartDBInstanceAutomatedBackupsReplicationOutput,
    crate::error::StartDBInstanceAutomatedBackupsReplicationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::start_db_instance_automated_backups_replication_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_start_db_instance_automated_backups_replication(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartExportTaskOutput, crate::error::StartExportTaskError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StartExportTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartExportTaskError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => {
            crate::error::StartExportTaskError {
                meta: generic,
                kind: crate::error::StartExportTaskErrorKind::DBClusterSnapshotNotFoundFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                }),
            }
        }
        "DBSnapshotNotFoundFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::DBSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_snapshot_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "ExportTaskAlreadyExistsFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::ExportTaskAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::export_task_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_export_task_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "IamRoleMissingPermissionsFault" => {
            crate::error::StartExportTaskError {
                meta: generic,
                kind: crate::error::StartExportTaskErrorKind::IamRoleMissingPermissionsFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::iam_role_missing_permissions_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_iam_role_missing_permissions_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                }),
            }
        }
        "IamRoleNotFoundFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::IamRoleNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::iam_role_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_iam_role_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "InvalidExportOnlyFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::InvalidExportOnlyFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_export_only_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_export_only_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "InvalidExportSourceStateFault" => {
            crate::error::StartExportTaskError {
                meta: generic,
                kind: crate::error::StartExportTaskErrorKind::InvalidExportSourceStateFault({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_export_source_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_export_source_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                }),
            }
        }
        "InvalidS3BucketFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::InvalidS3BucketFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_s3_bucket_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::KMSKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_kms_key_not_accessible_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartExportTaskError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StartExportTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartExportTaskOutput, crate::error::StartExportTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_export_task_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_start_export_task(response.body().as_ref(), output)
                .map_err(crate::error::StartExportTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_activity_stream_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopActivityStreamOutput,
    crate::error::StopActivityStreamError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StopActivityStreamError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopActivityStreamError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "DBInstanceNotFoundFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_resource_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopActivityStreamError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StopActivityStreamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_activity_stream_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopActivityStreamOutput,
    crate::error::StopActivityStreamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_activity_stream_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_stop_activity_stream(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopActivityStreamError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDBClusterOutput, crate::error::StopDBClusterError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StopDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopDBClusterError::unhandled(generic)),
    };
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::DBClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_cluster_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBClusterError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBClusterError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StopDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDBClusterOutput, crate::error::StopDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_db_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_stop_db_cluster(response.body().as_ref(), output)
                .map_err(crate::error::StopDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDBInstanceOutput, crate::error::StopDBInstanceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StopDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopDBInstanceError::unhandled(generic)),
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::DBInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "DBSnapshotAlreadyExistsFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::DBSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut output = crate::error::db_snapshot_already_exists_fault::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_db_snapshot_already_exists_fault_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::InvalidDBClusterStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_cluster_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidDBInstanceStateFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::InvalidDBInstanceStateFault({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        "SnapshotQuotaExceededFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut output = crate::error::snapshot_quota_exceeded_fault::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_snapshot_quota_exceeded_fault_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StopDBInstanceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::StopDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDBInstanceOutput, crate::error::StopDBInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_db_instance_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_stop_db_instance(response.body().as_ref(), output)
                .map_err(crate::error::StopDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_automated_backups_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopDBInstanceAutomatedBackupsReplicationOutput,
    crate::error::StopDBInstanceAutomatedBackupsReplicationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "DBInstanceNotFoundFault" => crate::error::StopDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StopDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault({
            #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        "InvalidDBInstanceStateFault" => crate::error::StopDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault({
            #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
            output.build()
        })},
        _ => crate::error::StopDBInstanceAutomatedBackupsReplicationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_automated_backups_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopDBInstanceAutomatedBackupsReplicationOutput,
    crate::error::StopDBInstanceAutomatedBackupsReplicationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::stop_db_instance_automated_backups_replication_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_stop_db_instance_automated_backups_replication(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
        output.build()
    })
}
