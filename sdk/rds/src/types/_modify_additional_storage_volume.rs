// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains details about the modification of an additional storage volume.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ModifyAdditionalStorageVolume {
    /// <p>The name of the additional storage volume that you want to modify.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub volume_name: ::std::option::Option<::std::string::String>,
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub allocated_storage: ::std::option::Option<i32>,
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume. This setting is only supported for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) storage types.</p>
    pub iops: ::std::option::Option<i32>,
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume. You must provide a value greater than or equal to <code>AllocatedStorage</code>.</p>
    pub max_allocated_storage: ::std::option::Option<i32>,
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub storage_throughput: ::std::option::Option<i32>,
    /// <p>The new storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub storage_type: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether to delete the additional storage volume. The value <code>true</code> schedules the volume for deletion. You can delete an additional storage volume only when it doesn't contain database files or other data.</p>
    pub set_for_delete: ::std::option::Option<bool>,
}
impl ModifyAdditionalStorageVolume {
    /// <p>The name of the additional storage volume that you want to modify.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn volume_name(&self) -> ::std::option::Option<&str> {
        self.volume_name.as_deref()
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn allocated_storage(&self) -> ::std::option::Option<i32> {
        self.allocated_storage
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume. This setting is only supported for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) storage types.</p>
    pub fn iops(&self) -> ::std::option::Option<i32> {
        self.iops
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume. You must provide a value greater than or equal to <code>AllocatedStorage</code>.</p>
    pub fn max_allocated_storage(&self) -> ::std::option::Option<i32> {
        self.max_allocated_storage
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn storage_throughput(&self) -> ::std::option::Option<i32> {
        self.storage_throughput
    }
    /// <p>The new storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn storage_type(&self) -> ::std::option::Option<&str> {
        self.storage_type.as_deref()
    }
    /// <p>Indicates whether to delete the additional storage volume. The value <code>true</code> schedules the volume for deletion. You can delete an additional storage volume only when it doesn't contain database files or other data.</p>
    pub fn set_for_delete(&self) -> ::std::option::Option<bool> {
        self.set_for_delete
    }
}
impl ModifyAdditionalStorageVolume {
    /// Creates a new builder-style object to manufacture [`ModifyAdditionalStorageVolume`](crate::types::ModifyAdditionalStorageVolume).
    pub fn builder() -> crate::types::builders::ModifyAdditionalStorageVolumeBuilder {
        crate::types::builders::ModifyAdditionalStorageVolumeBuilder::default()
    }
}

/// A builder for [`ModifyAdditionalStorageVolume`](crate::types::ModifyAdditionalStorageVolume).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ModifyAdditionalStorageVolumeBuilder {
    pub(crate) volume_name: ::std::option::Option<::std::string::String>,
    pub(crate) allocated_storage: ::std::option::Option<i32>,
    pub(crate) iops: ::std::option::Option<i32>,
    pub(crate) max_allocated_storage: ::std::option::Option<i32>,
    pub(crate) storage_throughput: ::std::option::Option<i32>,
    pub(crate) storage_type: ::std::option::Option<::std::string::String>,
    pub(crate) set_for_delete: ::std::option::Option<bool>,
}
impl ModifyAdditionalStorageVolumeBuilder {
    /// <p>The name of the additional storage volume that you want to modify.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    /// This field is required.
    pub fn volume_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.volume_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the additional storage volume that you want to modify.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn set_volume_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.volume_name = input;
        self
    }
    /// <p>The name of the additional storage volume that you want to modify.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn get_volume_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.volume_name
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn allocated_storage(mut self, input: i32) -> Self {
        self.allocated_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn set_allocated_storage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.allocated_storage = input;
        self
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn get_allocated_storage(&self) -> &::std::option::Option<i32> {
        &self.allocated_storage
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume. This setting is only supported for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) storage types.</p>
    pub fn iops(mut self, input: i32) -> Self {
        self.iops = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume. This setting is only supported for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) storage types.</p>
    pub fn set_iops(mut self, input: ::std::option::Option<i32>) -> Self {
        self.iops = input;
        self
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume. This setting is only supported for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) storage types.</p>
    pub fn get_iops(&self) -> &::std::option::Option<i32> {
        &self.iops
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume. You must provide a value greater than or equal to <code>AllocatedStorage</code>.</p>
    pub fn max_allocated_storage(mut self, input: i32) -> Self {
        self.max_allocated_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume. You must provide a value greater than or equal to <code>AllocatedStorage</code>.</p>
    pub fn set_max_allocated_storage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_allocated_storage = input;
        self
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume. You must provide a value greater than or equal to <code>AllocatedStorage</code>.</p>
    pub fn get_max_allocated_storage(&self) -> &::std::option::Option<i32> {
        &self.max_allocated_storage
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn storage_throughput(mut self, input: i32) -> Self {
        self.storage_throughput = ::std::option::Option::Some(input);
        self
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn set_storage_throughput(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_throughput = input;
        self
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn get_storage_throughput(&self) -> &::std::option::Option<i32> {
        &self.storage_throughput
    }
    /// <p>The new storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn storage_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The new storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn set_storage_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_type = input;
        self
    }
    /// <p>The new storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn get_storage_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_type
    }
    /// <p>Indicates whether to delete the additional storage volume. The value <code>true</code> schedules the volume for deletion. You can delete an additional storage volume only when it doesn't contain database files or other data.</p>
    pub fn set_for_delete(mut self, input: bool) -> Self {
        self.set_for_delete = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether to delete the additional storage volume. The value <code>true</code> schedules the volume for deletion. You can delete an additional storage volume only when it doesn't contain database files or other data.</p>
    pub fn set_set_for_delete(mut self, input: ::std::option::Option<bool>) -> Self {
        self.set_for_delete = input;
        self
    }
    /// <p>Indicates whether to delete the additional storage volume. The value <code>true</code> schedules the volume for deletion. You can delete an additional storage volume only when it doesn't contain database files or other data.</p>
    pub fn get_set_for_delete(&self) -> &::std::option::Option<bool> {
        &self.set_for_delete
    }
    /// Consumes the builder and constructs a [`ModifyAdditionalStorageVolume`](crate::types::ModifyAdditionalStorageVolume).
    pub fn build(self) -> crate::types::ModifyAdditionalStorageVolume {
        crate::types::ModifyAdditionalStorageVolume {
            volume_name: self.volume_name,
            allocated_storage: self.allocated_storage,
            iops: self.iops,
            max_allocated_storage: self.max_allocated_storage,
            storage_throughput: self.storage_throughput,
            storage_type: self.storage_type,
            set_for_delete: self.set_for_delete,
        }
    }
}
