// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains details about an additional storage volume for a DB instance. RDS support additional storage volumes for RDS for Oracle and RDS for SQL Server.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AdditionalStorageVolume {
    /// <p>The name of the additional storage volume.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub volume_name: ::std::option::Option<::std::string::String>,
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub allocated_storage: ::std::option::Option<i32>,
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume.</p>
    pub iops: ::std::option::Option<i32>,
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume.</p>
    pub max_allocated_storage: ::std::option::Option<i32>,
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub storage_throughput: ::std::option::Option<i32>,
    /// <p>The storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub storage_type: ::std::option::Option<::std::string::String>,
}
impl AdditionalStorageVolume {
    /// <p>The name of the additional storage volume.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn volume_name(&self) -> ::std::option::Option<&str> {
        self.volume_name.as_deref()
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn allocated_storage(&self) -> ::std::option::Option<i32> {
        self.allocated_storage
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume.</p>
    pub fn iops(&self) -> ::std::option::Option<i32> {
        self.iops
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume.</p>
    pub fn max_allocated_storage(&self) -> ::std::option::Option<i32> {
        self.max_allocated_storage
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn storage_throughput(&self) -> ::std::option::Option<i32> {
        self.storage_throughput
    }
    /// <p>The storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn storage_type(&self) -> ::std::option::Option<&str> {
        self.storage_type.as_deref()
    }
}
impl AdditionalStorageVolume {
    /// Creates a new builder-style object to manufacture [`AdditionalStorageVolume`](crate::types::AdditionalStorageVolume).
    pub fn builder() -> crate::types::builders::AdditionalStorageVolumeBuilder {
        crate::types::builders::AdditionalStorageVolumeBuilder::default()
    }
}

/// A builder for [`AdditionalStorageVolume`](crate::types::AdditionalStorageVolume).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct AdditionalStorageVolumeBuilder {
    pub(crate) volume_name: ::std::option::Option<::std::string::String>,
    pub(crate) allocated_storage: ::std::option::Option<i32>,
    pub(crate) iops: ::std::option::Option<i32>,
    pub(crate) max_allocated_storage: ::std::option::Option<i32>,
    pub(crate) storage_throughput: ::std::option::Option<i32>,
    pub(crate) storage_type: ::std::option::Option<::std::string::String>,
}
impl AdditionalStorageVolumeBuilder {
    /// <p>The name of the additional storage volume.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    /// This field is required.
    pub fn volume_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.volume_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the additional storage volume.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn set_volume_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.volume_name = input;
        self
    }
    /// <p>The name of the additional storage volume.</p>
    /// <p>Valid Values: <code>RDSDBDATA2 | RDSDBDATA3 | RDSDBDATA4</code></p>
    pub fn get_volume_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.volume_name
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn allocated_storage(mut self, input: i32) -> Self {
        self.allocated_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn set_allocated_storage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.allocated_storage = input;
        self
    }
    /// <p>The amount of storage allocated for the additional storage volume, in gibibytes (GiB). The minimum is 20 GiB. The maximum is 65,536 GiB (64 TiB).</p>
    pub fn get_allocated_storage(&self) -> &::std::option::Option<i32> {
        &self.allocated_storage
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume.</p>
    pub fn iops(mut self, input: i32) -> Self {
        self.iops = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume.</p>
    pub fn set_iops(mut self, input: ::std::option::Option<i32>) -> Self {
        self.iops = input;
        self
    }
    /// <p>The number of I/O operations per second (IOPS) provisioned for the additional storage volume.</p>
    pub fn get_iops(&self) -> &::std::option::Option<i32> {
        &self.iops
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume.</p>
    pub fn max_allocated_storage(mut self, input: i32) -> Self {
        self.max_allocated_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume.</p>
    pub fn set_max_allocated_storage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_allocated_storage = input;
        self
    }
    /// <p>The upper limit in gibibytes (GiB) to which RDS can automatically scale the storage of the additional storage volume.</p>
    pub fn get_max_allocated_storage(&self) -> &::std::option::Option<i32> {
        &self.max_allocated_storage
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn storage_throughput(mut self, input: i32) -> Self {
        self.storage_throughput = ::std::option::Option::Some(input);
        self
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn set_storage_throughput(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_throughput = input;
        self
    }
    /// <p>The storage throughput value for the additional storage volume, in mebibytes per second (MiBps). This setting applies only to the General Purpose SSD (<code>gp3</code>) storage type.</p>
    pub fn get_storage_throughput(&self) -> &::std::option::Option<i32> {
        &self.storage_throughput
    }
    /// <p>The storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn storage_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn set_storage_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_type = input;
        self
    }
    /// <p>The storage type for the additional storage volume.</p>
    /// <p>Valid Values: <code>GP3 | IO2</code></p>
    pub fn get_storage_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_type
    }
    /// Consumes the builder and constructs a [`AdditionalStorageVolume`](crate::types::AdditionalStorageVolume).
    pub fn build(self) -> crate::types::AdditionalStorageVolume {
        crate::types::AdditionalStorageVolume {
            volume_name: self.volume_name,
            allocated_storage: self.allocated_storage,
            iops: self.iops,
            max_allocated_storage: self.max_allocated_storage,
            storage_throughput: self.storage_throughput,
            storage_type: self.storage_type,
        }
    }
}
