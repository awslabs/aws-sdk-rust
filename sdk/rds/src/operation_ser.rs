// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_add_role_to_db_cluster(
    input: &crate::input::AddRoleToDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddRoleToDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("DBClusterIdentifier");
    if let Some(var_2) = &input.db_cluster_identifier {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("RoleArn");
    if let Some(var_4) = &input.role_arn {
        scope_3.string(var_4);
    }
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("FeatureName");
    if let Some(var_6) = &input.feature_name {
        scope_5.string(var_6);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_role_to_db_instance(
    input: &crate::input::AddRoleToDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddRoleToDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_7 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_8) = &input.db_instance_identifier {
        scope_7.string(var_8);
    }
    #[allow(unused_mut)]
    let mut scope_9 = writer.prefix("RoleArn");
    if let Some(var_10) = &input.role_arn {
        scope_9.string(var_10);
    }
    #[allow(unused_mut)]
    let mut scope_11 = writer.prefix("FeatureName");
    if let Some(var_12) = &input.feature_name {
        scope_11.string(var_12);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_source_identifier_to_subscription(
    input: &crate::input::AddSourceIdentifierToSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AddSourceIdentifierToSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_13 = writer.prefix("SubscriptionName");
    if let Some(var_14) = &input.subscription_name {
        scope_13.string(var_14);
    }
    #[allow(unused_mut)]
    let mut scope_15 = writer.prefix("SourceIdentifier");
    if let Some(var_16) = &input.source_identifier {
        scope_15.string(var_16);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_tags_to_resource(
    input: &crate::input::AddTagsToResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddTagsToResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_17 = writer.prefix("ResourceName");
    if let Some(var_18) = &input.resource_name {
        scope_17.string(var_18);
    }
    #[allow(unused_mut)]
    let mut scope_19 = writer.prefix("Tags");
    if let Some(var_20) = &input.tags {
        let mut list_22 = scope_19.start_list(false, Some("Tag"));
        for item_21 in var_20 {
            #[allow(unused_mut)]
            let mut entry_23 = list_22.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_23, item_21);
        }
        list_22.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_apply_pending_maintenance_action(
    input: &crate::input::ApplyPendingMaintenanceActionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ApplyPendingMaintenanceAction", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_24 = writer.prefix("ResourceIdentifier");
    if let Some(var_25) = &input.resource_identifier {
        scope_24.string(var_25);
    }
    #[allow(unused_mut)]
    let mut scope_26 = writer.prefix("ApplyAction");
    if let Some(var_27) = &input.apply_action {
        scope_26.string(var_27);
    }
    #[allow(unused_mut)]
    let mut scope_28 = writer.prefix("OptInType");
    if let Some(var_29) = &input.opt_in_type {
        scope_28.string(var_29);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_authorize_db_security_group_ingress(
    input: &crate::input::AuthorizeDbSecurityGroupIngressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AuthorizeDBSecurityGroupIngress", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_30 = writer.prefix("DBSecurityGroupName");
    if let Some(var_31) = &input.db_security_group_name {
        scope_30.string(var_31);
    }
    #[allow(unused_mut)]
    let mut scope_32 = writer.prefix("CIDRIP");
    if let Some(var_33) = &input.cidrip {
        scope_32.string(var_33);
    }
    #[allow(unused_mut)]
    let mut scope_34 = writer.prefix("EC2SecurityGroupName");
    if let Some(var_35) = &input.ec2_security_group_name {
        scope_34.string(var_35);
    }
    #[allow(unused_mut)]
    let mut scope_36 = writer.prefix("EC2SecurityGroupId");
    if let Some(var_37) = &input.ec2_security_group_id {
        scope_36.string(var_37);
    }
    #[allow(unused_mut)]
    let mut scope_38 = writer.prefix("EC2SecurityGroupOwnerId");
    if let Some(var_39) = &input.ec2_security_group_owner_id {
        scope_38.string(var_39);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_backtrack_db_cluster(
    input: &crate::input::BacktrackDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "BacktrackDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_40 = writer.prefix("DBClusterIdentifier");
    if let Some(var_41) = &input.db_cluster_identifier {
        scope_40.string(var_41);
    }
    #[allow(unused_mut)]
    let mut scope_42 = writer.prefix("BacktrackTo");
    if let Some(var_43) = &input.backtrack_to {
        scope_42.instant(var_43, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_44 = writer.prefix("Force");
    if let Some(var_45) = &input.force {
        scope_44.boolean(*var_45);
    }
    #[allow(unused_mut)]
    let mut scope_46 = writer.prefix("UseEarliestTimeOnPointInTimeUnavailable");
    if let Some(var_47) = &input.use_earliest_time_on_point_in_time_unavailable {
        scope_46.boolean(*var_47);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_cancel_export_task(
    input: &crate::input::CancelExportTaskInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CancelExportTask", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_48 = writer.prefix("ExportTaskIdentifier");
    if let Some(var_49) = &input.export_task_identifier {
        scope_48.string(var_49);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_cluster_parameter_group(
    input: &crate::input::CopyDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CopyDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_50 = writer.prefix("SourceDBClusterParameterGroupIdentifier");
    if let Some(var_51) = &input.source_db_cluster_parameter_group_identifier {
        scope_50.string(var_51);
    }
    #[allow(unused_mut)]
    let mut scope_52 = writer.prefix("TargetDBClusterParameterGroupIdentifier");
    if let Some(var_53) = &input.target_db_cluster_parameter_group_identifier {
        scope_52.string(var_53);
    }
    #[allow(unused_mut)]
    let mut scope_54 = writer.prefix("TargetDBClusterParameterGroupDescription");
    if let Some(var_55) = &input.target_db_cluster_parameter_group_description {
        scope_54.string(var_55);
    }
    #[allow(unused_mut)]
    let mut scope_56 = writer.prefix("Tags");
    if let Some(var_57) = &input.tags {
        let mut list_59 = scope_56.start_list(false, Some("Tag"));
        for item_58 in var_57 {
            #[allow(unused_mut)]
            let mut entry_60 = list_59.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_60, item_58);
        }
        list_59.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_cluster_snapshot(
    input: &crate::input::CopyDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CopyDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_61 = writer.prefix("SourceDBClusterSnapshotIdentifier");
    if let Some(var_62) = &input.source_db_cluster_snapshot_identifier {
        scope_61.string(var_62);
    }
    #[allow(unused_mut)]
    let mut scope_63 = writer.prefix("TargetDBClusterSnapshotIdentifier");
    if let Some(var_64) = &input.target_db_cluster_snapshot_identifier {
        scope_63.string(var_64);
    }
    #[allow(unused_mut)]
    let mut scope_65 = writer.prefix("KmsKeyId");
    if let Some(var_66) = &input.kms_key_id {
        scope_65.string(var_66);
    }
    #[allow(unused_mut)]
    let mut scope_67 = writer.prefix("PreSignedUrl");
    if let Some(var_68) = &input.pre_signed_url {
        scope_67.string(var_68);
    }
    #[allow(unused_mut)]
    let mut scope_69 = writer.prefix("CopyTags");
    if let Some(var_70) = &input.copy_tags {
        scope_69.boolean(*var_70);
    }
    #[allow(unused_mut)]
    let mut scope_71 = writer.prefix("Tags");
    if let Some(var_72) = &input.tags {
        let mut list_74 = scope_71.start_list(false, Some("Tag"));
        for item_73 in var_72 {
            #[allow(unused_mut)]
            let mut entry_75 = list_74.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_75, item_73);
        }
        list_74.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_parameter_group(
    input: &crate::input::CopyDbParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CopyDBParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_76 = writer.prefix("SourceDBParameterGroupIdentifier");
    if let Some(var_77) = &input.source_db_parameter_group_identifier {
        scope_76.string(var_77);
    }
    #[allow(unused_mut)]
    let mut scope_78 = writer.prefix("TargetDBParameterGroupIdentifier");
    if let Some(var_79) = &input.target_db_parameter_group_identifier {
        scope_78.string(var_79);
    }
    #[allow(unused_mut)]
    let mut scope_80 = writer.prefix("TargetDBParameterGroupDescription");
    if let Some(var_81) = &input.target_db_parameter_group_description {
        scope_80.string(var_81);
    }
    #[allow(unused_mut)]
    let mut scope_82 = writer.prefix("Tags");
    if let Some(var_83) = &input.tags {
        let mut list_85 = scope_82.start_list(false, Some("Tag"));
        for item_84 in var_83 {
            #[allow(unused_mut)]
            let mut entry_86 = list_85.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_86, item_84);
        }
        list_85.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_snapshot(
    input: &crate::input::CopyDbSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CopyDBSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_87 = writer.prefix("SourceDBSnapshotIdentifier");
    if let Some(var_88) = &input.source_db_snapshot_identifier {
        scope_87.string(var_88);
    }
    #[allow(unused_mut)]
    let mut scope_89 = writer.prefix("TargetDBSnapshotIdentifier");
    if let Some(var_90) = &input.target_db_snapshot_identifier {
        scope_89.string(var_90);
    }
    #[allow(unused_mut)]
    let mut scope_91 = writer.prefix("KmsKeyId");
    if let Some(var_92) = &input.kms_key_id {
        scope_91.string(var_92);
    }
    #[allow(unused_mut)]
    let mut scope_93 = writer.prefix("Tags");
    if let Some(var_94) = &input.tags {
        let mut list_96 = scope_93.start_list(false, Some("Tag"));
        for item_95 in var_94 {
            #[allow(unused_mut)]
            let mut entry_97 = list_96.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_97, item_95);
        }
        list_96.finish();
    }
    #[allow(unused_mut)]
    let mut scope_98 = writer.prefix("CopyTags");
    if let Some(var_99) = &input.copy_tags {
        scope_98.boolean(*var_99);
    }
    #[allow(unused_mut)]
    let mut scope_100 = writer.prefix("PreSignedUrl");
    if let Some(var_101) = &input.pre_signed_url {
        scope_100.string(var_101);
    }
    #[allow(unused_mut)]
    let mut scope_102 = writer.prefix("OptionGroupName");
    if let Some(var_103) = &input.option_group_name {
        scope_102.string(var_103);
    }
    #[allow(unused_mut)]
    let mut scope_104 = writer.prefix("TargetCustomAvailabilityZone");
    if let Some(var_105) = &input.target_custom_availability_zone {
        scope_104.string(var_105);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_option_group(
    input: &crate::input::CopyOptionGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CopyOptionGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_106 = writer.prefix("SourceOptionGroupIdentifier");
    if let Some(var_107) = &input.source_option_group_identifier {
        scope_106.string(var_107);
    }
    #[allow(unused_mut)]
    let mut scope_108 = writer.prefix("TargetOptionGroupIdentifier");
    if let Some(var_109) = &input.target_option_group_identifier {
        scope_108.string(var_109);
    }
    #[allow(unused_mut)]
    let mut scope_110 = writer.prefix("TargetOptionGroupDescription");
    if let Some(var_111) = &input.target_option_group_description {
        scope_110.string(var_111);
    }
    #[allow(unused_mut)]
    let mut scope_112 = writer.prefix("Tags");
    if let Some(var_113) = &input.tags {
        let mut list_115 = scope_112.start_list(false, Some("Tag"));
        for item_114 in var_113 {
            #[allow(unused_mut)]
            let mut entry_116 = list_115.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_116, item_114);
        }
        list_115.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_custom_availability_zone(
    input: &crate::input::CreateCustomAvailabilityZoneInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateCustomAvailabilityZone", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_117 = writer.prefix("CustomAvailabilityZoneName");
    if let Some(var_118) = &input.custom_availability_zone_name {
        scope_117.string(var_118);
    }
    #[allow(unused_mut)]
    let mut scope_119 = writer.prefix("ExistingVpnId");
    if let Some(var_120) = &input.existing_vpn_id {
        scope_119.string(var_120);
    }
    #[allow(unused_mut)]
    let mut scope_121 = writer.prefix("NewVpnTunnelName");
    if let Some(var_122) = &input.new_vpn_tunnel_name {
        scope_121.string(var_122);
    }
    #[allow(unused_mut)]
    let mut scope_123 = writer.prefix("VpnTunnelOriginatorIP");
    if let Some(var_124) = &input.vpn_tunnel_originator_ip {
        scope_123.string(var_124);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster(
    input: &crate::input::CreateDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_125 = writer.prefix("AvailabilityZones");
    if let Some(var_126) = &input.availability_zones {
        let mut list_128 = scope_125.start_list(false, Some("AvailabilityZone"));
        for item_127 in var_126 {
            #[allow(unused_mut)]
            let mut entry_129 = list_128.entry();
            entry_129.string(item_127);
        }
        list_128.finish();
    }
    #[allow(unused_mut)]
    let mut scope_130 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_131) = &input.backup_retention_period {
        scope_130.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_131).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_132 = writer.prefix("CharacterSetName");
    if let Some(var_133) = &input.character_set_name {
        scope_132.string(var_133);
    }
    #[allow(unused_mut)]
    let mut scope_134 = writer.prefix("DatabaseName");
    if let Some(var_135) = &input.database_name {
        scope_134.string(var_135);
    }
    #[allow(unused_mut)]
    let mut scope_136 = writer.prefix("DBClusterIdentifier");
    if let Some(var_137) = &input.db_cluster_identifier {
        scope_136.string(var_137);
    }
    #[allow(unused_mut)]
    let mut scope_138 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_139) = &input.db_cluster_parameter_group_name {
        scope_138.string(var_139);
    }
    #[allow(unused_mut)]
    let mut scope_140 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_141) = &input.vpc_security_group_ids {
        let mut list_143 = scope_140.start_list(false, Some("VpcSecurityGroupId"));
        for item_142 in var_141 {
            #[allow(unused_mut)]
            let mut entry_144 = list_143.entry();
            entry_144.string(item_142);
        }
        list_143.finish();
    }
    #[allow(unused_mut)]
    let mut scope_145 = writer.prefix("DBSubnetGroupName");
    if let Some(var_146) = &input.db_subnet_group_name {
        scope_145.string(var_146);
    }
    #[allow(unused_mut)]
    let mut scope_147 = writer.prefix("Engine");
    if let Some(var_148) = &input.engine {
        scope_147.string(var_148);
    }
    #[allow(unused_mut)]
    let mut scope_149 = writer.prefix("EngineVersion");
    if let Some(var_150) = &input.engine_version {
        scope_149.string(var_150);
    }
    #[allow(unused_mut)]
    let mut scope_151 = writer.prefix("Port");
    if let Some(var_152) = &input.port {
        scope_151.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_152).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_153 = writer.prefix("MasterUsername");
    if let Some(var_154) = &input.master_username {
        scope_153.string(var_154);
    }
    #[allow(unused_mut)]
    let mut scope_155 = writer.prefix("MasterUserPassword");
    if let Some(var_156) = &input.master_user_password {
        scope_155.string(var_156);
    }
    #[allow(unused_mut)]
    let mut scope_157 = writer.prefix("OptionGroupName");
    if let Some(var_158) = &input.option_group_name {
        scope_157.string(var_158);
    }
    #[allow(unused_mut)]
    let mut scope_159 = writer.prefix("PreferredBackupWindow");
    if let Some(var_160) = &input.preferred_backup_window {
        scope_159.string(var_160);
    }
    #[allow(unused_mut)]
    let mut scope_161 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_162) = &input.preferred_maintenance_window {
        scope_161.string(var_162);
    }
    #[allow(unused_mut)]
    let mut scope_163 = writer.prefix("ReplicationSourceIdentifier");
    if let Some(var_164) = &input.replication_source_identifier {
        scope_163.string(var_164);
    }
    #[allow(unused_mut)]
    let mut scope_165 = writer.prefix("Tags");
    if let Some(var_166) = &input.tags {
        let mut list_168 = scope_165.start_list(false, Some("Tag"));
        for item_167 in var_166 {
            #[allow(unused_mut)]
            let mut entry_169 = list_168.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_169, item_167);
        }
        list_168.finish();
    }
    #[allow(unused_mut)]
    let mut scope_170 = writer.prefix("StorageEncrypted");
    if let Some(var_171) = &input.storage_encrypted {
        scope_170.boolean(*var_171);
    }
    #[allow(unused_mut)]
    let mut scope_172 = writer.prefix("KmsKeyId");
    if let Some(var_173) = &input.kms_key_id {
        scope_172.string(var_173);
    }
    #[allow(unused_mut)]
    let mut scope_174 = writer.prefix("PreSignedUrl");
    if let Some(var_175) = &input.pre_signed_url {
        scope_174.string(var_175);
    }
    #[allow(unused_mut)]
    let mut scope_176 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_177) = &input.enable_iam_database_authentication {
        scope_176.boolean(*var_177);
    }
    #[allow(unused_mut)]
    let mut scope_178 = writer.prefix("BacktrackWindow");
    if let Some(var_179) = &input.backtrack_window {
        scope_178.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_179).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_180 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_181) = &input.enable_cloudwatch_logs_exports {
        let mut list_183 = scope_180.start_list(false, None);
        for item_182 in var_181 {
            #[allow(unused_mut)]
            let mut entry_184 = list_183.entry();
            entry_184.string(item_182);
        }
        list_183.finish();
    }
    #[allow(unused_mut)]
    let mut scope_185 = writer.prefix("EngineMode");
    if let Some(var_186) = &input.engine_mode {
        scope_185.string(var_186);
    }
    #[allow(unused_mut)]
    let mut scope_187 = writer.prefix("ScalingConfiguration");
    if let Some(var_188) = &input.scaling_configuration {
        crate::query_ser::serialize_structure_crate_model_scaling_configuration(scope_187, var_188);
    }
    #[allow(unused_mut)]
    let mut scope_189 = writer.prefix("DeletionProtection");
    if let Some(var_190) = &input.deletion_protection {
        scope_189.boolean(*var_190);
    }
    #[allow(unused_mut)]
    let mut scope_191 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_192) = &input.global_cluster_identifier {
        scope_191.string(var_192);
    }
    #[allow(unused_mut)]
    let mut scope_193 = writer.prefix("EnableHttpEndpoint");
    if let Some(var_194) = &input.enable_http_endpoint {
        scope_193.boolean(*var_194);
    }
    #[allow(unused_mut)]
    let mut scope_195 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_196) = &input.copy_tags_to_snapshot {
        scope_195.boolean(*var_196);
    }
    #[allow(unused_mut)]
    let mut scope_197 = writer.prefix("Domain");
    if let Some(var_198) = &input.domain {
        scope_197.string(var_198);
    }
    #[allow(unused_mut)]
    let mut scope_199 = writer.prefix("DomainIAMRoleName");
    if let Some(var_200) = &input.domain_iam_role_name {
        scope_199.string(var_200);
    }
    #[allow(unused_mut)]
    let mut scope_201 = writer.prefix("EnableGlobalWriteForwarding");
    if let Some(var_202) = &input.enable_global_write_forwarding {
        scope_201.boolean(*var_202);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster_endpoint(
    input: &crate::input::CreateDbClusterEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBClusterEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_203 = writer.prefix("DBClusterIdentifier");
    if let Some(var_204) = &input.db_cluster_identifier {
        scope_203.string(var_204);
    }
    #[allow(unused_mut)]
    let mut scope_205 = writer.prefix("DBClusterEndpointIdentifier");
    if let Some(var_206) = &input.db_cluster_endpoint_identifier {
        scope_205.string(var_206);
    }
    #[allow(unused_mut)]
    let mut scope_207 = writer.prefix("EndpointType");
    if let Some(var_208) = &input.endpoint_type {
        scope_207.string(var_208);
    }
    #[allow(unused_mut)]
    let mut scope_209 = writer.prefix("StaticMembers");
    if let Some(var_210) = &input.static_members {
        let mut list_212 = scope_209.start_list(false, None);
        for item_211 in var_210 {
            #[allow(unused_mut)]
            let mut entry_213 = list_212.entry();
            entry_213.string(item_211);
        }
        list_212.finish();
    }
    #[allow(unused_mut)]
    let mut scope_214 = writer.prefix("ExcludedMembers");
    if let Some(var_215) = &input.excluded_members {
        let mut list_217 = scope_214.start_list(false, None);
        for item_216 in var_215 {
            #[allow(unused_mut)]
            let mut entry_218 = list_217.entry();
            entry_218.string(item_216);
        }
        list_217.finish();
    }
    #[allow(unused_mut)]
    let mut scope_219 = writer.prefix("Tags");
    if let Some(var_220) = &input.tags {
        let mut list_222 = scope_219.start_list(false, Some("Tag"));
        for item_221 in var_220 {
            #[allow(unused_mut)]
            let mut entry_223 = list_222.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_223, item_221);
        }
        list_222.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster_parameter_group(
    input: &crate::input::CreateDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_224 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_225) = &input.db_cluster_parameter_group_name {
        scope_224.string(var_225);
    }
    #[allow(unused_mut)]
    let mut scope_226 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_227) = &input.db_parameter_group_family {
        scope_226.string(var_227);
    }
    #[allow(unused_mut)]
    let mut scope_228 = writer.prefix("Description");
    if let Some(var_229) = &input.description {
        scope_228.string(var_229);
    }
    #[allow(unused_mut)]
    let mut scope_230 = writer.prefix("Tags");
    if let Some(var_231) = &input.tags {
        let mut list_233 = scope_230.start_list(false, Some("Tag"));
        for item_232 in var_231 {
            #[allow(unused_mut)]
            let mut entry_234 = list_233.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_234, item_232);
        }
        list_233.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster_snapshot(
    input: &crate::input::CreateDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_235 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_236) = &input.db_cluster_snapshot_identifier {
        scope_235.string(var_236);
    }
    #[allow(unused_mut)]
    let mut scope_237 = writer.prefix("DBClusterIdentifier");
    if let Some(var_238) = &input.db_cluster_identifier {
        scope_237.string(var_238);
    }
    #[allow(unused_mut)]
    let mut scope_239 = writer.prefix("Tags");
    if let Some(var_240) = &input.tags {
        let mut list_242 = scope_239.start_list(false, Some("Tag"));
        for item_241 in var_240 {
            #[allow(unused_mut)]
            let mut entry_243 = list_242.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_243, item_241);
        }
        list_242.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_instance(
    input: &crate::input::CreateDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_244 = writer.prefix("DBName");
    if let Some(var_245) = &input.db_name {
        scope_244.string(var_245);
    }
    #[allow(unused_mut)]
    let mut scope_246 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_247) = &input.db_instance_identifier {
        scope_246.string(var_247);
    }
    #[allow(unused_mut)]
    let mut scope_248 = writer.prefix("AllocatedStorage");
    if let Some(var_249) = &input.allocated_storage {
        scope_248.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_249).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_250 = writer.prefix("DBInstanceClass");
    if let Some(var_251) = &input.db_instance_class {
        scope_250.string(var_251);
    }
    #[allow(unused_mut)]
    let mut scope_252 = writer.prefix("Engine");
    if let Some(var_253) = &input.engine {
        scope_252.string(var_253);
    }
    #[allow(unused_mut)]
    let mut scope_254 = writer.prefix("MasterUsername");
    if let Some(var_255) = &input.master_username {
        scope_254.string(var_255);
    }
    #[allow(unused_mut)]
    let mut scope_256 = writer.prefix("MasterUserPassword");
    if let Some(var_257) = &input.master_user_password {
        scope_256.string(var_257);
    }
    #[allow(unused_mut)]
    let mut scope_258 = writer.prefix("DBSecurityGroups");
    if let Some(var_259) = &input.db_security_groups {
        let mut list_261 = scope_258.start_list(false, Some("DBSecurityGroupName"));
        for item_260 in var_259 {
            #[allow(unused_mut)]
            let mut entry_262 = list_261.entry();
            entry_262.string(item_260);
        }
        list_261.finish();
    }
    #[allow(unused_mut)]
    let mut scope_263 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_264) = &input.vpc_security_group_ids {
        let mut list_266 = scope_263.start_list(false, Some("VpcSecurityGroupId"));
        for item_265 in var_264 {
            #[allow(unused_mut)]
            let mut entry_267 = list_266.entry();
            entry_267.string(item_265);
        }
        list_266.finish();
    }
    #[allow(unused_mut)]
    let mut scope_268 = writer.prefix("AvailabilityZone");
    if let Some(var_269) = &input.availability_zone {
        scope_268.string(var_269);
    }
    #[allow(unused_mut)]
    let mut scope_270 = writer.prefix("DBSubnetGroupName");
    if let Some(var_271) = &input.db_subnet_group_name {
        scope_270.string(var_271);
    }
    #[allow(unused_mut)]
    let mut scope_272 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_273) = &input.preferred_maintenance_window {
        scope_272.string(var_273);
    }
    #[allow(unused_mut)]
    let mut scope_274 = writer.prefix("DBParameterGroupName");
    if let Some(var_275) = &input.db_parameter_group_name {
        scope_274.string(var_275);
    }
    #[allow(unused_mut)]
    let mut scope_276 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_277) = &input.backup_retention_period {
        scope_276.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_277).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_278 = writer.prefix("PreferredBackupWindow");
    if let Some(var_279) = &input.preferred_backup_window {
        scope_278.string(var_279);
    }
    #[allow(unused_mut)]
    let mut scope_280 = writer.prefix("Port");
    if let Some(var_281) = &input.port {
        scope_280.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_281).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_282 = writer.prefix("MultiAZ");
    if let Some(var_283) = &input.multi_az {
        scope_282.boolean(*var_283);
    }
    #[allow(unused_mut)]
    let mut scope_284 = writer.prefix("EngineVersion");
    if let Some(var_285) = &input.engine_version {
        scope_284.string(var_285);
    }
    #[allow(unused_mut)]
    let mut scope_286 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_287) = &input.auto_minor_version_upgrade {
        scope_286.boolean(*var_287);
    }
    #[allow(unused_mut)]
    let mut scope_288 = writer.prefix("LicenseModel");
    if let Some(var_289) = &input.license_model {
        scope_288.string(var_289);
    }
    #[allow(unused_mut)]
    let mut scope_290 = writer.prefix("Iops");
    if let Some(var_291) = &input.iops {
        scope_290.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_291).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_292 = writer.prefix("OptionGroupName");
    if let Some(var_293) = &input.option_group_name {
        scope_292.string(var_293);
    }
    #[allow(unused_mut)]
    let mut scope_294 = writer.prefix("CharacterSetName");
    if let Some(var_295) = &input.character_set_name {
        scope_294.string(var_295);
    }
    #[allow(unused_mut)]
    let mut scope_296 = writer.prefix("NcharCharacterSetName");
    if let Some(var_297) = &input.nchar_character_set_name {
        scope_296.string(var_297);
    }
    #[allow(unused_mut)]
    let mut scope_298 = writer.prefix("PubliclyAccessible");
    if let Some(var_299) = &input.publicly_accessible {
        scope_298.boolean(*var_299);
    }
    #[allow(unused_mut)]
    let mut scope_300 = writer.prefix("Tags");
    if let Some(var_301) = &input.tags {
        let mut list_303 = scope_300.start_list(false, Some("Tag"));
        for item_302 in var_301 {
            #[allow(unused_mut)]
            let mut entry_304 = list_303.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_304, item_302);
        }
        list_303.finish();
    }
    #[allow(unused_mut)]
    let mut scope_305 = writer.prefix("DBClusterIdentifier");
    if let Some(var_306) = &input.db_cluster_identifier {
        scope_305.string(var_306);
    }
    #[allow(unused_mut)]
    let mut scope_307 = writer.prefix("StorageType");
    if let Some(var_308) = &input.storage_type {
        scope_307.string(var_308);
    }
    #[allow(unused_mut)]
    let mut scope_309 = writer.prefix("TdeCredentialArn");
    if let Some(var_310) = &input.tde_credential_arn {
        scope_309.string(var_310);
    }
    #[allow(unused_mut)]
    let mut scope_311 = writer.prefix("TdeCredentialPassword");
    if let Some(var_312) = &input.tde_credential_password {
        scope_311.string(var_312);
    }
    #[allow(unused_mut)]
    let mut scope_313 = writer.prefix("StorageEncrypted");
    if let Some(var_314) = &input.storage_encrypted {
        scope_313.boolean(*var_314);
    }
    #[allow(unused_mut)]
    let mut scope_315 = writer.prefix("KmsKeyId");
    if let Some(var_316) = &input.kms_key_id {
        scope_315.string(var_316);
    }
    #[allow(unused_mut)]
    let mut scope_317 = writer.prefix("Domain");
    if let Some(var_318) = &input.domain {
        scope_317.string(var_318);
    }
    #[allow(unused_mut)]
    let mut scope_319 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_320) = &input.copy_tags_to_snapshot {
        scope_319.boolean(*var_320);
    }
    #[allow(unused_mut)]
    let mut scope_321 = writer.prefix("MonitoringInterval");
    if let Some(var_322) = &input.monitoring_interval {
        scope_321.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_322).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_323 = writer.prefix("MonitoringRoleArn");
    if let Some(var_324) = &input.monitoring_role_arn {
        scope_323.string(var_324);
    }
    #[allow(unused_mut)]
    let mut scope_325 = writer.prefix("DomainIAMRoleName");
    if let Some(var_326) = &input.domain_iam_role_name {
        scope_325.string(var_326);
    }
    #[allow(unused_mut)]
    let mut scope_327 = writer.prefix("PromotionTier");
    if let Some(var_328) = &input.promotion_tier {
        scope_327.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_328).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_329 = writer.prefix("Timezone");
    if let Some(var_330) = &input.timezone {
        scope_329.string(var_330);
    }
    #[allow(unused_mut)]
    let mut scope_331 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_332) = &input.enable_iam_database_authentication {
        scope_331.boolean(*var_332);
    }
    #[allow(unused_mut)]
    let mut scope_333 = writer.prefix("EnablePerformanceInsights");
    if let Some(var_334) = &input.enable_performance_insights {
        scope_333.boolean(*var_334);
    }
    #[allow(unused_mut)]
    let mut scope_335 = writer.prefix("PerformanceInsightsKMSKeyId");
    if let Some(var_336) = &input.performance_insights_kms_key_id {
        scope_335.string(var_336);
    }
    #[allow(unused_mut)]
    let mut scope_337 = writer.prefix("PerformanceInsightsRetentionPeriod");
    if let Some(var_338) = &input.performance_insights_retention_period {
        scope_337.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_338).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_339 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_340) = &input.enable_cloudwatch_logs_exports {
        let mut list_342 = scope_339.start_list(false, None);
        for item_341 in var_340 {
            #[allow(unused_mut)]
            let mut entry_343 = list_342.entry();
            entry_343.string(item_341);
        }
        list_342.finish();
    }
    #[allow(unused_mut)]
    let mut scope_344 = writer.prefix("ProcessorFeatures");
    if let Some(var_345) = &input.processor_features {
        let mut list_347 = scope_344.start_list(false, Some("ProcessorFeature"));
        for item_346 in var_345 {
            #[allow(unused_mut)]
            let mut entry_348 = list_347.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_348, item_346,
            );
        }
        list_347.finish();
    }
    #[allow(unused_mut)]
    let mut scope_349 = writer.prefix("DeletionProtection");
    if let Some(var_350) = &input.deletion_protection {
        scope_349.boolean(*var_350);
    }
    #[allow(unused_mut)]
    let mut scope_351 = writer.prefix("MaxAllocatedStorage");
    if let Some(var_352) = &input.max_allocated_storage {
        scope_351.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_352).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_353 = writer.prefix("EnableCustomerOwnedIp");
    if let Some(var_354) = &input.enable_customer_owned_ip {
        scope_353.boolean(*var_354);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_instance_read_replica(
    input: &crate::input::CreateDbInstanceReadReplicaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBInstanceReadReplica", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_355 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_356) = &input.db_instance_identifier {
        scope_355.string(var_356);
    }
    #[allow(unused_mut)]
    let mut scope_357 = writer.prefix("SourceDBInstanceIdentifier");
    if let Some(var_358) = &input.source_db_instance_identifier {
        scope_357.string(var_358);
    }
    #[allow(unused_mut)]
    let mut scope_359 = writer.prefix("DBInstanceClass");
    if let Some(var_360) = &input.db_instance_class {
        scope_359.string(var_360);
    }
    #[allow(unused_mut)]
    let mut scope_361 = writer.prefix("AvailabilityZone");
    if let Some(var_362) = &input.availability_zone {
        scope_361.string(var_362);
    }
    #[allow(unused_mut)]
    let mut scope_363 = writer.prefix("Port");
    if let Some(var_364) = &input.port {
        scope_363.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_364).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_365 = writer.prefix("MultiAZ");
    if let Some(var_366) = &input.multi_az {
        scope_365.boolean(*var_366);
    }
    #[allow(unused_mut)]
    let mut scope_367 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_368) = &input.auto_minor_version_upgrade {
        scope_367.boolean(*var_368);
    }
    #[allow(unused_mut)]
    let mut scope_369 = writer.prefix("Iops");
    if let Some(var_370) = &input.iops {
        scope_369.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_370).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_371 = writer.prefix("OptionGroupName");
    if let Some(var_372) = &input.option_group_name {
        scope_371.string(var_372);
    }
    #[allow(unused_mut)]
    let mut scope_373 = writer.prefix("DBParameterGroupName");
    if let Some(var_374) = &input.db_parameter_group_name {
        scope_373.string(var_374);
    }
    #[allow(unused_mut)]
    let mut scope_375 = writer.prefix("PubliclyAccessible");
    if let Some(var_376) = &input.publicly_accessible {
        scope_375.boolean(*var_376);
    }
    #[allow(unused_mut)]
    let mut scope_377 = writer.prefix("Tags");
    if let Some(var_378) = &input.tags {
        let mut list_380 = scope_377.start_list(false, Some("Tag"));
        for item_379 in var_378 {
            #[allow(unused_mut)]
            let mut entry_381 = list_380.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_381, item_379);
        }
        list_380.finish();
    }
    #[allow(unused_mut)]
    let mut scope_382 = writer.prefix("DBSubnetGroupName");
    if let Some(var_383) = &input.db_subnet_group_name {
        scope_382.string(var_383);
    }
    #[allow(unused_mut)]
    let mut scope_384 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_385) = &input.vpc_security_group_ids {
        let mut list_387 = scope_384.start_list(false, Some("VpcSecurityGroupId"));
        for item_386 in var_385 {
            #[allow(unused_mut)]
            let mut entry_388 = list_387.entry();
            entry_388.string(item_386);
        }
        list_387.finish();
    }
    #[allow(unused_mut)]
    let mut scope_389 = writer.prefix("StorageType");
    if let Some(var_390) = &input.storage_type {
        scope_389.string(var_390);
    }
    #[allow(unused_mut)]
    let mut scope_391 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_392) = &input.copy_tags_to_snapshot {
        scope_391.boolean(*var_392);
    }
    #[allow(unused_mut)]
    let mut scope_393 = writer.prefix("MonitoringInterval");
    if let Some(var_394) = &input.monitoring_interval {
        scope_393.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_394).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_395 = writer.prefix("MonitoringRoleArn");
    if let Some(var_396) = &input.monitoring_role_arn {
        scope_395.string(var_396);
    }
    #[allow(unused_mut)]
    let mut scope_397 = writer.prefix("KmsKeyId");
    if let Some(var_398) = &input.kms_key_id {
        scope_397.string(var_398);
    }
    #[allow(unused_mut)]
    let mut scope_399 = writer.prefix("PreSignedUrl");
    if let Some(var_400) = &input.pre_signed_url {
        scope_399.string(var_400);
    }
    #[allow(unused_mut)]
    let mut scope_401 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_402) = &input.enable_iam_database_authentication {
        scope_401.boolean(*var_402);
    }
    #[allow(unused_mut)]
    let mut scope_403 = writer.prefix("EnablePerformanceInsights");
    if let Some(var_404) = &input.enable_performance_insights {
        scope_403.boolean(*var_404);
    }
    #[allow(unused_mut)]
    let mut scope_405 = writer.prefix("PerformanceInsightsKMSKeyId");
    if let Some(var_406) = &input.performance_insights_kms_key_id {
        scope_405.string(var_406);
    }
    #[allow(unused_mut)]
    let mut scope_407 = writer.prefix("PerformanceInsightsRetentionPeriod");
    if let Some(var_408) = &input.performance_insights_retention_period {
        scope_407.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_408).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_409 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_410) = &input.enable_cloudwatch_logs_exports {
        let mut list_412 = scope_409.start_list(false, None);
        for item_411 in var_410 {
            #[allow(unused_mut)]
            let mut entry_413 = list_412.entry();
            entry_413.string(item_411);
        }
        list_412.finish();
    }
    #[allow(unused_mut)]
    let mut scope_414 = writer.prefix("ProcessorFeatures");
    if let Some(var_415) = &input.processor_features {
        let mut list_417 = scope_414.start_list(false, Some("ProcessorFeature"));
        for item_416 in var_415 {
            #[allow(unused_mut)]
            let mut entry_418 = list_417.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_418, item_416,
            );
        }
        list_417.finish();
    }
    #[allow(unused_mut)]
    let mut scope_419 = writer.prefix("UseDefaultProcessorFeatures");
    if let Some(var_420) = &input.use_default_processor_features {
        scope_419.boolean(*var_420);
    }
    #[allow(unused_mut)]
    let mut scope_421 = writer.prefix("DeletionProtection");
    if let Some(var_422) = &input.deletion_protection {
        scope_421.boolean(*var_422);
    }
    #[allow(unused_mut)]
    let mut scope_423 = writer.prefix("Domain");
    if let Some(var_424) = &input.domain {
        scope_423.string(var_424);
    }
    #[allow(unused_mut)]
    let mut scope_425 = writer.prefix("DomainIAMRoleName");
    if let Some(var_426) = &input.domain_iam_role_name {
        scope_425.string(var_426);
    }
    #[allow(unused_mut)]
    let mut scope_427 = writer.prefix("ReplicaMode");
    if let Some(var_428) = &input.replica_mode {
        scope_427.string(var_428.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_429 = writer.prefix("MaxAllocatedStorage");
    if let Some(var_430) = &input.max_allocated_storage {
        scope_429.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_430).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_parameter_group(
    input: &crate::input::CreateDbParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_431 = writer.prefix("DBParameterGroupName");
    if let Some(var_432) = &input.db_parameter_group_name {
        scope_431.string(var_432);
    }
    #[allow(unused_mut)]
    let mut scope_433 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_434) = &input.db_parameter_group_family {
        scope_433.string(var_434);
    }
    #[allow(unused_mut)]
    let mut scope_435 = writer.prefix("Description");
    if let Some(var_436) = &input.description {
        scope_435.string(var_436);
    }
    #[allow(unused_mut)]
    let mut scope_437 = writer.prefix("Tags");
    if let Some(var_438) = &input.tags {
        let mut list_440 = scope_437.start_list(false, Some("Tag"));
        for item_439 in var_438 {
            #[allow(unused_mut)]
            let mut entry_441 = list_440.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_441, item_439);
        }
        list_440.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_proxy(
    input: &crate::input::CreateDbProxyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBProxy", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_442 = writer.prefix("DBProxyName");
    if let Some(var_443) = &input.db_proxy_name {
        scope_442.string(var_443);
    }
    #[allow(unused_mut)]
    let mut scope_444 = writer.prefix("EngineFamily");
    if let Some(var_445) = &input.engine_family {
        scope_444.string(var_445.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_446 = writer.prefix("Auth");
    if let Some(var_447) = &input.auth {
        let mut list_449 = scope_446.start_list(false, None);
        for item_448 in var_447 {
            #[allow(unused_mut)]
            let mut entry_450 = list_449.entry();
            crate::query_ser::serialize_structure_crate_model_user_auth_config(entry_450, item_448);
        }
        list_449.finish();
    }
    #[allow(unused_mut)]
    let mut scope_451 = writer.prefix("RoleArn");
    if let Some(var_452) = &input.role_arn {
        scope_451.string(var_452);
    }
    #[allow(unused_mut)]
    let mut scope_453 = writer.prefix("VpcSubnetIds");
    if let Some(var_454) = &input.vpc_subnet_ids {
        let mut list_456 = scope_453.start_list(false, None);
        for item_455 in var_454 {
            #[allow(unused_mut)]
            let mut entry_457 = list_456.entry();
            entry_457.string(item_455);
        }
        list_456.finish();
    }
    #[allow(unused_mut)]
    let mut scope_458 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_459) = &input.vpc_security_group_ids {
        let mut list_461 = scope_458.start_list(false, None);
        for item_460 in var_459 {
            #[allow(unused_mut)]
            let mut entry_462 = list_461.entry();
            entry_462.string(item_460);
        }
        list_461.finish();
    }
    #[allow(unused_mut)]
    let mut scope_463 = writer.prefix("RequireTLS");
    if input.require_tls {
        scope_463.boolean(input.require_tls);
    }
    #[allow(unused_mut)]
    let mut scope_464 = writer.prefix("IdleClientTimeout");
    if let Some(var_465) = &input.idle_client_timeout {
        scope_464.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_465).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_466 = writer.prefix("DebugLogging");
    if input.debug_logging {
        scope_466.boolean(input.debug_logging);
    }
    #[allow(unused_mut)]
    let mut scope_467 = writer.prefix("Tags");
    if let Some(var_468) = &input.tags {
        let mut list_470 = scope_467.start_list(false, Some("Tag"));
        for item_469 in var_468 {
            #[allow(unused_mut)]
            let mut entry_471 = list_470.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_471, item_469);
        }
        list_470.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_proxy_endpoint(
    input: &crate::input::CreateDbProxyEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBProxyEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_472 = writer.prefix("DBProxyName");
    if let Some(var_473) = &input.db_proxy_name {
        scope_472.string(var_473);
    }
    #[allow(unused_mut)]
    let mut scope_474 = writer.prefix("DBProxyEndpointName");
    if let Some(var_475) = &input.db_proxy_endpoint_name {
        scope_474.string(var_475);
    }
    #[allow(unused_mut)]
    let mut scope_476 = writer.prefix("VpcSubnetIds");
    if let Some(var_477) = &input.vpc_subnet_ids {
        let mut list_479 = scope_476.start_list(false, None);
        for item_478 in var_477 {
            #[allow(unused_mut)]
            let mut entry_480 = list_479.entry();
            entry_480.string(item_478);
        }
        list_479.finish();
    }
    #[allow(unused_mut)]
    let mut scope_481 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_482) = &input.vpc_security_group_ids {
        let mut list_484 = scope_481.start_list(false, None);
        for item_483 in var_482 {
            #[allow(unused_mut)]
            let mut entry_485 = list_484.entry();
            entry_485.string(item_483);
        }
        list_484.finish();
    }
    #[allow(unused_mut)]
    let mut scope_486 = writer.prefix("TargetRole");
    if let Some(var_487) = &input.target_role {
        scope_486.string(var_487.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_488 = writer.prefix("Tags");
    if let Some(var_489) = &input.tags {
        let mut list_491 = scope_488.start_list(false, Some("Tag"));
        for item_490 in var_489 {
            #[allow(unused_mut)]
            let mut entry_492 = list_491.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_492, item_490);
        }
        list_491.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_security_group(
    input: &crate::input::CreateDbSecurityGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBSecurityGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_493 = writer.prefix("DBSecurityGroupName");
    if let Some(var_494) = &input.db_security_group_name {
        scope_493.string(var_494);
    }
    #[allow(unused_mut)]
    let mut scope_495 = writer.prefix("DBSecurityGroupDescription");
    if let Some(var_496) = &input.db_security_group_description {
        scope_495.string(var_496);
    }
    #[allow(unused_mut)]
    let mut scope_497 = writer.prefix("Tags");
    if let Some(var_498) = &input.tags {
        let mut list_500 = scope_497.start_list(false, Some("Tag"));
        for item_499 in var_498 {
            #[allow(unused_mut)]
            let mut entry_501 = list_500.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_501, item_499);
        }
        list_500.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_snapshot(
    input: &crate::input::CreateDbSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_502 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_503) = &input.db_snapshot_identifier {
        scope_502.string(var_503);
    }
    #[allow(unused_mut)]
    let mut scope_504 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_505) = &input.db_instance_identifier {
        scope_504.string(var_505);
    }
    #[allow(unused_mut)]
    let mut scope_506 = writer.prefix("Tags");
    if let Some(var_507) = &input.tags {
        let mut list_509 = scope_506.start_list(false, Some("Tag"));
        for item_508 in var_507 {
            #[allow(unused_mut)]
            let mut entry_510 = list_509.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_510, item_508);
        }
        list_509.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_subnet_group(
    input: &crate::input::CreateDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_511 = writer.prefix("DBSubnetGroupName");
    if let Some(var_512) = &input.db_subnet_group_name {
        scope_511.string(var_512);
    }
    #[allow(unused_mut)]
    let mut scope_513 = writer.prefix("DBSubnetGroupDescription");
    if let Some(var_514) = &input.db_subnet_group_description {
        scope_513.string(var_514);
    }
    #[allow(unused_mut)]
    let mut scope_515 = writer.prefix("SubnetIds");
    if let Some(var_516) = &input.subnet_ids {
        let mut list_518 = scope_515.start_list(false, Some("SubnetIdentifier"));
        for item_517 in var_516 {
            #[allow(unused_mut)]
            let mut entry_519 = list_518.entry();
            entry_519.string(item_517);
        }
        list_518.finish();
    }
    #[allow(unused_mut)]
    let mut scope_520 = writer.prefix("Tags");
    if let Some(var_521) = &input.tags {
        let mut list_523 = scope_520.start_list(false, Some("Tag"));
        for item_522 in var_521 {
            #[allow(unused_mut)]
            let mut entry_524 = list_523.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_524, item_522);
        }
        list_523.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_event_subscription(
    input: &crate::input::CreateEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_525 = writer.prefix("SubscriptionName");
    if let Some(var_526) = &input.subscription_name {
        scope_525.string(var_526);
    }
    #[allow(unused_mut)]
    let mut scope_527 = writer.prefix("SnsTopicArn");
    if let Some(var_528) = &input.sns_topic_arn {
        scope_527.string(var_528);
    }
    #[allow(unused_mut)]
    let mut scope_529 = writer.prefix("SourceType");
    if let Some(var_530) = &input.source_type {
        scope_529.string(var_530);
    }
    #[allow(unused_mut)]
    let mut scope_531 = writer.prefix("EventCategories");
    if let Some(var_532) = &input.event_categories {
        let mut list_534 = scope_531.start_list(false, Some("EventCategory"));
        for item_533 in var_532 {
            #[allow(unused_mut)]
            let mut entry_535 = list_534.entry();
            entry_535.string(item_533);
        }
        list_534.finish();
    }
    #[allow(unused_mut)]
    let mut scope_536 = writer.prefix("SourceIds");
    if let Some(var_537) = &input.source_ids {
        let mut list_539 = scope_536.start_list(false, Some("SourceId"));
        for item_538 in var_537 {
            #[allow(unused_mut)]
            let mut entry_540 = list_539.entry();
            entry_540.string(item_538);
        }
        list_539.finish();
    }
    #[allow(unused_mut)]
    let mut scope_541 = writer.prefix("Enabled");
    if let Some(var_542) = &input.enabled {
        scope_541.boolean(*var_542);
    }
    #[allow(unused_mut)]
    let mut scope_543 = writer.prefix("Tags");
    if let Some(var_544) = &input.tags {
        let mut list_546 = scope_543.start_list(false, Some("Tag"));
        for item_545 in var_544 {
            #[allow(unused_mut)]
            let mut entry_547 = list_546.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_547, item_545);
        }
        list_546.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_global_cluster(
    input: &crate::input::CreateGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_548 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_549) = &input.global_cluster_identifier {
        scope_548.string(var_549);
    }
    #[allow(unused_mut)]
    let mut scope_550 = writer.prefix("SourceDBClusterIdentifier");
    if let Some(var_551) = &input.source_db_cluster_identifier {
        scope_550.string(var_551);
    }
    #[allow(unused_mut)]
    let mut scope_552 = writer.prefix("Engine");
    if let Some(var_553) = &input.engine {
        scope_552.string(var_553);
    }
    #[allow(unused_mut)]
    let mut scope_554 = writer.prefix("EngineVersion");
    if let Some(var_555) = &input.engine_version {
        scope_554.string(var_555);
    }
    #[allow(unused_mut)]
    let mut scope_556 = writer.prefix("DeletionProtection");
    if let Some(var_557) = &input.deletion_protection {
        scope_556.boolean(*var_557);
    }
    #[allow(unused_mut)]
    let mut scope_558 = writer.prefix("DatabaseName");
    if let Some(var_559) = &input.database_name {
        scope_558.string(var_559);
    }
    #[allow(unused_mut)]
    let mut scope_560 = writer.prefix("StorageEncrypted");
    if let Some(var_561) = &input.storage_encrypted {
        scope_560.boolean(*var_561);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_option_group(
    input: &crate::input::CreateOptionGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateOptionGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_562 = writer.prefix("OptionGroupName");
    if let Some(var_563) = &input.option_group_name {
        scope_562.string(var_563);
    }
    #[allow(unused_mut)]
    let mut scope_564 = writer.prefix("EngineName");
    if let Some(var_565) = &input.engine_name {
        scope_564.string(var_565);
    }
    #[allow(unused_mut)]
    let mut scope_566 = writer.prefix("MajorEngineVersion");
    if let Some(var_567) = &input.major_engine_version {
        scope_566.string(var_567);
    }
    #[allow(unused_mut)]
    let mut scope_568 = writer.prefix("OptionGroupDescription");
    if let Some(var_569) = &input.option_group_description {
        scope_568.string(var_569);
    }
    #[allow(unused_mut)]
    let mut scope_570 = writer.prefix("Tags");
    if let Some(var_571) = &input.tags {
        let mut list_573 = scope_570.start_list(false, Some("Tag"));
        for item_572 in var_571 {
            #[allow(unused_mut)]
            let mut entry_574 = list_573.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_574, item_572);
        }
        list_573.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_custom_availability_zone(
    input: &crate::input::DeleteCustomAvailabilityZoneInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteCustomAvailabilityZone", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_575 = writer.prefix("CustomAvailabilityZoneId");
    if let Some(var_576) = &input.custom_availability_zone_id {
        scope_575.string(var_576);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster(
    input: &crate::input::DeleteDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_577 = writer.prefix("DBClusterIdentifier");
    if let Some(var_578) = &input.db_cluster_identifier {
        scope_577.string(var_578);
    }
    #[allow(unused_mut)]
    let mut scope_579 = writer.prefix("SkipFinalSnapshot");
    if input.skip_final_snapshot {
        scope_579.boolean(input.skip_final_snapshot);
    }
    #[allow(unused_mut)]
    let mut scope_580 = writer.prefix("FinalDBSnapshotIdentifier");
    if let Some(var_581) = &input.final_db_snapshot_identifier {
        scope_580.string(var_581);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster_endpoint(
    input: &crate::input::DeleteDbClusterEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBClusterEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_582 = writer.prefix("DBClusterEndpointIdentifier");
    if let Some(var_583) = &input.db_cluster_endpoint_identifier {
        scope_582.string(var_583);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster_parameter_group(
    input: &crate::input::DeleteDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_584 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_585) = &input.db_cluster_parameter_group_name {
        scope_584.string(var_585);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster_snapshot(
    input: &crate::input::DeleteDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_586 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_587) = &input.db_cluster_snapshot_identifier {
        scope_586.string(var_587);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_instance(
    input: &crate::input::DeleteDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_588 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_589) = &input.db_instance_identifier {
        scope_588.string(var_589);
    }
    #[allow(unused_mut)]
    let mut scope_590 = writer.prefix("SkipFinalSnapshot");
    if input.skip_final_snapshot {
        scope_590.boolean(input.skip_final_snapshot);
    }
    #[allow(unused_mut)]
    let mut scope_591 = writer.prefix("FinalDBSnapshotIdentifier");
    if let Some(var_592) = &input.final_db_snapshot_identifier {
        scope_591.string(var_592);
    }
    #[allow(unused_mut)]
    let mut scope_593 = writer.prefix("DeleteAutomatedBackups");
    if let Some(var_594) = &input.delete_automated_backups {
        scope_593.boolean(*var_594);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_instance_automated_backup(
    input: &crate::input::DeleteDbInstanceAutomatedBackupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBInstanceAutomatedBackup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_595 = writer.prefix("DbiResourceId");
    if let Some(var_596) = &input.dbi_resource_id {
        scope_595.string(var_596);
    }
    #[allow(unused_mut)]
    let mut scope_597 = writer.prefix("DBInstanceAutomatedBackupsArn");
    if let Some(var_598) = &input.db_instance_automated_backups_arn {
        scope_597.string(var_598);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_parameter_group(
    input: &crate::input::DeleteDbParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_599 = writer.prefix("DBParameterGroupName");
    if let Some(var_600) = &input.db_parameter_group_name {
        scope_599.string(var_600);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_proxy(
    input: &crate::input::DeleteDbProxyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBProxy", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_601 = writer.prefix("DBProxyName");
    if let Some(var_602) = &input.db_proxy_name {
        scope_601.string(var_602);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_proxy_endpoint(
    input: &crate::input::DeleteDbProxyEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBProxyEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_603 = writer.prefix("DBProxyEndpointName");
    if let Some(var_604) = &input.db_proxy_endpoint_name {
        scope_603.string(var_604);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_security_group(
    input: &crate::input::DeleteDbSecurityGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBSecurityGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_605 = writer.prefix("DBSecurityGroupName");
    if let Some(var_606) = &input.db_security_group_name {
        scope_605.string(var_606);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_snapshot(
    input: &crate::input::DeleteDbSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_607 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_608) = &input.db_snapshot_identifier {
        scope_607.string(var_608);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_subnet_group(
    input: &crate::input::DeleteDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_609 = writer.prefix("DBSubnetGroupName");
    if let Some(var_610) = &input.db_subnet_group_name {
        scope_609.string(var_610);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_event_subscription(
    input: &crate::input::DeleteEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_611 = writer.prefix("SubscriptionName");
    if let Some(var_612) = &input.subscription_name {
        scope_611.string(var_612);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_global_cluster(
    input: &crate::input::DeleteGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_613 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_614) = &input.global_cluster_identifier {
        scope_613.string(var_614);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_installation_media(
    input: &crate::input::DeleteInstallationMediaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteInstallationMedia", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_615 = writer.prefix("InstallationMediaId");
    if let Some(var_616) = &input.installation_media_id {
        scope_615.string(var_616);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_option_group(
    input: &crate::input::DeleteOptionGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteOptionGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_617 = writer.prefix("OptionGroupName");
    if let Some(var_618) = &input.option_group_name {
        scope_617.string(var_618);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_deregister_db_proxy_targets(
    input: &crate::input::DeregisterDbProxyTargetsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeregisterDBProxyTargets", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_619 = writer.prefix("DBProxyName");
    if let Some(var_620) = &input.db_proxy_name {
        scope_619.string(var_620);
    }
    #[allow(unused_mut)]
    let mut scope_621 = writer.prefix("TargetGroupName");
    if let Some(var_622) = &input.target_group_name {
        scope_621.string(var_622);
    }
    #[allow(unused_mut)]
    let mut scope_623 = writer.prefix("DBInstanceIdentifiers");
    if let Some(var_624) = &input.db_instance_identifiers {
        let mut list_626 = scope_623.start_list(false, None);
        for item_625 in var_624 {
            #[allow(unused_mut)]
            let mut entry_627 = list_626.entry();
            entry_627.string(item_625);
        }
        list_626.finish();
    }
    #[allow(unused_mut)]
    let mut scope_628 = writer.prefix("DBClusterIdentifiers");
    if let Some(var_629) = &input.db_cluster_identifiers {
        let mut list_631 = scope_628.start_list(false, None);
        for item_630 in var_629 {
            #[allow(unused_mut)]
            let mut entry_632 = list_631.entry();
            entry_632.string(item_630);
        }
        list_631.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_account_attributes(
    input: &crate::input::DescribeAccountAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeAccountAttributes", "2014-10-31");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_certificates(
    input: &crate::input::DescribeCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeCertificates", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_633 = writer.prefix("CertificateIdentifier");
    if let Some(var_634) = &input.certificate_identifier {
        scope_633.string(var_634);
    }
    #[allow(unused_mut)]
    let mut scope_635 = writer.prefix("Filters");
    if let Some(var_636) = &input.filters {
        let mut list_638 = scope_635.start_list(false, Some("Filter"));
        for item_637 in var_636 {
            #[allow(unused_mut)]
            let mut entry_639 = list_638.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_639, item_637);
        }
        list_638.finish();
    }
    #[allow(unused_mut)]
    let mut scope_640 = writer.prefix("MaxRecords");
    if let Some(var_641) = &input.max_records {
        scope_640.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_641).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_642 = writer.prefix("Marker");
    if let Some(var_643) = &input.marker {
        scope_642.string(var_643);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_custom_availability_zones(
    input: &crate::input::DescribeCustomAvailabilityZonesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeCustomAvailabilityZones", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_644 = writer.prefix("CustomAvailabilityZoneId");
    if let Some(var_645) = &input.custom_availability_zone_id {
        scope_644.string(var_645);
    }
    #[allow(unused_mut)]
    let mut scope_646 = writer.prefix("Filters");
    if let Some(var_647) = &input.filters {
        let mut list_649 = scope_646.start_list(false, Some("Filter"));
        for item_648 in var_647 {
            #[allow(unused_mut)]
            let mut entry_650 = list_649.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_650, item_648);
        }
        list_649.finish();
    }
    #[allow(unused_mut)]
    let mut scope_651 = writer.prefix("MaxRecords");
    if let Some(var_652) = &input.max_records {
        scope_651.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_652).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_653 = writer.prefix("Marker");
    if let Some(var_654) = &input.marker {
        scope_653.string(var_654);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_backtracks(
    input: &crate::input::DescribeDbClusterBacktracksInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterBacktracks", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_655 = writer.prefix("DBClusterIdentifier");
    if let Some(var_656) = &input.db_cluster_identifier {
        scope_655.string(var_656);
    }
    #[allow(unused_mut)]
    let mut scope_657 = writer.prefix("BacktrackIdentifier");
    if let Some(var_658) = &input.backtrack_identifier {
        scope_657.string(var_658);
    }
    #[allow(unused_mut)]
    let mut scope_659 = writer.prefix("Filters");
    if let Some(var_660) = &input.filters {
        let mut list_662 = scope_659.start_list(false, Some("Filter"));
        for item_661 in var_660 {
            #[allow(unused_mut)]
            let mut entry_663 = list_662.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_663, item_661);
        }
        list_662.finish();
    }
    #[allow(unused_mut)]
    let mut scope_664 = writer.prefix("MaxRecords");
    if let Some(var_665) = &input.max_records {
        scope_664.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_665).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_666 = writer.prefix("Marker");
    if let Some(var_667) = &input.marker {
        scope_666.string(var_667);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_endpoints(
    input: &crate::input::DescribeDbClusterEndpointsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterEndpoints", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_668 = writer.prefix("DBClusterIdentifier");
    if let Some(var_669) = &input.db_cluster_identifier {
        scope_668.string(var_669);
    }
    #[allow(unused_mut)]
    let mut scope_670 = writer.prefix("DBClusterEndpointIdentifier");
    if let Some(var_671) = &input.db_cluster_endpoint_identifier {
        scope_670.string(var_671);
    }
    #[allow(unused_mut)]
    let mut scope_672 = writer.prefix("Filters");
    if let Some(var_673) = &input.filters {
        let mut list_675 = scope_672.start_list(false, Some("Filter"));
        for item_674 in var_673 {
            #[allow(unused_mut)]
            let mut entry_676 = list_675.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_676, item_674);
        }
        list_675.finish();
    }
    #[allow(unused_mut)]
    let mut scope_677 = writer.prefix("MaxRecords");
    if let Some(var_678) = &input.max_records {
        scope_677.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_678).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_679 = writer.prefix("Marker");
    if let Some(var_680) = &input.marker {
        scope_679.string(var_680);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_parameter_groups(
    input: &crate::input::DescribeDbClusterParameterGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterParameterGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_681 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_682) = &input.db_cluster_parameter_group_name {
        scope_681.string(var_682);
    }
    #[allow(unused_mut)]
    let mut scope_683 = writer.prefix("Filters");
    if let Some(var_684) = &input.filters {
        let mut list_686 = scope_683.start_list(false, Some("Filter"));
        for item_685 in var_684 {
            #[allow(unused_mut)]
            let mut entry_687 = list_686.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_687, item_685);
        }
        list_686.finish();
    }
    #[allow(unused_mut)]
    let mut scope_688 = writer.prefix("MaxRecords");
    if let Some(var_689) = &input.max_records {
        scope_688.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_689).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_690 = writer.prefix("Marker");
    if let Some(var_691) = &input.marker {
        scope_690.string(var_691);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_parameters(
    input: &crate::input::DescribeDbClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterParameters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_692 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_693) = &input.db_cluster_parameter_group_name {
        scope_692.string(var_693);
    }
    #[allow(unused_mut)]
    let mut scope_694 = writer.prefix("Source");
    if let Some(var_695) = &input.source {
        scope_694.string(var_695);
    }
    #[allow(unused_mut)]
    let mut scope_696 = writer.prefix("Filters");
    if let Some(var_697) = &input.filters {
        let mut list_699 = scope_696.start_list(false, Some("Filter"));
        for item_698 in var_697 {
            #[allow(unused_mut)]
            let mut entry_700 = list_699.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_700, item_698);
        }
        list_699.finish();
    }
    #[allow(unused_mut)]
    let mut scope_701 = writer.prefix("MaxRecords");
    if let Some(var_702) = &input.max_records {
        scope_701.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_702).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_703 = writer.prefix("Marker");
    if let Some(var_704) = &input.marker {
        scope_703.string(var_704);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_clusters(
    input: &crate::input::DescribeDbClustersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBClusters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_705 = writer.prefix("DBClusterIdentifier");
    if let Some(var_706) = &input.db_cluster_identifier {
        scope_705.string(var_706);
    }
    #[allow(unused_mut)]
    let mut scope_707 = writer.prefix("Filters");
    if let Some(var_708) = &input.filters {
        let mut list_710 = scope_707.start_list(false, Some("Filter"));
        for item_709 in var_708 {
            #[allow(unused_mut)]
            let mut entry_711 = list_710.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_711, item_709);
        }
        list_710.finish();
    }
    #[allow(unused_mut)]
    let mut scope_712 = writer.prefix("MaxRecords");
    if let Some(var_713) = &input.max_records {
        scope_712.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_713).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_714 = writer.prefix("Marker");
    if let Some(var_715) = &input.marker {
        scope_714.string(var_715);
    }
    #[allow(unused_mut)]
    let mut scope_716 = writer.prefix("IncludeShared");
    if input.include_shared {
        scope_716.boolean(input.include_shared);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_snapshot_attributes(
    input: &crate::input::DescribeDbClusterSnapshotAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeDBClusterSnapshotAttributes",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_717 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_718) = &input.db_cluster_snapshot_identifier {
        scope_717.string(var_718);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_snapshots(
    input: &crate::input::DescribeDbClusterSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterSnapshots", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_719 = writer.prefix("DBClusterIdentifier");
    if let Some(var_720) = &input.db_cluster_identifier {
        scope_719.string(var_720);
    }
    #[allow(unused_mut)]
    let mut scope_721 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_722) = &input.db_cluster_snapshot_identifier {
        scope_721.string(var_722);
    }
    #[allow(unused_mut)]
    let mut scope_723 = writer.prefix("SnapshotType");
    if let Some(var_724) = &input.snapshot_type {
        scope_723.string(var_724);
    }
    #[allow(unused_mut)]
    let mut scope_725 = writer.prefix("Filters");
    if let Some(var_726) = &input.filters {
        let mut list_728 = scope_725.start_list(false, Some("Filter"));
        for item_727 in var_726 {
            #[allow(unused_mut)]
            let mut entry_729 = list_728.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_729, item_727);
        }
        list_728.finish();
    }
    #[allow(unused_mut)]
    let mut scope_730 = writer.prefix("MaxRecords");
    if let Some(var_731) = &input.max_records {
        scope_730.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_731).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_732 = writer.prefix("Marker");
    if let Some(var_733) = &input.marker {
        scope_732.string(var_733);
    }
    #[allow(unused_mut)]
    let mut scope_734 = writer.prefix("IncludeShared");
    if input.include_shared {
        scope_734.boolean(input.include_shared);
    }
    #[allow(unused_mut)]
    let mut scope_735 = writer.prefix("IncludePublic");
    if input.include_public {
        scope_735.boolean(input.include_public);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_engine_versions(
    input: &crate::input::DescribeDbEngineVersionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBEngineVersions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_736 = writer.prefix("Engine");
    if let Some(var_737) = &input.engine {
        scope_736.string(var_737);
    }
    #[allow(unused_mut)]
    let mut scope_738 = writer.prefix("EngineVersion");
    if let Some(var_739) = &input.engine_version {
        scope_738.string(var_739);
    }
    #[allow(unused_mut)]
    let mut scope_740 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_741) = &input.db_parameter_group_family {
        scope_740.string(var_741);
    }
    #[allow(unused_mut)]
    let mut scope_742 = writer.prefix("Filters");
    if let Some(var_743) = &input.filters {
        let mut list_745 = scope_742.start_list(false, Some("Filter"));
        for item_744 in var_743 {
            #[allow(unused_mut)]
            let mut entry_746 = list_745.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_746, item_744);
        }
        list_745.finish();
    }
    #[allow(unused_mut)]
    let mut scope_747 = writer.prefix("MaxRecords");
    if let Some(var_748) = &input.max_records {
        scope_747.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_748).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_749 = writer.prefix("Marker");
    if let Some(var_750) = &input.marker {
        scope_749.string(var_750);
    }
    #[allow(unused_mut)]
    let mut scope_751 = writer.prefix("DefaultOnly");
    if input.default_only {
        scope_751.boolean(input.default_only);
    }
    #[allow(unused_mut)]
    let mut scope_752 = writer.prefix("ListSupportedCharacterSets");
    if let Some(var_753) = &input.list_supported_character_sets {
        scope_752.boolean(*var_753);
    }
    #[allow(unused_mut)]
    let mut scope_754 = writer.prefix("ListSupportedTimezones");
    if let Some(var_755) = &input.list_supported_timezones {
        scope_754.boolean(*var_755);
    }
    #[allow(unused_mut)]
    let mut scope_756 = writer.prefix("IncludeAll");
    if let Some(var_757) = &input.include_all {
        scope_756.boolean(*var_757);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_instance_automated_backups(
    input: &crate::input::DescribeDbInstanceAutomatedBackupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeDBInstanceAutomatedBackups",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_758 = writer.prefix("DbiResourceId");
    if let Some(var_759) = &input.dbi_resource_id {
        scope_758.string(var_759);
    }
    #[allow(unused_mut)]
    let mut scope_760 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_761) = &input.db_instance_identifier {
        scope_760.string(var_761);
    }
    #[allow(unused_mut)]
    let mut scope_762 = writer.prefix("Filters");
    if let Some(var_763) = &input.filters {
        let mut list_765 = scope_762.start_list(false, Some("Filter"));
        for item_764 in var_763 {
            #[allow(unused_mut)]
            let mut entry_766 = list_765.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_766, item_764);
        }
        list_765.finish();
    }
    #[allow(unused_mut)]
    let mut scope_767 = writer.prefix("MaxRecords");
    if let Some(var_768) = &input.max_records {
        scope_767.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_768).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_769 = writer.prefix("Marker");
    if let Some(var_770) = &input.marker {
        scope_769.string(var_770);
    }
    #[allow(unused_mut)]
    let mut scope_771 = writer.prefix("DBInstanceAutomatedBackupsArn");
    if let Some(var_772) = &input.db_instance_automated_backups_arn {
        scope_771.string(var_772);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_instances(
    input: &crate::input::DescribeDbInstancesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBInstances", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_773 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_774) = &input.db_instance_identifier {
        scope_773.string(var_774);
    }
    #[allow(unused_mut)]
    let mut scope_775 = writer.prefix("Filters");
    if let Some(var_776) = &input.filters {
        let mut list_778 = scope_775.start_list(false, Some("Filter"));
        for item_777 in var_776 {
            #[allow(unused_mut)]
            let mut entry_779 = list_778.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_779, item_777);
        }
        list_778.finish();
    }
    #[allow(unused_mut)]
    let mut scope_780 = writer.prefix("MaxRecords");
    if let Some(var_781) = &input.max_records {
        scope_780.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_781).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_782 = writer.prefix("Marker");
    if let Some(var_783) = &input.marker {
        scope_782.string(var_783);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_log_files(
    input: &crate::input::DescribeDbLogFilesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBLogFiles", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_784 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_785) = &input.db_instance_identifier {
        scope_784.string(var_785);
    }
    #[allow(unused_mut)]
    let mut scope_786 = writer.prefix("FilenameContains");
    if let Some(var_787) = &input.filename_contains {
        scope_786.string(var_787);
    }
    #[allow(unused_mut)]
    let mut scope_788 = writer.prefix("FileLastWritten");
    if input.file_last_written != 0 {
        scope_788.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.file_last_written).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_789 = writer.prefix("FileSize");
    if input.file_size != 0 {
        scope_789.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.file_size).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_790 = writer.prefix("Filters");
    if let Some(var_791) = &input.filters {
        let mut list_793 = scope_790.start_list(false, Some("Filter"));
        for item_792 in var_791 {
            #[allow(unused_mut)]
            let mut entry_794 = list_793.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_794, item_792);
        }
        list_793.finish();
    }
    #[allow(unused_mut)]
    let mut scope_795 = writer.prefix("MaxRecords");
    if let Some(var_796) = &input.max_records {
        scope_795.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_796).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_797 = writer.prefix("Marker");
    if let Some(var_798) = &input.marker {
        scope_797.string(var_798);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_parameter_groups(
    input: &crate::input::DescribeDbParameterGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBParameterGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_799 = writer.prefix("DBParameterGroupName");
    if let Some(var_800) = &input.db_parameter_group_name {
        scope_799.string(var_800);
    }
    #[allow(unused_mut)]
    let mut scope_801 = writer.prefix("Filters");
    if let Some(var_802) = &input.filters {
        let mut list_804 = scope_801.start_list(false, Some("Filter"));
        for item_803 in var_802 {
            #[allow(unused_mut)]
            let mut entry_805 = list_804.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_805, item_803);
        }
        list_804.finish();
    }
    #[allow(unused_mut)]
    let mut scope_806 = writer.prefix("MaxRecords");
    if let Some(var_807) = &input.max_records {
        scope_806.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_807).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_808 = writer.prefix("Marker");
    if let Some(var_809) = &input.marker {
        scope_808.string(var_809);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_parameters(
    input: &crate::input::DescribeDbParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBParameters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_810 = writer.prefix("DBParameterGroupName");
    if let Some(var_811) = &input.db_parameter_group_name {
        scope_810.string(var_811);
    }
    #[allow(unused_mut)]
    let mut scope_812 = writer.prefix("Source");
    if let Some(var_813) = &input.source {
        scope_812.string(var_813);
    }
    #[allow(unused_mut)]
    let mut scope_814 = writer.prefix("Filters");
    if let Some(var_815) = &input.filters {
        let mut list_817 = scope_814.start_list(false, Some("Filter"));
        for item_816 in var_815 {
            #[allow(unused_mut)]
            let mut entry_818 = list_817.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_818, item_816);
        }
        list_817.finish();
    }
    #[allow(unused_mut)]
    let mut scope_819 = writer.prefix("MaxRecords");
    if let Some(var_820) = &input.max_records {
        scope_819.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_820).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_821 = writer.prefix("Marker");
    if let Some(var_822) = &input.marker {
        scope_821.string(var_822);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_proxies(
    input: &crate::input::DescribeDbProxiesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBProxies", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_823 = writer.prefix("DBProxyName");
    if let Some(var_824) = &input.db_proxy_name {
        scope_823.string(var_824);
    }
    #[allow(unused_mut)]
    let mut scope_825 = writer.prefix("Filters");
    if let Some(var_826) = &input.filters {
        let mut list_828 = scope_825.start_list(false, Some("Filter"));
        for item_827 in var_826 {
            #[allow(unused_mut)]
            let mut entry_829 = list_828.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_829, item_827);
        }
        list_828.finish();
    }
    #[allow(unused_mut)]
    let mut scope_830 = writer.prefix("Marker");
    if let Some(var_831) = &input.marker {
        scope_830.string(var_831);
    }
    #[allow(unused_mut)]
    let mut scope_832 = writer.prefix("MaxRecords");
    if let Some(var_833) = &input.max_records {
        scope_832.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_833).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_proxy_endpoints(
    input: &crate::input::DescribeDbProxyEndpointsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBProxyEndpoints", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_834 = writer.prefix("DBProxyName");
    if let Some(var_835) = &input.db_proxy_name {
        scope_834.string(var_835);
    }
    #[allow(unused_mut)]
    let mut scope_836 = writer.prefix("DBProxyEndpointName");
    if let Some(var_837) = &input.db_proxy_endpoint_name {
        scope_836.string(var_837);
    }
    #[allow(unused_mut)]
    let mut scope_838 = writer.prefix("Filters");
    if let Some(var_839) = &input.filters {
        let mut list_841 = scope_838.start_list(false, Some("Filter"));
        for item_840 in var_839 {
            #[allow(unused_mut)]
            let mut entry_842 = list_841.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_842, item_840);
        }
        list_841.finish();
    }
    #[allow(unused_mut)]
    let mut scope_843 = writer.prefix("Marker");
    if let Some(var_844) = &input.marker {
        scope_843.string(var_844);
    }
    #[allow(unused_mut)]
    let mut scope_845 = writer.prefix("MaxRecords");
    if let Some(var_846) = &input.max_records {
        scope_845.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_846).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_proxy_target_groups(
    input: &crate::input::DescribeDbProxyTargetGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBProxyTargetGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_847 = writer.prefix("DBProxyName");
    if let Some(var_848) = &input.db_proxy_name {
        scope_847.string(var_848);
    }
    #[allow(unused_mut)]
    let mut scope_849 = writer.prefix("TargetGroupName");
    if let Some(var_850) = &input.target_group_name {
        scope_849.string(var_850);
    }
    #[allow(unused_mut)]
    let mut scope_851 = writer.prefix("Filters");
    if let Some(var_852) = &input.filters {
        let mut list_854 = scope_851.start_list(false, Some("Filter"));
        for item_853 in var_852 {
            #[allow(unused_mut)]
            let mut entry_855 = list_854.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_855, item_853);
        }
        list_854.finish();
    }
    #[allow(unused_mut)]
    let mut scope_856 = writer.prefix("Marker");
    if let Some(var_857) = &input.marker {
        scope_856.string(var_857);
    }
    #[allow(unused_mut)]
    let mut scope_858 = writer.prefix("MaxRecords");
    if let Some(var_859) = &input.max_records {
        scope_858.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_859).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_proxy_targets(
    input: &crate::input::DescribeDbProxyTargetsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBProxyTargets", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_860 = writer.prefix("DBProxyName");
    if let Some(var_861) = &input.db_proxy_name {
        scope_860.string(var_861);
    }
    #[allow(unused_mut)]
    let mut scope_862 = writer.prefix("TargetGroupName");
    if let Some(var_863) = &input.target_group_name {
        scope_862.string(var_863);
    }
    #[allow(unused_mut)]
    let mut scope_864 = writer.prefix("Filters");
    if let Some(var_865) = &input.filters {
        let mut list_867 = scope_864.start_list(false, Some("Filter"));
        for item_866 in var_865 {
            #[allow(unused_mut)]
            let mut entry_868 = list_867.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_868, item_866);
        }
        list_867.finish();
    }
    #[allow(unused_mut)]
    let mut scope_869 = writer.prefix("Marker");
    if let Some(var_870) = &input.marker {
        scope_869.string(var_870);
    }
    #[allow(unused_mut)]
    let mut scope_871 = writer.prefix("MaxRecords");
    if let Some(var_872) = &input.max_records {
        scope_871.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_872).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_security_groups(
    input: &crate::input::DescribeDbSecurityGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBSecurityGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_873 = writer.prefix("DBSecurityGroupName");
    if let Some(var_874) = &input.db_security_group_name {
        scope_873.string(var_874);
    }
    #[allow(unused_mut)]
    let mut scope_875 = writer.prefix("Filters");
    if let Some(var_876) = &input.filters {
        let mut list_878 = scope_875.start_list(false, Some("Filter"));
        for item_877 in var_876 {
            #[allow(unused_mut)]
            let mut entry_879 = list_878.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_879, item_877);
        }
        list_878.finish();
    }
    #[allow(unused_mut)]
    let mut scope_880 = writer.prefix("MaxRecords");
    if let Some(var_881) = &input.max_records {
        scope_880.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_881).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_882 = writer.prefix("Marker");
    if let Some(var_883) = &input.marker {
        scope_882.string(var_883);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_snapshot_attributes(
    input: &crate::input::DescribeDbSnapshotAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBSnapshotAttributes", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_884 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_885) = &input.db_snapshot_identifier {
        scope_884.string(var_885);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_snapshots(
    input: &crate::input::DescribeDbSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBSnapshots", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_886 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_887) = &input.db_instance_identifier {
        scope_886.string(var_887);
    }
    #[allow(unused_mut)]
    let mut scope_888 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_889) = &input.db_snapshot_identifier {
        scope_888.string(var_889);
    }
    #[allow(unused_mut)]
    let mut scope_890 = writer.prefix("SnapshotType");
    if let Some(var_891) = &input.snapshot_type {
        scope_890.string(var_891);
    }
    #[allow(unused_mut)]
    let mut scope_892 = writer.prefix("Filters");
    if let Some(var_893) = &input.filters {
        let mut list_895 = scope_892.start_list(false, Some("Filter"));
        for item_894 in var_893 {
            #[allow(unused_mut)]
            let mut entry_896 = list_895.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_896, item_894);
        }
        list_895.finish();
    }
    #[allow(unused_mut)]
    let mut scope_897 = writer.prefix("MaxRecords");
    if let Some(var_898) = &input.max_records {
        scope_897.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_898).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_899 = writer.prefix("Marker");
    if let Some(var_900) = &input.marker {
        scope_899.string(var_900);
    }
    #[allow(unused_mut)]
    let mut scope_901 = writer.prefix("IncludeShared");
    if input.include_shared {
        scope_901.boolean(input.include_shared);
    }
    #[allow(unused_mut)]
    let mut scope_902 = writer.prefix("IncludePublic");
    if input.include_public {
        scope_902.boolean(input.include_public);
    }
    #[allow(unused_mut)]
    let mut scope_903 = writer.prefix("DbiResourceId");
    if let Some(var_904) = &input.dbi_resource_id {
        scope_903.string(var_904);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_subnet_groups(
    input: &crate::input::DescribeDbSubnetGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBSubnetGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_905 = writer.prefix("DBSubnetGroupName");
    if let Some(var_906) = &input.db_subnet_group_name {
        scope_905.string(var_906);
    }
    #[allow(unused_mut)]
    let mut scope_907 = writer.prefix("Filters");
    if let Some(var_908) = &input.filters {
        let mut list_910 = scope_907.start_list(false, Some("Filter"));
        for item_909 in var_908 {
            #[allow(unused_mut)]
            let mut entry_911 = list_910.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_911, item_909);
        }
        list_910.finish();
    }
    #[allow(unused_mut)]
    let mut scope_912 = writer.prefix("MaxRecords");
    if let Some(var_913) = &input.max_records {
        scope_912.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_913).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_914 = writer.prefix("Marker");
    if let Some(var_915) = &input.marker {
        scope_914.string(var_915);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_engine_default_cluster_parameters(
    input: &crate::input::DescribeEngineDefaultClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeEngineDefaultClusterParameters",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_916 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_917) = &input.db_parameter_group_family {
        scope_916.string(var_917);
    }
    #[allow(unused_mut)]
    let mut scope_918 = writer.prefix("Filters");
    if let Some(var_919) = &input.filters {
        let mut list_921 = scope_918.start_list(false, Some("Filter"));
        for item_920 in var_919 {
            #[allow(unused_mut)]
            let mut entry_922 = list_921.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_922, item_920);
        }
        list_921.finish();
    }
    #[allow(unused_mut)]
    let mut scope_923 = writer.prefix("MaxRecords");
    if let Some(var_924) = &input.max_records {
        scope_923.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_924).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_925 = writer.prefix("Marker");
    if let Some(var_926) = &input.marker {
        scope_925.string(var_926);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_engine_default_parameters(
    input: &crate::input::DescribeEngineDefaultParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEngineDefaultParameters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_927 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_928) = &input.db_parameter_group_family {
        scope_927.string(var_928);
    }
    #[allow(unused_mut)]
    let mut scope_929 = writer.prefix("Filters");
    if let Some(var_930) = &input.filters {
        let mut list_932 = scope_929.start_list(false, Some("Filter"));
        for item_931 in var_930 {
            #[allow(unused_mut)]
            let mut entry_933 = list_932.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_933, item_931);
        }
        list_932.finish();
    }
    #[allow(unused_mut)]
    let mut scope_934 = writer.prefix("MaxRecords");
    if let Some(var_935) = &input.max_records {
        scope_934.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_935).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_936 = writer.prefix("Marker");
    if let Some(var_937) = &input.marker {
        scope_936.string(var_937);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_categories(
    input: &crate::input::DescribeEventCategoriesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventCategories", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_938 = writer.prefix("SourceType");
    if let Some(var_939) = &input.source_type {
        scope_938.string(var_939);
    }
    #[allow(unused_mut)]
    let mut scope_940 = writer.prefix("Filters");
    if let Some(var_941) = &input.filters {
        let mut list_943 = scope_940.start_list(false, Some("Filter"));
        for item_942 in var_941 {
            #[allow(unused_mut)]
            let mut entry_944 = list_943.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_944, item_942);
        }
        list_943.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_events(
    input: &crate::input::DescribeEventsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeEvents", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_945 = writer.prefix("SourceIdentifier");
    if let Some(var_946) = &input.source_identifier {
        scope_945.string(var_946);
    }
    #[allow(unused_mut)]
    let mut scope_947 = writer.prefix("SourceType");
    if let Some(var_948) = &input.source_type {
        scope_947.string(var_948.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_949 = writer.prefix("StartTime");
    if let Some(var_950) = &input.start_time {
        scope_949.instant(var_950, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_951 = writer.prefix("EndTime");
    if let Some(var_952) = &input.end_time {
        scope_951.instant(var_952, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_953 = writer.prefix("Duration");
    if let Some(var_954) = &input.duration {
        scope_953.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_954).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_955 = writer.prefix("EventCategories");
    if let Some(var_956) = &input.event_categories {
        let mut list_958 = scope_955.start_list(false, Some("EventCategory"));
        for item_957 in var_956 {
            #[allow(unused_mut)]
            let mut entry_959 = list_958.entry();
            entry_959.string(item_957);
        }
        list_958.finish();
    }
    #[allow(unused_mut)]
    let mut scope_960 = writer.prefix("Filters");
    if let Some(var_961) = &input.filters {
        let mut list_963 = scope_960.start_list(false, Some("Filter"));
        for item_962 in var_961 {
            #[allow(unused_mut)]
            let mut entry_964 = list_963.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_964, item_962);
        }
        list_963.finish();
    }
    #[allow(unused_mut)]
    let mut scope_965 = writer.prefix("MaxRecords");
    if let Some(var_966) = &input.max_records {
        scope_965.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_966).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_967 = writer.prefix("Marker");
    if let Some(var_968) = &input.marker {
        scope_967.string(var_968);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_subscriptions(
    input: &crate::input::DescribeEventSubscriptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventSubscriptions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_969 = writer.prefix("SubscriptionName");
    if let Some(var_970) = &input.subscription_name {
        scope_969.string(var_970);
    }
    #[allow(unused_mut)]
    let mut scope_971 = writer.prefix("Filters");
    if let Some(var_972) = &input.filters {
        let mut list_974 = scope_971.start_list(false, Some("Filter"));
        for item_973 in var_972 {
            #[allow(unused_mut)]
            let mut entry_975 = list_974.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_975, item_973);
        }
        list_974.finish();
    }
    #[allow(unused_mut)]
    let mut scope_976 = writer.prefix("MaxRecords");
    if let Some(var_977) = &input.max_records {
        scope_976.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_977).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_978 = writer.prefix("Marker");
    if let Some(var_979) = &input.marker {
        scope_978.string(var_979);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_export_tasks(
    input: &crate::input::DescribeExportTasksInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeExportTasks", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_980 = writer.prefix("ExportTaskIdentifier");
    if let Some(var_981) = &input.export_task_identifier {
        scope_980.string(var_981);
    }
    #[allow(unused_mut)]
    let mut scope_982 = writer.prefix("SourceArn");
    if let Some(var_983) = &input.source_arn {
        scope_982.string(var_983);
    }
    #[allow(unused_mut)]
    let mut scope_984 = writer.prefix("Filters");
    if let Some(var_985) = &input.filters {
        let mut list_987 = scope_984.start_list(false, Some("Filter"));
        for item_986 in var_985 {
            #[allow(unused_mut)]
            let mut entry_988 = list_987.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_988, item_986);
        }
        list_987.finish();
    }
    #[allow(unused_mut)]
    let mut scope_989 = writer.prefix("Marker");
    if let Some(var_990) = &input.marker {
        scope_989.string(var_990);
    }
    #[allow(unused_mut)]
    let mut scope_991 = writer.prefix("MaxRecords");
    if let Some(var_992) = &input.max_records {
        scope_991.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_992).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_global_clusters(
    input: &crate::input::DescribeGlobalClustersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeGlobalClusters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_993 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_994) = &input.global_cluster_identifier {
        scope_993.string(var_994);
    }
    #[allow(unused_mut)]
    let mut scope_995 = writer.prefix("Filters");
    if let Some(var_996) = &input.filters {
        let mut list_998 = scope_995.start_list(false, Some("Filter"));
        for item_997 in var_996 {
            #[allow(unused_mut)]
            let mut entry_999 = list_998.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_999, item_997);
        }
        list_998.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1000 = writer.prefix("MaxRecords");
    if let Some(var_1001) = &input.max_records {
        scope_1000.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1001).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1002 = writer.prefix("Marker");
    if let Some(var_1003) = &input.marker {
        scope_1002.string(var_1003);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_installation_media(
    input: &crate::input::DescribeInstallationMediaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeInstallationMedia", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1004 = writer.prefix("InstallationMediaId");
    if let Some(var_1005) = &input.installation_media_id {
        scope_1004.string(var_1005);
    }
    #[allow(unused_mut)]
    let mut scope_1006 = writer.prefix("Filters");
    if let Some(var_1007) = &input.filters {
        let mut list_1009 = scope_1006.start_list(false, Some("Filter"));
        for item_1008 in var_1007 {
            #[allow(unused_mut)]
            let mut entry_1010 = list_1009.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1010, item_1008);
        }
        list_1009.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1011 = writer.prefix("MaxRecords");
    if let Some(var_1012) = &input.max_records {
        scope_1011.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1012).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1013 = writer.prefix("Marker");
    if let Some(var_1014) = &input.marker {
        scope_1013.string(var_1014);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_option_group_options(
    input: &crate::input::DescribeOptionGroupOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeOptionGroupOptions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1015 = writer.prefix("EngineName");
    if let Some(var_1016) = &input.engine_name {
        scope_1015.string(var_1016);
    }
    #[allow(unused_mut)]
    let mut scope_1017 = writer.prefix("MajorEngineVersion");
    if let Some(var_1018) = &input.major_engine_version {
        scope_1017.string(var_1018);
    }
    #[allow(unused_mut)]
    let mut scope_1019 = writer.prefix("Filters");
    if let Some(var_1020) = &input.filters {
        let mut list_1022 = scope_1019.start_list(false, Some("Filter"));
        for item_1021 in var_1020 {
            #[allow(unused_mut)]
            let mut entry_1023 = list_1022.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1023, item_1021);
        }
        list_1022.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1024 = writer.prefix("MaxRecords");
    if let Some(var_1025) = &input.max_records {
        scope_1024.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1025).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1026 = writer.prefix("Marker");
    if let Some(var_1027) = &input.marker {
        scope_1026.string(var_1027);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_option_groups(
    input: &crate::input::DescribeOptionGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeOptionGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1028 = writer.prefix("OptionGroupName");
    if let Some(var_1029) = &input.option_group_name {
        scope_1028.string(var_1029);
    }
    #[allow(unused_mut)]
    let mut scope_1030 = writer.prefix("Filters");
    if let Some(var_1031) = &input.filters {
        let mut list_1033 = scope_1030.start_list(false, Some("Filter"));
        for item_1032 in var_1031 {
            #[allow(unused_mut)]
            let mut entry_1034 = list_1033.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1034, item_1032);
        }
        list_1033.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1035 = writer.prefix("Marker");
    if let Some(var_1036) = &input.marker {
        scope_1035.string(var_1036);
    }
    #[allow(unused_mut)]
    let mut scope_1037 = writer.prefix("MaxRecords");
    if let Some(var_1038) = &input.max_records {
        scope_1037.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1038).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1039 = writer.prefix("EngineName");
    if let Some(var_1040) = &input.engine_name {
        scope_1039.string(var_1040);
    }
    #[allow(unused_mut)]
    let mut scope_1041 = writer.prefix("MajorEngineVersion");
    if let Some(var_1042) = &input.major_engine_version {
        scope_1041.string(var_1042);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_orderable_db_instance_options(
    input: &crate::input::DescribeOrderableDbInstanceOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeOrderableDBInstanceOptions",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_1043 = writer.prefix("Engine");
    if let Some(var_1044) = &input.engine {
        scope_1043.string(var_1044);
    }
    #[allow(unused_mut)]
    let mut scope_1045 = writer.prefix("EngineVersion");
    if let Some(var_1046) = &input.engine_version {
        scope_1045.string(var_1046);
    }
    #[allow(unused_mut)]
    let mut scope_1047 = writer.prefix("DBInstanceClass");
    if let Some(var_1048) = &input.db_instance_class {
        scope_1047.string(var_1048);
    }
    #[allow(unused_mut)]
    let mut scope_1049 = writer.prefix("LicenseModel");
    if let Some(var_1050) = &input.license_model {
        scope_1049.string(var_1050);
    }
    #[allow(unused_mut)]
    let mut scope_1051 = writer.prefix("AvailabilityZoneGroup");
    if let Some(var_1052) = &input.availability_zone_group {
        scope_1051.string(var_1052);
    }
    #[allow(unused_mut)]
    let mut scope_1053 = writer.prefix("Vpc");
    if let Some(var_1054) = &input.vpc {
        scope_1053.boolean(*var_1054);
    }
    #[allow(unused_mut)]
    let mut scope_1055 = writer.prefix("Filters");
    if let Some(var_1056) = &input.filters {
        let mut list_1058 = scope_1055.start_list(false, Some("Filter"));
        for item_1057 in var_1056 {
            #[allow(unused_mut)]
            let mut entry_1059 = list_1058.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1059, item_1057);
        }
        list_1058.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1060 = writer.prefix("MaxRecords");
    if let Some(var_1061) = &input.max_records {
        scope_1060.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1061).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1062 = writer.prefix("Marker");
    if let Some(var_1063) = &input.marker {
        scope_1062.string(var_1063);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_pending_maintenance_actions(
    input: &crate::input::DescribePendingMaintenanceActionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribePendingMaintenanceActions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1064 = writer.prefix("ResourceIdentifier");
    if let Some(var_1065) = &input.resource_identifier {
        scope_1064.string(var_1065);
    }
    #[allow(unused_mut)]
    let mut scope_1066 = writer.prefix("Filters");
    if let Some(var_1067) = &input.filters {
        let mut list_1069 = scope_1066.start_list(false, Some("Filter"));
        for item_1068 in var_1067 {
            #[allow(unused_mut)]
            let mut entry_1070 = list_1069.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1070, item_1068);
        }
        list_1069.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1071 = writer.prefix("Marker");
    if let Some(var_1072) = &input.marker {
        scope_1071.string(var_1072);
    }
    #[allow(unused_mut)]
    let mut scope_1073 = writer.prefix("MaxRecords");
    if let Some(var_1074) = &input.max_records {
        scope_1073.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1074).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_reserved_db_instances(
    input: &crate::input::DescribeReservedDbInstancesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeReservedDBInstances", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1075 = writer.prefix("ReservedDBInstanceId");
    if let Some(var_1076) = &input.reserved_db_instance_id {
        scope_1075.string(var_1076);
    }
    #[allow(unused_mut)]
    let mut scope_1077 = writer.prefix("ReservedDBInstancesOfferingId");
    if let Some(var_1078) = &input.reserved_db_instances_offering_id {
        scope_1077.string(var_1078);
    }
    #[allow(unused_mut)]
    let mut scope_1079 = writer.prefix("DBInstanceClass");
    if let Some(var_1080) = &input.db_instance_class {
        scope_1079.string(var_1080);
    }
    #[allow(unused_mut)]
    let mut scope_1081 = writer.prefix("Duration");
    if let Some(var_1082) = &input.duration {
        scope_1081.string(var_1082);
    }
    #[allow(unused_mut)]
    let mut scope_1083 = writer.prefix("ProductDescription");
    if let Some(var_1084) = &input.product_description {
        scope_1083.string(var_1084);
    }
    #[allow(unused_mut)]
    let mut scope_1085 = writer.prefix("OfferingType");
    if let Some(var_1086) = &input.offering_type {
        scope_1085.string(var_1086);
    }
    #[allow(unused_mut)]
    let mut scope_1087 = writer.prefix("MultiAZ");
    if let Some(var_1088) = &input.multi_az {
        scope_1087.boolean(*var_1088);
    }
    #[allow(unused_mut)]
    let mut scope_1089 = writer.prefix("LeaseId");
    if let Some(var_1090) = &input.lease_id {
        scope_1089.string(var_1090);
    }
    #[allow(unused_mut)]
    let mut scope_1091 = writer.prefix("Filters");
    if let Some(var_1092) = &input.filters {
        let mut list_1094 = scope_1091.start_list(false, Some("Filter"));
        for item_1093 in var_1092 {
            #[allow(unused_mut)]
            let mut entry_1095 = list_1094.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1095, item_1093);
        }
        list_1094.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1096 = writer.prefix("MaxRecords");
    if let Some(var_1097) = &input.max_records {
        scope_1096.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1097).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1098 = writer.prefix("Marker");
    if let Some(var_1099) = &input.marker {
        scope_1098.string(var_1099);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_reserved_db_instances_offerings(
    input: &crate::input::DescribeReservedDbInstancesOfferingsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeReservedDBInstancesOfferings",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_1100 = writer.prefix("ReservedDBInstancesOfferingId");
    if let Some(var_1101) = &input.reserved_db_instances_offering_id {
        scope_1100.string(var_1101);
    }
    #[allow(unused_mut)]
    let mut scope_1102 = writer.prefix("DBInstanceClass");
    if let Some(var_1103) = &input.db_instance_class {
        scope_1102.string(var_1103);
    }
    #[allow(unused_mut)]
    let mut scope_1104 = writer.prefix("Duration");
    if let Some(var_1105) = &input.duration {
        scope_1104.string(var_1105);
    }
    #[allow(unused_mut)]
    let mut scope_1106 = writer.prefix("ProductDescription");
    if let Some(var_1107) = &input.product_description {
        scope_1106.string(var_1107);
    }
    #[allow(unused_mut)]
    let mut scope_1108 = writer.prefix("OfferingType");
    if let Some(var_1109) = &input.offering_type {
        scope_1108.string(var_1109);
    }
    #[allow(unused_mut)]
    let mut scope_1110 = writer.prefix("MultiAZ");
    if let Some(var_1111) = &input.multi_az {
        scope_1110.boolean(*var_1111);
    }
    #[allow(unused_mut)]
    let mut scope_1112 = writer.prefix("Filters");
    if let Some(var_1113) = &input.filters {
        let mut list_1115 = scope_1112.start_list(false, Some("Filter"));
        for item_1114 in var_1113 {
            #[allow(unused_mut)]
            let mut entry_1116 = list_1115.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1116, item_1114);
        }
        list_1115.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1117 = writer.prefix("MaxRecords");
    if let Some(var_1118) = &input.max_records {
        scope_1117.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1118).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1119 = writer.prefix("Marker");
    if let Some(var_1120) = &input.marker {
        scope_1119.string(var_1120);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_source_regions(
    input: &crate::input::DescribeSourceRegionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeSourceRegions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1121 = writer.prefix("RegionName");
    if let Some(var_1122) = &input.region_name {
        scope_1121.string(var_1122);
    }
    #[allow(unused_mut)]
    let mut scope_1123 = writer.prefix("MaxRecords");
    if let Some(var_1124) = &input.max_records {
        scope_1123.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1124).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1125 = writer.prefix("Marker");
    if let Some(var_1126) = &input.marker {
        scope_1125.string(var_1126);
    }
    #[allow(unused_mut)]
    let mut scope_1127 = writer.prefix("Filters");
    if let Some(var_1128) = &input.filters {
        let mut list_1130 = scope_1127.start_list(false, Some("Filter"));
        for item_1129 in var_1128 {
            #[allow(unused_mut)]
            let mut entry_1131 = list_1130.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1131, item_1129);
        }
        list_1130.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_valid_db_instance_modifications(
    input: &crate::input::DescribeValidDbInstanceModificationsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeValidDBInstanceModifications",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_1132 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1133) = &input.db_instance_identifier {
        scope_1132.string(var_1133);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_download_db_log_file_portion(
    input: &crate::input::DownloadDbLogFilePortionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DownloadDBLogFilePortion", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1134 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1135) = &input.db_instance_identifier {
        scope_1134.string(var_1135);
    }
    #[allow(unused_mut)]
    let mut scope_1136 = writer.prefix("LogFileName");
    if let Some(var_1137) = &input.log_file_name {
        scope_1136.string(var_1137);
    }
    #[allow(unused_mut)]
    let mut scope_1138 = writer.prefix("Marker");
    if let Some(var_1139) = &input.marker {
        scope_1138.string(var_1139);
    }
    #[allow(unused_mut)]
    let mut scope_1140 = writer.prefix("NumberOfLines");
    if input.number_of_lines != 0 {
        scope_1140.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.number_of_lines).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_failover_db_cluster(
    input: &crate::input::FailoverDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "FailoverDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1141 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1142) = &input.db_cluster_identifier {
        scope_1141.string(var_1142);
    }
    #[allow(unused_mut)]
    let mut scope_1143 = writer.prefix("TargetDBInstanceIdentifier");
    if let Some(var_1144) = &input.target_db_instance_identifier {
        scope_1143.string(var_1144);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_failover_global_cluster(
    input: &crate::input::FailoverGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "FailoverGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1145 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_1146) = &input.global_cluster_identifier {
        scope_1145.string(var_1146);
    }
    #[allow(unused_mut)]
    let mut scope_1147 = writer.prefix("TargetDbClusterIdentifier");
    if let Some(var_1148) = &input.target_db_cluster_identifier {
        scope_1147.string(var_1148);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_import_installation_media(
    input: &crate::input::ImportInstallationMediaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ImportInstallationMedia", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1149 = writer.prefix("CustomAvailabilityZoneId");
    if let Some(var_1150) = &input.custom_availability_zone_id {
        scope_1149.string(var_1150);
    }
    #[allow(unused_mut)]
    let mut scope_1151 = writer.prefix("Engine");
    if let Some(var_1152) = &input.engine {
        scope_1151.string(var_1152);
    }
    #[allow(unused_mut)]
    let mut scope_1153 = writer.prefix("EngineVersion");
    if let Some(var_1154) = &input.engine_version {
        scope_1153.string(var_1154);
    }
    #[allow(unused_mut)]
    let mut scope_1155 = writer.prefix("EngineInstallationMediaPath");
    if let Some(var_1156) = &input.engine_installation_media_path {
        scope_1155.string(var_1156);
    }
    #[allow(unused_mut)]
    let mut scope_1157 = writer.prefix("OSInstallationMediaPath");
    if let Some(var_1158) = &input.os_installation_media_path {
        scope_1157.string(var_1158);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_tags_for_resource(
    input: &crate::input::ListTagsForResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListTagsForResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1159 = writer.prefix("ResourceName");
    if let Some(var_1160) = &input.resource_name {
        scope_1159.string(var_1160);
    }
    #[allow(unused_mut)]
    let mut scope_1161 = writer.prefix("Filters");
    if let Some(var_1162) = &input.filters {
        let mut list_1164 = scope_1161.start_list(false, Some("Filter"));
        for item_1163 in var_1162 {
            #[allow(unused_mut)]
            let mut entry_1165 = list_1164.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_1165, item_1163);
        }
        list_1164.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_certificates(
    input: &crate::input::ModifyCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyCertificates", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1166 = writer.prefix("CertificateIdentifier");
    if let Some(var_1167) = &input.certificate_identifier {
        scope_1166.string(var_1167);
    }
    #[allow(unused_mut)]
    let mut scope_1168 = writer.prefix("RemoveCustomerOverride");
    if let Some(var_1169) = &input.remove_customer_override {
        scope_1168.boolean(*var_1169);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_current_db_cluster_capacity(
    input: &crate::input::ModifyCurrentDbClusterCapacityInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyCurrentDBClusterCapacity", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1170 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1171) = &input.db_cluster_identifier {
        scope_1170.string(var_1171);
    }
    #[allow(unused_mut)]
    let mut scope_1172 = writer.prefix("Capacity");
    if let Some(var_1173) = &input.capacity {
        scope_1172.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1173).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1174 = writer.prefix("SecondsBeforeTimeout");
    if let Some(var_1175) = &input.seconds_before_timeout {
        scope_1174.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1175).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1176 = writer.prefix("TimeoutAction");
    if let Some(var_1177) = &input.timeout_action {
        scope_1176.string(var_1177);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster(
    input: &crate::input::ModifyDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1178 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1179) = &input.db_cluster_identifier {
        scope_1178.string(var_1179);
    }
    #[allow(unused_mut)]
    let mut scope_1180 = writer.prefix("NewDBClusterIdentifier");
    if let Some(var_1181) = &input.new_db_cluster_identifier {
        scope_1180.string(var_1181);
    }
    #[allow(unused_mut)]
    let mut scope_1182 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_1182.boolean(input.apply_immediately);
    }
    #[allow(unused_mut)]
    let mut scope_1183 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_1184) = &input.backup_retention_period {
        scope_1183.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1184).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1185 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1186) = &input.db_cluster_parameter_group_name {
        scope_1185.string(var_1186);
    }
    #[allow(unused_mut)]
    let mut scope_1187 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1188) = &input.vpc_security_group_ids {
        let mut list_1190 = scope_1187.start_list(false, Some("VpcSecurityGroupId"));
        for item_1189 in var_1188 {
            #[allow(unused_mut)]
            let mut entry_1191 = list_1190.entry();
            entry_1191.string(item_1189);
        }
        list_1190.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1192 = writer.prefix("Port");
    if let Some(var_1193) = &input.port {
        scope_1192.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1193).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1194 = writer.prefix("MasterUserPassword");
    if let Some(var_1195) = &input.master_user_password {
        scope_1194.string(var_1195);
    }
    #[allow(unused_mut)]
    let mut scope_1196 = writer.prefix("OptionGroupName");
    if let Some(var_1197) = &input.option_group_name {
        scope_1196.string(var_1197);
    }
    #[allow(unused_mut)]
    let mut scope_1198 = writer.prefix("PreferredBackupWindow");
    if let Some(var_1199) = &input.preferred_backup_window {
        scope_1198.string(var_1199);
    }
    #[allow(unused_mut)]
    let mut scope_1200 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_1201) = &input.preferred_maintenance_window {
        scope_1200.string(var_1201);
    }
    #[allow(unused_mut)]
    let mut scope_1202 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1203) = &input.enable_iam_database_authentication {
        scope_1202.boolean(*var_1203);
    }
    #[allow(unused_mut)]
    let mut scope_1204 = writer.prefix("BacktrackWindow");
    if let Some(var_1205) = &input.backtrack_window {
        scope_1204.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1205).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1206 = writer.prefix("CloudwatchLogsExportConfiguration");
    if let Some(var_1207) = &input.cloudwatch_logs_export_configuration {
        crate::query_ser::serialize_structure_crate_model_cloudwatch_logs_export_configuration(
            scope_1206, var_1207,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1208 = writer.prefix("EngineVersion");
    if let Some(var_1209) = &input.engine_version {
        scope_1208.string(var_1209);
    }
    #[allow(unused_mut)]
    let mut scope_1210 = writer.prefix("AllowMajorVersionUpgrade");
    if input.allow_major_version_upgrade {
        scope_1210.boolean(input.allow_major_version_upgrade);
    }
    #[allow(unused_mut)]
    let mut scope_1211 = writer.prefix("DBInstanceParameterGroupName");
    if let Some(var_1212) = &input.db_instance_parameter_group_name {
        scope_1211.string(var_1212);
    }
    #[allow(unused_mut)]
    let mut scope_1213 = writer.prefix("Domain");
    if let Some(var_1214) = &input.domain {
        scope_1213.string(var_1214);
    }
    #[allow(unused_mut)]
    let mut scope_1215 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1216) = &input.domain_iam_role_name {
        scope_1215.string(var_1216);
    }
    #[allow(unused_mut)]
    let mut scope_1217 = writer.prefix("ScalingConfiguration");
    if let Some(var_1218) = &input.scaling_configuration {
        crate::query_ser::serialize_structure_crate_model_scaling_configuration(
            scope_1217, var_1218,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1219 = writer.prefix("DeletionProtection");
    if let Some(var_1220) = &input.deletion_protection {
        scope_1219.boolean(*var_1220);
    }
    #[allow(unused_mut)]
    let mut scope_1221 = writer.prefix("EnableHttpEndpoint");
    if let Some(var_1222) = &input.enable_http_endpoint {
        scope_1221.boolean(*var_1222);
    }
    #[allow(unused_mut)]
    let mut scope_1223 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1224) = &input.copy_tags_to_snapshot {
        scope_1223.boolean(*var_1224);
    }
    #[allow(unused_mut)]
    let mut scope_1225 = writer.prefix("EnableGlobalWriteForwarding");
    if let Some(var_1226) = &input.enable_global_write_forwarding {
        scope_1225.boolean(*var_1226);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster_endpoint(
    input: &crate::input::ModifyDbClusterEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBClusterEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1227 = writer.prefix("DBClusterEndpointIdentifier");
    if let Some(var_1228) = &input.db_cluster_endpoint_identifier {
        scope_1227.string(var_1228);
    }
    #[allow(unused_mut)]
    let mut scope_1229 = writer.prefix("EndpointType");
    if let Some(var_1230) = &input.endpoint_type {
        scope_1229.string(var_1230);
    }
    #[allow(unused_mut)]
    let mut scope_1231 = writer.prefix("StaticMembers");
    if let Some(var_1232) = &input.static_members {
        let mut list_1234 = scope_1231.start_list(false, None);
        for item_1233 in var_1232 {
            #[allow(unused_mut)]
            let mut entry_1235 = list_1234.entry();
            entry_1235.string(item_1233);
        }
        list_1234.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1236 = writer.prefix("ExcludedMembers");
    if let Some(var_1237) = &input.excluded_members {
        let mut list_1239 = scope_1236.start_list(false, None);
        for item_1238 in var_1237 {
            #[allow(unused_mut)]
            let mut entry_1240 = list_1239.entry();
            entry_1240.string(item_1238);
        }
        list_1239.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster_parameter_group(
    input: &crate::input::ModifyDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1241 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1242) = &input.db_cluster_parameter_group_name {
        scope_1241.string(var_1242);
    }
    #[allow(unused_mut)]
    let mut scope_1243 = writer.prefix("Parameters");
    if let Some(var_1244) = &input.parameters {
        let mut list_1246 = scope_1243.start_list(false, Some("Parameter"));
        for item_1245 in var_1244 {
            #[allow(unused_mut)]
            let mut entry_1247 = list_1246.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_1247, item_1245);
        }
        list_1246.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster_snapshot_attribute(
    input: &crate::input::ModifyDbClusterSnapshotAttributeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBClusterSnapshotAttribute", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1248 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_1249) = &input.db_cluster_snapshot_identifier {
        scope_1248.string(var_1249);
    }
    #[allow(unused_mut)]
    let mut scope_1250 = writer.prefix("AttributeName");
    if let Some(var_1251) = &input.attribute_name {
        scope_1250.string(var_1251);
    }
    #[allow(unused_mut)]
    let mut scope_1252 = writer.prefix("ValuesToAdd");
    if let Some(var_1253) = &input.values_to_add {
        let mut list_1255 = scope_1252.start_list(false, Some("AttributeValue"));
        for item_1254 in var_1253 {
            #[allow(unused_mut)]
            let mut entry_1256 = list_1255.entry();
            entry_1256.string(item_1254);
        }
        list_1255.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1257 = writer.prefix("ValuesToRemove");
    if let Some(var_1258) = &input.values_to_remove {
        let mut list_1260 = scope_1257.start_list(false, Some("AttributeValue"));
        for item_1259 in var_1258 {
            #[allow(unused_mut)]
            let mut entry_1261 = list_1260.entry();
            entry_1261.string(item_1259);
        }
        list_1260.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_instance(
    input: &crate::input::ModifyDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1262 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1263) = &input.db_instance_identifier {
        scope_1262.string(var_1263);
    }
    #[allow(unused_mut)]
    let mut scope_1264 = writer.prefix("AllocatedStorage");
    if let Some(var_1265) = &input.allocated_storage {
        scope_1264.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1265).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1266 = writer.prefix("DBInstanceClass");
    if let Some(var_1267) = &input.db_instance_class {
        scope_1266.string(var_1267);
    }
    #[allow(unused_mut)]
    let mut scope_1268 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1269) = &input.db_subnet_group_name {
        scope_1268.string(var_1269);
    }
    #[allow(unused_mut)]
    let mut scope_1270 = writer.prefix("DBSecurityGroups");
    if let Some(var_1271) = &input.db_security_groups {
        let mut list_1273 = scope_1270.start_list(false, Some("DBSecurityGroupName"));
        for item_1272 in var_1271 {
            #[allow(unused_mut)]
            let mut entry_1274 = list_1273.entry();
            entry_1274.string(item_1272);
        }
        list_1273.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1275 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1276) = &input.vpc_security_group_ids {
        let mut list_1278 = scope_1275.start_list(false, Some("VpcSecurityGroupId"));
        for item_1277 in var_1276 {
            #[allow(unused_mut)]
            let mut entry_1279 = list_1278.entry();
            entry_1279.string(item_1277);
        }
        list_1278.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1280 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_1280.boolean(input.apply_immediately);
    }
    #[allow(unused_mut)]
    let mut scope_1281 = writer.prefix("MasterUserPassword");
    if let Some(var_1282) = &input.master_user_password {
        scope_1281.string(var_1282);
    }
    #[allow(unused_mut)]
    let mut scope_1283 = writer.prefix("DBParameterGroupName");
    if let Some(var_1284) = &input.db_parameter_group_name {
        scope_1283.string(var_1284);
    }
    #[allow(unused_mut)]
    let mut scope_1285 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_1286) = &input.backup_retention_period {
        scope_1285.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1286).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1287 = writer.prefix("PreferredBackupWindow");
    if let Some(var_1288) = &input.preferred_backup_window {
        scope_1287.string(var_1288);
    }
    #[allow(unused_mut)]
    let mut scope_1289 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_1290) = &input.preferred_maintenance_window {
        scope_1289.string(var_1290);
    }
    #[allow(unused_mut)]
    let mut scope_1291 = writer.prefix("MultiAZ");
    if let Some(var_1292) = &input.multi_az {
        scope_1291.boolean(*var_1292);
    }
    #[allow(unused_mut)]
    let mut scope_1293 = writer.prefix("EngineVersion");
    if let Some(var_1294) = &input.engine_version {
        scope_1293.string(var_1294);
    }
    #[allow(unused_mut)]
    let mut scope_1295 = writer.prefix("AllowMajorVersionUpgrade");
    if input.allow_major_version_upgrade {
        scope_1295.boolean(input.allow_major_version_upgrade);
    }
    #[allow(unused_mut)]
    let mut scope_1296 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_1297) = &input.auto_minor_version_upgrade {
        scope_1296.boolean(*var_1297);
    }
    #[allow(unused_mut)]
    let mut scope_1298 = writer.prefix("LicenseModel");
    if let Some(var_1299) = &input.license_model {
        scope_1298.string(var_1299);
    }
    #[allow(unused_mut)]
    let mut scope_1300 = writer.prefix("Iops");
    if let Some(var_1301) = &input.iops {
        scope_1300.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1301).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1302 = writer.prefix("OptionGroupName");
    if let Some(var_1303) = &input.option_group_name {
        scope_1302.string(var_1303);
    }
    #[allow(unused_mut)]
    let mut scope_1304 = writer.prefix("NewDBInstanceIdentifier");
    if let Some(var_1305) = &input.new_db_instance_identifier {
        scope_1304.string(var_1305);
    }
    #[allow(unused_mut)]
    let mut scope_1306 = writer.prefix("StorageType");
    if let Some(var_1307) = &input.storage_type {
        scope_1306.string(var_1307);
    }
    #[allow(unused_mut)]
    let mut scope_1308 = writer.prefix("TdeCredentialArn");
    if let Some(var_1309) = &input.tde_credential_arn {
        scope_1308.string(var_1309);
    }
    #[allow(unused_mut)]
    let mut scope_1310 = writer.prefix("TdeCredentialPassword");
    if let Some(var_1311) = &input.tde_credential_password {
        scope_1310.string(var_1311);
    }
    #[allow(unused_mut)]
    let mut scope_1312 = writer.prefix("CACertificateIdentifier");
    if let Some(var_1313) = &input.ca_certificate_identifier {
        scope_1312.string(var_1313);
    }
    #[allow(unused_mut)]
    let mut scope_1314 = writer.prefix("Domain");
    if let Some(var_1315) = &input.domain {
        scope_1314.string(var_1315);
    }
    #[allow(unused_mut)]
    let mut scope_1316 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1317) = &input.copy_tags_to_snapshot {
        scope_1316.boolean(*var_1317);
    }
    #[allow(unused_mut)]
    let mut scope_1318 = writer.prefix("MonitoringInterval");
    if let Some(var_1319) = &input.monitoring_interval {
        scope_1318.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1319).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1320 = writer.prefix("DBPortNumber");
    if let Some(var_1321) = &input.db_port_number {
        scope_1320.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1321).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1322 = writer.prefix("PubliclyAccessible");
    if let Some(var_1323) = &input.publicly_accessible {
        scope_1322.boolean(*var_1323);
    }
    #[allow(unused_mut)]
    let mut scope_1324 = writer.prefix("MonitoringRoleArn");
    if let Some(var_1325) = &input.monitoring_role_arn {
        scope_1324.string(var_1325);
    }
    #[allow(unused_mut)]
    let mut scope_1326 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1327) = &input.domain_iam_role_name {
        scope_1326.string(var_1327);
    }
    #[allow(unused_mut)]
    let mut scope_1328 = writer.prefix("PromotionTier");
    if let Some(var_1329) = &input.promotion_tier {
        scope_1328.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1329).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1330 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1331) = &input.enable_iam_database_authentication {
        scope_1330.boolean(*var_1331);
    }
    #[allow(unused_mut)]
    let mut scope_1332 = writer.prefix("EnablePerformanceInsights");
    if let Some(var_1333) = &input.enable_performance_insights {
        scope_1332.boolean(*var_1333);
    }
    #[allow(unused_mut)]
    let mut scope_1334 = writer.prefix("PerformanceInsightsKMSKeyId");
    if let Some(var_1335) = &input.performance_insights_kms_key_id {
        scope_1334.string(var_1335);
    }
    #[allow(unused_mut)]
    let mut scope_1336 = writer.prefix("PerformanceInsightsRetentionPeriod");
    if let Some(var_1337) = &input.performance_insights_retention_period {
        scope_1336.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1337).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1338 = writer.prefix("CloudwatchLogsExportConfiguration");
    if let Some(var_1339) = &input.cloudwatch_logs_export_configuration {
        crate::query_ser::serialize_structure_crate_model_cloudwatch_logs_export_configuration(
            scope_1338, var_1339,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1340 = writer.prefix("ProcessorFeatures");
    if let Some(var_1341) = &input.processor_features {
        let mut list_1343 = scope_1340.start_list(false, Some("ProcessorFeature"));
        for item_1342 in var_1341 {
            #[allow(unused_mut)]
            let mut entry_1344 = list_1343.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_1344, item_1342,
            );
        }
        list_1343.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1345 = writer.prefix("UseDefaultProcessorFeatures");
    if let Some(var_1346) = &input.use_default_processor_features {
        scope_1345.boolean(*var_1346);
    }
    #[allow(unused_mut)]
    let mut scope_1347 = writer.prefix("DeletionProtection");
    if let Some(var_1348) = &input.deletion_protection {
        scope_1347.boolean(*var_1348);
    }
    #[allow(unused_mut)]
    let mut scope_1349 = writer.prefix("MaxAllocatedStorage");
    if let Some(var_1350) = &input.max_allocated_storage {
        scope_1349.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1350).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1351 = writer.prefix("CertificateRotationRestart");
    if let Some(var_1352) = &input.certificate_rotation_restart {
        scope_1351.boolean(*var_1352);
    }
    #[allow(unused_mut)]
    let mut scope_1353 = writer.prefix("ReplicaMode");
    if let Some(var_1354) = &input.replica_mode {
        scope_1353.string(var_1354.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_1355 = writer.prefix("EnableCustomerOwnedIp");
    if let Some(var_1356) = &input.enable_customer_owned_ip {
        scope_1355.boolean(*var_1356);
    }
    #[allow(unused_mut)]
    let mut scope_1357 = writer.prefix("AwsBackupRecoveryPointArn");
    if let Some(var_1358) = &input.aws_backup_recovery_point_arn {
        scope_1357.string(var_1358);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_parameter_group(
    input: &crate::input::ModifyDbParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1359 = writer.prefix("DBParameterGroupName");
    if let Some(var_1360) = &input.db_parameter_group_name {
        scope_1359.string(var_1360);
    }
    #[allow(unused_mut)]
    let mut scope_1361 = writer.prefix("Parameters");
    if let Some(var_1362) = &input.parameters {
        let mut list_1364 = scope_1361.start_list(false, Some("Parameter"));
        for item_1363 in var_1362 {
            #[allow(unused_mut)]
            let mut entry_1365 = list_1364.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_1365, item_1363);
        }
        list_1364.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_proxy(
    input: &crate::input::ModifyDbProxyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBProxy", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1366 = writer.prefix("DBProxyName");
    if let Some(var_1367) = &input.db_proxy_name {
        scope_1366.string(var_1367);
    }
    #[allow(unused_mut)]
    let mut scope_1368 = writer.prefix("NewDBProxyName");
    if let Some(var_1369) = &input.new_db_proxy_name {
        scope_1368.string(var_1369);
    }
    #[allow(unused_mut)]
    let mut scope_1370 = writer.prefix("Auth");
    if let Some(var_1371) = &input.auth {
        let mut list_1373 = scope_1370.start_list(false, None);
        for item_1372 in var_1371 {
            #[allow(unused_mut)]
            let mut entry_1374 = list_1373.entry();
            crate::query_ser::serialize_structure_crate_model_user_auth_config(
                entry_1374, item_1372,
            );
        }
        list_1373.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1375 = writer.prefix("RequireTLS");
    if let Some(var_1376) = &input.require_tls {
        scope_1375.boolean(*var_1376);
    }
    #[allow(unused_mut)]
    let mut scope_1377 = writer.prefix("IdleClientTimeout");
    if let Some(var_1378) = &input.idle_client_timeout {
        scope_1377.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1378).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1379 = writer.prefix("DebugLogging");
    if let Some(var_1380) = &input.debug_logging {
        scope_1379.boolean(*var_1380);
    }
    #[allow(unused_mut)]
    let mut scope_1381 = writer.prefix("RoleArn");
    if let Some(var_1382) = &input.role_arn {
        scope_1381.string(var_1382);
    }
    #[allow(unused_mut)]
    let mut scope_1383 = writer.prefix("SecurityGroups");
    if let Some(var_1384) = &input.security_groups {
        let mut list_1386 = scope_1383.start_list(false, None);
        for item_1385 in var_1384 {
            #[allow(unused_mut)]
            let mut entry_1387 = list_1386.entry();
            entry_1387.string(item_1385);
        }
        list_1386.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_proxy_endpoint(
    input: &crate::input::ModifyDbProxyEndpointInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBProxyEndpoint", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1388 = writer.prefix("DBProxyEndpointName");
    if let Some(var_1389) = &input.db_proxy_endpoint_name {
        scope_1388.string(var_1389);
    }
    #[allow(unused_mut)]
    let mut scope_1390 = writer.prefix("NewDBProxyEndpointName");
    if let Some(var_1391) = &input.new_db_proxy_endpoint_name {
        scope_1390.string(var_1391);
    }
    #[allow(unused_mut)]
    let mut scope_1392 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1393) = &input.vpc_security_group_ids {
        let mut list_1395 = scope_1392.start_list(false, None);
        for item_1394 in var_1393 {
            #[allow(unused_mut)]
            let mut entry_1396 = list_1395.entry();
            entry_1396.string(item_1394);
        }
        list_1395.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_proxy_target_group(
    input: &crate::input::ModifyDbProxyTargetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBProxyTargetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1397 = writer.prefix("TargetGroupName");
    if let Some(var_1398) = &input.target_group_name {
        scope_1397.string(var_1398);
    }
    #[allow(unused_mut)]
    let mut scope_1399 = writer.prefix("DBProxyName");
    if let Some(var_1400) = &input.db_proxy_name {
        scope_1399.string(var_1400);
    }
    #[allow(unused_mut)]
    let mut scope_1401 = writer.prefix("ConnectionPoolConfig");
    if let Some(var_1402) = &input.connection_pool_config {
        crate::query_ser::serialize_structure_crate_model_connection_pool_configuration(
            scope_1401, var_1402,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1403 = writer.prefix("NewName");
    if let Some(var_1404) = &input.new_name {
        scope_1403.string(var_1404);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_snapshot(
    input: &crate::input::ModifyDbSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1405 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_1406) = &input.db_snapshot_identifier {
        scope_1405.string(var_1406);
    }
    #[allow(unused_mut)]
    let mut scope_1407 = writer.prefix("EngineVersion");
    if let Some(var_1408) = &input.engine_version {
        scope_1407.string(var_1408);
    }
    #[allow(unused_mut)]
    let mut scope_1409 = writer.prefix("OptionGroupName");
    if let Some(var_1410) = &input.option_group_name {
        scope_1409.string(var_1410);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_snapshot_attribute(
    input: &crate::input::ModifyDbSnapshotAttributeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBSnapshotAttribute", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1411 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_1412) = &input.db_snapshot_identifier {
        scope_1411.string(var_1412);
    }
    #[allow(unused_mut)]
    let mut scope_1413 = writer.prefix("AttributeName");
    if let Some(var_1414) = &input.attribute_name {
        scope_1413.string(var_1414);
    }
    #[allow(unused_mut)]
    let mut scope_1415 = writer.prefix("ValuesToAdd");
    if let Some(var_1416) = &input.values_to_add {
        let mut list_1418 = scope_1415.start_list(false, Some("AttributeValue"));
        for item_1417 in var_1416 {
            #[allow(unused_mut)]
            let mut entry_1419 = list_1418.entry();
            entry_1419.string(item_1417);
        }
        list_1418.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1420 = writer.prefix("ValuesToRemove");
    if let Some(var_1421) = &input.values_to_remove {
        let mut list_1423 = scope_1420.start_list(false, Some("AttributeValue"));
        for item_1422 in var_1421 {
            #[allow(unused_mut)]
            let mut entry_1424 = list_1423.entry();
            entry_1424.string(item_1422);
        }
        list_1423.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_subnet_group(
    input: &crate::input::ModifyDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1425 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1426) = &input.db_subnet_group_name {
        scope_1425.string(var_1426);
    }
    #[allow(unused_mut)]
    let mut scope_1427 = writer.prefix("DBSubnetGroupDescription");
    if let Some(var_1428) = &input.db_subnet_group_description {
        scope_1427.string(var_1428);
    }
    #[allow(unused_mut)]
    let mut scope_1429 = writer.prefix("SubnetIds");
    if let Some(var_1430) = &input.subnet_ids {
        let mut list_1432 = scope_1429.start_list(false, Some("SubnetIdentifier"));
        for item_1431 in var_1430 {
            #[allow(unused_mut)]
            let mut entry_1433 = list_1432.entry();
            entry_1433.string(item_1431);
        }
        list_1432.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_event_subscription(
    input: &crate::input::ModifyEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1434 = writer.prefix("SubscriptionName");
    if let Some(var_1435) = &input.subscription_name {
        scope_1434.string(var_1435);
    }
    #[allow(unused_mut)]
    let mut scope_1436 = writer.prefix("SnsTopicArn");
    if let Some(var_1437) = &input.sns_topic_arn {
        scope_1436.string(var_1437);
    }
    #[allow(unused_mut)]
    let mut scope_1438 = writer.prefix("SourceType");
    if let Some(var_1439) = &input.source_type {
        scope_1438.string(var_1439);
    }
    #[allow(unused_mut)]
    let mut scope_1440 = writer.prefix("EventCategories");
    if let Some(var_1441) = &input.event_categories {
        let mut list_1443 = scope_1440.start_list(false, Some("EventCategory"));
        for item_1442 in var_1441 {
            #[allow(unused_mut)]
            let mut entry_1444 = list_1443.entry();
            entry_1444.string(item_1442);
        }
        list_1443.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1445 = writer.prefix("Enabled");
    if let Some(var_1446) = &input.enabled {
        scope_1445.boolean(*var_1446);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_global_cluster(
    input: &crate::input::ModifyGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1447 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_1448) = &input.global_cluster_identifier {
        scope_1447.string(var_1448);
    }
    #[allow(unused_mut)]
    let mut scope_1449 = writer.prefix("NewGlobalClusterIdentifier");
    if let Some(var_1450) = &input.new_global_cluster_identifier {
        scope_1449.string(var_1450);
    }
    #[allow(unused_mut)]
    let mut scope_1451 = writer.prefix("DeletionProtection");
    if let Some(var_1452) = &input.deletion_protection {
        scope_1451.boolean(*var_1452);
    }
    #[allow(unused_mut)]
    let mut scope_1453 = writer.prefix("EngineVersion");
    if let Some(var_1454) = &input.engine_version {
        scope_1453.string(var_1454);
    }
    #[allow(unused_mut)]
    let mut scope_1455 = writer.prefix("AllowMajorVersionUpgrade");
    if let Some(var_1456) = &input.allow_major_version_upgrade {
        scope_1455.boolean(*var_1456);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_option_group(
    input: &crate::input::ModifyOptionGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyOptionGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1457 = writer.prefix("OptionGroupName");
    if let Some(var_1458) = &input.option_group_name {
        scope_1457.string(var_1458);
    }
    #[allow(unused_mut)]
    let mut scope_1459 = writer.prefix("OptionsToInclude");
    if let Some(var_1460) = &input.options_to_include {
        let mut list_1462 = scope_1459.start_list(false, Some("OptionConfiguration"));
        for item_1461 in var_1460 {
            #[allow(unused_mut)]
            let mut entry_1463 = list_1462.entry();
            crate::query_ser::serialize_structure_crate_model_option_configuration(
                entry_1463, item_1461,
            );
        }
        list_1462.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1464 = writer.prefix("OptionsToRemove");
    if let Some(var_1465) = &input.options_to_remove {
        let mut list_1467 = scope_1464.start_list(false, None);
        for item_1466 in var_1465 {
            #[allow(unused_mut)]
            let mut entry_1468 = list_1467.entry();
            entry_1468.string(item_1466);
        }
        list_1467.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1469 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_1469.boolean(input.apply_immediately);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_promote_read_replica(
    input: &crate::input::PromoteReadReplicaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PromoteReadReplica", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1470 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1471) = &input.db_instance_identifier {
        scope_1470.string(var_1471);
    }
    #[allow(unused_mut)]
    let mut scope_1472 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_1473) = &input.backup_retention_period {
        scope_1472.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1473).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1474 = writer.prefix("PreferredBackupWindow");
    if let Some(var_1475) = &input.preferred_backup_window {
        scope_1474.string(var_1475);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_promote_read_replica_db_cluster(
    input: &crate::input::PromoteReadReplicaDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "PromoteReadReplicaDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1476 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1477) = &input.db_cluster_identifier {
        scope_1476.string(var_1477);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_purchase_reserved_db_instances_offering(
    input: &crate::input::PurchaseReservedDbInstancesOfferingInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "PurchaseReservedDBInstancesOffering",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_1478 = writer.prefix("ReservedDBInstancesOfferingId");
    if let Some(var_1479) = &input.reserved_db_instances_offering_id {
        scope_1478.string(var_1479);
    }
    #[allow(unused_mut)]
    let mut scope_1480 = writer.prefix("ReservedDBInstanceId");
    if let Some(var_1481) = &input.reserved_db_instance_id {
        scope_1480.string(var_1481);
    }
    #[allow(unused_mut)]
    let mut scope_1482 = writer.prefix("DBInstanceCount");
    if let Some(var_1483) = &input.db_instance_count {
        scope_1482.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1483).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1484 = writer.prefix("Tags");
    if let Some(var_1485) = &input.tags {
        let mut list_1487 = scope_1484.start_list(false, Some("Tag"));
        for item_1486 in var_1485 {
            #[allow(unused_mut)]
            let mut entry_1488 = list_1487.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1488, item_1486);
        }
        list_1487.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reboot_db_instance(
    input: &crate::input::RebootDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RebootDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1489 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1490) = &input.db_instance_identifier {
        scope_1489.string(var_1490);
    }
    #[allow(unused_mut)]
    let mut scope_1491 = writer.prefix("ForceFailover");
    if let Some(var_1492) = &input.force_failover {
        scope_1491.boolean(*var_1492);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_register_db_proxy_targets(
    input: &crate::input::RegisterDbProxyTargetsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RegisterDBProxyTargets", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1493 = writer.prefix("DBProxyName");
    if let Some(var_1494) = &input.db_proxy_name {
        scope_1493.string(var_1494);
    }
    #[allow(unused_mut)]
    let mut scope_1495 = writer.prefix("TargetGroupName");
    if let Some(var_1496) = &input.target_group_name {
        scope_1495.string(var_1496);
    }
    #[allow(unused_mut)]
    let mut scope_1497 = writer.prefix("DBInstanceIdentifiers");
    if let Some(var_1498) = &input.db_instance_identifiers {
        let mut list_1500 = scope_1497.start_list(false, None);
        for item_1499 in var_1498 {
            #[allow(unused_mut)]
            let mut entry_1501 = list_1500.entry();
            entry_1501.string(item_1499);
        }
        list_1500.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1502 = writer.prefix("DBClusterIdentifiers");
    if let Some(var_1503) = &input.db_cluster_identifiers {
        let mut list_1505 = scope_1502.start_list(false, None);
        for item_1504 in var_1503 {
            #[allow(unused_mut)]
            let mut entry_1506 = list_1505.entry();
            entry_1506.string(item_1504);
        }
        list_1505.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_from_global_cluster(
    input: &crate::input::RemoveFromGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveFromGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1507 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_1508) = &input.global_cluster_identifier {
        scope_1507.string(var_1508);
    }
    #[allow(unused_mut)]
    let mut scope_1509 = writer.prefix("DbClusterIdentifier");
    if let Some(var_1510) = &input.db_cluster_identifier {
        scope_1509.string(var_1510);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_role_from_db_cluster(
    input: &crate::input::RemoveRoleFromDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveRoleFromDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1511 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1512) = &input.db_cluster_identifier {
        scope_1511.string(var_1512);
    }
    #[allow(unused_mut)]
    let mut scope_1513 = writer.prefix("RoleArn");
    if let Some(var_1514) = &input.role_arn {
        scope_1513.string(var_1514);
    }
    #[allow(unused_mut)]
    let mut scope_1515 = writer.prefix("FeatureName");
    if let Some(var_1516) = &input.feature_name {
        scope_1515.string(var_1516);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_role_from_db_instance(
    input: &crate::input::RemoveRoleFromDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveRoleFromDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1517 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1518) = &input.db_instance_identifier {
        scope_1517.string(var_1518);
    }
    #[allow(unused_mut)]
    let mut scope_1519 = writer.prefix("RoleArn");
    if let Some(var_1520) = &input.role_arn {
        scope_1519.string(var_1520);
    }
    #[allow(unused_mut)]
    let mut scope_1521 = writer.prefix("FeatureName");
    if let Some(var_1522) = &input.feature_name {
        scope_1521.string(var_1522);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_source_identifier_from_subscription(
    input: &crate::input::RemoveSourceIdentifierFromSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "RemoveSourceIdentifierFromSubscription",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_1523 = writer.prefix("SubscriptionName");
    if let Some(var_1524) = &input.subscription_name {
        scope_1523.string(var_1524);
    }
    #[allow(unused_mut)]
    let mut scope_1525 = writer.prefix("SourceIdentifier");
    if let Some(var_1526) = &input.source_identifier {
        scope_1525.string(var_1526);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_tags_from_resource(
    input: &crate::input::RemoveTagsFromResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveTagsFromResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1527 = writer.prefix("ResourceName");
    if let Some(var_1528) = &input.resource_name {
        scope_1527.string(var_1528);
    }
    #[allow(unused_mut)]
    let mut scope_1529 = writer.prefix("TagKeys");
    if let Some(var_1530) = &input.tag_keys {
        let mut list_1532 = scope_1529.start_list(false, None);
        for item_1531 in var_1530 {
            #[allow(unused_mut)]
            let mut entry_1533 = list_1532.entry();
            entry_1533.string(item_1531);
        }
        list_1532.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reset_db_cluster_parameter_group(
    input: &crate::input::ResetDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ResetDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1534 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1535) = &input.db_cluster_parameter_group_name {
        scope_1534.string(var_1535);
    }
    #[allow(unused_mut)]
    let mut scope_1536 = writer.prefix("ResetAllParameters");
    if input.reset_all_parameters {
        scope_1536.boolean(input.reset_all_parameters);
    }
    #[allow(unused_mut)]
    let mut scope_1537 = writer.prefix("Parameters");
    if let Some(var_1538) = &input.parameters {
        let mut list_1540 = scope_1537.start_list(false, Some("Parameter"));
        for item_1539 in var_1538 {
            #[allow(unused_mut)]
            let mut entry_1541 = list_1540.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_1541, item_1539);
        }
        list_1540.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reset_db_parameter_group(
    input: &crate::input::ResetDbParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ResetDBParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1542 = writer.prefix("DBParameterGroupName");
    if let Some(var_1543) = &input.db_parameter_group_name {
        scope_1542.string(var_1543);
    }
    #[allow(unused_mut)]
    let mut scope_1544 = writer.prefix("ResetAllParameters");
    if input.reset_all_parameters {
        scope_1544.boolean(input.reset_all_parameters);
    }
    #[allow(unused_mut)]
    let mut scope_1545 = writer.prefix("Parameters");
    if let Some(var_1546) = &input.parameters {
        let mut list_1548 = scope_1545.start_list(false, Some("Parameter"));
        for item_1547 in var_1546 {
            #[allow(unused_mut)]
            let mut entry_1549 = list_1548.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_1549, item_1547);
        }
        list_1548.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_cluster_from_s3(
    input: &crate::input::RestoreDbClusterFromS3Input,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBClusterFromS3", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1550 = writer.prefix("AvailabilityZones");
    if let Some(var_1551) = &input.availability_zones {
        let mut list_1553 = scope_1550.start_list(false, Some("AvailabilityZone"));
        for item_1552 in var_1551 {
            #[allow(unused_mut)]
            let mut entry_1554 = list_1553.entry();
            entry_1554.string(item_1552);
        }
        list_1553.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1555 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_1556) = &input.backup_retention_period {
        scope_1555.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1556).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1557 = writer.prefix("CharacterSetName");
    if let Some(var_1558) = &input.character_set_name {
        scope_1557.string(var_1558);
    }
    #[allow(unused_mut)]
    let mut scope_1559 = writer.prefix("DatabaseName");
    if let Some(var_1560) = &input.database_name {
        scope_1559.string(var_1560);
    }
    #[allow(unused_mut)]
    let mut scope_1561 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1562) = &input.db_cluster_identifier {
        scope_1561.string(var_1562);
    }
    #[allow(unused_mut)]
    let mut scope_1563 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1564) = &input.db_cluster_parameter_group_name {
        scope_1563.string(var_1564);
    }
    #[allow(unused_mut)]
    let mut scope_1565 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1566) = &input.vpc_security_group_ids {
        let mut list_1568 = scope_1565.start_list(false, Some("VpcSecurityGroupId"));
        for item_1567 in var_1566 {
            #[allow(unused_mut)]
            let mut entry_1569 = list_1568.entry();
            entry_1569.string(item_1567);
        }
        list_1568.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1570 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1571) = &input.db_subnet_group_name {
        scope_1570.string(var_1571);
    }
    #[allow(unused_mut)]
    let mut scope_1572 = writer.prefix("Engine");
    if let Some(var_1573) = &input.engine {
        scope_1572.string(var_1573);
    }
    #[allow(unused_mut)]
    let mut scope_1574 = writer.prefix("EngineVersion");
    if let Some(var_1575) = &input.engine_version {
        scope_1574.string(var_1575);
    }
    #[allow(unused_mut)]
    let mut scope_1576 = writer.prefix("Port");
    if let Some(var_1577) = &input.port {
        scope_1576.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1577).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1578 = writer.prefix("MasterUsername");
    if let Some(var_1579) = &input.master_username {
        scope_1578.string(var_1579);
    }
    #[allow(unused_mut)]
    let mut scope_1580 = writer.prefix("MasterUserPassword");
    if let Some(var_1581) = &input.master_user_password {
        scope_1580.string(var_1581);
    }
    #[allow(unused_mut)]
    let mut scope_1582 = writer.prefix("OptionGroupName");
    if let Some(var_1583) = &input.option_group_name {
        scope_1582.string(var_1583);
    }
    #[allow(unused_mut)]
    let mut scope_1584 = writer.prefix("PreferredBackupWindow");
    if let Some(var_1585) = &input.preferred_backup_window {
        scope_1584.string(var_1585);
    }
    #[allow(unused_mut)]
    let mut scope_1586 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_1587) = &input.preferred_maintenance_window {
        scope_1586.string(var_1587);
    }
    #[allow(unused_mut)]
    let mut scope_1588 = writer.prefix("Tags");
    if let Some(var_1589) = &input.tags {
        let mut list_1591 = scope_1588.start_list(false, Some("Tag"));
        for item_1590 in var_1589 {
            #[allow(unused_mut)]
            let mut entry_1592 = list_1591.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1592, item_1590);
        }
        list_1591.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1593 = writer.prefix("StorageEncrypted");
    if let Some(var_1594) = &input.storage_encrypted {
        scope_1593.boolean(*var_1594);
    }
    #[allow(unused_mut)]
    let mut scope_1595 = writer.prefix("KmsKeyId");
    if let Some(var_1596) = &input.kms_key_id {
        scope_1595.string(var_1596);
    }
    #[allow(unused_mut)]
    let mut scope_1597 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1598) = &input.enable_iam_database_authentication {
        scope_1597.boolean(*var_1598);
    }
    #[allow(unused_mut)]
    let mut scope_1599 = writer.prefix("SourceEngine");
    if let Some(var_1600) = &input.source_engine {
        scope_1599.string(var_1600);
    }
    #[allow(unused_mut)]
    let mut scope_1601 = writer.prefix("SourceEngineVersion");
    if let Some(var_1602) = &input.source_engine_version {
        scope_1601.string(var_1602);
    }
    #[allow(unused_mut)]
    let mut scope_1603 = writer.prefix("S3BucketName");
    if let Some(var_1604) = &input.s3_bucket_name {
        scope_1603.string(var_1604);
    }
    #[allow(unused_mut)]
    let mut scope_1605 = writer.prefix("S3Prefix");
    if let Some(var_1606) = &input.s3_prefix {
        scope_1605.string(var_1606);
    }
    #[allow(unused_mut)]
    let mut scope_1607 = writer.prefix("S3IngestionRoleArn");
    if let Some(var_1608) = &input.s3_ingestion_role_arn {
        scope_1607.string(var_1608);
    }
    #[allow(unused_mut)]
    let mut scope_1609 = writer.prefix("BacktrackWindow");
    if let Some(var_1610) = &input.backtrack_window {
        scope_1609.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1610).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1611 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1612) = &input.enable_cloudwatch_logs_exports {
        let mut list_1614 = scope_1611.start_list(false, None);
        for item_1613 in var_1612 {
            #[allow(unused_mut)]
            let mut entry_1615 = list_1614.entry();
            entry_1615.string(item_1613);
        }
        list_1614.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1616 = writer.prefix("DeletionProtection");
    if let Some(var_1617) = &input.deletion_protection {
        scope_1616.boolean(*var_1617);
    }
    #[allow(unused_mut)]
    let mut scope_1618 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1619) = &input.copy_tags_to_snapshot {
        scope_1618.boolean(*var_1619);
    }
    #[allow(unused_mut)]
    let mut scope_1620 = writer.prefix("Domain");
    if let Some(var_1621) = &input.domain {
        scope_1620.string(var_1621);
    }
    #[allow(unused_mut)]
    let mut scope_1622 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1623) = &input.domain_iam_role_name {
        scope_1622.string(var_1623);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_cluster_from_snapshot(
    input: &crate::input::RestoreDbClusterFromSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBClusterFromSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1624 = writer.prefix("AvailabilityZones");
    if let Some(var_1625) = &input.availability_zones {
        let mut list_1627 = scope_1624.start_list(false, Some("AvailabilityZone"));
        for item_1626 in var_1625 {
            #[allow(unused_mut)]
            let mut entry_1628 = list_1627.entry();
            entry_1628.string(item_1626);
        }
        list_1627.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1629 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1630) = &input.db_cluster_identifier {
        scope_1629.string(var_1630);
    }
    #[allow(unused_mut)]
    let mut scope_1631 = writer.prefix("SnapshotIdentifier");
    if let Some(var_1632) = &input.snapshot_identifier {
        scope_1631.string(var_1632);
    }
    #[allow(unused_mut)]
    let mut scope_1633 = writer.prefix("Engine");
    if let Some(var_1634) = &input.engine {
        scope_1633.string(var_1634);
    }
    #[allow(unused_mut)]
    let mut scope_1635 = writer.prefix("EngineVersion");
    if let Some(var_1636) = &input.engine_version {
        scope_1635.string(var_1636);
    }
    #[allow(unused_mut)]
    let mut scope_1637 = writer.prefix("Port");
    if let Some(var_1638) = &input.port {
        scope_1637.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1638).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1639 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1640) = &input.db_subnet_group_name {
        scope_1639.string(var_1640);
    }
    #[allow(unused_mut)]
    let mut scope_1641 = writer.prefix("DatabaseName");
    if let Some(var_1642) = &input.database_name {
        scope_1641.string(var_1642);
    }
    #[allow(unused_mut)]
    let mut scope_1643 = writer.prefix("OptionGroupName");
    if let Some(var_1644) = &input.option_group_name {
        scope_1643.string(var_1644);
    }
    #[allow(unused_mut)]
    let mut scope_1645 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1646) = &input.vpc_security_group_ids {
        let mut list_1648 = scope_1645.start_list(false, Some("VpcSecurityGroupId"));
        for item_1647 in var_1646 {
            #[allow(unused_mut)]
            let mut entry_1649 = list_1648.entry();
            entry_1649.string(item_1647);
        }
        list_1648.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1650 = writer.prefix("Tags");
    if let Some(var_1651) = &input.tags {
        let mut list_1653 = scope_1650.start_list(false, Some("Tag"));
        for item_1652 in var_1651 {
            #[allow(unused_mut)]
            let mut entry_1654 = list_1653.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1654, item_1652);
        }
        list_1653.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1655 = writer.prefix("KmsKeyId");
    if let Some(var_1656) = &input.kms_key_id {
        scope_1655.string(var_1656);
    }
    #[allow(unused_mut)]
    let mut scope_1657 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1658) = &input.enable_iam_database_authentication {
        scope_1657.boolean(*var_1658);
    }
    #[allow(unused_mut)]
    let mut scope_1659 = writer.prefix("BacktrackWindow");
    if let Some(var_1660) = &input.backtrack_window {
        scope_1659.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1660).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1661 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1662) = &input.enable_cloudwatch_logs_exports {
        let mut list_1664 = scope_1661.start_list(false, None);
        for item_1663 in var_1662 {
            #[allow(unused_mut)]
            let mut entry_1665 = list_1664.entry();
            entry_1665.string(item_1663);
        }
        list_1664.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1666 = writer.prefix("EngineMode");
    if let Some(var_1667) = &input.engine_mode {
        scope_1666.string(var_1667);
    }
    #[allow(unused_mut)]
    let mut scope_1668 = writer.prefix("ScalingConfiguration");
    if let Some(var_1669) = &input.scaling_configuration {
        crate::query_ser::serialize_structure_crate_model_scaling_configuration(
            scope_1668, var_1669,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1670 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1671) = &input.db_cluster_parameter_group_name {
        scope_1670.string(var_1671);
    }
    #[allow(unused_mut)]
    let mut scope_1672 = writer.prefix("DeletionProtection");
    if let Some(var_1673) = &input.deletion_protection {
        scope_1672.boolean(*var_1673);
    }
    #[allow(unused_mut)]
    let mut scope_1674 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1675) = &input.copy_tags_to_snapshot {
        scope_1674.boolean(*var_1675);
    }
    #[allow(unused_mut)]
    let mut scope_1676 = writer.prefix("Domain");
    if let Some(var_1677) = &input.domain {
        scope_1676.string(var_1677);
    }
    #[allow(unused_mut)]
    let mut scope_1678 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1679) = &input.domain_iam_role_name {
        scope_1678.string(var_1679);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_cluster_to_point_in_time(
    input: &crate::input::RestoreDbClusterToPointInTimeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBClusterToPointInTime", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1680 = writer.prefix("DBClusterIdentifier");
    if let Some(var_1681) = &input.db_cluster_identifier {
        scope_1680.string(var_1681);
    }
    #[allow(unused_mut)]
    let mut scope_1682 = writer.prefix("RestoreType");
    if let Some(var_1683) = &input.restore_type {
        scope_1682.string(var_1683);
    }
    #[allow(unused_mut)]
    let mut scope_1684 = writer.prefix("SourceDBClusterIdentifier");
    if let Some(var_1685) = &input.source_db_cluster_identifier {
        scope_1684.string(var_1685);
    }
    #[allow(unused_mut)]
    let mut scope_1686 = writer.prefix("RestoreToTime");
    if let Some(var_1687) = &input.restore_to_time {
        scope_1686.instant(var_1687, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_1688 = writer.prefix("UseLatestRestorableTime");
    if input.use_latest_restorable_time {
        scope_1688.boolean(input.use_latest_restorable_time);
    }
    #[allow(unused_mut)]
    let mut scope_1689 = writer.prefix("Port");
    if let Some(var_1690) = &input.port {
        scope_1689.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1690).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1691 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1692) = &input.db_subnet_group_name {
        scope_1691.string(var_1692);
    }
    #[allow(unused_mut)]
    let mut scope_1693 = writer.prefix("OptionGroupName");
    if let Some(var_1694) = &input.option_group_name {
        scope_1693.string(var_1694);
    }
    #[allow(unused_mut)]
    let mut scope_1695 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1696) = &input.vpc_security_group_ids {
        let mut list_1698 = scope_1695.start_list(false, Some("VpcSecurityGroupId"));
        for item_1697 in var_1696 {
            #[allow(unused_mut)]
            let mut entry_1699 = list_1698.entry();
            entry_1699.string(item_1697);
        }
        list_1698.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1700 = writer.prefix("Tags");
    if let Some(var_1701) = &input.tags {
        let mut list_1703 = scope_1700.start_list(false, Some("Tag"));
        for item_1702 in var_1701 {
            #[allow(unused_mut)]
            let mut entry_1704 = list_1703.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1704, item_1702);
        }
        list_1703.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1705 = writer.prefix("KmsKeyId");
    if let Some(var_1706) = &input.kms_key_id {
        scope_1705.string(var_1706);
    }
    #[allow(unused_mut)]
    let mut scope_1707 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1708) = &input.enable_iam_database_authentication {
        scope_1707.boolean(*var_1708);
    }
    #[allow(unused_mut)]
    let mut scope_1709 = writer.prefix("BacktrackWindow");
    if let Some(var_1710) = &input.backtrack_window {
        scope_1709.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1710).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1711 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1712) = &input.enable_cloudwatch_logs_exports {
        let mut list_1714 = scope_1711.start_list(false, None);
        for item_1713 in var_1712 {
            #[allow(unused_mut)]
            let mut entry_1715 = list_1714.entry();
            entry_1715.string(item_1713);
        }
        list_1714.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1716 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_1717) = &input.db_cluster_parameter_group_name {
        scope_1716.string(var_1717);
    }
    #[allow(unused_mut)]
    let mut scope_1718 = writer.prefix("DeletionProtection");
    if let Some(var_1719) = &input.deletion_protection {
        scope_1718.boolean(*var_1719);
    }
    #[allow(unused_mut)]
    let mut scope_1720 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1721) = &input.copy_tags_to_snapshot {
        scope_1720.boolean(*var_1721);
    }
    #[allow(unused_mut)]
    let mut scope_1722 = writer.prefix("Domain");
    if let Some(var_1723) = &input.domain {
        scope_1722.string(var_1723);
    }
    #[allow(unused_mut)]
    let mut scope_1724 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1725) = &input.domain_iam_role_name {
        scope_1724.string(var_1725);
    }
    #[allow(unused_mut)]
    let mut scope_1726 = writer.prefix("ScalingConfiguration");
    if let Some(var_1727) = &input.scaling_configuration {
        crate::query_ser::serialize_structure_crate_model_scaling_configuration(
            scope_1726, var_1727,
        );
    }
    #[allow(unused_mut)]
    let mut scope_1728 = writer.prefix("EngineMode");
    if let Some(var_1729) = &input.engine_mode {
        scope_1728.string(var_1729);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_instance_from_db_snapshot(
    input: &crate::input::RestoreDbInstanceFromDbSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBInstanceFromDBSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1730 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1731) = &input.db_instance_identifier {
        scope_1730.string(var_1731);
    }
    #[allow(unused_mut)]
    let mut scope_1732 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_1733) = &input.db_snapshot_identifier {
        scope_1732.string(var_1733);
    }
    #[allow(unused_mut)]
    let mut scope_1734 = writer.prefix("DBInstanceClass");
    if let Some(var_1735) = &input.db_instance_class {
        scope_1734.string(var_1735);
    }
    #[allow(unused_mut)]
    let mut scope_1736 = writer.prefix("Port");
    if let Some(var_1737) = &input.port {
        scope_1736.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1737).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1738 = writer.prefix("AvailabilityZone");
    if let Some(var_1739) = &input.availability_zone {
        scope_1738.string(var_1739);
    }
    #[allow(unused_mut)]
    let mut scope_1740 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1741) = &input.db_subnet_group_name {
        scope_1740.string(var_1741);
    }
    #[allow(unused_mut)]
    let mut scope_1742 = writer.prefix("MultiAZ");
    if let Some(var_1743) = &input.multi_az {
        scope_1742.boolean(*var_1743);
    }
    #[allow(unused_mut)]
    let mut scope_1744 = writer.prefix("PubliclyAccessible");
    if let Some(var_1745) = &input.publicly_accessible {
        scope_1744.boolean(*var_1745);
    }
    #[allow(unused_mut)]
    let mut scope_1746 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_1747) = &input.auto_minor_version_upgrade {
        scope_1746.boolean(*var_1747);
    }
    #[allow(unused_mut)]
    let mut scope_1748 = writer.prefix("LicenseModel");
    if let Some(var_1749) = &input.license_model {
        scope_1748.string(var_1749);
    }
    #[allow(unused_mut)]
    let mut scope_1750 = writer.prefix("DBName");
    if let Some(var_1751) = &input.db_name {
        scope_1750.string(var_1751);
    }
    #[allow(unused_mut)]
    let mut scope_1752 = writer.prefix("Engine");
    if let Some(var_1753) = &input.engine {
        scope_1752.string(var_1753);
    }
    #[allow(unused_mut)]
    let mut scope_1754 = writer.prefix("Iops");
    if let Some(var_1755) = &input.iops {
        scope_1754.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1755).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1756 = writer.prefix("OptionGroupName");
    if let Some(var_1757) = &input.option_group_name {
        scope_1756.string(var_1757);
    }
    #[allow(unused_mut)]
    let mut scope_1758 = writer.prefix("Tags");
    if let Some(var_1759) = &input.tags {
        let mut list_1761 = scope_1758.start_list(false, Some("Tag"));
        for item_1760 in var_1759 {
            #[allow(unused_mut)]
            let mut entry_1762 = list_1761.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1762, item_1760);
        }
        list_1761.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1763 = writer.prefix("StorageType");
    if let Some(var_1764) = &input.storage_type {
        scope_1763.string(var_1764);
    }
    #[allow(unused_mut)]
    let mut scope_1765 = writer.prefix("TdeCredentialArn");
    if let Some(var_1766) = &input.tde_credential_arn {
        scope_1765.string(var_1766);
    }
    #[allow(unused_mut)]
    let mut scope_1767 = writer.prefix("TdeCredentialPassword");
    if let Some(var_1768) = &input.tde_credential_password {
        scope_1767.string(var_1768);
    }
    #[allow(unused_mut)]
    let mut scope_1769 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1770) = &input.vpc_security_group_ids {
        let mut list_1772 = scope_1769.start_list(false, Some("VpcSecurityGroupId"));
        for item_1771 in var_1770 {
            #[allow(unused_mut)]
            let mut entry_1773 = list_1772.entry();
            entry_1773.string(item_1771);
        }
        list_1772.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1774 = writer.prefix("Domain");
    if let Some(var_1775) = &input.domain {
        scope_1774.string(var_1775);
    }
    #[allow(unused_mut)]
    let mut scope_1776 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1777) = &input.copy_tags_to_snapshot {
        scope_1776.boolean(*var_1777);
    }
    #[allow(unused_mut)]
    let mut scope_1778 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1779) = &input.domain_iam_role_name {
        scope_1778.string(var_1779);
    }
    #[allow(unused_mut)]
    let mut scope_1780 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1781) = &input.enable_iam_database_authentication {
        scope_1780.boolean(*var_1781);
    }
    #[allow(unused_mut)]
    let mut scope_1782 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1783) = &input.enable_cloudwatch_logs_exports {
        let mut list_1785 = scope_1782.start_list(false, None);
        for item_1784 in var_1783 {
            #[allow(unused_mut)]
            let mut entry_1786 = list_1785.entry();
            entry_1786.string(item_1784);
        }
        list_1785.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1787 = writer.prefix("ProcessorFeatures");
    if let Some(var_1788) = &input.processor_features {
        let mut list_1790 = scope_1787.start_list(false, Some("ProcessorFeature"));
        for item_1789 in var_1788 {
            #[allow(unused_mut)]
            let mut entry_1791 = list_1790.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_1791, item_1789,
            );
        }
        list_1790.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1792 = writer.prefix("UseDefaultProcessorFeatures");
    if let Some(var_1793) = &input.use_default_processor_features {
        scope_1792.boolean(*var_1793);
    }
    #[allow(unused_mut)]
    let mut scope_1794 = writer.prefix("DBParameterGroupName");
    if let Some(var_1795) = &input.db_parameter_group_name {
        scope_1794.string(var_1795);
    }
    #[allow(unused_mut)]
    let mut scope_1796 = writer.prefix("DeletionProtection");
    if let Some(var_1797) = &input.deletion_protection {
        scope_1796.boolean(*var_1797);
    }
    #[allow(unused_mut)]
    let mut scope_1798 = writer.prefix("EnableCustomerOwnedIp");
    if let Some(var_1799) = &input.enable_customer_owned_ip {
        scope_1798.boolean(*var_1799);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_instance_from_s3(
    input: &crate::input::RestoreDbInstanceFromS3Input,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBInstanceFromS3", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1800 = writer.prefix("DBName");
    if let Some(var_1801) = &input.db_name {
        scope_1800.string(var_1801);
    }
    #[allow(unused_mut)]
    let mut scope_1802 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_1803) = &input.db_instance_identifier {
        scope_1802.string(var_1803);
    }
    #[allow(unused_mut)]
    let mut scope_1804 = writer.prefix("AllocatedStorage");
    if let Some(var_1805) = &input.allocated_storage {
        scope_1804.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1805).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1806 = writer.prefix("DBInstanceClass");
    if let Some(var_1807) = &input.db_instance_class {
        scope_1806.string(var_1807);
    }
    #[allow(unused_mut)]
    let mut scope_1808 = writer.prefix("Engine");
    if let Some(var_1809) = &input.engine {
        scope_1808.string(var_1809);
    }
    #[allow(unused_mut)]
    let mut scope_1810 = writer.prefix("MasterUsername");
    if let Some(var_1811) = &input.master_username {
        scope_1810.string(var_1811);
    }
    #[allow(unused_mut)]
    let mut scope_1812 = writer.prefix("MasterUserPassword");
    if let Some(var_1813) = &input.master_user_password {
        scope_1812.string(var_1813);
    }
    #[allow(unused_mut)]
    let mut scope_1814 = writer.prefix("DBSecurityGroups");
    if let Some(var_1815) = &input.db_security_groups {
        let mut list_1817 = scope_1814.start_list(false, Some("DBSecurityGroupName"));
        for item_1816 in var_1815 {
            #[allow(unused_mut)]
            let mut entry_1818 = list_1817.entry();
            entry_1818.string(item_1816);
        }
        list_1817.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1819 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1820) = &input.vpc_security_group_ids {
        let mut list_1822 = scope_1819.start_list(false, Some("VpcSecurityGroupId"));
        for item_1821 in var_1820 {
            #[allow(unused_mut)]
            let mut entry_1823 = list_1822.entry();
            entry_1823.string(item_1821);
        }
        list_1822.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1824 = writer.prefix("AvailabilityZone");
    if let Some(var_1825) = &input.availability_zone {
        scope_1824.string(var_1825);
    }
    #[allow(unused_mut)]
    let mut scope_1826 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1827) = &input.db_subnet_group_name {
        scope_1826.string(var_1827);
    }
    #[allow(unused_mut)]
    let mut scope_1828 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_1829) = &input.preferred_maintenance_window {
        scope_1828.string(var_1829);
    }
    #[allow(unused_mut)]
    let mut scope_1830 = writer.prefix("DBParameterGroupName");
    if let Some(var_1831) = &input.db_parameter_group_name {
        scope_1830.string(var_1831);
    }
    #[allow(unused_mut)]
    let mut scope_1832 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_1833) = &input.backup_retention_period {
        scope_1832.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1833).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1834 = writer.prefix("PreferredBackupWindow");
    if let Some(var_1835) = &input.preferred_backup_window {
        scope_1834.string(var_1835);
    }
    #[allow(unused_mut)]
    let mut scope_1836 = writer.prefix("Port");
    if let Some(var_1837) = &input.port {
        scope_1836.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1837).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1838 = writer.prefix("MultiAZ");
    if let Some(var_1839) = &input.multi_az {
        scope_1838.boolean(*var_1839);
    }
    #[allow(unused_mut)]
    let mut scope_1840 = writer.prefix("EngineVersion");
    if let Some(var_1841) = &input.engine_version {
        scope_1840.string(var_1841);
    }
    #[allow(unused_mut)]
    let mut scope_1842 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_1843) = &input.auto_minor_version_upgrade {
        scope_1842.boolean(*var_1843);
    }
    #[allow(unused_mut)]
    let mut scope_1844 = writer.prefix("LicenseModel");
    if let Some(var_1845) = &input.license_model {
        scope_1844.string(var_1845);
    }
    #[allow(unused_mut)]
    let mut scope_1846 = writer.prefix("Iops");
    if let Some(var_1847) = &input.iops {
        scope_1846.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1847).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1848 = writer.prefix("OptionGroupName");
    if let Some(var_1849) = &input.option_group_name {
        scope_1848.string(var_1849);
    }
    #[allow(unused_mut)]
    let mut scope_1850 = writer.prefix("PubliclyAccessible");
    if let Some(var_1851) = &input.publicly_accessible {
        scope_1850.boolean(*var_1851);
    }
    #[allow(unused_mut)]
    let mut scope_1852 = writer.prefix("Tags");
    if let Some(var_1853) = &input.tags {
        let mut list_1855 = scope_1852.start_list(false, Some("Tag"));
        for item_1854 in var_1853 {
            #[allow(unused_mut)]
            let mut entry_1856 = list_1855.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1856, item_1854);
        }
        list_1855.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1857 = writer.prefix("StorageType");
    if let Some(var_1858) = &input.storage_type {
        scope_1857.string(var_1858);
    }
    #[allow(unused_mut)]
    let mut scope_1859 = writer.prefix("StorageEncrypted");
    if let Some(var_1860) = &input.storage_encrypted {
        scope_1859.boolean(*var_1860);
    }
    #[allow(unused_mut)]
    let mut scope_1861 = writer.prefix("KmsKeyId");
    if let Some(var_1862) = &input.kms_key_id {
        scope_1861.string(var_1862);
    }
    #[allow(unused_mut)]
    let mut scope_1863 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1864) = &input.copy_tags_to_snapshot {
        scope_1863.boolean(*var_1864);
    }
    #[allow(unused_mut)]
    let mut scope_1865 = writer.prefix("MonitoringInterval");
    if let Some(var_1866) = &input.monitoring_interval {
        scope_1865.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1866).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1867 = writer.prefix("MonitoringRoleArn");
    if let Some(var_1868) = &input.monitoring_role_arn {
        scope_1867.string(var_1868);
    }
    #[allow(unused_mut)]
    let mut scope_1869 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1870) = &input.enable_iam_database_authentication {
        scope_1869.boolean(*var_1870);
    }
    #[allow(unused_mut)]
    let mut scope_1871 = writer.prefix("SourceEngine");
    if let Some(var_1872) = &input.source_engine {
        scope_1871.string(var_1872);
    }
    #[allow(unused_mut)]
    let mut scope_1873 = writer.prefix("SourceEngineVersion");
    if let Some(var_1874) = &input.source_engine_version {
        scope_1873.string(var_1874);
    }
    #[allow(unused_mut)]
    let mut scope_1875 = writer.prefix("S3BucketName");
    if let Some(var_1876) = &input.s3_bucket_name {
        scope_1875.string(var_1876);
    }
    #[allow(unused_mut)]
    let mut scope_1877 = writer.prefix("S3Prefix");
    if let Some(var_1878) = &input.s3_prefix {
        scope_1877.string(var_1878);
    }
    #[allow(unused_mut)]
    let mut scope_1879 = writer.prefix("S3IngestionRoleArn");
    if let Some(var_1880) = &input.s3_ingestion_role_arn {
        scope_1879.string(var_1880);
    }
    #[allow(unused_mut)]
    let mut scope_1881 = writer.prefix("EnablePerformanceInsights");
    if let Some(var_1882) = &input.enable_performance_insights {
        scope_1881.boolean(*var_1882);
    }
    #[allow(unused_mut)]
    let mut scope_1883 = writer.prefix("PerformanceInsightsKMSKeyId");
    if let Some(var_1884) = &input.performance_insights_kms_key_id {
        scope_1883.string(var_1884);
    }
    #[allow(unused_mut)]
    let mut scope_1885 = writer.prefix("PerformanceInsightsRetentionPeriod");
    if let Some(var_1886) = &input.performance_insights_retention_period {
        scope_1885.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1886).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1887 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1888) = &input.enable_cloudwatch_logs_exports {
        let mut list_1890 = scope_1887.start_list(false, None);
        for item_1889 in var_1888 {
            #[allow(unused_mut)]
            let mut entry_1891 = list_1890.entry();
            entry_1891.string(item_1889);
        }
        list_1890.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1892 = writer.prefix("ProcessorFeatures");
    if let Some(var_1893) = &input.processor_features {
        let mut list_1895 = scope_1892.start_list(false, Some("ProcessorFeature"));
        for item_1894 in var_1893 {
            #[allow(unused_mut)]
            let mut entry_1896 = list_1895.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_1896, item_1894,
            );
        }
        list_1895.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1897 = writer.prefix("UseDefaultProcessorFeatures");
    if let Some(var_1898) = &input.use_default_processor_features {
        scope_1897.boolean(*var_1898);
    }
    #[allow(unused_mut)]
    let mut scope_1899 = writer.prefix("DeletionProtection");
    if let Some(var_1900) = &input.deletion_protection {
        scope_1899.boolean(*var_1900);
    }
    #[allow(unused_mut)]
    let mut scope_1901 = writer.prefix("MaxAllocatedStorage");
    if let Some(var_1902) = &input.max_allocated_storage {
        scope_1901.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1902).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_instance_to_point_in_time(
    input: &crate::input::RestoreDbInstanceToPointInTimeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBInstanceToPointInTime", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1903 = writer.prefix("SourceDBInstanceIdentifier");
    if let Some(var_1904) = &input.source_db_instance_identifier {
        scope_1903.string(var_1904);
    }
    #[allow(unused_mut)]
    let mut scope_1905 = writer.prefix("TargetDBInstanceIdentifier");
    if let Some(var_1906) = &input.target_db_instance_identifier {
        scope_1905.string(var_1906);
    }
    #[allow(unused_mut)]
    let mut scope_1907 = writer.prefix("RestoreTime");
    if let Some(var_1908) = &input.restore_time {
        scope_1907.instant(var_1908, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_1909 = writer.prefix("UseLatestRestorableTime");
    if input.use_latest_restorable_time {
        scope_1909.boolean(input.use_latest_restorable_time);
    }
    #[allow(unused_mut)]
    let mut scope_1910 = writer.prefix("DBInstanceClass");
    if let Some(var_1911) = &input.db_instance_class {
        scope_1910.string(var_1911);
    }
    #[allow(unused_mut)]
    let mut scope_1912 = writer.prefix("Port");
    if let Some(var_1913) = &input.port {
        scope_1912.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1913).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1914 = writer.prefix("AvailabilityZone");
    if let Some(var_1915) = &input.availability_zone {
        scope_1914.string(var_1915);
    }
    #[allow(unused_mut)]
    let mut scope_1916 = writer.prefix("DBSubnetGroupName");
    if let Some(var_1917) = &input.db_subnet_group_name {
        scope_1916.string(var_1917);
    }
    #[allow(unused_mut)]
    let mut scope_1918 = writer.prefix("MultiAZ");
    if let Some(var_1919) = &input.multi_az {
        scope_1918.boolean(*var_1919);
    }
    #[allow(unused_mut)]
    let mut scope_1920 = writer.prefix("PubliclyAccessible");
    if let Some(var_1921) = &input.publicly_accessible {
        scope_1920.boolean(*var_1921);
    }
    #[allow(unused_mut)]
    let mut scope_1922 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_1923) = &input.auto_minor_version_upgrade {
        scope_1922.boolean(*var_1923);
    }
    #[allow(unused_mut)]
    let mut scope_1924 = writer.prefix("LicenseModel");
    if let Some(var_1925) = &input.license_model {
        scope_1924.string(var_1925);
    }
    #[allow(unused_mut)]
    let mut scope_1926 = writer.prefix("DBName");
    if let Some(var_1927) = &input.db_name {
        scope_1926.string(var_1927);
    }
    #[allow(unused_mut)]
    let mut scope_1928 = writer.prefix("Engine");
    if let Some(var_1929) = &input.engine {
        scope_1928.string(var_1929);
    }
    #[allow(unused_mut)]
    let mut scope_1930 = writer.prefix("Iops");
    if let Some(var_1931) = &input.iops {
        scope_1930.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1931).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1932 = writer.prefix("OptionGroupName");
    if let Some(var_1933) = &input.option_group_name {
        scope_1932.string(var_1933);
    }
    #[allow(unused_mut)]
    let mut scope_1934 = writer.prefix("CopyTagsToSnapshot");
    if let Some(var_1935) = &input.copy_tags_to_snapshot {
        scope_1934.boolean(*var_1935);
    }
    #[allow(unused_mut)]
    let mut scope_1936 = writer.prefix("Tags");
    if let Some(var_1937) = &input.tags {
        let mut list_1939 = scope_1936.start_list(false, Some("Tag"));
        for item_1938 in var_1937 {
            #[allow(unused_mut)]
            let mut entry_1940 = list_1939.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_1940, item_1938);
        }
        list_1939.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1941 = writer.prefix("StorageType");
    if let Some(var_1942) = &input.storage_type {
        scope_1941.string(var_1942);
    }
    #[allow(unused_mut)]
    let mut scope_1943 = writer.prefix("TdeCredentialArn");
    if let Some(var_1944) = &input.tde_credential_arn {
        scope_1943.string(var_1944);
    }
    #[allow(unused_mut)]
    let mut scope_1945 = writer.prefix("TdeCredentialPassword");
    if let Some(var_1946) = &input.tde_credential_password {
        scope_1945.string(var_1946);
    }
    #[allow(unused_mut)]
    let mut scope_1947 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1948) = &input.vpc_security_group_ids {
        let mut list_1950 = scope_1947.start_list(false, Some("VpcSecurityGroupId"));
        for item_1949 in var_1948 {
            #[allow(unused_mut)]
            let mut entry_1951 = list_1950.entry();
            entry_1951.string(item_1949);
        }
        list_1950.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1952 = writer.prefix("Domain");
    if let Some(var_1953) = &input.domain {
        scope_1952.string(var_1953);
    }
    #[allow(unused_mut)]
    let mut scope_1954 = writer.prefix("DomainIAMRoleName");
    if let Some(var_1955) = &input.domain_iam_role_name {
        scope_1954.string(var_1955);
    }
    #[allow(unused_mut)]
    let mut scope_1956 = writer.prefix("EnableIAMDatabaseAuthentication");
    if let Some(var_1957) = &input.enable_iam_database_authentication {
        scope_1956.boolean(*var_1957);
    }
    #[allow(unused_mut)]
    let mut scope_1958 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_1959) = &input.enable_cloudwatch_logs_exports {
        let mut list_1961 = scope_1958.start_list(false, None);
        for item_1960 in var_1959 {
            #[allow(unused_mut)]
            let mut entry_1962 = list_1961.entry();
            entry_1962.string(item_1960);
        }
        list_1961.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1963 = writer.prefix("ProcessorFeatures");
    if let Some(var_1964) = &input.processor_features {
        let mut list_1966 = scope_1963.start_list(false, Some("ProcessorFeature"));
        for item_1965 in var_1964 {
            #[allow(unused_mut)]
            let mut entry_1967 = list_1966.entry();
            crate::query_ser::serialize_structure_crate_model_processor_feature(
                entry_1967, item_1965,
            );
        }
        list_1966.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1968 = writer.prefix("UseDefaultProcessorFeatures");
    if let Some(var_1969) = &input.use_default_processor_features {
        scope_1968.boolean(*var_1969);
    }
    #[allow(unused_mut)]
    let mut scope_1970 = writer.prefix("DBParameterGroupName");
    if let Some(var_1971) = &input.db_parameter_group_name {
        scope_1970.string(var_1971);
    }
    #[allow(unused_mut)]
    let mut scope_1972 = writer.prefix("DeletionProtection");
    if let Some(var_1973) = &input.deletion_protection {
        scope_1972.boolean(*var_1973);
    }
    #[allow(unused_mut)]
    let mut scope_1974 = writer.prefix("SourceDbiResourceId");
    if let Some(var_1975) = &input.source_dbi_resource_id {
        scope_1974.string(var_1975);
    }
    #[allow(unused_mut)]
    let mut scope_1976 = writer.prefix("MaxAllocatedStorage");
    if let Some(var_1977) = &input.max_allocated_storage {
        scope_1976.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1977).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1978 = writer.prefix("SourceDBInstanceAutomatedBackupsArn");
    if let Some(var_1979) = &input.source_db_instance_automated_backups_arn {
        scope_1978.string(var_1979);
    }
    #[allow(unused_mut)]
    let mut scope_1980 = writer.prefix("EnableCustomerOwnedIp");
    if let Some(var_1981) = &input.enable_customer_owned_ip {
        scope_1980.boolean(*var_1981);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_revoke_db_security_group_ingress(
    input: &crate::input::RevokeDbSecurityGroupIngressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RevokeDBSecurityGroupIngress", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1982 = writer.prefix("DBSecurityGroupName");
    if let Some(var_1983) = &input.db_security_group_name {
        scope_1982.string(var_1983);
    }
    #[allow(unused_mut)]
    let mut scope_1984 = writer.prefix("CIDRIP");
    if let Some(var_1985) = &input.cidrip {
        scope_1984.string(var_1985);
    }
    #[allow(unused_mut)]
    let mut scope_1986 = writer.prefix("EC2SecurityGroupName");
    if let Some(var_1987) = &input.ec2_security_group_name {
        scope_1986.string(var_1987);
    }
    #[allow(unused_mut)]
    let mut scope_1988 = writer.prefix("EC2SecurityGroupId");
    if let Some(var_1989) = &input.ec2_security_group_id {
        scope_1988.string(var_1989);
    }
    #[allow(unused_mut)]
    let mut scope_1990 = writer.prefix("EC2SecurityGroupOwnerId");
    if let Some(var_1991) = &input.ec2_security_group_owner_id {
        scope_1990.string(var_1991);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_activity_stream(
    input: &crate::input::StartActivityStreamInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StartActivityStream", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1992 = writer.prefix("ResourceArn");
    if let Some(var_1993) = &input.resource_arn {
        scope_1992.string(var_1993);
    }
    #[allow(unused_mut)]
    let mut scope_1994 = writer.prefix("Mode");
    if let Some(var_1995) = &input.mode {
        scope_1994.string(var_1995.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_1996 = writer.prefix("KmsKeyId");
    if let Some(var_1997) = &input.kms_key_id {
        scope_1996.string(var_1997);
    }
    #[allow(unused_mut)]
    let mut scope_1998 = writer.prefix("ApplyImmediately");
    if let Some(var_1999) = &input.apply_immediately {
        scope_1998.boolean(*var_1999);
    }
    #[allow(unused_mut)]
    let mut scope_2000 = writer.prefix("EngineNativeAuditFieldsIncluded");
    if let Some(var_2001) = &input.engine_native_audit_fields_included {
        scope_2000.boolean(*var_2001);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_db_cluster(
    input: &crate::input::StartDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StartDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2002 = writer.prefix("DBClusterIdentifier");
    if let Some(var_2003) = &input.db_cluster_identifier {
        scope_2002.string(var_2003);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_db_instance(
    input: &crate::input::StartDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StartDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2004 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_2005) = &input.db_instance_identifier {
        scope_2004.string(var_2005);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_db_instance_automated_backups_replication(
    input: &crate::input::StartDbInstanceAutomatedBackupsReplicationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "StartDBInstanceAutomatedBackupsReplication",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_2006 = writer.prefix("SourceDBInstanceArn");
    if let Some(var_2007) = &input.source_db_instance_arn {
        scope_2006.string(var_2007);
    }
    #[allow(unused_mut)]
    let mut scope_2008 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_2009) = &input.backup_retention_period {
        scope_2008.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_2009).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_2010 = writer.prefix("KmsKeyId");
    if let Some(var_2011) = &input.kms_key_id {
        scope_2010.string(var_2011);
    }
    #[allow(unused_mut)]
    let mut scope_2012 = writer.prefix("PreSignedUrl");
    if let Some(var_2013) = &input.pre_signed_url {
        scope_2012.string(var_2013);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_export_task(
    input: &crate::input::StartExportTaskInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StartExportTask", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2014 = writer.prefix("ExportTaskIdentifier");
    if let Some(var_2015) = &input.export_task_identifier {
        scope_2014.string(var_2015);
    }
    #[allow(unused_mut)]
    let mut scope_2016 = writer.prefix("SourceArn");
    if let Some(var_2017) = &input.source_arn {
        scope_2016.string(var_2017);
    }
    #[allow(unused_mut)]
    let mut scope_2018 = writer.prefix("S3BucketName");
    if let Some(var_2019) = &input.s3_bucket_name {
        scope_2018.string(var_2019);
    }
    #[allow(unused_mut)]
    let mut scope_2020 = writer.prefix("IamRoleArn");
    if let Some(var_2021) = &input.iam_role_arn {
        scope_2020.string(var_2021);
    }
    #[allow(unused_mut)]
    let mut scope_2022 = writer.prefix("KmsKeyId");
    if let Some(var_2023) = &input.kms_key_id {
        scope_2022.string(var_2023);
    }
    #[allow(unused_mut)]
    let mut scope_2024 = writer.prefix("S3Prefix");
    if let Some(var_2025) = &input.s3_prefix {
        scope_2024.string(var_2025);
    }
    #[allow(unused_mut)]
    let mut scope_2026 = writer.prefix("ExportOnly");
    if let Some(var_2027) = &input.export_only {
        let mut list_2029 = scope_2026.start_list(false, None);
        for item_2028 in var_2027 {
            #[allow(unused_mut)]
            let mut entry_2030 = list_2029.entry();
            entry_2030.string(item_2028);
        }
        list_2029.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_stop_activity_stream(
    input: &crate::input::StopActivityStreamInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StopActivityStream", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2031 = writer.prefix("ResourceArn");
    if let Some(var_2032) = &input.resource_arn {
        scope_2031.string(var_2032);
    }
    #[allow(unused_mut)]
    let mut scope_2033 = writer.prefix("ApplyImmediately");
    if let Some(var_2034) = &input.apply_immediately {
        scope_2033.boolean(*var_2034);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_stop_db_cluster(
    input: &crate::input::StopDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StopDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2035 = writer.prefix("DBClusterIdentifier");
    if let Some(var_2036) = &input.db_cluster_identifier {
        scope_2035.string(var_2036);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_stop_db_instance(
    input: &crate::input::StopDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StopDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_2037 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_2038) = &input.db_instance_identifier {
        scope_2037.string(var_2038);
    }
    #[allow(unused_mut)]
    let mut scope_2039 = writer.prefix("DBSnapshotIdentifier");
    if let Some(var_2040) = &input.db_snapshot_identifier {
        scope_2039.string(var_2040);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_stop_db_instance_automated_backups_replication(
    input: &crate::input::StopDbInstanceAutomatedBackupsReplicationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "StopDBInstanceAutomatedBackupsReplication",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_2041 = writer.prefix("SourceDBInstanceArn");
    if let Some(var_2042) = &input.source_db_instance_arn {
        scope_2041.string(var_2042);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDbClusterOutput,
    crate::error::AddRoleToDBClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddRoleToDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterRoleAlreadyExists" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::DbClusterRoleAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_role_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_role_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterRoleQuotaExceeded" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::DbClusterRoleQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_role_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_role_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::AddRoleToDBClusterError {
            meta: generic,
            kind: crate::error::AddRoleToDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddRoleToDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDbClusterOutput,
    crate::error::AddRoleToDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_db_cluster_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDbInstanceOutput,
    crate::error::AddRoleToDBInstanceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddRoleToDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceRoleAlreadyExists" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DbInstanceRoleAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_role_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_role_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceRoleQuotaExceeded" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::DbInstanceRoleQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_role_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_role_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::AddRoleToDBInstanceError {
            meta: generic,
            kind: crate::error::AddRoleToDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddRoleToDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToDbInstanceOutput,
    crate::error::AddRoleToDBInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SourceNotFound" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind: crate::error::AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionNotFound" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind:
                crate::error::AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::subscription_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::AddSourceIdentifierToSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::add_source_identifier_to_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_add_source_identifier_to_subscription(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddTagsToResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddTagsToResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ApplyPendingMaintenanceActionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDBClusterStateFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDbClusterStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDBInstanceState" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDbInstanceStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_instance_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ResourceNotFoundFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ApplyPendingMaintenanceActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::apply_pending_maintenance_action_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_apply_pending_maintenance_action(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_db_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDbSecurityGroupIngressOutput,
    crate::error::AuthorizeDBSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationAlreadyExists" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AuthorizationQuotaExceeded" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSecurityGroupNotFound" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSecurityGroupState" => crate::error::AuthorizeDBSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AuthorizeDBSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_db_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDbSecurityGroupIngressOutput,
    crate::error::AuthorizeDBSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::authorize_db_security_group_ingress_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_authorize_db_security_group_ingress(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AuthorizeDBSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_backtrack_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BacktrackDbClusterOutput,
    crate::error::BacktrackDBClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BacktrackDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::BacktrackDBClusterError {
            meta: generic,
            kind: crate::error::BacktrackDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::BacktrackDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::BacktrackDBClusterError {
            meta: generic,
            kind: crate::error::BacktrackDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::BacktrackDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BacktrackDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_backtrack_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BacktrackDbClusterOutput,
    crate::error::BacktrackDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::backtrack_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_backtrack_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BacktrackDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CancelExportTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelExportTaskError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ExportTaskNotFound" => crate::error::CancelExportTaskError {
            meta: generic,
            kind: crate::error::CancelExportTaskErrorKind::ExportTaskNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::export_task_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_export_task_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidExportTaskStateFault" => crate::error::CancelExportTaskError {
            meta: generic,
            kind: crate::error::CancelExportTaskErrorKind::InvalidExportTaskStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_export_task_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_export_task_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CancelExportTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_export_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_export_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelExportTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CopyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupNotFound" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupQuotaExceeded" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CopyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DBClusterSnapshotNotFoundFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => {
            crate::error::CopyDBClusterSnapshotError {
                meta: generic,
                kind:
                    crate::error::CopyDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "InvalidDBClusterStateFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CopyDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbParameterGroupOutput,
    crate::error::CopyDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBParameterGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => {
            crate::error::CopyDBParameterGroupError {
                meta: generic,
                kind:
                    crate::error::CopyDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "DBParameterGroupNotFound" => crate::error::CopyDBParameterGroupError {
            meta: generic,
            kind: crate::error::CopyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupQuotaExceeded" => {
            crate::error::CopyDBParameterGroupError {
                meta: generic,
                kind:
                    crate::error::CopyDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::CopyDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbParameterGroupOutput,
    crate::error::CopyDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDbSnapshotOutput, crate::error::CopyDBSnapshotError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomAvailabilityZoneNotFound" => {
            crate::error::CopyDBSnapshotError {
                meta: generic,
                kind: crate::error::CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DBSnapshotAlreadyExists" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSnapshotState" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::InvalidDbSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CopyDBSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CopyDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDbSnapshotOutput, crate::error::CopyDBSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyOptionGroupOutput, crate::error::CopyOptionGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyOptionGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OptionGroupAlreadyExistsFault" => crate::error::CopyOptionGroupError {
            meta: generic,
            kind: crate::error::CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::CopyOptionGroupError {
            meta: generic,
            kind: crate::error::CopyOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupQuotaExceededFault" => crate::error::CopyOptionGroupError {
            meta: generic,
            kind: crate::error::CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CopyOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyOptionGroupOutput, crate::error::CopyOptionGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_option_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_option_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_availability_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomAvailabilityZoneOutput,
    crate::error::CreateCustomAvailabilityZoneError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateCustomAvailabilityZoneError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomAvailabilityZoneAlreadyExists" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CustomAvailabilityZoneQuotaExceeded" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::CreateCustomAvailabilityZoneError { meta: generic, kind: crate::error::CreateCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateCustomAvailabilityZoneError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_availability_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomAvailabilityZoneOutput,
    crate::error::CreateCustomAvailabilityZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_custom_availability_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_custom_availability_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCustomAvailabilityZoneError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbClusterOutput, crate::error::CreateDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterParameterGroupNotFound" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterQuotaExceededFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => {
            crate::error::CreateDBClusterError {
                meta: generic,
                kind: crate::error::CreateDBClusterErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DomainNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientStorageClusterCapacity" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbClusterOutput, crate::error::CreateDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterEndpointOutput,
    crate::error::CreateDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterEndpointAlreadyExistsFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterEndpointErrorKind::DbClusterEndpointAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_cluster_endpoint_already_exists_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_cluster_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBClusterEndpointQuotaExceededFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterEndpointErrorKind::DbClusterEndpointQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_cluster_endpoint_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::CreateDBClusterEndpointError {
            meta: generic,
            kind: crate::error::CreateDBClusterEndpointErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterEndpointOutput,
    crate::error::CreateDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupQuotaExceeded" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbInstanceOutput, crate::error::CreateDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::backup_policy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceAlreadyExists" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSecurityGroupNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DomainNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InstanceQuotaExceeded" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InstanceQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InsufficientDbInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::provisioned_iops_not_available_in_az_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageTypeNotSupported" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbInstanceOutput, crate::error::CreateDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_read_replica_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbInstanceReadReplicaOutput,
    crate::error::CreateDBInstanceReadReplicaError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBInstanceReadReplicaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceAlreadyExists" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceNotFound" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbInstanceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupNotFound" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSecurityGroupNotFound" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotAllowedFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotAllowedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_allowed_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_allowed_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InstanceQuotaExceeded" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBInstanceCapacity" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InsufficientDbInstanceCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceState" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidDbInstanceStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSubnetGroupFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidDbSubnetGroupFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_subnet_group_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OptionGroupNotFoundFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAzFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageTypeNotSupported" => crate::error::CreateDBInstanceReadReplicaError { meta: generic, kind: crate::error::CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDBInstanceReadReplicaError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_read_replica_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbInstanceReadReplicaOutput,
    crate::error::CreateDBInstanceReadReplicaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_instance_read_replica_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_instance_read_replica(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBInstanceReadReplicaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbParameterGroupOutput,
    crate::error::CreateDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => crate::error::CreateDBParameterGroupError {
            meta: generic,
            kind: crate::error::CreateDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_already_exists_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DBParameterGroupQuotaExceeded" => crate::error::CreateDBParameterGroupError {
            meta: generic,
            kind: crate::error::CreateDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_quota_exceeded_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::CreateDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbParameterGroupOutput,
    crate::error::CreateDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbProxyOutput, crate::error::CreateDBProxyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBProxyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyAlreadyExistsFault" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::DbProxyAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyQuotaExceededFault" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::DbProxyQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBProxyError {
            meta: generic,
            kind: crate::error::CreateDBProxyErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbProxyOutput, crate::error::CreateDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_proxy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_proxy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbProxyEndpointOutput,
    crate::error::CreateDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBProxyEndpointError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyEndpointAlreadyExistsFault" => {
            crate::error::CreateDBProxyEndpointError {
                meta: generic,
                kind:
                    crate::error::CreateDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_proxy_endpoint_already_exists_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "DBProxyEndpointQuotaExceededFault" => {
            crate::error::CreateDBProxyEndpointError {
                meta: generic,
                kind:
                    crate::error::CreateDBProxyEndpointErrorKind::DbProxyEndpointQuotaExceededFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "DBProxyNotFoundFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBProxyEndpointError {
            meta: generic,
            kind: crate::error::CreateDBProxyEndpointErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbProxyEndpointOutput,
    crate::error::CreateDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSecurityGroupOutput,
    crate::error::CreateDBSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSecurityGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSecurityGroupAlreadyExists" => {
            crate::error::CreateDBSecurityGroupError {
                meta: generic,
                kind:
                    crate::error::CreateDBSecurityGroupErrorKind::DbSecurityGroupAlreadyExistsFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_security_group_already_exists_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_security_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "DBSecurityGroupNotSupported" => crate::error::CreateDBSecurityGroupError {
            meta: generic,
            kind: crate::error::CreateDBSecurityGroupErrorKind::DbSecurityGroupNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "QuotaExceeded.DBSecurityGroup" => {
            crate::error::CreateDBSecurityGroupError {
                meta: generic,
                kind:
                    crate::error::CreateDBSecurityGroupErrorKind::DbSecurityGroupQuotaExceededFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_security_group_quota_exceeded_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_security_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::CreateDBSecurityGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSecurityGroupOutput,
    crate::error::CreateDBSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_security_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_security_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSecurityGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbSnapshotOutput, crate::error::CreateDBSnapshotError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotAlreadyExists" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CreateDBSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbSnapshotOutput, crate::error::CreateDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupAlreadyExists" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupQuotaExceeded" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetQuotaExceededFault" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EventSubscriptionQuotaExceeded" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::event_subscription_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SNSInvalidTopic" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionAlreadyExist" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::subscription_already_exist_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_already_exist_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::CreateEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterAlreadyExistsFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterQuotaExceededFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOptionGroupOutput, crate::error::CreateOptionGroupError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOptionGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OptionGroupAlreadyExistsFault" => crate::error::CreateOptionGroupError {
            meta: generic,
            kind: crate::error::CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupQuotaExceededFault" => crate::error::CreateOptionGroupError {
            meta: generic,
            kind: crate::error::CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::option_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOptionGroupOutput, crate::error::CreateOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_option_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_option_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_availability_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomAvailabilityZoneOutput,
    crate::error::DeleteCustomAvailabilityZoneError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteCustomAvailabilityZoneError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomAvailabilityZoneNotFound" => crate::error::DeleteCustomAvailabilityZoneError { meta: generic, kind: crate::error::DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::DeleteCustomAvailabilityZoneError { meta: generic, kind: crate::error::DeleteCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteCustomAvailabilityZoneError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_availability_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomAvailabilityZoneOutput,
    crate::error::DeleteCustomAvailabilityZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_custom_availability_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_custom_availability_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCustomAvailabilityZoneError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbClusterOutput, crate::error::DeleteDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DbClusterSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDbClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbClusterOutput, crate::error::DeleteDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterEndpointOutput,
    crate::error::DeleteDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterEndpointNotFoundFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterEndpointStateFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::DeleteDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBClusterEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBClusterEndpointErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterEndpointOutput,
    crate::error::DeleteDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::DeleteDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DeleteDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbInstanceOutput, crate::error::DeleteDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceAutomatedBackupQuotaExceeded" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind:
                crate::error::DeleteDBInstanceErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_instance_automated_backup_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBInstanceNotFound" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotAlreadyExists" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DbSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbInstanceOutput, crate::error::DeleteDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_automated_backup_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbInstanceAutomatedBackupOutput,
    crate::error::DeleteDBInstanceAutomatedBackupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceAutomatedBackupNotFound" => crate::error::DeleteDBInstanceAutomatedBackupError { meta: generic, kind: crate::error::DeleteDBInstanceAutomatedBackupErrorKind::DbInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceAutomatedBackupState" => crate::error::DeleteDBInstanceAutomatedBackupError { meta: generic, kind: crate::error::DeleteDBInstanceAutomatedBackupErrorKind::InvalidDbInstanceAutomatedBackupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_automated_backup_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_automated_backup_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDBInstanceAutomatedBackupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_automated_backup_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbInstanceAutomatedBackupOutput,
    crate::error::DeleteDBInstanceAutomatedBackupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_db_instance_automated_backup_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_db_instance_automated_backup(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteDBInstanceAutomatedBackupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbParameterGroupOutput,
    crate::error::DeleteDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DeleteDBParameterGroupError {
            meta: generic,
            kind: crate::error::DeleteDBParameterGroupErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBParameterGroupState" => {
            crate::error::DeleteDBParameterGroupError {
                meta: generic,
                kind:
                    crate::error::DeleteDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBParameterGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::DeleteDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbParameterGroupOutput,
    crate::error::DeleteDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbProxyOutput, crate::error::DeleteDBProxyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBProxyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DeleteDBProxyError {
            meta: generic,
            kind: crate::error::DeleteDBProxyErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DeleteDBProxyError {
            meta: generic,
            kind: crate::error::DeleteDBProxyErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbProxyOutput, crate::error::DeleteDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_proxy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_proxy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbProxyEndpointOutput,
    crate::error::DeleteDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBProxyEndpointError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyEndpointNotFoundFault" => crate::error::DeleteDBProxyEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyEndpointStateFault" => crate::error::DeleteDBProxyEndpointError {
            meta: generic,
            kind: crate::error::DeleteDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbProxyEndpointOutput,
    crate::error::DeleteDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSecurityGroupOutput,
    crate::error::DeleteDBSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSecurityGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSecurityGroupNotFound" => crate::error::DeleteDBSecurityGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSecurityGroupErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSecurityGroupState" => crate::error::DeleteDBSecurityGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSecurityGroupErrorKind::InvalidDbSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSecurityGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBSecurityGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSecurityGroupOutput,
    crate::error::DeleteDBSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_security_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbSnapshotOutput, crate::error::DeleteDBSnapshotError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSnapshotNotFound" => crate::error::DeleteDBSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBSnapshotErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSnapshotState" => crate::error::DeleteDBSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBSnapshotErrorKind::InvalidDbSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbSnapshotOutput, crate::error::DeleteDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetStateFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDbSubnetStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_subnet_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidEventSubscriptionState" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_event_subscription_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_event_subscription_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SubscriptionNotFound" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind: crate::error::DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DeleteGlobalClusterError {
            meta: generic,
            kind: crate::error::DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::DeleteGlobalClusterError {
            meta: generic,
            kind: crate::error::DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstallationMediaOutput,
    crate::error::DeleteInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteInstallationMediaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InstallationMediaNotFound" => crate::error::DeleteInstallationMediaError {
            meta: generic,
            kind: crate::error::DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::installation_media_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_installation_media_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstallationMediaOutput,
    crate::error::DeleteInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOptionGroupOutput, crate::error::DeleteOptionGroupError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteOptionGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOptionGroupStateFault" => crate::error::DeleteOptionGroupError {
            meta: generic,
            kind: crate::error::DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_option_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_option_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::DeleteOptionGroupError {
            meta: generic,
            kind: crate::error::DeleteOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOptionGroupOutput, crate::error::DeleteOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_option_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterDbProxyTargetsOutput,
    crate::error::DeregisterDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DBProxyTargetNotFoundFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DeregisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DeregisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeregisterDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterDbProxyTargetsOutput,
    crate::error::DeregisterDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_db_proxy_targets_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
    Err(crate::error::DescribeAccountAttributesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_account_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCertificatesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CertificateNotFound" => crate::error::DescribeCertificatesError {
            meta: generic,
            kind: crate::error::DescribeCertificatesErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_custom_availability_zones_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomAvailabilityZonesOutput,
    crate::error::DescribeCustomAvailabilityZonesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCustomAvailabilityZonesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomAvailabilityZoneNotFound" => crate::error::DescribeCustomAvailabilityZonesError { meta: generic, kind: crate::error::DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeCustomAvailabilityZonesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_custom_availability_zones_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomAvailabilityZonesOutput,
    crate::error::DescribeCustomAvailabilityZonesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_custom_availability_zones_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_custom_availability_zones(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeCustomAvailabilityZonesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_backtracks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterBacktracksOutput,
    crate::error::DescribeDBClusterBacktracksError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterBacktracksError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterBacktrackNotFoundFault" => crate::error::DescribeDBClusterBacktracksError {
            meta: generic,
            kind:
                crate::error::DescribeDBClusterBacktracksErrorKind::DbClusterBacktrackNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_cluster_backtrack_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_cluster_backtrack_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBClusterNotFoundFault" => crate::error::DescribeDBClusterBacktracksError {
            meta: generic,
            kind: crate::error::DescribeDBClusterBacktracksErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBClusterBacktracksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_backtracks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterBacktracksOutput,
    crate::error::DescribeDBClusterBacktracksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_backtracks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_backtracks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterBacktracksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterEndpointsOutput,
    crate::error::DescribeDBClusterEndpointsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterEndpointsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DescribeDBClusterEndpointsError {
            meta: generic,
            kind: crate::error::DescribeDBClusterEndpointsErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBClusterEndpointsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterEndpointsOutput,
    crate::error::DescribeDBClusterEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterEndpointsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParameterGroupsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBClusterParameterGroupsError { meta: generic, kind: crate::error::DescribeDBClusterParameterGroupsErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDBClusterParameterGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_parameter_groups_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_parameter_groups(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParametersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBClusterParametersError {
            meta: generic,
            kind: crate::error::DescribeDBClusterParametersErrorKind::DbParameterGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDBClusterParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBClustersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DescribeDBClustersError {
            meta: generic,
            kind: crate::error::DescribeDBClustersErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotAttributesError { meta: generic, kind: crate::error::DescribeDBClusterSnapshotAttributesErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDBClusterSnapshotAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_snapshot_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_snapshot_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeDBClusterSnapshotsErrorKind::DbClusterSnapshotNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDBClusterSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
    Err(crate::error::DescribeDBEngineVersionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_engine_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_engine_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instance_automated_backups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstanceAutomatedBackupsOutput,
    crate::error::DescribeDBInstanceAutomatedBackupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceAutomatedBackupNotFound" => crate::error::DescribeDBInstanceAutomatedBackupsError { meta: generic, kind: crate::error::DescribeDBInstanceAutomatedBackupsErrorKind::DbInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDBInstanceAutomatedBackupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instance_automated_backups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstanceAutomatedBackupsOutput,
    crate::error::DescribeDBInstanceAutomatedBackupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_instance_automated_backups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_instance_automated_backups(response.body().as_ref(), output).map_err(crate::error::DescribeDBInstanceAutomatedBackupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DescribeDBInstancesError {
            meta: generic,
            kind: crate::error::DescribeDBInstancesErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_log_files_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbLogFilesOutput,
    crate::error::DescribeDBLogFilesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBLogFilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DescribeDBLogFilesError {
            meta: generic,
            kind: crate::error::DescribeDBLogFilesErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBLogFilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_log_files_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbLogFilesOutput,
    crate::error::DescribeDBLogFilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_log_files_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_log_files(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBLogFilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbParameterGroupsOutput,
    crate::error::DescribeDBParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBParameterGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBParameterGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBParameterGroupsErrorKind::DbParameterGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDBParameterGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbParameterGroupsOutput,
    crate::error::DescribeDBParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_parameter_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_parameter_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbParametersOutput,
    crate::error::DescribeDBParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBParametersError {
            meta: generic,
            kind: crate::error::DescribeDBParametersErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbParametersOutput,
    crate::error::DescribeDBParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDbProxiesOutput, crate::error::DescribeDBProxiesError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBProxiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBProxiesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxiesError {
            meta: generic,
            kind: crate::error::DescribeDBProxiesErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBProxiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDbProxiesOutput, crate::error::DescribeDBProxiesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_proxies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyEndpointsOutput,
    crate::error::DescribeDBProxyEndpointsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyEndpointsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyEndpointNotFoundFault" => crate::error::DescribeDBProxyEndpointsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyEndpointsErrorKind::DbProxyEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyEndpointsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyEndpointsErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBProxyEndpointsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyEndpointsOutput,
    crate::error::DescribeDBProxyEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_proxy_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyEndpointsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_target_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyTargetGroupsOutput,
    crate::error::DescribeDBProxyTargetGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyTargetGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetGroupsErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind:
                crate::error::DescribeDBProxyTargetGroupsErrorKind::DbProxyTargetGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBProxyStateFault" => crate::error::DescribeDBProxyTargetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetGroupsErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBProxyTargetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_target_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyTargetGroupsOutput,
    crate::error::DescribeDBProxyTargetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_target_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_proxy_target_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyTargetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyTargetsOutput,
    crate::error::DescribeDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetNotFoundFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::DescribeDBProxyTargetsError {
            meta: generic,
            kind: crate::error::DescribeDBProxyTargetsErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbProxyTargetsOutput,
    crate::error::DescribeDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_proxy_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_proxy_targets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBProxyTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_security_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSecurityGroupsOutput,
    crate::error::DescribeDBSecurityGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSecurityGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSecurityGroupNotFound" => crate::error::DescribeDBSecurityGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBSecurityGroupsErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBSecurityGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_security_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSecurityGroupsOutput,
    crate::error::DescribeDBSecurityGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_security_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSecurityGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshot_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSnapshotAttributesOutput,
    crate::error::DescribeDBSnapshotAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSnapshotAttributesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSnapshotNotFound" => crate::error::DescribeDBSnapshotAttributesError {
            meta: generic,
            kind: crate::error::DescribeDBSnapshotAttributesErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBSnapshotAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshot_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSnapshotAttributesOutput,
    crate::error::DescribeDBSnapshotAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_snapshot_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_snapshot_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSnapshotAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSnapshotsOutput,
    crate::error::DescribeDBSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBSnapshotsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSnapshotNotFound" => crate::error::DescribeDBSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeDBSnapshotsErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSnapshotsOutput,
    crate::error::DescribeDBSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSubnetGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DescribeDBSubnetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBSubnetGroupsErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBSubnetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_subnet_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_subnet_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
    Err(crate::error::DescribeEngineDefaultClusterParametersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_engine_default_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_engine_default_cluster_parameters(response.body().as_ref(), output).map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultParametersOutput,
    crate::error::DescribeEngineDefaultParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEngineDefaultParametersError::unhandled)?;
    Err(crate::error::DescribeEngineDefaultParametersError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultParametersOutput,
    crate::error::DescribeEngineDefaultParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_engine_default_parameters_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_engine_default_parameters(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeEngineDefaultParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
    Err(crate::error::DescribeEventCategoriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_categories_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_categories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventsError::unhandled)?;
    Err(crate::error::DescribeEventsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_events_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEventSubscriptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SubscriptionNotFound" => crate::error::DescribeEventSubscriptionsError {
            meta: generic,
            kind: crate::error::DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeEventSubscriptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_subscriptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeExportTasksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ExportTaskNotFound" => crate::error::DescribeExportTasksError {
            meta: generic,
            kind: crate::error::DescribeExportTasksErrorKind::ExportTaskNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::export_task_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_export_task_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeExportTasksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeExportTasksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_export_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeGlobalClustersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DescribeGlobalClustersError {
            meta: generic,
            kind: crate::error::DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeGlobalClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_global_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_global_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstallationMediaOutput,
    crate::error::DescribeInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstallationMediaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InstallationMediaNotFound" => crate::error::DescribeInstallationMediaError {
            meta: generic,
            kind: crate::error::DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::installation_media_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_installation_media_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstallationMediaOutput,
    crate::error::DescribeInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_group_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupOptionsOutput,
    crate::error::DescribeOptionGroupOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOptionGroupOptionsError::unhandled)?;
    Err(crate::error::DescribeOptionGroupOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_group_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupOptionsOutput,
    crate::error::DescribeOptionGroupOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_option_group_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_option_group_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOptionGroupOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupsOutput,
    crate::error::DescribeOptionGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeOptionGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OptionGroupNotFoundFault" => crate::error::DescribeOptionGroupsError {
            meta: generic,
            kind: crate::error::DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeOptionGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_option_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOptionGroupsOutput,
    crate::error::DescribeOptionGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_option_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_option_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOptionGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDbInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
    Err(crate::error::DescribeOrderableDBInstanceOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDbInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_orderable_db_instance_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_orderable_db_instance_options(response.body().as_ref(), output).map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePendingMaintenanceActionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundFault" => crate::error::DescribePendingMaintenanceActionsError {
            meta: generic,
            kind: crate::error::DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribePendingMaintenanceActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_pending_maintenance_actions_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_pending_maintenance_actions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDbInstancesOutput,
    crate::error::DescribeReservedDBInstancesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReservedDBInstancesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReservedDBInstanceNotFound" => crate::error::DescribeReservedDBInstancesError {
            meta: generic,
            kind:
                crate::error::DescribeReservedDBInstancesErrorKind::ReservedDbInstanceNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::reserved_db_instance_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_reserved_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeReservedDBInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDbInstancesOutput,
    crate::error::DescribeReservedDBInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_db_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_db_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReservedDBInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDbInstancesOfferingsOutput,
    crate::error::DescribeReservedDBInstancesOfferingsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReservedDBInstancesOfferingNotFound" => crate::error::DescribeReservedDBInstancesOfferingsError { meta: generic, kind: crate::error::DescribeReservedDBInstancesOfferingsErrorKind::ReservedDbInstancesOfferingNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_db_instances_offering_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_db_instances_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeReservedDBInstancesOfferingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_db_instances_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedDbInstancesOfferingsOutput,
    crate::error::DescribeReservedDBInstancesOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_reserved_db_instances_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_db_instances_offerings(response.body().as_ref(), output).map_err(crate::error::DescribeReservedDBInstancesOfferingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_regions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceRegionsOutput,
    crate::error::DescribeSourceRegionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeSourceRegionsError::unhandled)?;
    Err(crate::error::DescribeSourceRegionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_regions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceRegionsOutput,
    crate::error::DescribeSourceRegionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_source_regions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_source_regions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSourceRegionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_valid_db_instance_modifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeValidDbInstanceModificationsOutput,
    crate::error::DescribeValidDBInstanceModificationsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeValidDBInstanceModificationsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DescribeValidDBInstanceModificationsError { meta: generic, kind: crate::error::DescribeValidDBInstanceModificationsErrorKind::DbInstanceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceState" => crate::error::DescribeValidDBInstanceModificationsError { meta: generic, kind: crate::error::DescribeValidDBInstanceModificationsErrorKind::InvalidDbInstanceStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeValidDBInstanceModificationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_valid_db_instance_modifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeValidDbInstanceModificationsOutput,
    crate::error::DescribeValidDBInstanceModificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_valid_db_instance_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_valid_db_instance_modifications(response.body().as_ref(), output).map_err(crate::error::DescribeValidDBInstanceModificationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_download_db_log_file_portion_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DownloadDbLogFilePortionOutput,
    crate::error::DownloadDBLogFilePortionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DownloadDBLogFilePortionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DownloadDBLogFilePortionError {
            meta: generic,
            kind: crate::error::DownloadDBLogFilePortionErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBLogFileNotFoundFault" => crate::error::DownloadDBLogFilePortionError {
            meta: generic,
            kind: crate::error::DownloadDBLogFilePortionErrorKind::DbLogFileNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_log_file_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_log_file_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DownloadDBLogFilePortionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_download_db_log_file_portion_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DownloadDbLogFilePortionOutput,
    crate::error::DownloadDBLogFilePortionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::download_db_log_file_portion_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_download_db_log_file_portion(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DownloadDBLogFilePortionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDbClusterOutput, crate::error::FailoverDBClusterError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::FailoverDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FailoverDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::FailoverDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDbClusterOutput, crate::error::FailoverDBClusterError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::failover_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_failover_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::FailoverDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FailoverGlobalClusterOutput,
    crate::error::FailoverGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FailoverGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::FailoverGlobalClusterError {
            meta: generic,
            kind: crate::error::FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::FailoverGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FailoverGlobalClusterOutput,
    crate::error::FailoverGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::failover_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_failover_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::FailoverGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_installation_media_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportInstallationMediaOutput,
    crate::error::ImportInstallationMediaError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ImportInstallationMediaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ImportInstallationMediaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomAvailabilityZoneNotFound" => crate::error::ImportInstallationMediaError {
            meta: generic,
            kind:
                crate::error::ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::custom_availability_zone_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_custom_availability_zone_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportInstallationMediaError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InstallationMediaAlreadyExists" => crate::error::ImportInstallationMediaError {
            meta: generic,
            kind:
                crate::error::ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::installation_media_already_exists_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_installation_media_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportInstallationMediaError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ImportInstallationMediaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_installation_media_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportInstallationMediaOutput,
    crate::error::ImportInstallationMediaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_installation_media_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_installation_media(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportInstallationMediaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCertificatesOutput,
    crate::error::ModifyCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyCertificatesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CertificateNotFound" => crate::error::ModifyCertificatesError {
            meta: generic,
            kind: crate::error::ModifyCertificatesErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCertificatesOutput,
    crate::error::ModifyCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_current_db_cluster_capacity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCurrentDbClusterCapacityOutput,
    crate::error::ModifyCurrentDBClusterCapacityError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind: crate::error::ModifyCurrentDBClusterCapacityErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterCapacityFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind:
                crate::error::ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterCapacityFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_db_cluster_capacity_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyCurrentDBClusterCapacityError {
            meta: generic,
            kind: crate::error::ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::ModifyCurrentDBClusterCapacityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_current_db_cluster_capacity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCurrentDbClusterCapacityOutput,
    crate::error::ModifyCurrentDBClusterCapacityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_current_db_cluster_capacity_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_current_db_cluster_capacity(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyCurrentDBClusterCapacityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbClusterOutput, crate::error::ModifyDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterParameterGroupNotFound" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DomainNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSecurityGroupState" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbClusterOutput, crate::error::ModifyDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterEndpointOutput,
    crate::error::ModifyDBClusterEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterEndpointError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterEndpointNotFoundFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterEndpointStateFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind:
                crate::error::ModifyDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyDBClusterEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBClusterEndpointErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBClusterEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterEndpointOutput,
    crate::error::ModifyDBClusterEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_cluster_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_cluster_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SharedSnapshotQuotaExceeded" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::shared_snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_shared_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyDBClusterSnapshotAttributeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_snapshot_attribute_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_db_cluster_snapshot_attribute(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbInstanceOutput, crate::error::ModifyDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::backup_policy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CertificateNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceAlreadyExists" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSecurityGroupNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBUpgradeDependencyFailure" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbUpgradeDependencyFailureFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_upgrade_dependency_failure_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_upgrade_dependency_failure_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DomainNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DomainNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InsufficientDbInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSecurityGroupState" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDbSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::provisioned_iops_not_available_in_az_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageTypeNotSupported" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbInstanceOutput, crate::error::ModifyDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbParameterGroupOutput,
    crate::error::ModifyDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ModifyDBParameterGroupError {
            meta: generic,
            kind: crate::error::ModifyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBParameterGroupState" => {
            crate::error::ModifyDBParameterGroupError {
                meta: generic,
                kind:
                    crate::error::ModifyDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::ModifyDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbParameterGroupOutput,
    crate::error::ModifyDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbProxyOutput, crate::error::ModifyDBProxyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBProxyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBProxyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyAlreadyExistsFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::DbProxyAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyError {
            meta: generic,
            kind: crate::error::ModifyDBProxyErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBProxyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbProxyOutput, crate::error::ModifyDBProxyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_proxy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBProxyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbProxyEndpointOutput,
    crate::error::ModifyDBProxyEndpointError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBProxyEndpointError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyEndpointAlreadyExistsFault" => {
            crate::error::ModifyDBProxyEndpointError {
                meta: generic,
                kind:
                    crate::error::ModifyDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::db_proxy_endpoint_already_exists_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "DBProxyEndpointNotFoundFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyEndpointStateFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyEndpointError {
            meta: generic,
            kind: crate::error::ModifyDBProxyEndpointErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBProxyEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbProxyEndpointOutput,
    crate::error::ModifyDBProxyEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_proxy_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBProxyEndpointError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_target_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbProxyTargetGroupOutput,
    crate::error::ModifyDBProxyTargetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBProxyTargetGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBProxyNotFoundFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::DbProxyTargetGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDBProxyStateFault" => crate::error::ModifyDBProxyTargetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBProxyTargetGroupErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBProxyTargetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_proxy_target_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbProxyTargetGroupOutput,
    crate::error::ModifyDBProxyTargetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_proxy_target_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_proxy_target_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBProxyTargetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbSnapshotOutput, crate::error::ModifyDBSnapshotError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSnapshotNotFound" => crate::error::ModifyDBSnapshotError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbSnapshotOutput, crate::error::ModifyDBSnapshotError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSnapshotAttributeOutput,
    crate::error::ModifyDBSnapshotAttributeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBSnapshotAttributeError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSnapshotNotFound" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotAttributeErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSnapshotState" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind: crate::error::ModifyDBSnapshotAttributeErrorKind::InvalidDbSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SharedSnapshotQuotaExceeded" => crate::error::ModifyDBSnapshotAttributeError {
            meta: generic,
            kind:
                crate::error::ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::shared_snapshot_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_shared_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ModifyDBSnapshotAttributeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSnapshotAttributeOutput,
    crate::error::ModifyDBSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_snapshot_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_snapshot_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSnapshotAttributeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetQuotaExceededFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubnetAlreadyInUse" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subnet_already_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subnet_already_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EventSubscriptionQuotaExceeded" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::event_subscription_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SNSInvalidTopic" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_option_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyOptionGroupOutput, crate::error::ModifyOptionGroupError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyOptionGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOptionGroupStateFault" => crate::error::ModifyOptionGroupError {
            meta: generic,
            kind: crate::error::ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_option_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_option_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::ModifyOptionGroupError {
            meta: generic,
            kind: crate::error::ModifyOptionGroupErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyOptionGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyOptionGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_option_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyOptionGroupOutput, crate::error::ModifyOptionGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_option_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_option_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyOptionGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaOutput,
    crate::error::PromoteReadReplicaError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PromoteReadReplicaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::PromoteReadReplicaError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PromoteReadReplicaError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::PromoteReadReplicaError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PromoteReadReplicaError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PromoteReadReplicaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaOutput,
    crate::error::PromoteReadReplicaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::promote_read_replica_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_promote_read_replica(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PromoteReadReplicaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaDbClusterOutput,
    crate::error::PromoteReadReplicaDBClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PromoteReadReplicaDBClusterError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::PromoteReadReplicaDBClusterError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::PromoteReadReplicaDBClusterError {
            meta: generic,
            kind: crate::error::PromoteReadReplicaDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PromoteReadReplicaDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_promote_read_replica_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PromoteReadReplicaDbClusterOutput,
    crate::error::PromoteReadReplicaDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::promote_read_replica_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_promote_read_replica_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PromoteReadReplicaDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_db_instances_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedDbInstancesOfferingOutput,
    crate::error::PurchaseReservedDBInstancesOfferingError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReservedDBInstanceAlreadyExists" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedDBInstanceQuotaExceeded" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_db_instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_db_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedDBInstancesOfferingNotFound" => crate::error::PurchaseReservedDBInstancesOfferingError { meta: generic, kind: crate::error::PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstancesOfferingNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_db_instances_offering_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_db_instances_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PurchaseReservedDBInstancesOfferingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_db_instances_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedDbInstancesOfferingOutput,
    crate::error::PurchaseReservedDBInstancesOfferingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::purchase_reserved_db_instances_offering_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_reserved_db_instances_offering(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedDBInstancesOfferingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDbInstanceOutput, crate::error::RebootDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RebootDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RebootDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RebootDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDbInstanceOutput, crate::error::RebootDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reboot_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RebootDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_db_proxy_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDbProxyTargetsOutput,
    crate::error::RegisterDBProxyTargetsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterDBProxyTargetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetAlreadyRegisteredFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind:
                crate::error::RegisterDBProxyTargetsErrorKind::DbProxyTargetAlreadyRegisteredFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_proxy_target_already_registered_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_already_registered_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientAvailableIPsInSubnetFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind:
                crate::error::RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::insufficient_available_i_ps_in_subnet_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_insufficient_available_i_ps_in_subnet_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBProxyStateFault" => crate::error::RegisterDBProxyTargetsError {
            meta: generic,
            kind: crate::error::RegisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_db_proxy_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_proxy_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RegisterDBProxyTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_db_proxy_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDbProxyTargetsOutput,
    crate::error::RegisterDBProxyTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_db_proxy_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_db_proxy_targets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RegisterDBProxyTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveFromGlobalClusterError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveFromGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_from_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_remove_from_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDbClusterOutput,
    crate::error::RemoveRoleFromDBClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromDBClusterError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterRoleNotFound" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::DbClusterRoleNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_role_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_role_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::RemoveRoleFromDBClusterError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveRoleFromDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDbClusterOutput,
    crate::error::RemoveRoleFromDBClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_role_from_db_cluster_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDbInstanceOutput,
    crate::error::RemoveRoleFromDBInstanceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromDBInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::RemoveRoleFromDBInstanceError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceRoleNotFound" => crate::error::RemoveRoleFromDBInstanceError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBInstanceErrorKind::DbInstanceRoleNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_role_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_role_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::RemoveRoleFromDBInstanceError {
            meta: generic,
            kind: crate::error::RemoveRoleFromDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveRoleFromDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromDbInstanceOutput,
    crate::error::RemoveRoleFromDBInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_role_from_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SourceNotFound" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SubscriptionNotFound" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RemoveSourceIdentifierFromSubscriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_source_identifier_from_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_remove_source_identifier_from_subscription(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbProxyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_proxy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBProxyTargetGroupNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbProxyTargetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_proxy_target_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_proxy_target_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveTagsFromResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ResetDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ResetDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_reset_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbParameterGroupOutput,
    crate::error::ResetDBParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetDBParameterGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ResetDBParameterGroupError {
            meta: generic,
            kind: crate::error::ResetDBParameterGroupErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBParameterGroupState" => {
            crate::error::ResetDBParameterGroupError {
                meta: generic,
                kind:
                    crate::error::ResetDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::ResetDBParameterGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbParameterGroupOutput,
    crate::error::ResetDBParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_db_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_db_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetDBParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_s3_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromS3Output,
    crate::error::RestoreDBClusterFromS3Error,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterFromS3Error::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DbClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DbClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterParameterGroupNotFound" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DbClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DbClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientStorageClusterCapacity" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidDbClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSubnetGroupStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidDbSubnetGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidS3BucketFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_bucket_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBClusterFromS3Error { meta: generic, kind: crate::error::RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBClusterFromS3Error::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_s3_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromS3Output,
    crate::error::RestoreDBClusterFromS3Error,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_cluster_from_s3_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_db_cluster_from_s3(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBClusterFromS3Error::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterFromSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterParameterGroupNotFound" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSnapshotNotFound" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientDbClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientStorageClusterCapacity" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSnapshotState" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDbSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBClusterFromSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_cluster_from_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_cluster_from_snapshot(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterToPointInTimeError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterParameterGroupNotFound" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientDbClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientStorageClusterCapacity" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSnapshotState" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBClusterToPointInTimeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_cluster_to_point_in_time_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_cluster_to_point_in_time(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_db_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceFromDbSnapshotOutput,
    crate::error::RestoreDBInstanceFromDBSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceAlreadyExists" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupNotFound" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSecurityGroupNotFound" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSnapshotNotFound" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InstanceQuotaExceeded" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBInstanceCapacity" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDbInstanceCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSnapshotState" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDbSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAzFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageTypeNotSupported" => crate::error::RestoreDBInstanceFromDBSnapshotError { meta: generic, kind: crate::error::RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBInstanceFromDBSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_db_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceFromDbSnapshotOutput,
    crate::error::RestoreDBInstanceFromDBSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_instance_from_db_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_instance_from_db_snapshot(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBInstanceFromDBSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_s3_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceFromS3Output,
    crate::error::RestoreDBInstanceFromS3Error,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBInstanceFromS3Error::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::backup_policy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceAlreadyExists" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DbInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupNotFound" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSecurityGroupNotFound" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InstanceQuotaExceeded" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::InsufficientDbInstanceCapacityFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidS3BucketFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_bucket_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind:
                crate::error::RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAzFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "StorageQuotaExceeded" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageTypeNotSupported" => crate::error::RestoreDBInstanceFromS3Error {
            meta: generic,
            kind: crate::error::RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RestoreDBInstanceFromS3Error::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_from_s3_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceFromS3Output,
    crate::error::RestoreDBInstanceFromS3Error,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_instance_from_s3_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_db_instance_from_s3(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreDBInstanceFromS3Error::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_to_point_in_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceToPointInTimeOutput,
    crate::error::RestoreDBInstanceToPointInTimeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BackupPolicyNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::backup_policy_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_backup_policy_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceAlreadyExists" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceAutomatedBackupNotFound" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAutomatedBackupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_automated_backup_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceNotFound" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbInstanceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupNotFound" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSecurityGroupNotFound" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DomainNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::domain_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_domain_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InstanceQuotaExceeded" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBInstanceCapacity" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InsufficientDbInstanceCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceState" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidDbInstanceStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OptionGroupNotFoundFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::option_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_option_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PointInTimeRestoreNotEnabled" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::point_in_time_restore_not_enabled_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_point_in_time_restore_not_enabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProvisionedIopsNotAvailableInAZFault" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAzFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::provisioned_iops_not_available_in_az_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_provisioned_iops_not_available_in_az_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageTypeNotSupported" => crate::error::RestoreDBInstanceToPointInTimeError { meta: generic, kind: crate::error::RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBInstanceToPointInTimeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_instance_to_point_in_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbInstanceToPointInTimeOutput,
    crate::error::RestoreDBInstanceToPointInTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_instance_to_point_in_time_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_instance_to_point_in_time(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBInstanceToPointInTimeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_db_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeDbSecurityGroupIngressOutput,
    crate::error::RevokeDBSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RevokeDBSecurityGroupIngressError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSecurityGroupNotFound" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSecurityGroupState" => crate::error::RevokeDBSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RevokeDBSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_db_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeDbSecurityGroupIngressOutput,
    crate::error::RevokeDBSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_db_security_group_ingress_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_revoke_db_security_group_ingress(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RevokeDBSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_activity_stream_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartActivityStreamOutput,
    crate::error::StartActivityStreamError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartActivityStreamError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartActivityStreamError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundFault" => crate::error::StartActivityStreamError {
            meta: generic,
            kind: crate::error::StartActivityStreamErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartActivityStreamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_activity_stream_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartActivityStreamOutput,
    crate::error::StartActivityStreamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_activity_stream_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_activity_stream(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartActivityStreamError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbClusterOutput, crate::error::StartDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbClusterOutput, crate::error::StartDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbInstanceOutput, crate::error::StartDBInstanceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => {
            crate::error::StartDBInstanceError {
                meta: generic,
                kind: crate::error::StartDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DBSubnetGroupNotFoundFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InsufficientDbInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartDBInstanceError {
            meta: generic,
            kind: crate::error::StartDBInstanceErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbInstanceOutput, crate::error::StartDBInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_automated_backups_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartDbInstanceAutomatedBackupsReplicationOutput,
    crate::error::StartDBInstanceAutomatedBackupsReplicationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceAutomatedBackupQuotaExceeded" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceAutomatedBackupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_automated_backup_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBInstanceNotFound" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceState" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageTypeNotSupported" => crate::error::StartDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartDBInstanceAutomatedBackupsReplicationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_instance_automated_backups_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartDbInstanceAutomatedBackupsReplicationOutput,
    crate::error::StartDBInstanceAutomatedBackupsReplicationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::start_db_instance_automated_backups_replication_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_db_instance_automated_backups_replication(response.body().as_ref(), output).map_err(crate::error::StartDBInstanceAutomatedBackupsReplicationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartExportTaskOutput, crate::error::StartExportTaskError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartExportTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartExportTaskError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::DbClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ExportTaskAlreadyExists" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::ExportTaskAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::export_task_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_export_task_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IamRoleMissingPermissions" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::IamRoleMissingPermissionsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::iam_role_missing_permissions_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_iam_role_missing_permissions_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IamRoleNotFound" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::IamRoleNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::iam_role_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_iam_role_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidExportOnly" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::InvalidExportOnlyFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_export_only_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_export_only_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidExportSourceState" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::InvalidExportSourceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_export_source_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_export_source_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidS3BucketFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::InvalidS3BucketFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_s3_bucket_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_bucket_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::StartExportTaskError {
            meta: generic,
            kind: crate::error::StartExportTaskErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartExportTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartExportTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartExportTaskOutput, crate::error::StartExportTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_export_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_export_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartExportTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_activity_stream_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopActivityStreamOutput,
    crate::error::StopActivityStreamError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopActivityStreamError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopActivityStreamError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundFault" => crate::error::StopActivityStreamError {
            meta: generic,
            kind: crate::error::StopActivityStreamErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopActivityStreamError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopActivityStreamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_activity_stream_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopActivityStreamOutput,
    crate::error::StopActivityStreamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_activity_stream_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_activity_stream(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopActivityStreamError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbClusterOutput, crate::error::StopDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbClusterOutput, crate::error::StopDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbInstanceOutput, crate::error::StopDBInstanceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotAlreadyExists" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::DbSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::StopDBInstanceError {
            meta: generic,
            kind: crate::error::StopDBInstanceErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbInstanceOutput, crate::error::StopDBInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_automated_backups_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopDbInstanceAutomatedBackupsReplicationOutput,
    crate::error::StopDBInstanceAutomatedBackupsReplicationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::StopDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StopDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBInstanceState" => crate::error::StopDBInstanceAutomatedBackupsReplicationError { meta: generic, kind: crate::error::StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopDBInstanceAutomatedBackupsReplicationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_instance_automated_backups_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopDbInstanceAutomatedBackupsReplicationOutput,
    crate::error::StopDBInstanceAutomatedBackupsReplicationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::stop_db_instance_automated_backups_replication_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_db_instance_automated_backups_replication(response.body().as_ref(), output).map_err(crate::error::StopDBInstanceAutomatedBackupsReplicationError::unhandled)?;
        output.build()
    })
}
