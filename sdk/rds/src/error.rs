// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToDBClusterError {
    pub kind: AddRoleToDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterRoleAlreadyExistsFault(crate::error::DBClusterRoleAlreadyExistsFault),
    DBClusterRoleQuotaExceededFault(crate::error::DBClusterRoleQuotaExceededFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::DBClusterRoleAlreadyExistsFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::DBClusterRoleQuotaExceededFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToDBClusterError {
    fn code(&self) -> Option<&str> {
        AddRoleToDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToDBClusterError {
    pub fn new(kind: AddRoleToDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_role_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DBClusterRoleAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_role_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DBClusterRoleQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for AddRoleToDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::DBClusterRoleAlreadyExistsFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::DBClusterRoleQuotaExceededFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToDBInstanceError {
    pub kind: AddRoleToDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToDBInstanceErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBInstanceRoleAlreadyExistsFault(crate::error::DBInstanceRoleAlreadyExistsFault),
    DBInstanceRoleQuotaExceededFault(crate::error::DBInstanceRoleQuotaExceededFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::DBInstanceRoleAlreadyExistsFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::DBInstanceRoleQuotaExceededFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToDBInstanceError {
    fn code(&self) -> Option<&str> {
        AddRoleToDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToDBInstanceError {
    pub fn new(kind: AddRoleToDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_instance_role_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DBInstanceRoleAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_role_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DBInstanceRoleQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for AddRoleToDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::DBInstanceRoleAlreadyExistsFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::DBInstanceRoleQuotaExceededFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddSourceIdentifierToSubscriptionError {
    pub kind: AddSourceIdentifierToSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddSourceIdentifierToSubscriptionErrorKind {
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddSourceIdentifierToSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AddSourceIdentifierToSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddSourceIdentifierToSubscriptionError {
    fn code(&self) -> Option<&str> {
        AddSourceIdentifierToSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddSourceIdentifierToSubscriptionError {
    pub fn new(
        kind: AddSourceIdentifierToSubscriptionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddSourceIdentifierToSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddSourceIdentifierToSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for AddSourceIdentifierToSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_inner) => Some(_inner),
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                Some(_inner)
            }
            AddSourceIdentifierToSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsToResourceError {
    pub kind: AddTagsToResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsToResourceErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        AddTagsToResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    pub fn new(kind: AddTagsToResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsToResourceErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ApplyPendingMaintenanceActionError {
    pub kind: ApplyPendingMaintenanceActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ApplyPendingMaintenanceActionErrorKind {
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ApplyPendingMaintenanceActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ApplyPendingMaintenanceActionErrorKind::InvalidDBClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            ApplyPendingMaintenanceActionErrorKind::InvalidDBInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            ApplyPendingMaintenanceActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ApplyPendingMaintenanceActionError {
    fn code(&self) -> Option<&str> {
        ApplyPendingMaintenanceActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ApplyPendingMaintenanceActionError {
    pub fn new(kind: ApplyPendingMaintenanceActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ApplyPendingMaintenanceActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ApplyPendingMaintenanceActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for ApplyPendingMaintenanceActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ApplyPendingMaintenanceActionErrorKind::InvalidDBClusterStateFault(_inner) => {
                Some(_inner)
            }
            ApplyPendingMaintenanceActionErrorKind::InvalidDBInstanceStateFault(_inner) => {
                Some(_inner)
            }
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            ApplyPendingMaintenanceActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AuthorizeDBSecurityGroupIngressError {
    pub kind: AuthorizeDBSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeDBSecurityGroupIngressErrorKind {
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    AuthorizationQuotaExceededFault(crate::error::AuthorizationQuotaExceededFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    InvalidDBSecurityGroupStateFault(crate::error::InvalidDBSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AuthorizeDBSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AuthorizeDBSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        AuthorizeDBSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeDBSecurityGroupIngressError {
    pub fn new(kind: AuthorizeDBSecurityGroupIngressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_)
        )
    }
    pub fn is_authorization_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for AuthorizeDBSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BacktrackDBClusterError {
    pub kind: BacktrackDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BacktrackDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BacktrackDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BacktrackDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            BacktrackDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            BacktrackDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BacktrackDBClusterError {
    fn code(&self) -> Option<&str> {
        BacktrackDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BacktrackDBClusterError {
    pub fn new(kind: BacktrackDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BacktrackDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BacktrackDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            BacktrackDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            BacktrackDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for BacktrackDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BacktrackDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            BacktrackDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            BacktrackDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelExportTaskError {
    pub kind: CancelExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelExportTaskErrorKind {
    ExportTaskNotFoundFault(crate::error::ExportTaskNotFoundFault),
    InvalidExportTaskStateFault(crate::error::InvalidExportTaskStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelExportTaskError {
    fn code(&self) -> Option<&str> {
        CancelExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelExportTaskError {
    pub fn new(kind: CancelExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_export_task_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_)
        )
    }
    pub fn is_invalid_export_task_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_)
        )
    }
}
impl std::error::Error for CancelExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_inner) => Some(_inner),
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_inner) => Some(_inner),
            CancelExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBClusterParameterGroupError {
    pub kind: CopyDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterParameterGroupErrorKind {
    DBParameterGroupAlreadyExistsFault(crate::error::DBParameterGroupAlreadyExistsFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBParameterGroupQuotaExceededFault(crate::error::DBParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        CopyDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterParameterGroupError {
    pub fn new(kind: CopyDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBClusterSnapshotError {
    pub kind: CopyDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterSnapshotErrorKind {
    DBClusterSnapshotAlreadyExistsFault(crate::error::DBClusterSnapshotAlreadyExistsFault),
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        CopyDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterSnapshotError {
    pub fn new(kind: CopyDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBParameterGroupError {
    pub kind: CopyDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBParameterGroupErrorKind {
    DBParameterGroupAlreadyExistsFault(crate::error::DBParameterGroupAlreadyExistsFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBParameterGroupQuotaExceededFault(crate::error::DBParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        CopyDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBParameterGroupError {
    pub fn new(kind: CopyDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            CopyDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CopyDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBSnapshotError {
    pub kind: CopyDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBSnapshotErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    DBSnapshotAlreadyExistsFault(crate::error::DBSnapshotAlreadyExistsFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBSnapshotError {
    fn code(&self) -> Option<&str> {
        CopyDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBSnapshotError {
    pub fn new(kind: CopyDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyOptionGroupError {
    pub kind: CopyOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyOptionGroupErrorKind {
    OptionGroupAlreadyExistsFault(crate::error::OptionGroupAlreadyExistsFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    OptionGroupQuotaExceededFault(crate::error::OptionGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyOptionGroupError {
    fn code(&self) -> Option<&str> {
        CopyOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyOptionGroupError {
    pub fn new(kind: CopyOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_option_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomAvailabilityZoneError {
    pub kind: CreateCustomAvailabilityZoneErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomAvailabilityZoneErrorKind {
    CustomAvailabilityZoneAlreadyExistsFault(
        crate::error::CustomAvailabilityZoneAlreadyExistsFault,
    ),
    CustomAvailabilityZoneQuotaExceededFault(
        crate::error::CustomAvailabilityZoneQuotaExceededFault,
    ),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomAvailabilityZoneError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(
                _inner,
            ) => _inner.fmt(f),
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(
                _inner,
            ) => _inner.fmt(f),
            CreateCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomAvailabilityZoneErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomAvailabilityZoneError {
    fn code(&self) -> Option<&str> {
        CreateCustomAvailabilityZoneError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomAvailabilityZoneError {
    pub fn new(kind: CreateCustomAvailabilityZoneErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(_)
        )
    }
    pub fn is_custom_availability_zone_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for CreateCustomAvailabilityZoneError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(
                _inner,
            ) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(
                _inner,
            ) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterError {
    pub kind: CreateDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterErrorKind {
    DBClusterAlreadyExistsFault(crate::error::DBClusterAlreadyExistsFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterParameterGroupNotFoundFault(crate::error::DBClusterParameterGroupNotFoundFault),
    DBClusterQuotaExceededFault(crate::error::DBClusterQuotaExceededFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidDBSubnetGroupStateFault(crate::error::InvalidDBSubnetGroupStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterErrorKind::DBClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterError {
    pub fn new(kind: CreateDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(&self.kind, CreateDBClusterErrorKind::DomainNotFoundFault(_))
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBClusterErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterErrorKind::DBClusterAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBClusterQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterEndpointError {
    pub kind: CreateDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterEndpointErrorKind {
    DBClusterEndpointAlreadyExistsFault(crate::error::DBClusterEndpointAlreadyExistsFault),
    DBClusterEndpointQuotaExceededFault(crate::error::DBClusterEndpointQuotaExceededFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterEndpointErrorKind::DBClusterEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterEndpointErrorKind::DBClusterEndpointQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterEndpointErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterEndpointError {
    pub fn new(kind: CreateDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DBClusterEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_endpoint_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DBClusterEndpointQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterEndpointErrorKind::DBClusterEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterEndpointErrorKind::DBClusterEndpointQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterEndpointErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterParameterGroupError {
    pub kind: CreateDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterParameterGroupErrorKind {
    DBParameterGroupAlreadyExistsFault(crate::error::DBParameterGroupAlreadyExistsFault),
    DBParameterGroupQuotaExceededFault(crate::error::DBParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterParameterGroupError {
    pub fn new(kind: CreateDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterSnapshotError {
    pub kind: CreateDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterSnapshotErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterSnapshotAlreadyExistsFault(crate::error::DBClusterSnapshotAlreadyExistsFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterSnapshotErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterSnapshotError {
    pub fn new(kind: CreateDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterSnapshotErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBInstanceError {
    pub kind: CreateDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBInstanceError {
    fn code(&self) -> Option<&str> {
        CreateDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBInstanceError {
    pub fn new(kind: CreateDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBInstanceErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for CreateDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBInstanceReadReplicaError {
    pub kind: CreateDBInstanceReadReplicaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBInstanceReadReplicaErrorKind {
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotAllowedFault(crate::error::DBSubnetGroupNotAllowedFault),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidDBSubnetGroupFault(crate::error::InvalidDBSubnetGroupFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBInstanceReadReplicaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBInstanceReadReplicaErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotAllowedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InsufficientDBInstanceCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDBInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDBSubnetGroupFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBInstanceReadReplicaError {
    fn code(&self) -> Option<&str> {
        CreateDBInstanceReadReplicaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBInstanceReadReplicaError {
    pub fn new(kind: CreateDBInstanceReadReplicaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBInstanceReadReplicaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBInstanceReadReplicaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_allowed_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotAllowedFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidDBSubnetGroupFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for CreateDBInstanceReadReplicaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBInstanceReadReplicaErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotAllowedFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InsufficientDBInstanceCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDBInstanceStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDBSubnetGroupFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBParameterGroupError {
    pub kind: CreateDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBParameterGroupErrorKind {
    DBParameterGroupAlreadyExistsFault(crate::error::DBParameterGroupAlreadyExistsFault),
    DBParameterGroupQuotaExceededFault(crate::error::DBParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBParameterGroupError {
    pub fn new(kind: CreateDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBParameterGroupErrorKind::DBParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBParameterGroupErrorKind::DBParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBProxyError {
    pub kind: CreateDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBProxyErrorKind {
    DBProxyAlreadyExistsFault(crate::error::DBProxyAlreadyExistsFault),
    DBProxyQuotaExceededFault(crate::error::DBProxyQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBProxyErrorKind::DBProxyAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::DBProxyQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBProxyError {
    fn code(&self) -> Option<&str> {
        CreateDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBProxyError {
    pub fn new(kind: CreateDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyErrorKind::DBProxyAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyErrorKind::DBProxyQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBProxyErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBProxyErrorKind::DBProxyAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBProxyErrorKind::DBProxyQuotaExceededFault(_inner) => Some(_inner),
            CreateDBProxyErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBProxyEndpointError {
    pub kind: CreateDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBProxyEndpointErrorKind {
    DBProxyEndpointAlreadyExistsFault(crate::error::DBProxyEndpointAlreadyExistsFault),
    DBProxyEndpointQuotaExceededFault(crate::error::DBProxyEndpointQuotaExceededFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBProxyEndpointErrorKind::DBProxyEndpointQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBProxyEndpointErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        CreateDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBProxyEndpointError {
    pub fn new(kind: CreateDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_endpoint_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DBProxyEndpointQuotaExceededFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBProxyEndpointErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBProxyEndpointErrorKind::DBProxyEndpointQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBProxyEndpointErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSecurityGroupError {
    pub kind: CreateDBSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSecurityGroupErrorKind {
    DBSecurityGroupAlreadyExistsFault(crate::error::DBSecurityGroupAlreadyExistsFault),
    DBSecurityGroupNotSupportedFault(crate::error::DBSecurityGroupNotSupportedFault),
    DBSecurityGroupQuotaExceededFault(crate::error::DBSecurityGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSecurityGroupErrorKind::DBSecurityGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::DBSecurityGroupNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::DBSecurityGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSecurityGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSecurityGroupError {
    pub fn new(kind: CreateDBSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DBSecurityGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_security_group_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DBSecurityGroupNotSupportedFault(_)
        )
    }
    pub fn is_db_security_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DBSecurityGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSecurityGroupErrorKind::DBSecurityGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::DBSecurityGroupNotSupportedFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::DBSecurityGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSnapshotError {
    pub kind: CreateDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSnapshotErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBSnapshotAlreadyExistsFault(crate::error::DBSnapshotAlreadyExistsFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSnapshotErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSnapshotError {
    pub fn new(kind: CreateDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSnapshotErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::DBSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSubnetGroupError {
    pub kind: CreateDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSubnetGroupErrorKind {
    DBSubnetGroupAlreadyExistsFault(crate::error::DBSubnetGroupAlreadyExistsFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupQuotaExceededFault(crate::error::DBSubnetGroupQuotaExceededFault),
    DBSubnetQuotaExceededFault(crate::error::DBSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSubnetGroupErrorKind::DBSubnetGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSubnetGroupErrorKind::DBSubnetGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSubnetGroupError {
    pub fn new(kind: CreateDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DBSubnetGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DBSubnetGroupQuotaExceededFault(_)
        )
    }
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBSubnetGroupErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSubnetGroupErrorKind::DBSubnetGroupAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            CreateDBSubnetGroupErrorKind::DBSubnetGroupQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEventSubscriptionError {
    pub kind: CreateEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSubscriptionErrorKind {
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    SNSInvalidTopicFault(crate::error::SNSInvalidTopicFault),
    SNSNoAuthorizationFault(crate::error::SNSNoAuthorizationFault),
    SNSTopicArnNotFoundFault(crate::error::SNSTopicArnNotFoundFault),
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionAlreadyExistFault(crate::error::SubscriptionAlreadyExistFault),
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::SNSInvalidTopicFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SNSNoAuthorizationFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        CreateEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventSubscriptionError {
    pub fn new(kind: CreateEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_)
        )
    }
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SNSInvalidTopicFault(_)
        )
    }
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SNSNoAuthorizationFault(_)
        )
    }
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_)
        )
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_already_exist_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_)
        )
    }
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_)
        )
    }
}
impl std::error::Error for CreateEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateEventSubscriptionErrorKind::SNSInvalidTopicFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SNSNoAuthorizationFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGlobalClusterError {
    pub kind: CreateGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGlobalClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    GlobalClusterAlreadyExistsFault(crate::error::GlobalClusterAlreadyExistsFault),
    GlobalClusterQuotaExceededFault(crate::error::GlobalClusterQuotaExceededFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGlobalClusterError {
    fn code(&self) -> Option<&str> {
        CreateGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGlobalClusterError {
    pub fn new(kind: CreateGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_global_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for CreateGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOptionGroupError {
    pub kind: CreateOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOptionGroupErrorKind {
    OptionGroupAlreadyExistsFault(crate::error::OptionGroupAlreadyExistsFault),
    OptionGroupQuotaExceededFault(crate::error::OptionGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOptionGroupError {
    fn code(&self) -> Option<&str> {
        CreateOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOptionGroupError {
    pub fn new(kind: CreateOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_option_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => Some(_inner),
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => Some(_inner),
            CreateOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomAvailabilityZoneError {
    pub kind: DeleteCustomAvailabilityZoneErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomAvailabilityZoneErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomAvailabilityZoneError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomAvailabilityZoneErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomAvailabilityZoneError {
    fn code(&self) -> Option<&str> {
        DeleteCustomAvailabilityZoneError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomAvailabilityZoneError {
    pub fn new(kind: DeleteCustomAvailabilityZoneErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for DeleteCustomAvailabilityZoneError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteCustomAvailabilityZoneErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            DeleteCustomAvailabilityZoneErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterError {
    pub kind: DeleteDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterSnapshotAlreadyExistsFault(crate::error::DBClusterSnapshotAlreadyExistsFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterError {
    pub fn new(kind: DeleteDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::DBClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::DBClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterEndpointError {
    pub kind: DeleteDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterEndpointErrorKind {
    DBClusterEndpointNotFoundFault(crate::error::DBClusterEndpointNotFoundFault),
    InvalidDBClusterEndpointStateFault(crate::error::InvalidDBClusterEndpointStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterEndpointError {
    pub fn new(kind: DeleteDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            DeleteDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterParameterGroupError {
    pub kind: DeleteDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterParameterGroupError {
    pub fn new(kind: DeleteDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterSnapshotError {
    pub kind: DeleteDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterSnapshotErrorKind {
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterSnapshotError {
    pub fn new(kind: DeleteDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBInstanceError {
    pub kind: DeleteDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBInstanceErrorKind {
    DBInstanceAutomatedBackupQuotaExceededFault(
        crate::error::DBInstanceAutomatedBackupQuotaExceededFault,
    ),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBSnapshotAlreadyExistsFault(crate::error::DBSnapshotAlreadyExistsFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBInstanceErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBInstanceError {
    pub fn new(kind: DeleteDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBInstanceErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            DeleteDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBInstanceAutomatedBackupError {
    pub kind: DeleteDBInstanceAutomatedBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBInstanceAutomatedBackupErrorKind {
    DBInstanceAutomatedBackupNotFoundFault(crate::error::DBInstanceAutomatedBackupNotFoundFault),
    InvalidDBInstanceAutomatedBackupStateFault(
        crate::error::InvalidDBInstanceAutomatedBackupStateFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBInstanceAutomatedBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBInstanceAutomatedBackupErrorKind::DBInstanceAutomatedBackupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDBInstanceAutomatedBackupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBInstanceAutomatedBackupError {
    fn code(&self) -> Option<&str> {
        DeleteDBInstanceAutomatedBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBInstanceAutomatedBackupError {
    pub fn new(kind: DeleteDBInstanceAutomatedBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceAutomatedBackupErrorKind::DBInstanceAutomatedBackupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_automated_backup_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDBInstanceAutomatedBackupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBInstanceAutomatedBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBInstanceAutomatedBackupErrorKind::DBInstanceAutomatedBackupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDBInstanceAutomatedBackupStateFault(_inner) =>
            Some(_inner)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBParameterGroupError {
    pub kind: DeleteDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBParameterGroupError {
    pub fn new(kind: DeleteDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBProxyError {
    pub kind: DeleteDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBProxyErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBProxyErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBProxyErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            DeleteDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBProxyError {
    fn code(&self) -> Option<&str> {
        DeleteDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBProxyError {
    pub fn new(kind: DeleteDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(&self.kind, DeleteDBProxyErrorKind::DBProxyNotFoundFault(_))
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBProxyErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DeleteDBProxyErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            DeleteDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBProxyEndpointError {
    pub kind: DeleteDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBProxyEndpointErrorKind {
    DBProxyEndpointNotFoundFault(crate::error::DBProxyEndpointNotFoundFault),
    InvalidDBProxyEndpointStateFault(crate::error::InvalidDBProxyEndpointStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBProxyEndpointError {
    pub fn new(kind: DeleteDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_inner) => Some(_inner),
            DeleteDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSecurityGroupError {
    pub kind: DeleteDBSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSecurityGroupErrorKind {
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    InvalidDBSecurityGroupStateFault(crate::error::InvalidDBSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSecurityGroupErrorKind::DBSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSecurityGroupErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSecurityGroupError {
    pub fn new(kind: DeleteDBSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSecurityGroupErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSecurityGroupErrorKind::InvalidDBSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSecurityGroupErrorKind::DBSecurityGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBSecurityGroupErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSnapshotError {
    pub kind: DeleteDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSnapshotErrorKind {
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => _inner.fmt(f),
            DeleteDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSnapshotError {
    pub fn new(kind: DeleteDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSnapshotErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            DeleteDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => Some(_inner),
            DeleteDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSubnetGroupError {
    pub kind: DeleteDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSubnetGroupErrorKind {
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    InvalidDBSubnetGroupStateFault(crate::error::InvalidDBSubnetGroupStateFault),
    InvalidDBSubnetStateFault(crate::error::InvalidDBSubnetStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetGroupStateFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetStateFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSubnetGroupError {
    pub fn new(kind: DeleteDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetGroupStateFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::InvalidDBSubnetStateFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventSubscriptionError {
    pub kind: DeleteEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSubscriptionErrorKind {
    InvalidEventSubscriptionStateFault(crate::error::InvalidEventSubscriptionStateFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            DeleteEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        DeleteEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventSubscriptionError {
    pub fn new(kind: DeleteEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_event_subscription_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_inner) => {
                Some(_inner)
            }
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            DeleteEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGlobalClusterError {
    pub kind: DeleteGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGlobalClusterErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            DeleteGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGlobalClusterError {
    fn code(&self) -> Option<&str> {
        DeleteGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGlobalClusterError {
    pub fn new(kind: DeleteGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for DeleteGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            DeleteGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstallationMediaError {
    pub kind: DeleteInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstallationMediaErrorKind {
    InstallationMediaNotFoundFault(crate::error::InstallationMediaNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstallationMediaError {
    fn code(&self) -> Option<&str> {
        DeleteInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstallationMediaError {
    pub fn new(kind: DeleteInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_installation_media_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOptionGroupError {
    pub kind: DeleteOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOptionGroupErrorKind {
    InvalidOptionGroupStateFault(crate::error::InvalidOptionGroupStateFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => _inner.fmt(f),
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOptionGroupError {
    fn code(&self) -> Option<&str> {
        DeleteOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOptionGroupError {
    pub fn new(kind: DeleteOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_option_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => Some(_inner),
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            DeleteOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterDBProxyTargetsError {
    pub kind: DeregisterDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterDBProxyTargetsErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    DBProxyTargetNotFoundFault(crate::error::DBProxyTargetNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        DeregisterDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterDBProxyTargetsError {
    pub fn new(kind: DeregisterDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for DeregisterDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeregisterDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAttributesError {
    pub kind: DescribeAccountAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAttributesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAttributesError {
    pub fn new(kind: DescribeAccountAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeAccountAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificatesError {
    pub kind: DescribeCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificatesErrorKind {
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            DescribeCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCertificatesError {
    fn code(&self) -> Option<&str> {
        DescribeCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificatesError {
    pub fn new(kind: DescribeCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            DescribeCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomAvailabilityZonesError {
    pub kind: DescribeCustomAvailabilityZonesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomAvailabilityZonesErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomAvailabilityZonesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeCustomAvailabilityZonesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomAvailabilityZonesError {
    fn code(&self) -> Option<&str> {
        DescribeCustomAvailabilityZonesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomAvailabilityZonesError {
    pub fn new(kind: DescribeCustomAvailabilityZonesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomAvailabilityZonesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomAvailabilityZonesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeCustomAvailabilityZonesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeCustomAvailabilityZonesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterBacktracksError {
    pub kind: DescribeDBClusterBacktracksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterBacktracksErrorKind {
    DBClusterBacktrackNotFoundFault(crate::error::DBClusterBacktrackNotFoundFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterBacktracksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterBacktracksErrorKind::DBClusterBacktrackNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterBacktracksErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClusterBacktracksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterBacktracksError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterBacktracksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterBacktracksError {
    pub fn new(kind: DescribeDBClusterBacktracksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterBacktracksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterBacktracksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_backtrack_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterBacktracksErrorKind::DBClusterBacktrackNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterBacktracksErrorKind::DBClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterBacktracksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterBacktracksErrorKind::DBClusterBacktrackNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterBacktracksErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClusterBacktracksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterEndpointsError {
    pub kind: DescribeDBClusterEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterEndpointsErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterEndpointsErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClusterEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterEndpointsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterEndpointsError {
    pub fn new(kind: DescribeDBClusterEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterEndpointsErrorKind::DBClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterEndpointsErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClusterEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterParameterGroupsError {
    pub kind: DescribeDBClusterParameterGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParameterGroupsErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterParameterGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterParameterGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterParameterGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParameterGroupsError {
    pub fn new(kind: DescribeDBClusterParameterGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterParameterGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterParameterGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterParameterGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterParametersError {
    pub kind: DescribeDBClusterParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParametersErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterParametersErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterParametersError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParametersError {
    pub fn new(kind: DescribeDBClusterParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterParametersErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterParametersErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClustersError {
    pub kind: DescribeDBClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClustersErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClustersErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClustersError {
    fn code(&self) -> Option<&str> {
        DescribeDBClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClustersError {
    pub fn new(kind: DescribeDBClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClustersErrorKind::DBClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClustersErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterSnapshotAttributesError {
    pub kind: DescribeDBClusterSnapshotAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotAttributesErrorKind {
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterSnapshotAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterSnapshotAttributesErrorKind::DBClusterSnapshotNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterSnapshotAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotAttributesError {
    pub fn new(
        kind: DescribeDBClusterSnapshotAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterSnapshotAttributesErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterSnapshotAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterSnapshotAttributesErrorKind::DBClusterSnapshotNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterSnapshotsError {
    pub kind: DescribeDBClusterSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotsErrorKind {
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterSnapshotsErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotsError {
    pub fn new(kind: DescribeDBClusterSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterSnapshotsErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterSnapshotsErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBEngineVersionsError {
    pub kind: DescribeDBEngineVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBEngineVersionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBEngineVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBEngineVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBEngineVersionsError {
    fn code(&self) -> Option<&str> {
        DescribeDBEngineVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBEngineVersionsError {
    pub fn new(kind: DescribeDBEngineVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBEngineVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBEngineVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeDBEngineVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBEngineVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBInstanceAutomatedBackupsError {
    pub kind: DescribeDBInstanceAutomatedBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBInstanceAutomatedBackupsErrorKind {
    DBInstanceAutomatedBackupNotFoundFault(crate::error::DBInstanceAutomatedBackupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBInstanceAutomatedBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBInstanceAutomatedBackupsErrorKind::DBInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBInstanceAutomatedBackupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBInstanceAutomatedBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBInstanceAutomatedBackupsError {
    pub fn new(
        kind: DescribeDBInstanceAutomatedBackupsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBInstanceAutomatedBackupsErrorKind::DBInstanceAutomatedBackupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBInstanceAutomatedBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBInstanceAutomatedBackupsErrorKind::DBInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBInstancesError {
    pub kind: DescribeDBInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBInstancesErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBInstancesErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeDBInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBInstancesError {
    pub fn new(kind: DescribeDBInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBInstancesErrorKind::DBInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBInstancesErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            DescribeDBInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBLogFilesError {
    pub kind: DescribeDBLogFilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBLogFilesErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBLogFilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBLogFilesErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBLogFilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBLogFilesError {
    fn code(&self) -> Option<&str> {
        DescribeDBLogFilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBLogFilesError {
    pub fn new(kind: DescribeDBLogFilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBLogFilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBLogFilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBLogFilesErrorKind::DBInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBLogFilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBLogFilesErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            DescribeDBLogFilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBParameterGroupsError {
    pub kind: DescribeDBParameterGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParameterGroupsErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBParameterGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBParameterGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBParameterGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParameterGroupsError {
    pub fn new(kind: DescribeDBParameterGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBParameterGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBParameterGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBParameterGroupsErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBParameterGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBParametersError {
    pub kind: DescribeDBParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParametersErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBParametersErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBParametersError {
    fn code(&self) -> Option<&str> {
        DescribeDBParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParametersError {
    pub fn new(kind: DescribeDBParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBParametersErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBParametersErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxiesError {
    pub kind: DescribeDBProxiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxiesErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxiesErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxiesError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxiesError {
    pub fn new(kind: DescribeDBProxiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxiesErrorKind::DBProxyNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxiesErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyEndpointsError {
    pub kind: DescribeDBProxyEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyEndpointsErrorKind {
    DBProxyEndpointNotFoundFault(crate::error::DBProxyEndpointNotFoundFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyEndpointsErrorKind::DBProxyEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyEndpointsErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyEndpointsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyEndpointsError {
    pub fn new(kind: DescribeDBProxyEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyEndpointsErrorKind::DBProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyEndpointsErrorKind::DBProxyNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyEndpointsErrorKind::DBProxyEndpointNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyEndpointsErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyTargetGroupsError {
    pub kind: DescribeDBProxyTargetGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyTargetGroupsErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyTargetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyTargetGroupsErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetGroupsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyTargetGroupsErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyTargetGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyTargetGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyTargetGroupsError {
    pub fn new(kind: DescribeDBProxyTargetGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyTargetGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyTargetGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyTargetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyTargetGroupsErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetGroupsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBProxyTargetGroupsErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            DescribeDBProxyTargetGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyTargetsError {
    pub kind: DescribeDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyTargetsErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    DBProxyTargetNotFoundFault(crate::error::DBProxyTargetNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyTargetsError {
    pub fn new(kind: DescribeDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBProxyTargetsErrorKind::DBProxyTargetNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSecurityGroupsError {
    pub kind: DescribeDBSecurityGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSecurityGroupsErrorKind {
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSecurityGroupsErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBSecurityGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSecurityGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSecurityGroupsError {
    pub fn new(kind: DescribeDBSecurityGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSecurityGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSecurityGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSecurityGroupsErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSecurityGroupsErrorKind::DBSecurityGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBSecurityGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSnapshotAttributesError {
    pub kind: DescribeDBSnapshotAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSnapshotAttributesErrorKind {
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSnapshotAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSnapshotAttributesErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSnapshotAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSnapshotAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeDBSnapshotAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSnapshotAttributesError {
    pub fn new(kind: DescribeDBSnapshotAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSnapshotAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSnapshotAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSnapshotAttributesErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSnapshotAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSnapshotAttributesErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            DescribeDBSnapshotAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSnapshotsError {
    pub kind: DescribeDBSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSnapshotsErrorKind {
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSnapshotsErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSnapshotsError {
    pub fn new(kind: DescribeDBSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSnapshotsErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSnapshotsErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            DescribeDBSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSubnetGroupsError {
    pub kind: DescribeDBSubnetGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSubnetGroupsErrorKind {
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSubnetGroupsErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSubnetGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSubnetGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSubnetGroupsError {
    pub fn new(kind: DescribeDBSubnetGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSubnetGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSubnetGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSubnetGroupsErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSubnetGroupsErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBSubnetGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEngineDefaultClusterParametersError {
    pub kind: DescribeEngineDefaultClusterParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultClusterParametersErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEngineDefaultClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEngineDefaultClusterParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultClusterParametersError {
    fn code(&self) -> Option<&str> {
        DescribeEngineDefaultClusterParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultClusterParametersError {
    pub fn new(
        kind: DescribeEngineDefaultClusterParametersErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEngineDefaultClusterParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEngineDefaultClusterParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEngineDefaultClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEngineDefaultClusterParametersErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEngineDefaultParametersError {
    pub kind: DescribeEngineDefaultParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultParametersErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEngineDefaultParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultParametersError {
    fn code(&self) -> Option<&str> {
        DescribeEngineDefaultParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultParametersError {
    pub fn new(kind: DescribeEngineDefaultParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEngineDefaultParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventCategoriesError {
    pub kind: DescribeEventCategoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventCategoriesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventCategoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventCategoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventCategoriesError {
    fn code(&self) -> Option<&str> {
        DescribeEventCategoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventCategoriesError {
    pub fn new(kind: DescribeEventCategoriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventCategoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventCategoriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEventCategoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventCategoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventsError {
    pub kind: DescribeEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        DescribeEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    pub fn new(kind: DescribeEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventSubscriptionsError {
    pub kind: DescribeEventSubscriptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventSubscriptionsErrorKind {
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            DescribeEventSubscriptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventSubscriptionsError {
    fn code(&self) -> Option<&str> {
        DescribeEventSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventSubscriptionsError {
    pub fn new(kind: DescribeEventSubscriptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventSubscriptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventSubscriptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeEventSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            DescribeEventSubscriptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportTasksError {
    pub kind: DescribeExportTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportTasksErrorKind {
    ExportTaskNotFoundFault(crate::error::ExportTaskNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportTasksError {
    fn code(&self) -> Option<&str> {
        DescribeExportTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportTasksError {
    pub fn new(kind: DescribeExportTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_export_task_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeExportTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalClustersError {
    pub kind: DescribeGlobalClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalClustersErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeGlobalClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalClustersError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalClustersError {
    pub fn new(kind: DescribeGlobalClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeGlobalClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            DescribeGlobalClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstallationMediaError {
    pub kind: DescribeInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstallationMediaErrorKind {
    InstallationMediaNotFoundFault(crate::error::InstallationMediaNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstallationMediaError {
    fn code(&self) -> Option<&str> {
        DescribeInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstallationMediaError {
    pub fn new(kind: DescribeInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_installation_media_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOptionGroupOptionsError {
    pub kind: DescribeOptionGroupOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOptionGroupOptionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOptionGroupOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOptionGroupOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOptionGroupOptionsError {
    fn code(&self) -> Option<&str> {
        DescribeOptionGroupOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOptionGroupOptionsError {
    pub fn new(kind: DescribeOptionGroupOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOptionGroupOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOptionGroupOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeOptionGroupOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOptionGroupOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOptionGroupsError {
    pub kind: DescribeOptionGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOptionGroupsErrorKind {
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOptionGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeOptionGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOptionGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeOptionGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOptionGroupsError {
    pub fn new(kind: DescribeOptionGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOptionGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOptionGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeOptionGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            DescribeOptionGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrderableDBInstanceOptionsError {
    pub kind: DescribeOrderableDBInstanceOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrderableDBInstanceOptionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrderableDBInstanceOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrderableDBInstanceOptionsError {
    fn code(&self) -> Option<&str> {
        DescribeOrderableDBInstanceOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrderableDBInstanceOptionsError {
    pub fn new(
        kind: DescribeOrderableDBInstanceOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeOrderableDBInstanceOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePendingMaintenanceActionsError {
    pub kind: DescribePendingMaintenanceActionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePendingMaintenanceActionsErrorKind {
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePendingMaintenanceActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribePendingMaintenanceActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePendingMaintenanceActionsError {
    fn code(&self) -> Option<&str> {
        DescribePendingMaintenanceActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePendingMaintenanceActionsError {
    pub fn new(
        kind: DescribePendingMaintenanceActionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePendingMaintenanceActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePendingMaintenanceActionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribePendingMaintenanceActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribePendingMaintenanceActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedDBInstancesError {
    pub kind: DescribeReservedDBInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedDBInstancesErrorKind {
    ReservedDBInstanceNotFoundFault(crate::error::ReservedDBInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedDBInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedDBInstancesErrorKind::ReservedDBInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeReservedDBInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedDBInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeReservedDBInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedDBInstancesError {
    pub fn new(kind: DescribeReservedDBInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedDBInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedDBInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedDBInstancesErrorKind::ReservedDBInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeReservedDBInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedDBInstancesErrorKind::ReservedDBInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeReservedDBInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedDBInstancesOfferingsError {
    pub kind: DescribeReservedDBInstancesOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedDBInstancesOfferingsErrorKind {
    ReservedDBInstancesOfferingNotFoundFault(
        crate::error::ReservedDBInstancesOfferingNotFoundFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedDBInstancesOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDBInstancesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedDBInstancesOfferingsError {
    fn code(&self) -> Option<&str> {
        DescribeReservedDBInstancesOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedDBInstancesOfferingsError {
    pub fn new(
        kind: DescribeReservedDBInstancesOfferingsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instances_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDBInstancesOfferingNotFoundFault(
                _
            )
        )
    }
}
impl std::error::Error for DescribeReservedDBInstancesOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDBInstancesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSourceRegionsError {
    pub kind: DescribeSourceRegionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSourceRegionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSourceRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSourceRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSourceRegionsError {
    fn code(&self) -> Option<&str> {
        DescribeSourceRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSourceRegionsError {
    pub fn new(kind: DescribeSourceRegionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSourceRegionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSourceRegionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeSourceRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSourceRegionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeValidDBInstanceModificationsError {
    pub kind: DescribeValidDBInstanceModificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeValidDBInstanceModificationsErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeValidDBInstanceModificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeValidDBInstanceModificationsErrorKind::DBInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeValidDBInstanceModificationsErrorKind::InvalidDBInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeValidDBInstanceModificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeValidDBInstanceModificationsError {
    fn code(&self) -> Option<&str> {
        DescribeValidDBInstanceModificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeValidDBInstanceModificationsError {
    pub fn new(
        kind: DescribeValidDBInstanceModificationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeValidDBInstanceModificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeValidDBInstanceModificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeValidDBInstanceModificationsErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeValidDBInstanceModificationsErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for DescribeValidDBInstanceModificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeValidDBInstanceModificationsErrorKind::DBInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeValidDBInstanceModificationsErrorKind::InvalidDBInstanceStateFault(_inner) => {
                Some(_inner)
            }
            DescribeValidDBInstanceModificationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DownloadDBLogFilePortionError {
    pub kind: DownloadDBLogFilePortionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DownloadDBLogFilePortionErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBLogFileNotFoundFault(crate::error::DBLogFileNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DownloadDBLogFilePortionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DownloadDBLogFilePortionErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DownloadDBLogFilePortionErrorKind::DBLogFileNotFoundFault(_inner) => _inner.fmt(f),
            DownloadDBLogFilePortionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DownloadDBLogFilePortionError {
    fn code(&self) -> Option<&str> {
        DownloadDBLogFilePortionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DownloadDBLogFilePortionError {
    pub fn new(kind: DownloadDBLogFilePortionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DownloadDBLogFilePortionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DownloadDBLogFilePortionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDBLogFilePortionErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_log_file_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDBLogFilePortionErrorKind::DBLogFileNotFoundFault(_)
        )
    }
}
impl std::error::Error for DownloadDBLogFilePortionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DownloadDBLogFilePortionErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            DownloadDBLogFilePortionErrorKind::DBLogFileNotFoundFault(_inner) => Some(_inner),
            DownloadDBLogFilePortionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FailoverDBClusterError {
    pub kind: FailoverDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FailoverDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FailoverDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FailoverDBClusterError {
    fn code(&self) -> Option<&str> {
        FailoverDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverDBClusterError {
    pub fn new(kind: FailoverDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FailoverDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FailoverDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for FailoverDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FailoverDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FailoverGlobalClusterError {
    pub kind: FailoverGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverGlobalClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FailoverGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FailoverGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FailoverGlobalClusterError {
    fn code(&self) -> Option<&str> {
        FailoverGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverGlobalClusterError {
    pub fn new(kind: FailoverGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FailoverGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FailoverGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for FailoverGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FailoverGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportInstallationMediaError {
    pub kind: ImportInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportInstallationMediaErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    InstallationMediaAlreadyExistsFault(crate::error::InstallationMediaAlreadyExistsFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            ImportInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportInstallationMediaError {
    fn code(&self) -> Option<&str> {
        ImportInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportInstallationMediaError {
    pub fn new(kind: ImportInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_installation_media_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_)
        )
    }
}
impl std::error::Error for ImportInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                Some(_inner)
            }
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            ImportInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCertificatesError {
    pub kind: ModifyCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCertificatesErrorKind {
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCertificatesError {
    fn code(&self) -> Option<&str> {
        ModifyCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCertificatesError {
    pub fn new(kind: ModifyCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            ModifyCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCurrentDBClusterCapacityError {
    pub kind: ModifyCurrentDBClusterCapacityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCurrentDBClusterCapacityErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterCapacityFault(crate::error::InvalidDBClusterCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCurrentDBClusterCapacityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCurrentDBClusterCapacityErrorKind::DBClusterNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCurrentDBClusterCapacityError {
    fn code(&self) -> Option<&str> {
        ModifyCurrentDBClusterCapacityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCurrentDBClusterCapacityError {
    pub fn new(kind: ModifyCurrentDBClusterCapacityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCurrentDBClusterCapacityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCurrentDBClusterCapacityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for ModifyCurrentDBClusterCapacityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCurrentDBClusterCapacityErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDBClusterStateFault(_inner) => {
                Some(_inner)
            }
            ModifyCurrentDBClusterCapacityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterError {
    pub kind: ModifyDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterErrorKind {
    DBClusterAlreadyExistsFault(crate::error::DBClusterAlreadyExistsFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterParameterGroupNotFoundFault(crate::error::DBClusterParameterGroupNotFoundFault),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidDBSecurityGroupStateFault(crate::error::InvalidDBSecurityGroupStateFault),
    InvalidDBSubnetGroupStateFault(crate::error::InvalidDBSubnetGroupStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterErrorKind::DBClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDBSecurityGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterError {
    pub fn new(kind: ModifyDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DBClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyDBClusterErrorKind::DomainNotFoundFault(_))
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDBSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, ModifyDBClusterErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterErrorKind::DBClusterAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDBSecurityGroupStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDBSubnetGroupStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidSubnet(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterEndpointError {
    pub kind: ModifyDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterEndpointErrorKind {
    DBClusterEndpointNotFoundFault(crate::error::DBClusterEndpointNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBClusterEndpointStateFault(crate::error::InvalidDBClusterEndpointStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterEndpointError {
    pub fn new(kind: ModifyDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterEndpointErrorKind::DBClusterEndpointNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterEndpointErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterEndpointStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterEndpointErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterParameterGroupError {
    pub kind: ModifyDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterParameterGroupError {
    pub fn new(kind: ModifyDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterSnapshotAttributeError {
    pub kind: ModifyDBClusterSnapshotAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterSnapshotAttributeErrorKind {
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    SharedSnapshotQuotaExceededFault(crate::error::SharedSnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterSnapshotAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterSnapshotAttributeErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDBClusterSnapshotStateFault(
                _inner,
            ) => _inner.fmt(f),
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterSnapshotAttributeError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterSnapshotAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterSnapshotAttributeError {
    pub fn new(kind: ModifyDBClusterSnapshotAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_shared_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterSnapshotAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterSnapshotAttributeErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDBClusterSnapshotStateFault(
                _inner,
            ) => Some(_inner),
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBInstanceError {
    pub kind: ModifyDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBUpgradeDependencyFailureFault(crate::error::DBUpgradeDependencyFailureFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidDBSecurityGroupStateFault(crate::error::InvalidDBSecurityGroupStateFault),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DBUpgradeDependencyFailureFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDBSecurityGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBInstanceError {
    fn code(&self) -> Option<&str> {
        ModifyDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBInstanceError {
    pub fn new(kind: ModifyDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_upgrade_dependency_failure_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DBUpgradeDependencyFailureFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDBSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for ModifyDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DBInstanceAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DBSecurityGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DBUpgradeDependencyFailureFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDBSecurityGroupStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBParameterGroupError {
    pub kind: ModifyDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBParameterGroupError {
    pub fn new(kind: ModifyDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyError {
    pub kind: ModifyDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyErrorKind {
    DBProxyAlreadyExistsFault(crate::error::DBProxyAlreadyExistsFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyErrorKind::DBProxyAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyError {
    pub fn new(kind: ModifyDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyErrorKind::DBProxyAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyDBProxyErrorKind::DBProxyNotFoundFault(_))
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyErrorKind::DBProxyAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyEndpointError {
    pub kind: ModifyDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyEndpointErrorKind {
    DBProxyEndpointAlreadyExistsFault(crate::error::DBProxyEndpointAlreadyExistsFault),
    DBProxyEndpointNotFoundFault(crate::error::DBProxyEndpointNotFoundFault),
    InvalidDBProxyEndpointStateFault(crate::error::InvalidDBProxyEndpointStateFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyEndpointError {
    pub fn new(kind: ModifyDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyEndpointErrorKind::DBProxyEndpointNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyEndpointStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyEndpointErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyTargetGroupError {
    pub kind: ModifyDBProxyTargetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyTargetGroupErrorKind {
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyTargetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyTargetGroupErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyTargetGroupErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyTargetGroupErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyTargetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyTargetGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyTargetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyTargetGroupError {
    pub fn new(kind: ModifyDBProxyTargetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyTargetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyTargetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyTargetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyTargetGroupErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyTargetGroupErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyTargetGroupErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyTargetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSnapshotError {
    pub kind: ModifyDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSnapshotErrorKind {
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSnapshotError {
    fn code(&self) -> Option<&str> {
        ModifyDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSnapshotError {
    pub fn new(kind: ModifyDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            ModifyDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSnapshotAttributeError {
    pub kind: ModifyDBSnapshotAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSnapshotAttributeErrorKind {
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    SharedSnapshotQuotaExceededFault(crate::error::SharedSnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSnapshotAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSnapshotAttributeErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSnapshotAttributeErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSnapshotAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSnapshotAttributeError {
    fn code(&self) -> Option<&str> {
        ModifyDBSnapshotAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSnapshotAttributeError {
    pub fn new(kind: ModifyDBSnapshotAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSnapshotAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSnapshotAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
    pub fn is_shared_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBSnapshotAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSnapshotAttributeErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            ModifyDBSnapshotAttributeErrorKind::InvalidDBSnapshotStateFault(_inner) => Some(_inner),
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyDBSnapshotAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSubnetGroupError {
    pub kind: ModifyDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSubnetGroupErrorKind {
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DBSubnetQuotaExceededFault(crate::error::DBSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    SubnetAlreadyInUse(crate::error::SubnetAlreadyInUse),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSubnetGroupError {
    pub fn new(kind: ModifyDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, ModifyDBSubnetGroupErrorKind::InvalidSubnet(_))
    }
    pub fn is_subnet_already_in_use(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_)
        )
    }
}
impl std::error::Error for ModifyDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            ModifyDBSubnetGroupErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::DBSubnetQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyEventSubscriptionError {
    pub kind: ModifyEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyEventSubscriptionErrorKind {
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    SNSInvalidTopicFault(crate::error::SNSInvalidTopicFault),
    SNSNoAuthorizationFault(crate::error::SNSNoAuthorizationFault),
    SNSTopicArnNotFoundFault(crate::error::SNSTopicArnNotFoundFault),
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyEventSubscriptionErrorKind::SNSInvalidTopicFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SNSNoAuthorizationFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        ModifyEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyEventSubscriptionError {
    pub fn new(kind: ModifyEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_)
        )
    }
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SNSInvalidTopicFault(_)
        )
    }
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SNSNoAuthorizationFault(_)
        )
    }
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_)
        )
    }
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyEventSubscriptionErrorKind::SNSInvalidTopicFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SNSNoAuthorizationFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SNSTopicArnNotFoundFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyGlobalClusterError {
    pub kind: ModifyGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyGlobalClusterErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyGlobalClusterError {
    fn code(&self) -> Option<&str> {
        ModifyGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyGlobalClusterError {
    pub fn new(kind: ModifyGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for ModifyGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyOptionGroupError {
    pub kind: ModifyOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyOptionGroupErrorKind {
    InvalidOptionGroupStateFault(crate::error::InvalidOptionGroupStateFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => _inner.fmt(f),
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyOptionGroupError {
    fn code(&self) -> Option<&str> {
        ModifyOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyOptionGroupError {
    pub fn new(kind: ModifyOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_option_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => Some(_inner),
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            ModifyOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PromoteReadReplicaError {
    pub kind: PromoteReadReplicaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PromoteReadReplicaErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PromoteReadReplicaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PromoteReadReplicaErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PromoteReadReplicaError {
    fn code(&self) -> Option<&str> {
        PromoteReadReplicaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PromoteReadReplicaError {
    pub fn new(kind: PromoteReadReplicaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PromoteReadReplicaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PromoteReadReplicaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for PromoteReadReplicaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PromoteReadReplicaErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            PromoteReadReplicaErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            PromoteReadReplicaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PromoteReadReplicaDBClusterError {
    pub kind: PromoteReadReplicaDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PromoteReadReplicaDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PromoteReadReplicaDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PromoteReadReplicaDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            PromoteReadReplicaDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PromoteReadReplicaDBClusterError {
    fn code(&self) -> Option<&str> {
        PromoteReadReplicaDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PromoteReadReplicaDBClusterError {
    pub fn new(kind: PromoteReadReplicaDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PromoteReadReplicaDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PromoteReadReplicaDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for PromoteReadReplicaDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PromoteReadReplicaDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            PromoteReadReplicaDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => {
                Some(_inner)
            }
            PromoteReadReplicaDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseReservedDBInstancesOfferingError {
    pub kind: PurchaseReservedDBInstancesOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedDBInstancesOfferingErrorKind {
    ReservedDBInstanceAlreadyExistsFault(crate::error::ReservedDBInstanceAlreadyExistsFault),
    ReservedDBInstanceQuotaExceededFault(crate::error::ReservedDBInstanceQuotaExceededFault),
    ReservedDBInstancesOfferingNotFoundFault(
        crate::error::ReservedDBInstancesOfferingNotFoundFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseReservedDBInstancesOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstancesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseReservedDBInstancesOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseReservedDBInstancesOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedDBInstancesOfferingError {
    pub fn new(
        kind: PurchaseReservedDBInstancesOfferingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_reserved_db_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceQuotaExceededFault(_)
        )
    }
    pub fn is_reserved_db_instances_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstancesOfferingNotFoundFault(
                _
            )
        )
    }
}
impl std::error::Error for PurchaseReservedDBInstancesOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstanceQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDBInstancesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootDBInstanceError {
    pub kind: RebootDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootDBInstanceErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RebootDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            RebootDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootDBInstanceError {
    fn code(&self) -> Option<&str> {
        RebootDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootDBInstanceError {
    pub fn new(kind: RebootDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for RebootDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            RebootDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            RebootDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterDBProxyTargetsError {
    pub kind: RegisterDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDBProxyTargetsErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetAlreadyRegisteredFault(crate::error::DBProxyTargetAlreadyRegisteredFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    InsufficientAvailableIPsInSubnetFault(crate::error::InsufficientAvailableIPsInSubnetFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidDBProxyStateFault(crate::error::InvalidDBProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterDBProxyTargetsErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DBProxyTargetAlreadyRegisteredFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        RegisterDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDBProxyTargetsError {
    pub fn new(kind: RegisterDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_already_registered_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DBProxyTargetAlreadyRegisteredFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_available_i_ps_in_subnet_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_)
        )
    }
}
impl std::error::Error for RegisterDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterDBProxyTargetsErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DBProxyTargetAlreadyRegisteredFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::InvalidDBProxyStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveFromGlobalClusterError {
    pub kind: RemoveFromGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveFromGlobalClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveFromGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveFromGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveFromGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveFromGlobalClusterError {
    fn code(&self) -> Option<&str> {
        RemoveFromGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveFromGlobalClusterError {
    pub fn new(kind: RemoveFromGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveFromGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveFromGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for RemoveFromGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveFromGlobalClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => {
                Some(_inner)
            }
            RemoveFromGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromDBClusterError {
    pub kind: RemoveRoleFromDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterRoleNotFoundFault(crate::error::DBClusterRoleNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::DBClusterRoleNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromDBClusterError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromDBClusterError {
    pub fn new(kind: RemoveRoleFromDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::DBClusterRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::DBClusterRoleNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromDBInstanceError {
    pub kind: RemoveRoleFromDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromDBInstanceErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBInstanceRoleNotFoundFault(crate::error::DBInstanceRoleNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::DBInstanceRoleNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromDBInstanceError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromDBInstanceError {
    pub fn new(kind: RemoveRoleFromDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_instance_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::DBInstanceRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::DBInstanceRoleNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveSourceIdentifierFromSubscriptionError {
    pub kind: RemoveSourceIdentifierFromSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveSourceIdentifierFromSubscriptionErrorKind {
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveSourceIdentifierFromSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveSourceIdentifierFromSubscriptionError {
    fn code(&self) -> Option<&str> {
        RemoveSourceIdentifierFromSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveSourceIdentifierFromSubscriptionError {
    pub fn new(
        kind: RemoveSourceIdentifierFromSubscriptionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for RemoveSourceIdentifierFromSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsFromResourceError {
    pub kind: RemoveTagsFromResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBProxyNotFoundFault(crate::error::DBProxyNotFoundFault),
    DBProxyTargetGroupNotFoundFault(crate::error::DBProxyTargetGroupNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DBProxyNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    pub fn new(kind: RemoveTagsFromResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DBProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DBProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DBProxyNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DBProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveTagsFromResourceErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetDBClusterParameterGroupError {
    pub kind: ResetDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBClusterParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        ResetDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBClusterParameterGroupError {
    pub fn new(kind: ResetDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ResetDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetDBClusterParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ResetDBClusterParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetDBParameterGroupError {
    pub kind: ResetDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBParameterGroupErrorKind {
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    InvalidDBParameterGroupStateFault(crate::error::InvalidDBParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ResetDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        ResetDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBParameterGroupError {
    pub fn new(kind: ResetDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ResetDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetDBParameterGroupErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            ResetDBParameterGroupErrorKind::InvalidDBParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterFromS3Error {
    pub kind: RestoreDBClusterFromS3ErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterFromS3ErrorKind {
    DBClusterAlreadyExistsFault(crate::error::DBClusterAlreadyExistsFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterParameterGroupNotFoundFault(crate::error::DBClusterParameterGroupNotFoundFault),
    DBClusterQuotaExceededFault(crate::error::DBClusterQuotaExceededFault),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBSubnetGroupStateFault(crate::error::InvalidDBSubnetGroupStateFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterFromS3Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterFromS3ErrorKind::DBClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::DBClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidDBSubnetGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromS3Error {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterFromS3Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterFromS3Error {
    pub fn new(kind: RestoreDBClusterFromS3ErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterFromS3ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterFromS3ErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DBClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DBClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DBClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidDBSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterFromS3Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterFromS3ErrorKind::DBClusterAlreadyExistsFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromS3ErrorKind::DBClusterQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidDBSubnetGroupStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterFromSnapshotError {
    pub kind: RestoreDBClusterFromSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterFromSnapshotErrorKind {
    DBClusterAlreadyExistsFault(crate::error::DBClusterAlreadyExistsFault),
    DBClusterParameterGroupNotFoundFault(crate::error::DBClusterParameterGroupNotFoundFault),
    DBClusterQuotaExceededFault(crate::error::DBClusterQuotaExceededFault),
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDBClusterCapacityFault(crate::error::InsufficientDBClusterCapacityFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterFromSnapshotErrorKind::DBClusterAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDBClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromSnapshotError {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterFromSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterFromSnapshotError {
    pub fn new(kind: RestoreDBClusterFromSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterFromSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterFromSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDBClusterCapacityFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterFromSnapshotErrorKind::DBClusterAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDBClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterToPointInTimeError {
    pub kind: RestoreDBClusterToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterToPointInTimeErrorKind {
    DBClusterAlreadyExistsFault(crate::error::DBClusterAlreadyExistsFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBClusterParameterGroupNotFoundFault(crate::error::DBClusterParameterGroupNotFoundFault),
    DBClusterQuotaExceededFault(crate::error::DBClusterQuotaExceededFault),
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDBClusterCapacityFault(crate::error::InsufficientDBClusterCapacityFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDBClusterSnapshotStateFault(crate::error::InvalidDBClusterSnapshotStateFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterToPointInTimeErrorKind::DBClusterAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::DBClusterParameterGroupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::DBClusterQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDBClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterToPointInTimeError {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterToPointInTimeError {
    pub fn new(kind: RestoreDBClusterToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDBClusterCapacityFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterToPointInTimeErrorKind::DBClusterAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::DBClusterParameterGroupNotFoundFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::DBClusterQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDBClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBClusterStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceFromDBSnapshotError {
    pub kind: RestoreDBInstanceFromDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceFromDBSnapshotErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBSnapshotStateFault(crate::error::InvalidDBSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceFromDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDBInstanceCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAZFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceFromDBSnapshotError {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceFromDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceFromDBSnapshotError {
    pub fn new(kind: RestoreDBInstanceFromDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceFromDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDBInstanceCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDBSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAZFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceFromS3Error {
    pub kind: RestoreDBInstanceFromS3ErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceFromS3ErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceFromS3Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DBInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::DBSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InsufficientDBInstanceCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceFromS3Error {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceFromS3Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceFromS3Error {
    pub fn new(kind: RestoreDBInstanceFromS3ErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceFromS3ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceFromS3ErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceFromS3Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DBInstanceAlreadyExistsFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DBParameterGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DBSecurityGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InsufficientDBInstanceCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAZFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceToPointInTimeError {
    pub kind: RestoreDBInstanceToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceToPointInTimeErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DBInstanceAlreadyExistsFault(crate::error::DBInstanceAlreadyExistsFault),
    DBInstanceAutomatedBackupNotFoundFault(crate::error::DBInstanceAutomatedBackupNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBParameterGroupNotFoundFault(crate::error::DBParameterGroupNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    PointInTimeRestoreNotEnabledFault(crate::error::PointInTimeRestoreNotEnabledFault),
    ProvisionedIopsNotAvailableInAZFault(crate::error::ProvisionedIopsNotAvailableInAZFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDBInstanceCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDBInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAZFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceToPointInTimeError {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceToPointInTimeError {
    pub fn new(kind: RestoreDBInstanceToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAutomatedBackupNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_point_in_time_restore_not_enabled_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAZFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::DBInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DBSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDBInstanceCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDBInstanceStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVPCNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::KMSKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAZFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeDBSecurityGroupIngressError {
    pub kind: RevokeDBSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeDBSecurityGroupIngressErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    DBSecurityGroupNotFoundFault(crate::error::DBSecurityGroupNotFoundFault),
    InvalidDBSecurityGroupStateFault(crate::error::InvalidDBSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeDBSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeDBSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        RevokeDBSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeDBSecurityGroupIngressError {
    pub fn new(kind: RevokeDBSecurityGroupIngressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for RevokeDBSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::DBSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::InvalidDBSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartActivityStreamError {
    pub kind: StartActivityStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartActivityStreamErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartActivityStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartActivityStreamErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartActivityStreamError {
    fn code(&self) -> Option<&str> {
        StartActivityStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartActivityStreamError {
    pub fn new(kind: StartActivityStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartActivityStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartActivityStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for StartActivityStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartActivityStreamErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBClusterError {
    pub kind: StartDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBClusterError {
    fn code(&self) -> Option<&str> {
        StartDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBClusterError {
    pub fn new(kind: StartDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StartDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBInstanceError {
    pub kind: StartDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBSubnetGroupDoesNotCoverEnoughAZs(crate::error::DBSubnetGroupDoesNotCoverEnoughAZs),
    DBSubnetGroupNotFoundFault(crate::error::DBSubnetGroupNotFoundFault),
    InsufficientDBInstanceCapacityFault(crate::error::InsufficientDBInstanceCapacityFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVPCNetworkStateFault(crate::error::InvalidVPCNetworkStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBInstanceError {
    fn code(&self) -> Option<&str> {
        StartDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBInstanceError {
    pub fn new(kind: StartDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, StartDBInstanceErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidVPCNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for StartDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DBSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DBSubnetGroupNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InsufficientDBInstanceCapacityFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidSubnet(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidVPCNetworkStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBInstanceAutomatedBackupsReplicationError {
    pub kind: StartDBInstanceAutomatedBackupsReplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBInstanceAutomatedBackupsReplicationErrorKind {
    DBInstanceAutomatedBackupQuotaExceededFault(
        crate::error::DBInstanceAutomatedBackupQuotaExceededFault,
    ),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBInstanceAutomatedBackupsReplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KMSKeyNotAccessibleFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBInstanceAutomatedBackupsReplicationError {
    fn code(&self) -> Option<&str> {
        StartDBInstanceAutomatedBackupsReplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBInstanceAutomatedBackupsReplicationError {
    pub fn new(
        kind: StartDBInstanceAutomatedBackupsReplicationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_quota_exceeded_fault(&self) -> bool {
        matches!(&self.kind, StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_))
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for StartDBInstanceAutomatedBackupsReplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceAutomatedBackupQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KMSKeyNotAccessibleFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartExportTaskError {
    pub kind: StartExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartExportTaskErrorKind {
    DBClusterSnapshotNotFoundFault(crate::error::DBClusterSnapshotNotFoundFault),
    DBSnapshotNotFoundFault(crate::error::DBSnapshotNotFoundFault),
    ExportTaskAlreadyExistsFault(crate::error::ExportTaskAlreadyExistsFault),
    IamRoleMissingPermissionsFault(crate::error::IamRoleMissingPermissionsFault),
    IamRoleNotFoundFault(crate::error::IamRoleNotFoundFault),
    InvalidExportOnlyFault(crate::error::InvalidExportOnlyFault),
    InvalidExportSourceStateFault(crate::error::InvalidExportSourceStateFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    KMSKeyNotAccessibleFault(crate::error::KMSKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartExportTaskErrorKind::DBClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::DBSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::IamRoleNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidExportOnlyFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::KMSKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartExportTaskError {
    fn code(&self) -> Option<&str> {
        StartExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartExportTaskError {
    pub fn new(kind: StartExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::DBClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::DBSnapshotNotFoundFault(_)
        )
    }
    pub fn is_export_task_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_)
        )
    }
    pub fn is_iam_role_missing_permissions_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_)
        )
    }
    pub fn is_iam_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::IamRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_export_only_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidExportOnlyFault(_)
        )
    }
    pub fn is_invalid_export_source_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::KMSKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for StartExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartExportTaskErrorKind::DBClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::DBSnapshotNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::IamRoleNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidExportOnlyFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::KMSKeyNotAccessibleFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopActivityStreamError {
    pub kind: StopActivityStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopActivityStreamErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopActivityStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopActivityStreamErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopActivityStreamError {
    fn code(&self) -> Option<&str> {
        StopActivityStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopActivityStreamError {
    pub fn new(kind: StopActivityStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopActivityStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopActivityStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for StopActivityStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopActivityStreamErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBClusterError {
    pub kind: StopDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBClusterErrorKind {
    DBClusterNotFoundFault(crate::error::DBClusterNotFoundFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBClusterErrorKind::DBClusterNotFoundFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBClusterError {
    fn code(&self) -> Option<&str> {
        StopDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBClusterError {
    pub fn new(kind: StopDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::DBClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StopDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBClusterErrorKind::DBClusterNotFoundFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBInstanceError {
    pub kind: StopDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBInstanceErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    DBSnapshotAlreadyExistsFault(crate::error::DBSnapshotAlreadyExistsFault),
    InvalidDBClusterStateFault(crate::error::InvalidDBClusterStateFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBInstanceError {
    fn code(&self) -> Option<&str> {
        StopDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBInstanceError {
    pub fn new(kind: StopDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::InvalidDBClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for StopDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBInstanceErrorKind::DBInstanceNotFoundFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::DBSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::InvalidDBClusterStateFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::InvalidDBInstanceStateFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBInstanceAutomatedBackupsReplicationError {
    pub kind: StopDBInstanceAutomatedBackupsReplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBInstanceAutomatedBackupsReplicationErrorKind {
    DBInstanceNotFoundFault(crate::error::DBInstanceNotFoundFault),
    InvalidDBInstanceStateFault(crate::error::InvalidDBInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBInstanceAutomatedBackupsReplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(
                _inner,
            ) => _inner.fmt(f),
            StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBInstanceAutomatedBackupsReplicationError {
    fn code(&self) -> Option<&str> {
        StopDBInstanceAutomatedBackupsReplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBInstanceAutomatedBackupsReplicationError {
    pub fn new(
        kind: StopDBInstanceAutomatedBackupsReplicationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StopDBInstanceAutomatedBackupsReplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DBInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDBInstanceStateFault(
                _inner,
            ) => Some(_inner),
            StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// <p>The DB instance isn't in a valid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBInstanceStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBInstanceStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBInstanceStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBInstanceStateFault")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBInstanceStateFault {}
/// See [`InvalidDBInstanceStateFault`](crate::error::InvalidDBInstanceStateFault)
pub mod invalid_db_instance_state_fault {
    /// A builder for [`InvalidDBInstanceStateFault`](crate::error::InvalidDBInstanceStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBInstanceStateFault`](crate::error::InvalidDBInstanceStateFault)
        pub fn build(self) -> crate::error::InvalidDBInstanceStateFault {
            crate::error::InvalidDBInstanceStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBInstanceStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBInstanceStateFault`](crate::error::InvalidDBInstanceStateFault)
    pub fn builder() -> crate::error::invalid_db_instance_state_fault::Builder {
        crate::error::invalid_db_instance_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBInstanceIdentifier</code> doesn't refer to an existing DB instance.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceNotFoundFault")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceNotFoundFault {}
/// See [`DBInstanceNotFoundFault`](crate::error::DBInstanceNotFoundFault)
pub mod db_instance_not_found_fault {
    /// A builder for [`DBInstanceNotFoundFault`](crate::error::DBInstanceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceNotFoundFault`](crate::error::DBInstanceNotFoundFault)
        pub fn build(self) -> crate::error::DBInstanceNotFoundFault {
            crate::error::DBInstanceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceNotFoundFault`](crate::error::DBInstanceNotFoundFault)
    pub fn builder() -> crate::error::db_instance_not_found_fault::Builder {
        crate::error::db_instance_not_found_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
/// snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotQuotaExceededFault")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotQuotaExceededFault {}
/// See [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
pub mod snapshot_quota_exceeded_fault {
    /// A builder for [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
        pub fn build(self) -> crate::error::SnapshotQuotaExceededFault {
            crate::error::SnapshotQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    pub fn builder() -> crate::error::snapshot_quota_exceeded_fault::Builder {
        crate::error::snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed while the cluster is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBClusterStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBClusterStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBClusterStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBClusterStateFault")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBClusterStateFault {}
/// See [`InvalidDBClusterStateFault`](crate::error::InvalidDBClusterStateFault)
pub mod invalid_db_cluster_state_fault {
    /// A builder for [`InvalidDBClusterStateFault`](crate::error::InvalidDBClusterStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBClusterStateFault`](crate::error::InvalidDBClusterStateFault)
        pub fn build(self) -> crate::error::InvalidDBClusterStateFault {
            crate::error::InvalidDBClusterStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBClusterStateFault`](crate::error::InvalidDBClusterStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_state_fault::Builder {
        crate::error::invalid_db_cluster_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSnapshotIdentifier</code> is already used by an existing snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSnapshotAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSnapshotAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSnapshotAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSnapshotAlreadyExistsFault")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSnapshotAlreadyExistsFault {}
/// See [`DBSnapshotAlreadyExistsFault`](crate::error::DBSnapshotAlreadyExistsFault)
pub mod db_snapshot_already_exists_fault {
    /// A builder for [`DBSnapshotAlreadyExistsFault`](crate::error::DBSnapshotAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSnapshotAlreadyExistsFault`](crate::error::DBSnapshotAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBSnapshotAlreadyExistsFault {
            crate::error::DBSnapshotAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBSnapshotAlreadyExistsFault`](crate::error::DBSnapshotAlreadyExistsFault)
    pub fn builder() -> crate::error::db_snapshot_already_exists_fault::Builder {
        crate::error::db_snapshot_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterIdentifier</code> doesn't refer to an existing DB cluster.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterNotFoundFault")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterNotFoundFault {}
/// See [`DBClusterNotFoundFault`](crate::error::DBClusterNotFoundFault)
pub mod db_cluster_not_found_fault {
    /// A builder for [`DBClusterNotFoundFault`](crate::error::DBClusterNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterNotFoundFault`](crate::error::DBClusterNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterNotFoundFault {
            crate::error::DBClusterNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterNotFoundFault`](crate::error::DBClusterNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_not_found_fault::Builder {
        crate::error::db_cluster_not_found_fault::Builder::default()
    }
}

/// <p>The specified resource ID was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundFault")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundFault {}
/// See [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
pub mod resource_not_found_fault {
    /// A builder for [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
        pub fn build(self) -> crate::error::ResourceNotFoundFault {
            crate::error::ResourceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
    pub fn builder() -> crate::error::resource_not_found_fault::Builder {
        crate::error::resource_not_found_fault::Builder::default()
    }
}

/// <p>An error occurred accessing an AWS KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSKeyNotAccessibleFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSKeyNotAccessibleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSKeyNotAccessibleFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSKeyNotAccessibleFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSKeyNotAccessibleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSKeyNotAccessibleFault")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSKeyNotAccessibleFault {}
/// See [`KMSKeyNotAccessibleFault`](crate::error::KMSKeyNotAccessibleFault)
pub mod kms_key_not_accessible_fault {
    /// A builder for [`KMSKeyNotAccessibleFault`](crate::error::KMSKeyNotAccessibleFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KMSKeyNotAccessibleFault`](crate::error::KMSKeyNotAccessibleFault)
        pub fn build(self) -> crate::error::KMSKeyNotAccessibleFault {
            crate::error::KMSKeyNotAccessibleFault {
                message: self.message,
            }
        }
    }
}
impl KMSKeyNotAccessibleFault {
    /// Creates a new builder-style object to manufacture [`KMSKeyNotAccessibleFault`](crate::error::KMSKeyNotAccessibleFault)
    pub fn builder() -> crate::error::kms_key_not_accessible_fault::Builder {
        crate::error::kms_key_not_accessible_fault::Builder::default()
    }
}

/// <p>The specified Amazon S3 bucket name can't be found or Amazon RDS isn't
/// authorized to access the specified Amazon S3 bucket. Verify the <b>SourceS3BucketName</b> and <b>S3IngestionRoleArn</b> values and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3BucketFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3BucketFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3BucketFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3BucketFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3BucketFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3BucketFault")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3BucketFault {}
/// See [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
pub mod invalid_s3_bucket_fault {
    /// A builder for [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
        pub fn build(self) -> crate::error::InvalidS3BucketFault {
            crate::error::InvalidS3BucketFault {
                message: self.message,
            }
        }
    }
}
impl InvalidS3BucketFault {
    /// Creates a new builder-style object to manufacture [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
    pub fn builder() -> crate::error::invalid_s3_bucket_fault::Builder {
        crate::error::invalid_s3_bucket_fault::Builder::default()
    }
}

/// <p>The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportSourceStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportSourceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportSourceStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportSourceStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportSourceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportSourceStateFault")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportSourceStateFault {}
/// See [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
pub mod invalid_export_source_state_fault {
    /// A builder for [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
        pub fn build(self) -> crate::error::InvalidExportSourceStateFault {
            crate::error::InvalidExportSourceStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportSourceStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
    pub fn builder() -> crate::error::invalid_export_source_state_fault::Builder {
        crate::error::invalid_export_source_state_fault::Builder::default()
    }
}

/// <p>The export is invalid for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportOnlyFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportOnlyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportOnlyFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportOnlyFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportOnlyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportOnlyFault")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportOnlyFault {}
/// See [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
pub mod invalid_export_only_fault {
    /// A builder for [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
        pub fn build(self) -> crate::error::InvalidExportOnlyFault {
            crate::error::InvalidExportOnlyFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportOnlyFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
    pub fn builder() -> crate::error::invalid_export_only_fault::Builder {
        crate::error::invalid_export_only_fault::Builder::default()
    }
}

/// <p>The IAM role is missing for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IamRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamRoleNotFoundFault")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IamRoleNotFoundFault {}
/// See [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
pub mod iam_role_not_found_fault {
    /// A builder for [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
        pub fn build(self) -> crate::error::IamRoleNotFoundFault {
            crate::error::IamRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl IamRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
    pub fn builder() -> crate::error::iam_role_not_found_fault::Builder {
        crate::error::iam_role_not_found_fault::Builder::default()
    }
}

/// <p>The IAM role requires additional permissions to export to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamRoleMissingPermissionsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamRoleMissingPermissionsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamRoleMissingPermissionsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IamRoleMissingPermissionsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamRoleMissingPermissionsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamRoleMissingPermissionsFault")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for IamRoleMissingPermissionsFault {}
/// See [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
pub mod iam_role_missing_permissions_fault {
    /// A builder for [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
        pub fn build(self) -> crate::error::IamRoleMissingPermissionsFault {
            crate::error::IamRoleMissingPermissionsFault {
                message: self.message,
            }
        }
    }
}
impl IamRoleMissingPermissionsFault {
    /// Creates a new builder-style object to manufacture [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
    pub fn builder() -> crate::error::iam_role_missing_permissions_fault::Builder {
        crate::error::iam_role_missing_permissions_fault::Builder::default()
    }
}

/// <p>You can't start an export task that's already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportTaskAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportTaskAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportTaskAlreadyExistsFault")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportTaskAlreadyExistsFault {}
/// See [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
pub mod export_task_already_exists_fault {
    /// A builder for [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
        pub fn build(self) -> crate::error::ExportTaskAlreadyExistsFault {
            crate::error::ExportTaskAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ExportTaskAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
    pub fn builder() -> crate::error::export_task_already_exists_fault::Builder {
        crate::error::export_task_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSnapshotIdentifier</code> doesn't refer to an existing DB snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSnapshotNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSnapshotNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSnapshotNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSnapshotNotFoundFault")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSnapshotNotFoundFault {}
/// See [`DBSnapshotNotFoundFault`](crate::error::DBSnapshotNotFoundFault)
pub mod db_snapshot_not_found_fault {
    /// A builder for [`DBSnapshotNotFoundFault`](crate::error::DBSnapshotNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSnapshotNotFoundFault`](crate::error::DBSnapshotNotFoundFault)
        pub fn build(self) -> crate::error::DBSnapshotNotFoundFault {
            crate::error::DBSnapshotNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBSnapshotNotFoundFault`](crate::error::DBSnapshotNotFoundFault)
    pub fn builder() -> crate::error::db_snapshot_not_found_fault::Builder {
        crate::error::db_snapshot_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterSnapshotIdentifier</code> doesn't refer to an existing DB cluster snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterSnapshotNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterSnapshotNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterSnapshotNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterSnapshotNotFoundFault")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterSnapshotNotFoundFault {}
/// See [`DBClusterSnapshotNotFoundFault`](crate::error::DBClusterSnapshotNotFoundFault)
pub mod db_cluster_snapshot_not_found_fault {
    /// A builder for [`DBClusterSnapshotNotFoundFault`](crate::error::DBClusterSnapshotNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterSnapshotNotFoundFault`](crate::error::DBClusterSnapshotNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterSnapshotNotFoundFault {
            crate::error::DBClusterSnapshotNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterSnapshotNotFoundFault`](crate::error::DBClusterSnapshotNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_snapshot_not_found_fault::Builder {
        crate::error::db_cluster_snapshot_not_found_fault::Builder::default()
    }
}

/// <p>Storage of the <code>StorageType</code> specified can't be associated
/// with the DB instance. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageTypeNotSupportedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StorageTypeNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageTypeNotSupportedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StorageTypeNotSupportedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageTypeNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageTypeNotSupportedFault")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for StorageTypeNotSupportedFault {}
/// See [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
pub mod storage_type_not_supported_fault {
    /// A builder for [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
        pub fn build(self) -> crate::error::StorageTypeNotSupportedFault {
            crate::error::StorageTypeNotSupportedFault {
                message: self.message,
            }
        }
    }
}
impl StorageTypeNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
    pub fn builder() -> crate::error::storage_type_not_supported_fault::Builder {
        crate::error::storage_type_not_supported_fault::Builder::default()
    }
}

/// <p>The quota for retained automated backups was exceeded. This prevents you
/// from retaining any additional automated backups. The retained automated backups
/// quota is the same as your DB Instance quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceAutomatedBackupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceAutomatedBackupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceAutomatedBackupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceAutomatedBackupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceAutomatedBackupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceAutomatedBackupQuotaExceededFault")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceAutomatedBackupQuotaExceededFault {}
/// See [`DBInstanceAutomatedBackupQuotaExceededFault`](crate::error::DBInstanceAutomatedBackupQuotaExceededFault)
pub mod db_instance_automated_backup_quota_exceeded_fault {
    /// A builder for [`DBInstanceAutomatedBackupQuotaExceededFault`](crate::error::DBInstanceAutomatedBackupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceAutomatedBackupQuotaExceededFault`](crate::error::DBInstanceAutomatedBackupQuotaExceededFault)
        pub fn build(self) -> crate::error::DBInstanceAutomatedBackupQuotaExceededFault {
            crate::error::DBInstanceAutomatedBackupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceAutomatedBackupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceAutomatedBackupQuotaExceededFault`](crate::error::DBInstanceAutomatedBackupQuotaExceededFault)
    pub fn builder() -> crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder {
        crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The DB subnet group doesn't cover all Availability Zones after it's
/// created because of users' change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidVPCNetworkStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidVPCNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidVPCNetworkStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidVPCNetworkStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVPCNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidVPCNetworkStateFault")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVPCNetworkStateFault {}
/// See [`InvalidVPCNetworkStateFault`](crate::error::InvalidVPCNetworkStateFault)
pub mod invalid_vpc_network_state_fault {
    /// A builder for [`InvalidVPCNetworkStateFault`](crate::error::InvalidVPCNetworkStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVPCNetworkStateFault`](crate::error::InvalidVPCNetworkStateFault)
        pub fn build(self) -> crate::error::InvalidVPCNetworkStateFault {
            crate::error::InvalidVPCNetworkStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidVPCNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVPCNetworkStateFault`](crate::error::InvalidVPCNetworkStateFault)
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSubnet {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSubnet");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSubnet {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
/// See [`InvalidSubnet`](crate::error::InvalidSubnet)
pub mod invalid_subnet {
    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet)
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
            }
        }
    }
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet)
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}

/// <p>The specified DB instance class isn't available in the specified Availability
/// Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDBInstanceCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDBInstanceCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientDBInstanceCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDBInstanceCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDBInstanceCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientDBInstanceCapacityFault")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDBInstanceCapacityFault {}
/// See [`InsufficientDBInstanceCapacityFault`](crate::error::InsufficientDBInstanceCapacityFault)
pub mod insufficient_db_instance_capacity_fault {
    /// A builder for [`InsufficientDBInstanceCapacityFault`](crate::error::InsufficientDBInstanceCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDBInstanceCapacityFault`](crate::error::InsufficientDBInstanceCapacityFault)
        pub fn build(self) -> crate::error::InsufficientDBInstanceCapacityFault {
            crate::error::InsufficientDBInstanceCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientDBInstanceCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDBInstanceCapacityFault`](crate::error::InsufficientDBInstanceCapacityFault)
    pub fn builder() -> crate::error::insufficient_db_instance_capacity_fault::Builder {
        crate::error::insufficient_db_instance_capacity_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSubnetGroupName</code> doesn't refer to an existing DB subnet group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetGroupNotFoundFault")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetGroupNotFoundFault {}
/// See [`DBSubnetGroupNotFoundFault`](crate::error::DBSubnetGroupNotFoundFault)
pub mod db_subnet_group_not_found_fault {
    /// A builder for [`DBSubnetGroupNotFoundFault`](crate::error::DBSubnetGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetGroupNotFoundFault`](crate::error::DBSubnetGroupNotFoundFault)
        pub fn build(self) -> crate::error::DBSubnetGroupNotFoundFault {
            crate::error::DBSubnetGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBSubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBSubnetGroupNotFoundFault`](crate::error::DBSubnetGroupNotFoundFault)
    pub fn builder() -> crate::error::db_subnet_group_not_found_fault::Builder {
        crate::error::db_subnet_group_not_found_fault::Builder::default()
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetGroupDoesNotCoverEnoughAZs {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetGroupDoesNotCoverEnoughAZs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetGroupDoesNotCoverEnoughAZs");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetGroupDoesNotCoverEnoughAZs {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetGroupDoesNotCoverEnoughAZs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetGroupDoesNotCoverEnoughAZs")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetGroupDoesNotCoverEnoughAZs {}
/// See [`DBSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DBSubnetGroupDoesNotCoverEnoughAZs)
pub mod db_subnet_group_does_not_cover_enough_a_zs {
    /// A builder for [`DBSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DBSubnetGroupDoesNotCoverEnoughAZs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DBSubnetGroupDoesNotCoverEnoughAZs)
        pub fn build(self) -> crate::error::DBSubnetGroupDoesNotCoverEnoughAZs {
            crate::error::DBSubnetGroupDoesNotCoverEnoughAZs {
                message: self.message,
            }
        }
    }
}
impl DBSubnetGroupDoesNotCoverEnoughAZs {
    /// Creates a new builder-style object to manufacture [`DBSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DBSubnetGroupDoesNotCoverEnoughAZs)
    pub fn builder() -> crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder {
        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default()
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group might not be authorized
/// for the specified DB security group.</p>
/// <p>Or, RDS might not be authorized to perform necessary actions using IAM on your
/// behalf.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationNotFoundFault")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationNotFoundFault {}
/// See [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
pub mod authorization_not_found_fault {
    /// A builder for [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
        pub fn build(self) -> crate::error::AuthorizationNotFoundFault {
            crate::error::AuthorizationNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    pub fn builder() -> crate::error::authorization_not_found_fault::Builder {
        crate::error::authorization_not_found_fault::Builder::default()
    }
}

/// <p>The state of the DB security group doesn't allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBSecurityGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBSecurityGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBSecurityGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBSecurityGroupStateFault")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBSecurityGroupStateFault {}
/// See [`InvalidDBSecurityGroupStateFault`](crate::error::InvalidDBSecurityGroupStateFault)
pub mod invalid_db_security_group_state_fault {
    /// A builder for [`InvalidDBSecurityGroupStateFault`](crate::error::InvalidDBSecurityGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBSecurityGroupStateFault`](crate::error::InvalidDBSecurityGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDBSecurityGroupStateFault {
            crate::error::InvalidDBSecurityGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBSecurityGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBSecurityGroupStateFault`](crate::error::InvalidDBSecurityGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_security_group_state_fault::Builder {
        crate::error::invalid_db_security_group_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSecurityGroupName</code> doesn't refer to an existing DB security group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSecurityGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSecurityGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSecurityGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSecurityGroupNotFoundFault")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSecurityGroupNotFoundFault {}
/// See [`DBSecurityGroupNotFoundFault`](crate::error::DBSecurityGroupNotFoundFault)
pub mod db_security_group_not_found_fault {
    /// A builder for [`DBSecurityGroupNotFoundFault`](crate::error::DBSecurityGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSecurityGroupNotFoundFault`](crate::error::DBSecurityGroupNotFoundFault)
        pub fn build(self) -> crate::error::DBSecurityGroupNotFoundFault {
            crate::error::DBSecurityGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBSecurityGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBSecurityGroupNotFoundFault`](crate::error::DBSecurityGroupNotFoundFault)
    pub fn builder() -> crate::error::db_security_group_not_found_fault::Builder {
        crate::error::db_security_group_not_found_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed amount of storage
/// available across all DB instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StorageQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StorageQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageQuotaExceededFault")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for StorageQuotaExceededFault {}
/// See [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
pub mod storage_quota_exceeded_fault {
    /// A builder for [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
        pub fn build(self) -> crate::error::StorageQuotaExceededFault {
            crate::error::StorageQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl StorageQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
    pub fn builder() -> crate::error::storage_quota_exceeded_fault::Builder {
        crate::error::storage_quota_exceeded_fault::Builder::default()
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedIopsNotAvailableInAZFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedIopsNotAvailableInAZFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedIopsNotAvailableInAZFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedIopsNotAvailableInAZFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedIopsNotAvailableInAZFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedIopsNotAvailableInAZFault")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedIopsNotAvailableInAZFault {}
/// See [`ProvisionedIopsNotAvailableInAZFault`](crate::error::ProvisionedIopsNotAvailableInAZFault)
pub mod provisioned_iops_not_available_in_az_fault {
    /// A builder for [`ProvisionedIopsNotAvailableInAZFault`](crate::error::ProvisionedIopsNotAvailableInAZFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedIopsNotAvailableInAZFault`](crate::error::ProvisionedIopsNotAvailableInAZFault)
        pub fn build(self) -> crate::error::ProvisionedIopsNotAvailableInAZFault {
            crate::error::ProvisionedIopsNotAvailableInAZFault {
                message: self.message,
            }
        }
    }
}
impl ProvisionedIopsNotAvailableInAZFault {
    /// Creates a new builder-style object to manufacture [`ProvisionedIopsNotAvailableInAZFault`](crate::error::ProvisionedIopsNotAvailableInAZFault)
    pub fn builder() -> crate::error::provisioned_iops_not_available_in_az_fault::Builder {
        crate::error::provisioned_iops_not_available_in_az_fault::Builder::default()
    }
}

/// <p>
/// <code>SourceDBInstanceIdentifier</code>
/// refers to a DB instance with
/// <code>BackupRetentionPeriod</code> equal to 0.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PointInTimeRestoreNotEnabledFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PointInTimeRestoreNotEnabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PointInTimeRestoreNotEnabledFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PointInTimeRestoreNotEnabledFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PointInTimeRestoreNotEnabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PointInTimeRestoreNotEnabledFault")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for PointInTimeRestoreNotEnabledFault {}
/// See [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
pub mod point_in_time_restore_not_enabled_fault {
    /// A builder for [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
        pub fn build(self) -> crate::error::PointInTimeRestoreNotEnabledFault {
            crate::error::PointInTimeRestoreNotEnabledFault {
                message: self.message,
            }
        }
    }
}
impl PointInTimeRestoreNotEnabledFault {
    /// Creates a new builder-style object to manufacture [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
    pub fn builder() -> crate::error::point_in_time_restore_not_enabled_fault::Builder {
        crate::error::point_in_time_restore_not_enabled_fault::Builder::default()
    }
}

/// <p>The specified option group could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupNotFoundFault")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupNotFoundFault {}
/// See [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
pub mod option_group_not_found_fault {
    /// A builder for [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
        pub fn build(self) -> crate::error::OptionGroupNotFoundFault {
            crate::error::OptionGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
    pub fn builder() -> crate::error::option_group_not_found_fault::Builder {
        crate::error::option_group_not_found_fault::Builder::default()
    }
}

/// <p>Cannot restore from VPC backup to non-VPC DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRestoreFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRestoreFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRestoreFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreFault")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRestoreFault {}
/// See [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
pub mod invalid_restore_fault {
    /// A builder for [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
        pub fn build(self) -> crate::error::InvalidRestoreFault {
            crate::error::InvalidRestoreFault {
                message: self.message,
            }
        }
    }
}
impl InvalidRestoreFault {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
    pub fn builder() -> crate::error::invalid_restore_fault::Builder {
        crate::error::invalid_restore_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
/// instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstanceQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceQuotaExceededFault")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstanceQuotaExceededFault {}
/// See [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
pub mod instance_quota_exceeded_fault {
    /// A builder for [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
        pub fn build(self) -> crate::error::InstanceQuotaExceededFault {
            crate::error::InstanceQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl InstanceQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
    pub fn builder() -> crate::error::instance_quota_exceeded_fault::Builder {
        crate::error::instance_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>Domain</code> doesn't refer to an existing Active Directory domain.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DomainNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainNotFoundFault")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainNotFoundFault {}
/// See [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
pub mod domain_not_found_fault {
    /// A builder for [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
        pub fn build(self) -> crate::error::DomainNotFoundFault {
            crate::error::DomainNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DomainNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
    pub fn builder() -> crate::error::domain_not_found_fault::Builder {
        crate::error::domain_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>DBParameterGroupName</code> doesn't refer to an
/// existing DB parameter group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBParameterGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBParameterGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBParameterGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBParameterGroupNotFoundFault")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBParameterGroupNotFoundFault {}
/// See [`DBParameterGroupNotFoundFault`](crate::error::DBParameterGroupNotFoundFault)
pub mod db_parameter_group_not_found_fault {
    /// A builder for [`DBParameterGroupNotFoundFault`](crate::error::DBParameterGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBParameterGroupNotFoundFault`](crate::error::DBParameterGroupNotFoundFault)
        pub fn build(self) -> crate::error::DBParameterGroupNotFoundFault {
            crate::error::DBParameterGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBParameterGroupNotFoundFault`](crate::error::DBParameterGroupNotFoundFault)
    pub fn builder() -> crate::error::db_parameter_group_not_found_fault::Builder {
        crate::error::db_parameter_group_not_found_fault::Builder::default()
    }
}

/// <p>No automated backup for this DB instance was found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceAutomatedBackupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceAutomatedBackupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceAutomatedBackupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceAutomatedBackupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceAutomatedBackupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceAutomatedBackupNotFoundFault")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceAutomatedBackupNotFoundFault {}
/// See [`DBInstanceAutomatedBackupNotFoundFault`](crate::error::DBInstanceAutomatedBackupNotFoundFault)
pub mod db_instance_automated_backup_not_found_fault {
    /// A builder for [`DBInstanceAutomatedBackupNotFoundFault`](crate::error::DBInstanceAutomatedBackupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceAutomatedBackupNotFoundFault`](crate::error::DBInstanceAutomatedBackupNotFoundFault)
        pub fn build(self) -> crate::error::DBInstanceAutomatedBackupNotFoundFault {
            crate::error::DBInstanceAutomatedBackupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceAutomatedBackupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceAutomatedBackupNotFoundFault`](crate::error::DBInstanceAutomatedBackupNotFoundFault)
    pub fn builder() -> crate::error::db_instance_automated_backup_not_found_fault::Builder {
        crate::error::db_instance_automated_backup_not_found_fault::Builder::default()
    }
}

/// <p>The user already has a DB instance with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceAlreadyExistsFault")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceAlreadyExistsFault {}
/// See [`DBInstanceAlreadyExistsFault`](crate::error::DBInstanceAlreadyExistsFault)
pub mod db_instance_already_exists_fault {
    /// A builder for [`DBInstanceAlreadyExistsFault`](crate::error::DBInstanceAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceAlreadyExistsFault`](crate::error::DBInstanceAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBInstanceAlreadyExistsFault {
            crate::error::DBInstanceAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceAlreadyExistsFault`](crate::error::DBInstanceAlreadyExistsFault)
    pub fn builder() -> crate::error::db_instance_already_exists_fault::Builder {
        crate::error::db_instance_already_exists_fault::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupPolicyNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupPolicyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupPolicyNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupPolicyNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupPolicyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupPolicyNotFoundFault")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupPolicyNotFoundFault {}
/// See [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
pub mod backup_policy_not_found_fault {
    /// A builder for [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
        pub fn build(self) -> crate::error::BackupPolicyNotFoundFault {
            crate::error::BackupPolicyNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl BackupPolicyNotFoundFault {
    /// Creates a new builder-style object to manufacture [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
    pub fn builder() -> crate::error::backup_policy_not_found_fault::Builder {
        crate::error::backup_policy_not_found_fault::Builder::default()
    }
}

/// <p>The state of the DB snapshot doesn't allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBSnapshotStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBSnapshotStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBSnapshotStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBSnapshotStateFault")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBSnapshotStateFault {}
/// See [`InvalidDBSnapshotStateFault`](crate::error::InvalidDBSnapshotStateFault)
pub mod invalid_db_snapshot_state_fault {
    /// A builder for [`InvalidDBSnapshotStateFault`](crate::error::InvalidDBSnapshotStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBSnapshotStateFault`](crate::error::InvalidDBSnapshotStateFault)
        pub fn build(self) -> crate::error::InvalidDBSnapshotStateFault {
            crate::error::InvalidDBSnapshotStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBSnapshotStateFault`](crate::error::InvalidDBSnapshotStateFault)
    pub fn builder() -> crate::error::invalid_db_snapshot_state_fault::Builder {
        crate::error::invalid_db_snapshot_state_fault::Builder::default()
    }
}

/// <p>The supplied value isn't a valid DB cluster snapshot state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBClusterSnapshotStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBClusterSnapshotStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBClusterSnapshotStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBClusterSnapshotStateFault")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBClusterSnapshotStateFault {}
/// See [`InvalidDBClusterSnapshotStateFault`](crate::error::InvalidDBClusterSnapshotStateFault)
pub mod invalid_db_cluster_snapshot_state_fault {
    /// A builder for [`InvalidDBClusterSnapshotStateFault`](crate::error::InvalidDBClusterSnapshotStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBClusterSnapshotStateFault`](crate::error::InvalidDBClusterSnapshotStateFault)
        pub fn build(self) -> crate::error::InvalidDBClusterSnapshotStateFault {
            crate::error::InvalidDBClusterSnapshotStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBClusterSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBClusterSnapshotStateFault`](crate::error::InvalidDBClusterSnapshotStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_snapshot_state_fault::Builder {
        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default()
    }
}

/// <p>There is insufficient storage available for the current action. You might be able to
/// resolve this error by updating your subnet group to use different Availability Zones
/// that have more storage available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientStorageClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientStorageClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientStorageClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientStorageClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientStorageClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientStorageClusterCapacityFault")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientStorageClusterCapacityFault {}
/// See [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
pub mod insufficient_storage_cluster_capacity_fault {
    /// A builder for [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
        pub fn build(self) -> crate::error::InsufficientStorageClusterCapacityFault {
            crate::error::InsufficientStorageClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientStorageClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
    pub fn builder() -> crate::error::insufficient_storage_cluster_capacity_fault::Builder {
        crate::error::insufficient_storage_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The DB cluster doesn't have enough capacity for the current operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDBClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDBClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientDBClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDBClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDBClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientDBClusterCapacityFault")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDBClusterCapacityFault {}
/// See [`InsufficientDBClusterCapacityFault`](crate::error::InsufficientDBClusterCapacityFault)
pub mod insufficient_db_cluster_capacity_fault {
    /// A builder for [`InsufficientDBClusterCapacityFault`](crate::error::InsufficientDBClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDBClusterCapacityFault`](crate::error::InsufficientDBClusterCapacityFault)
        pub fn build(self) -> crate::error::InsufficientDBClusterCapacityFault {
            crate::error::InsufficientDBClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientDBClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDBClusterCapacityFault`](crate::error::InsufficientDBClusterCapacityFault)
    pub fn builder() -> crate::error::insufficient_db_cluster_capacity_fault::Builder {
        crate::error::insufficient_db_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The user attempted to create a new DB cluster and the user has already reached the
/// maximum allowed DB cluster quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterQuotaExceededFault")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterQuotaExceededFault {}
/// See [`DBClusterQuotaExceededFault`](crate::error::DBClusterQuotaExceededFault)
pub mod db_cluster_quota_exceeded_fault {
    /// A builder for [`DBClusterQuotaExceededFault`](crate::error::DBClusterQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterQuotaExceededFault`](crate::error::DBClusterQuotaExceededFault)
        pub fn build(self) -> crate::error::DBClusterQuotaExceededFault {
            crate::error::DBClusterQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBClusterQuotaExceededFault`](crate::error::DBClusterQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_quota_exceeded_fault::Builder {
        crate::error::db_cluster_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterParameterGroupName</code> doesn't refer to an existing DB
/// cluster parameter group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterParameterGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterParameterGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterParameterGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterParameterGroupNotFoundFault")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterParameterGroupNotFoundFault {}
/// See [`DBClusterParameterGroupNotFoundFault`](crate::error::DBClusterParameterGroupNotFoundFault)
pub mod db_cluster_parameter_group_not_found_fault {
    /// A builder for [`DBClusterParameterGroupNotFoundFault`](crate::error::DBClusterParameterGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterParameterGroupNotFoundFault`](crate::error::DBClusterParameterGroupNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterParameterGroupNotFoundFault {
            crate::error::DBClusterParameterGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterParameterGroupNotFoundFault`](crate::error::DBClusterParameterGroupNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_parameter_group_not_found_fault::Builder {
        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default()
    }
}

/// <p>The user already has a DB cluster with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterAlreadyExistsFault")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterAlreadyExistsFault {}
/// See [`DBClusterAlreadyExistsFault`](crate::error::DBClusterAlreadyExistsFault)
pub mod db_cluster_already_exists_fault {
    /// A builder for [`DBClusterAlreadyExistsFault`](crate::error::DBClusterAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterAlreadyExistsFault`](crate::error::DBClusterAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBClusterAlreadyExistsFault {
            crate::error::DBClusterAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBClusterAlreadyExistsFault`](crate::error::DBClusterAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_already_exists_fault::Builder {
        crate::error::db_cluster_already_exists_fault::Builder::default()
    }
}

/// <p>The DB subnet group cannot be deleted because it's in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBSubnetGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBSubnetGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBSubnetGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBSubnetGroupStateFault")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBSubnetGroupStateFault {}
/// See [`InvalidDBSubnetGroupStateFault`](crate::error::InvalidDBSubnetGroupStateFault)
pub mod invalid_db_subnet_group_state_fault {
    /// A builder for [`InvalidDBSubnetGroupStateFault`](crate::error::InvalidDBSubnetGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBSubnetGroupStateFault`](crate::error::InvalidDBSubnetGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDBSubnetGroupStateFault {
            crate::error::InvalidDBSubnetGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBSubnetGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBSubnetGroupStateFault`](crate::error::InvalidDBSubnetGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_subnet_group_state_fault::Builder {
        crate::error::invalid_db_subnet_group_state_fault::Builder::default()
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting
/// to delete the parameter group, you can't delete it when the parameter group is in
/// this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBParameterGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBParameterGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBParameterGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBParameterGroupStateFault")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBParameterGroupStateFault {}
/// See [`InvalidDBParameterGroupStateFault`](crate::error::InvalidDBParameterGroupStateFault)
pub mod invalid_db_parameter_group_state_fault {
    /// A builder for [`InvalidDBParameterGroupStateFault`](crate::error::InvalidDBParameterGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBParameterGroupStateFault`](crate::error::InvalidDBParameterGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDBParameterGroupStateFault {
            crate::error::InvalidDBParameterGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBParameterGroupStateFault`](crate::error::InvalidDBParameterGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_parameter_group_state_fault::Builder {
        crate::error::invalid_db_parameter_group_state_fault::Builder::default()
    }
}

/// <p>The specified target group isn't available for a proxy owned by your AWS account in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyTargetGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyTargetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyTargetGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyTargetGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyTargetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyTargetGroupNotFoundFault")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyTargetGroupNotFoundFault {}
/// See [`DBProxyTargetGroupNotFoundFault`](crate::error::DBProxyTargetGroupNotFoundFault)
pub mod db_proxy_target_group_not_found_fault {
    /// A builder for [`DBProxyTargetGroupNotFoundFault`](crate::error::DBProxyTargetGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyTargetGroupNotFoundFault`](crate::error::DBProxyTargetGroupNotFoundFault)
        pub fn build(self) -> crate::error::DBProxyTargetGroupNotFoundFault {
            crate::error::DBProxyTargetGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyTargetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBProxyTargetGroupNotFoundFault`](crate::error::DBProxyTargetGroupNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_target_group_not_found_fault::Builder {
        crate::error::db_proxy_target_group_not_found_fault::Builder::default()
    }
}

/// <p>The specified proxy name doesn't correspond to a proxy owned by your AWS account in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyNotFoundFault")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyNotFoundFault {}
/// See [`DBProxyNotFoundFault`](crate::error::DBProxyNotFoundFault)
pub mod db_proxy_not_found_fault {
    /// A builder for [`DBProxyNotFoundFault`](crate::error::DBProxyNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyNotFoundFault`](crate::error::DBProxyNotFoundFault)
        pub fn build(self) -> crate::error::DBProxyNotFoundFault {
            crate::error::DBProxyNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBProxyNotFoundFault`](crate::error::DBProxyNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_not_found_fault::Builder {
        crate::error::db_proxy_not_found_fault::Builder::default()
    }
}

/// <p>The subscription name does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionNotFoundFault")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionNotFoundFault {}
/// See [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
pub mod subscription_not_found_fault {
    /// A builder for [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
        pub fn build(self) -> crate::error::SubscriptionNotFoundFault {
            crate::error::SubscriptionNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
    pub fn builder() -> crate::error::subscription_not_found_fault::Builder {
        crate::error::subscription_not_found_fault::Builder::default()
    }
}

/// <p>The requested source could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceNotFoundFault")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceNotFoundFault {}
/// See [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
pub mod source_not_found_fault {
    /// A builder for [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
        pub fn build(self) -> crate::error::SourceNotFoundFault {
            crate::error::SourceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
    pub fn builder() -> crate::error::source_not_found_fault::Builder {
        crate::error::source_not_found_fault::Builder::default()
    }
}

/// <p>The specified <code>RoleArn</code> value doesn't match the specified feature for
/// the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceRoleNotFoundFault")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceRoleNotFoundFault {}
/// See [`DBInstanceRoleNotFoundFault`](crate::error::DBInstanceRoleNotFoundFault)
pub mod db_instance_role_not_found_fault {
    /// A builder for [`DBInstanceRoleNotFoundFault`](crate::error::DBInstanceRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceRoleNotFoundFault`](crate::error::DBInstanceRoleNotFoundFault)
        pub fn build(self) -> crate::error::DBInstanceRoleNotFoundFault {
            crate::error::DBInstanceRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceRoleNotFoundFault`](crate::error::DBInstanceRoleNotFoundFault)
    pub fn builder() -> crate::error::db_instance_role_not_found_fault::Builder {
        crate::error::db_instance_role_not_found_fault::Builder::default()
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterRoleNotFoundFault")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterRoleNotFoundFault {}
/// See [`DBClusterRoleNotFoundFault`](crate::error::DBClusterRoleNotFoundFault)
pub mod db_cluster_role_not_found_fault {
    /// A builder for [`DBClusterRoleNotFoundFault`](crate::error::DBClusterRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterRoleNotFoundFault`](crate::error::DBClusterRoleNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterRoleNotFoundFault {
            crate::error::DBClusterRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterRoleNotFoundFault`](crate::error::DBClusterRoleNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_role_not_found_fault::Builder {
        crate::error::db_cluster_role_not_found_fault::Builder::default()
    }
}

/// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGlobalClusterStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGlobalClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGlobalClusterStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGlobalClusterStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGlobalClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGlobalClusterStateFault")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGlobalClusterStateFault {}
/// See [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
pub mod invalid_global_cluster_state_fault {
    /// A builder for [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
        pub fn build(self) -> crate::error::InvalidGlobalClusterStateFault {
            crate::error::InvalidGlobalClusterStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidGlobalClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
    pub fn builder() -> crate::error::invalid_global_cluster_state_fault::Builder {
        crate::error::invalid_global_cluster_state_fault::Builder::default()
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterNotFoundFault")?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterNotFoundFault {}
/// See [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
pub mod global_cluster_not_found_fault {
    /// A builder for [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
        pub fn build(self) -> crate::error::GlobalClusterNotFoundFault {
            crate::error::GlobalClusterNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
    pub fn builder() -> crate::error::global_cluster_not_found_fault::Builder {
        crate::error::global_cluster_not_found_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed while the proxy is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBProxyStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBProxyStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBProxyStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBProxyStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBProxyStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBProxyStateFault")?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBProxyStateFault {}
/// See [`InvalidDBProxyStateFault`](crate::error::InvalidDBProxyStateFault)
pub mod invalid_db_proxy_state_fault {
    /// A builder for [`InvalidDBProxyStateFault`](crate::error::InvalidDBProxyStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBProxyStateFault`](crate::error::InvalidDBProxyStateFault)
        pub fn build(self) -> crate::error::InvalidDBProxyStateFault {
            crate::error::InvalidDBProxyStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBProxyStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBProxyStateFault`](crate::error::InvalidDBProxyStateFault)
    pub fn builder() -> crate::error::invalid_db_proxy_state_fault::Builder {
        crate::error::invalid_db_proxy_state_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed because there aren't enough available IP addresses
/// in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required
/// from the subnets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientAvailableIPsInSubnetFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientAvailableIPsInSubnetFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientAvailableIPsInSubnetFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientAvailableIPsInSubnetFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientAvailableIPsInSubnetFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientAvailableIPsInSubnetFault")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientAvailableIPsInSubnetFault {}
/// See [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
pub mod insufficient_available_i_ps_in_subnet_fault {
    /// A builder for [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
        pub fn build(self) -> crate::error::InsufficientAvailableIPsInSubnetFault {
            crate::error::InsufficientAvailableIPsInSubnetFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientAvailableIPsInSubnetFault {
    /// Creates a new builder-style object to manufacture [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
    pub fn builder() -> crate::error::insufficient_available_i_ps_in_subnet_fault::Builder {
        crate::error::insufficient_available_i_ps_in_subnet_fault::Builder::default()
    }
}

/// <p>The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyTargetAlreadyRegisteredFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyTargetAlreadyRegisteredFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyTargetAlreadyRegisteredFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyTargetAlreadyRegisteredFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyTargetAlreadyRegisteredFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyTargetAlreadyRegisteredFault")?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyTargetAlreadyRegisteredFault {}
/// See [`DBProxyTargetAlreadyRegisteredFault`](crate::error::DBProxyTargetAlreadyRegisteredFault)
pub mod db_proxy_target_already_registered_fault {
    /// A builder for [`DBProxyTargetAlreadyRegisteredFault`](crate::error::DBProxyTargetAlreadyRegisteredFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyTargetAlreadyRegisteredFault`](crate::error::DBProxyTargetAlreadyRegisteredFault)
        pub fn build(self) -> crate::error::DBProxyTargetAlreadyRegisteredFault {
            crate::error::DBProxyTargetAlreadyRegisteredFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyTargetAlreadyRegisteredFault {
    /// Creates a new builder-style object to manufacture [`DBProxyTargetAlreadyRegisteredFault`](crate::error::DBProxyTargetAlreadyRegisteredFault)
    pub fn builder() -> crate::error::db_proxy_target_already_registered_fault::Builder {
        crate::error::db_proxy_target_already_registered_fault::Builder::default()
    }
}

/// <p>Specified offering does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDBInstancesOfferingNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDBInstancesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDBInstancesOfferingNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDBInstancesOfferingNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDBInstancesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedDBInstancesOfferingNotFoundFault")?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDBInstancesOfferingNotFoundFault {}
/// See [`ReservedDBInstancesOfferingNotFoundFault`](crate::error::ReservedDBInstancesOfferingNotFoundFault)
pub mod reserved_db_instances_offering_not_found_fault {
    /// A builder for [`ReservedDBInstancesOfferingNotFoundFault`](crate::error::ReservedDBInstancesOfferingNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDBInstancesOfferingNotFoundFault`](crate::error::ReservedDBInstancesOfferingNotFoundFault)
        pub fn build(self) -> crate::error::ReservedDBInstancesOfferingNotFoundFault {
            crate::error::ReservedDBInstancesOfferingNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDBInstancesOfferingNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedDBInstancesOfferingNotFoundFault`](crate::error::ReservedDBInstancesOfferingNotFoundFault)
    pub fn builder() -> crate::error::reserved_db_instances_offering_not_found_fault::Builder {
        crate::error::reserved_db_instances_offering_not_found_fault::Builder::default()
    }
}

/// <p>Request would exceed the user's DB Instance quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDBInstanceQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDBInstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDBInstanceQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDBInstanceQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDBInstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedDBInstanceQuotaExceededFault")?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDBInstanceQuotaExceededFault {}
/// See [`ReservedDBInstanceQuotaExceededFault`](crate::error::ReservedDBInstanceQuotaExceededFault)
pub mod reserved_db_instance_quota_exceeded_fault {
    /// A builder for [`ReservedDBInstanceQuotaExceededFault`](crate::error::ReservedDBInstanceQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDBInstanceQuotaExceededFault`](crate::error::ReservedDBInstanceQuotaExceededFault)
        pub fn build(self) -> crate::error::ReservedDBInstanceQuotaExceededFault {
            crate::error::ReservedDBInstanceQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDBInstanceQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ReservedDBInstanceQuotaExceededFault`](crate::error::ReservedDBInstanceQuotaExceededFault)
    pub fn builder() -> crate::error::reserved_db_instance_quota_exceeded_fault::Builder {
        crate::error::reserved_db_instance_quota_exceeded_fault::Builder::default()
    }
}

/// <p>User already has a reservation with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDBInstanceAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDBInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDBInstanceAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDBInstanceAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDBInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedDBInstanceAlreadyExistsFault")?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDBInstanceAlreadyExistsFault {}
/// See [`ReservedDBInstanceAlreadyExistsFault`](crate::error::ReservedDBInstanceAlreadyExistsFault)
pub mod reserved_db_instance_already_exists_fault {
    /// A builder for [`ReservedDBInstanceAlreadyExistsFault`](crate::error::ReservedDBInstanceAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDBInstanceAlreadyExistsFault`](crate::error::ReservedDBInstanceAlreadyExistsFault)
        pub fn build(self) -> crate::error::ReservedDBInstanceAlreadyExistsFault {
            crate::error::ReservedDBInstanceAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDBInstanceAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReservedDBInstanceAlreadyExistsFault`](crate::error::ReservedDBInstanceAlreadyExistsFault)
    pub fn builder() -> crate::error::reserved_db_instance_already_exists_fault::Builder {
        crate::error::reserved_db_instance_already_exists_fault::Builder::default()
    }
}

/// <p>
/// The option group isn't in the <i>available</i> state.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOptionGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOptionGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOptionGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOptionGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOptionGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOptionGroupStateFault")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOptionGroupStateFault {}
/// See [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
pub mod invalid_option_group_state_fault {
    /// A builder for [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
        pub fn build(self) -> crate::error::InvalidOptionGroupStateFault {
            crate::error::InvalidOptionGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidOptionGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
    pub fn builder() -> crate::error::invalid_option_group_state_fault::Builder {
        crate::error::invalid_option_group_state_fault::Builder::default()
    }
}

/// <p>The supplied category does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionCategoryNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionCategoryNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionCategoryNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionCategoryNotFoundFault")?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionCategoryNotFoundFault {}
/// See [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
pub mod subscription_category_not_found_fault {
    /// A builder for [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
        pub fn build(self) -> crate::error::SubscriptionCategoryNotFoundFault {
            crate::error::SubscriptionCategoryNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionCategoryNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
    pub fn builder() -> crate::error::subscription_category_not_found_fault::Builder {
        crate::error::subscription_category_not_found_fault::Builder::default()
    }
}

/// <p>The SNS topic ARN does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SNSTopicArnNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SNSTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SNSTopicArnNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SNSTopicArnNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SNSTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SNSTopicArnNotFoundFault")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for SNSTopicArnNotFoundFault {}
/// See [`SNSTopicArnNotFoundFault`](crate::error::SNSTopicArnNotFoundFault)
pub mod sns_topic_arn_not_found_fault {
    /// A builder for [`SNSTopicArnNotFoundFault`](crate::error::SNSTopicArnNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SNSTopicArnNotFoundFault`](crate::error::SNSTopicArnNotFoundFault)
        pub fn build(self) -> crate::error::SNSTopicArnNotFoundFault {
            crate::error::SNSTopicArnNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SNSTopicArnNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SNSTopicArnNotFoundFault`](crate::error::SNSTopicArnNotFoundFault)
    pub fn builder() -> crate::error::sns_topic_arn_not_found_fault::Builder {
        crate::error::sns_topic_arn_not_found_fault::Builder::default()
    }
}

/// <p>You do not have permission to publish to the SNS topic ARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SNSNoAuthorizationFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SNSNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SNSNoAuthorizationFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SNSNoAuthorizationFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SNSNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SNSNoAuthorizationFault")?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for SNSNoAuthorizationFault {}
/// See [`SNSNoAuthorizationFault`](crate::error::SNSNoAuthorizationFault)
pub mod sns_no_authorization_fault {
    /// A builder for [`SNSNoAuthorizationFault`](crate::error::SNSNoAuthorizationFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SNSNoAuthorizationFault`](crate::error::SNSNoAuthorizationFault)
        pub fn build(self) -> crate::error::SNSNoAuthorizationFault {
            crate::error::SNSNoAuthorizationFault {
                message: self.message,
            }
        }
    }
}
impl SNSNoAuthorizationFault {
    /// Creates a new builder-style object to manufacture [`SNSNoAuthorizationFault`](crate::error::SNSNoAuthorizationFault)
    pub fn builder() -> crate::error::sns_no_authorization_fault::Builder {
        crate::error::sns_no_authorization_fault::Builder::default()
    }
}

/// <p>SNS has responded that there is a problem with the SND topic specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SNSInvalidTopicFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SNSInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SNSInvalidTopicFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SNSInvalidTopicFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SNSInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SNSInvalidTopicFault")?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for SNSInvalidTopicFault {}
/// See [`SNSInvalidTopicFault`](crate::error::SNSInvalidTopicFault)
pub mod sns_invalid_topic_fault {
    /// A builder for [`SNSInvalidTopicFault`](crate::error::SNSInvalidTopicFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SNSInvalidTopicFault`](crate::error::SNSInvalidTopicFault)
        pub fn build(self) -> crate::error::SNSInvalidTopicFault {
            crate::error::SNSInvalidTopicFault {
                message: self.message,
            }
        }
    }
}
impl SNSInvalidTopicFault {
    /// Creates a new builder-style object to manufacture [`SNSInvalidTopicFault`](crate::error::SNSInvalidTopicFault)
    pub fn builder() -> crate::error::sns_invalid_topic_fault::Builder {
        crate::error::sns_invalid_topic_fault::Builder::default()
    }
}

/// <p>You have reached the maximum number of event subscriptions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventSubscriptionQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventSubscriptionQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EventSubscriptionQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EventSubscriptionQuotaExceededFault")?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for EventSubscriptionQuotaExceededFault {}
/// See [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
pub mod event_subscription_quota_exceeded_fault {
    /// A builder for [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
        pub fn build(self) -> crate::error::EventSubscriptionQuotaExceededFault {
            crate::error::EventSubscriptionQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl EventSubscriptionQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
    pub fn builder() -> crate::error::event_subscription_quota_exceeded_fault::Builder {
        crate::error::event_subscription_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetAlreadyInUse {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetAlreadyInUse");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetAlreadyInUse {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetAlreadyInUse")?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetAlreadyInUse {}
/// See [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
pub mod subnet_already_in_use {
    /// A builder for [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
        pub fn build(self) -> crate::error::SubnetAlreadyInUse {
            crate::error::SubnetAlreadyInUse {
                message: self.message,
            }
        }
    }
}
impl SubnetAlreadyInUse {
    /// Creates a new builder-style object to manufacture [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
    pub fn builder() -> crate::error::subnet_already_in_use::Builder {
        crate::error::subnet_already_in_use::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of subnets in a
/// DB subnet groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetQuotaExceededFault")?;
        if let Some(inner_68) = &self.message {
            write!(f, ": {}", inner_68)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetQuotaExceededFault {}
/// See [`DBSubnetQuotaExceededFault`](crate::error::DBSubnetQuotaExceededFault)
pub mod db_subnet_quota_exceeded_fault {
    /// A builder for [`DBSubnetQuotaExceededFault`](crate::error::DBSubnetQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetQuotaExceededFault`](crate::error::DBSubnetQuotaExceededFault)
        pub fn build(self) -> crate::error::DBSubnetQuotaExceededFault {
            crate::error::DBSubnetQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBSubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBSubnetQuotaExceededFault`](crate::error::DBSubnetQuotaExceededFault)
    pub fn builder() -> crate::error::db_subnet_quota_exceeded_fault::Builder {
        crate::error::db_subnet_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharedSnapshotQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SharedSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharedSnapshotQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SharedSnapshotQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SharedSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SharedSnapshotQuotaExceededFault")?;
        if let Some(inner_69) = &self.message {
            write!(f, ": {}", inner_69)?;
        }
        Ok(())
    }
}
impl std::error::Error for SharedSnapshotQuotaExceededFault {}
/// See [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
pub mod shared_snapshot_quota_exceeded_fault {
    /// A builder for [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
        pub fn build(self) -> crate::error::SharedSnapshotQuotaExceededFault {
            crate::error::SharedSnapshotQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl SharedSnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
    pub fn builder() -> crate::error::shared_snapshot_quota_exceeded_fault::Builder {
        crate::error::shared_snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You can't perform this operation while the DB proxy endpoint is in a particular state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBProxyEndpointStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBProxyEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBProxyEndpointStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBProxyEndpointStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBProxyEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBProxyEndpointStateFault")?;
        if let Some(inner_70) = &self.message {
            write!(f, ": {}", inner_70)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBProxyEndpointStateFault {}
/// See [`InvalidDBProxyEndpointStateFault`](crate::error::InvalidDBProxyEndpointStateFault)
pub mod invalid_db_proxy_endpoint_state_fault {
    /// A builder for [`InvalidDBProxyEndpointStateFault`](crate::error::InvalidDBProxyEndpointStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBProxyEndpointStateFault`](crate::error::InvalidDBProxyEndpointStateFault)
        pub fn build(self) -> crate::error::InvalidDBProxyEndpointStateFault {
            crate::error::InvalidDBProxyEndpointStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBProxyEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBProxyEndpointStateFault`](crate::error::InvalidDBProxyEndpointStateFault)
    pub fn builder() -> crate::error::invalid_db_proxy_endpoint_state_fault::Builder {
        crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default()
    }
}

/// <p>The DB proxy endpoint doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyEndpointNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyEndpointNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyEndpointNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyEndpointNotFoundFault")?;
        if let Some(inner_71) = &self.message {
            write!(f, ": {}", inner_71)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyEndpointNotFoundFault {}
/// See [`DBProxyEndpointNotFoundFault`](crate::error::DBProxyEndpointNotFoundFault)
pub mod db_proxy_endpoint_not_found_fault {
    /// A builder for [`DBProxyEndpointNotFoundFault`](crate::error::DBProxyEndpointNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyEndpointNotFoundFault`](crate::error::DBProxyEndpointNotFoundFault)
        pub fn build(self) -> crate::error::DBProxyEndpointNotFoundFault {
            crate::error::DBProxyEndpointNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyEndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBProxyEndpointNotFoundFault`](crate::error::DBProxyEndpointNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_not_found_fault::Builder {
        crate::error::db_proxy_endpoint_not_found_fault::Builder::default()
    }
}

/// <p>The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your AWS account in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyEndpointAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyEndpointAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyEndpointAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyEndpointAlreadyExistsFault")?;
        if let Some(inner_72) = &self.message {
            write!(f, ": {}", inner_72)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyEndpointAlreadyExistsFault {}
/// See [`DBProxyEndpointAlreadyExistsFault`](crate::error::DBProxyEndpointAlreadyExistsFault)
pub mod db_proxy_endpoint_already_exists_fault {
    /// A builder for [`DBProxyEndpointAlreadyExistsFault`](crate::error::DBProxyEndpointAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyEndpointAlreadyExistsFault`](crate::error::DBProxyEndpointAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBProxyEndpointAlreadyExistsFault {
            crate::error::DBProxyEndpointAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyEndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBProxyEndpointAlreadyExistsFault`](crate::error::DBProxyEndpointAlreadyExistsFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_already_exists_fault::Builder {
        crate::error::db_proxy_endpoint_already_exists_fault::Builder::default()
    }
}

/// <p>The specified proxy name must be unique for all proxies owned by your AWS account in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyAlreadyExistsFault")?;
        if let Some(inner_73) = &self.message {
            write!(f, ": {}", inner_73)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyAlreadyExistsFault {}
/// See [`DBProxyAlreadyExistsFault`](crate::error::DBProxyAlreadyExistsFault)
pub mod db_proxy_already_exists_fault {
    /// A builder for [`DBProxyAlreadyExistsFault`](crate::error::DBProxyAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyAlreadyExistsFault`](crate::error::DBProxyAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBProxyAlreadyExistsFault {
            crate::error::DBProxyAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBProxyAlreadyExistsFault`](crate::error::DBProxyAlreadyExistsFault)
    pub fn builder() -> crate::error::db_proxy_already_exists_fault::Builder {
        crate::error::db_proxy_already_exists_fault::Builder::default()
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on can't be
/// modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBUpgradeDependencyFailureFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBUpgradeDependencyFailureFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBUpgradeDependencyFailureFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBUpgradeDependencyFailureFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBUpgradeDependencyFailureFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBUpgradeDependencyFailureFault")?;
        if let Some(inner_74) = &self.message {
            write!(f, ": {}", inner_74)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBUpgradeDependencyFailureFault {}
/// See [`DBUpgradeDependencyFailureFault`](crate::error::DBUpgradeDependencyFailureFault)
pub mod db_upgrade_dependency_failure_fault {
    /// A builder for [`DBUpgradeDependencyFailureFault`](crate::error::DBUpgradeDependencyFailureFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBUpgradeDependencyFailureFault`](crate::error::DBUpgradeDependencyFailureFault)
        pub fn build(self) -> crate::error::DBUpgradeDependencyFailureFault {
            crate::error::DBUpgradeDependencyFailureFault {
                message: self.message,
            }
        }
    }
}
impl DBUpgradeDependencyFailureFault {
    /// Creates a new builder-style object to manufacture [`DBUpgradeDependencyFailureFault`](crate::error::DBUpgradeDependencyFailureFault)
    pub fn builder() -> crate::error::db_upgrade_dependency_failure_fault::Builder {
        crate::error::db_upgrade_dependency_failure_fault::Builder::default()
    }
}

/// <p>
/// <code>CertificateIdentifier</code> doesn't refer to an
/// existing certificate.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateNotFoundFault")?;
        if let Some(inner_75) = &self.message {
            write!(f, ": {}", inner_75)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateNotFoundFault {}
/// See [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
pub mod certificate_not_found_fault {
    /// A builder for [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
        pub fn build(self) -> crate::error::CertificateNotFoundFault {
            crate::error::CertificateNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CertificateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
    pub fn builder() -> crate::error::certificate_not_found_fault::Builder {
        crate::error::certificate_not_found_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed on the endpoint while the endpoint is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBClusterEndpointStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBClusterEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBClusterEndpointStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBClusterEndpointStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBClusterEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBClusterEndpointStateFault")?;
        if let Some(inner_76) = &self.message {
            write!(f, ": {}", inner_76)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBClusterEndpointStateFault {}
/// See [`InvalidDBClusterEndpointStateFault`](crate::error::InvalidDBClusterEndpointStateFault)
pub mod invalid_db_cluster_endpoint_state_fault {
    /// A builder for [`InvalidDBClusterEndpointStateFault`](crate::error::InvalidDBClusterEndpointStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBClusterEndpointStateFault`](crate::error::InvalidDBClusterEndpointStateFault)
        pub fn build(self) -> crate::error::InvalidDBClusterEndpointStateFault {
            crate::error::InvalidDBClusterEndpointStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBClusterEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBClusterEndpointStateFault`](crate::error::InvalidDBClusterEndpointStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_endpoint_state_fault::Builder {
        crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default()
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterEndpointNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterEndpointNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterEndpointNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterEndpointNotFoundFault")?;
        if let Some(inner_77) = &self.message {
            write!(f, ": {}", inner_77)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterEndpointNotFoundFault {}
/// See [`DBClusterEndpointNotFoundFault`](crate::error::DBClusterEndpointNotFoundFault)
pub mod db_cluster_endpoint_not_found_fault {
    /// A builder for [`DBClusterEndpointNotFoundFault`](crate::error::DBClusterEndpointNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterEndpointNotFoundFault`](crate::error::DBClusterEndpointNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterEndpointNotFoundFault {
            crate::error::DBClusterEndpointNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterEndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterEndpointNotFoundFault`](crate::error::DBClusterEndpointNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_not_found_fault::Builder {
        crate::error::db_cluster_endpoint_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>Capacity</code> isn't a valid Aurora Serverless DB cluster
/// capacity. Valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>,
/// <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBClusterCapacityFault")?;
        if let Some(inner_78) = &self.message {
            write!(f, ": {}", inner_78)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBClusterCapacityFault {}
/// See [`InvalidDBClusterCapacityFault`](crate::error::InvalidDBClusterCapacityFault)
pub mod invalid_db_cluster_capacity_fault {
    /// A builder for [`InvalidDBClusterCapacityFault`](crate::error::InvalidDBClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBClusterCapacityFault`](crate::error::InvalidDBClusterCapacityFault)
        pub fn build(self) -> crate::error::InvalidDBClusterCapacityFault {
            crate::error::InvalidDBClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBClusterCapacityFault`](crate::error::InvalidDBClusterCapacityFault)
    pub fn builder() -> crate::error::invalid_db_cluster_capacity_fault::Builder {
        crate::error::invalid_db_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The specified installation medium has already been imported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstallationMediaAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstallationMediaAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstallationMediaAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstallationMediaAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstallationMediaAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstallationMediaAlreadyExistsFault")?;
        if let Some(inner_79) = &self.message {
            write!(f, ": {}", inner_79)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstallationMediaAlreadyExistsFault {}
/// See [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
pub mod installation_media_already_exists_fault {
    /// A builder for [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
        pub fn build(self) -> crate::error::InstallationMediaAlreadyExistsFault {
            crate::error::InstallationMediaAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl InstallationMediaAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
    pub fn builder() -> crate::error::installation_media_already_exists_fault::Builder {
        crate::error::installation_media_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>CustomAvailabilityZoneId</code> doesn't refer to an existing custom
/// Availability Zone identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneNotFoundFault")?;
        if let Some(inner_80) = &self.message {
            write!(f, ": {}", inner_80)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneNotFoundFault {}
/// See [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
pub mod custom_availability_zone_not_found_fault {
    /// A builder for [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneNotFoundFault {
            crate::error::CustomAvailabilityZoneNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
    pub fn builder() -> crate::error::custom_availability_zone_not_found_fault::Builder {
        crate::error::custom_availability_zone_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>LogFileName</code> doesn't refer to an existing DB log file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBLogFileNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBLogFileNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBLogFileNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBLogFileNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBLogFileNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBLogFileNotFoundFault")?;
        if let Some(inner_81) = &self.message {
            write!(f, ": {}", inner_81)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBLogFileNotFoundFault {}
/// See [`DBLogFileNotFoundFault`](crate::error::DBLogFileNotFoundFault)
pub mod db_log_file_not_found_fault {
    /// A builder for [`DBLogFileNotFoundFault`](crate::error::DBLogFileNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBLogFileNotFoundFault`](crate::error::DBLogFileNotFoundFault)
        pub fn build(self) -> crate::error::DBLogFileNotFoundFault {
            crate::error::DBLogFileNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBLogFileNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBLogFileNotFoundFault`](crate::error::DBLogFileNotFoundFault)
    pub fn builder() -> crate::error::db_log_file_not_found_fault::Builder {
        crate::error::db_log_file_not_found_fault::Builder::default()
    }
}

/// <p>The specified reserved DB Instance not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDBInstanceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDBInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDBInstanceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDBInstanceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDBInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedDBInstanceNotFoundFault")?;
        if let Some(inner_82) = &self.message {
            write!(f, ": {}", inner_82)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDBInstanceNotFoundFault {}
/// See [`ReservedDBInstanceNotFoundFault`](crate::error::ReservedDBInstanceNotFoundFault)
pub mod reserved_db_instance_not_found_fault {
    /// A builder for [`ReservedDBInstanceNotFoundFault`](crate::error::ReservedDBInstanceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDBInstanceNotFoundFault`](crate::error::ReservedDBInstanceNotFoundFault)
        pub fn build(self) -> crate::error::ReservedDBInstanceNotFoundFault {
            crate::error::ReservedDBInstanceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDBInstanceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedDBInstanceNotFoundFault`](crate::error::ReservedDBInstanceNotFoundFault)
    pub fn builder() -> crate::error::reserved_db_instance_not_found_fault::Builder {
        crate::error::reserved_db_instance_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>InstallationMediaID</code> doesn't refer to an existing installation medium.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstallationMediaNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstallationMediaNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstallationMediaNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstallationMediaNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstallationMediaNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstallationMediaNotFoundFault")?;
        if let Some(inner_83) = &self.message {
            write!(f, ": {}", inner_83)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstallationMediaNotFoundFault {}
/// See [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
pub mod installation_media_not_found_fault {
    /// A builder for [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
        pub fn build(self) -> crate::error::InstallationMediaNotFoundFault {
            crate::error::InstallationMediaNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl InstallationMediaNotFoundFault {
    /// Creates a new builder-style object to manufacture [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
    pub fn builder() -> crate::error::installation_media_not_found_fault::Builder {
        crate::error::installation_media_not_found_fault::Builder::default()
    }
}

/// <p>The export task doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportTaskNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportTaskNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportTaskNotFoundFault")?;
        if let Some(inner_84) = &self.message {
            write!(f, ": {}", inner_84)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportTaskNotFoundFault {}
/// See [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
pub mod export_task_not_found_fault {
    /// A builder for [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
        pub fn build(self) -> crate::error::ExportTaskNotFoundFault {
            crate::error::ExportTaskNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ExportTaskNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
    pub fn builder() -> crate::error::export_task_not_found_fault::Builder {
        crate::error::export_task_not_found_fault::Builder::default()
    }
}

/// <p>The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your AWS account in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyTargetNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyTargetNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyTargetNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyTargetNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyTargetNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyTargetNotFoundFault")?;
        if let Some(inner_85) = &self.message {
            write!(f, ": {}", inner_85)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyTargetNotFoundFault {}
/// See [`DBProxyTargetNotFoundFault`](crate::error::DBProxyTargetNotFoundFault)
pub mod db_proxy_target_not_found_fault {
    /// A builder for [`DBProxyTargetNotFoundFault`](crate::error::DBProxyTargetNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyTargetNotFoundFault`](crate::error::DBProxyTargetNotFoundFault)
        pub fn build(self) -> crate::error::DBProxyTargetNotFoundFault {
            crate::error::DBProxyTargetNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyTargetNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBProxyTargetNotFoundFault`](crate::error::DBProxyTargetNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_target_not_found_fault::Builder {
        crate::error::db_proxy_target_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>BacktrackIdentifier</code> doesn't refer to an existing backtrack. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterBacktrackNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterBacktrackNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterBacktrackNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterBacktrackNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterBacktrackNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterBacktrackNotFoundFault")?;
        if let Some(inner_86) = &self.message {
            write!(f, ": {}", inner_86)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterBacktrackNotFoundFault {}
/// See [`DBClusterBacktrackNotFoundFault`](crate::error::DBClusterBacktrackNotFoundFault)
pub mod db_cluster_backtrack_not_found_fault {
    /// A builder for [`DBClusterBacktrackNotFoundFault`](crate::error::DBClusterBacktrackNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterBacktrackNotFoundFault`](crate::error::DBClusterBacktrackNotFoundFault)
        pub fn build(self) -> crate::error::DBClusterBacktrackNotFoundFault {
            crate::error::DBClusterBacktrackNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterBacktrackNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DBClusterBacktrackNotFoundFault`](crate::error::DBClusterBacktrackNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_backtrack_not_found_fault::Builder {
        crate::error::db_cluster_backtrack_not_found_fault::Builder::default()
    }
}

/// <p>This error can occur if someone else is modifying a subscription. You should retry the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEventSubscriptionStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEventSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEventSubscriptionStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEventSubscriptionStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventSubscriptionStateFault")?;
        if let Some(inner_87) = &self.message {
            write!(f, ": {}", inner_87)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventSubscriptionStateFault {}
/// See [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
pub mod invalid_event_subscription_state_fault {
    /// A builder for [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
        pub fn build(self) -> crate::error::InvalidEventSubscriptionStateFault {
            crate::error::InvalidEventSubscriptionStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidEventSubscriptionStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
    pub fn builder() -> crate::error::invalid_event_subscription_state_fault::Builder {
        crate::error::invalid_event_subscription_state_fault::Builder::default()
    }
}

/// <p>
/// The DB subnet isn't in the <i>available</i> state.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBSubnetStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBSubnetStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBSubnetStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBSubnetStateFault")?;
        if let Some(inner_88) = &self.message {
            write!(f, ": {}", inner_88)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBSubnetStateFault {}
/// See [`InvalidDBSubnetStateFault`](crate::error::InvalidDBSubnetStateFault)
pub mod invalid_db_subnet_state_fault {
    /// A builder for [`InvalidDBSubnetStateFault`](crate::error::InvalidDBSubnetStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBSubnetStateFault`](crate::error::InvalidDBSubnetStateFault)
        pub fn build(self) -> crate::error::InvalidDBSubnetStateFault {
            crate::error::InvalidDBSubnetStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBSubnetStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBSubnetStateFault`](crate::error::InvalidDBSubnetStateFault)
    pub fn builder() -> crate::error::invalid_db_subnet_state_fault::Builder {
        crate::error::invalid_db_subnet_state_fault::Builder::default()
    }
}

/// <p>The automated backup is in an invalid state.
/// For example, this automated backup is associated with an active instance. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBInstanceAutomatedBackupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBInstanceAutomatedBackupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBInstanceAutomatedBackupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBInstanceAutomatedBackupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBInstanceAutomatedBackupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBInstanceAutomatedBackupStateFault")?;
        if let Some(inner_89) = &self.message {
            write!(f, ": {}", inner_89)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBInstanceAutomatedBackupStateFault {}
/// See [`InvalidDBInstanceAutomatedBackupStateFault`](crate::error::InvalidDBInstanceAutomatedBackupStateFault)
pub mod invalid_db_instance_automated_backup_state_fault {
    /// A builder for [`InvalidDBInstanceAutomatedBackupStateFault`](crate::error::InvalidDBInstanceAutomatedBackupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBInstanceAutomatedBackupStateFault`](crate::error::InvalidDBInstanceAutomatedBackupStateFault)
        pub fn build(self) -> crate::error::InvalidDBInstanceAutomatedBackupStateFault {
            crate::error::InvalidDBInstanceAutomatedBackupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBInstanceAutomatedBackupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBInstanceAutomatedBackupStateFault`](crate::error::InvalidDBInstanceAutomatedBackupStateFault)
    pub fn builder() -> crate::error::invalid_db_instance_automated_backup_state_fault::Builder {
        crate::error::invalid_db_instance_automated_backup_state_fault::Builder::default()
    }
}

/// <p>The user already has a DB cluster snapshot with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterSnapshotAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterSnapshotAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterSnapshotAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterSnapshotAlreadyExistsFault")?;
        if let Some(inner_90) = &self.message {
            write!(f, ": {}", inner_90)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterSnapshotAlreadyExistsFault {}
/// See [`DBClusterSnapshotAlreadyExistsFault`](crate::error::DBClusterSnapshotAlreadyExistsFault)
pub mod db_cluster_snapshot_already_exists_fault {
    /// A builder for [`DBClusterSnapshotAlreadyExistsFault`](crate::error::DBClusterSnapshotAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterSnapshotAlreadyExistsFault`](crate::error::DBClusterSnapshotAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBClusterSnapshotAlreadyExistsFault {
            crate::error::DBClusterSnapshotAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBClusterSnapshotAlreadyExistsFault`](crate::error::DBClusterSnapshotAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_snapshot_already_exists_fault::Builder {
        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default()
    }
}

/// <p>The quota of 20 option groups was exceeded for this AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupQuotaExceededFault")?;
        if let Some(inner_91) = &self.message {
            write!(f, ": {}", inner_91)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupQuotaExceededFault {}
/// See [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
pub mod option_group_quota_exceeded_fault {
    /// A builder for [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::OptionGroupQuotaExceededFault {
            crate::error::OptionGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
    pub fn builder() -> crate::error::option_group_quota_exceeded_fault::Builder {
        crate::error::option_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The option group you are trying to create already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupAlreadyExistsFault")?;
        if let Some(inner_92) = &self.message {
            write!(f, ": {}", inner_92)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupAlreadyExistsFault {}
/// See [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
pub mod option_group_already_exists_fault {
    /// A builder for [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::OptionGroupAlreadyExistsFault {
            crate::error::OptionGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::option_group_already_exists_fault::Builder {
        crate::error::option_group_already_exists_fault::Builder::default()
    }
}

/// <p>The number of global database clusters for this account is already at the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterQuotaExceededFault")?;
        if let Some(inner_93) = &self.message {
            write!(f, ": {}", inner_93)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterQuotaExceededFault {}
/// See [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
pub mod global_cluster_quota_exceeded_fault {
    /// A builder for [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
        pub fn build(self) -> crate::error::GlobalClusterQuotaExceededFault {
            crate::error::GlobalClusterQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
    pub fn builder() -> crate::error::global_cluster_quota_exceeded_fault::Builder {
        crate::error::global_cluster_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> already exists. Choose a new global database identifier (unique name) to create a new global database cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterAlreadyExistsFault")?;
        if let Some(inner_94) = &self.message {
            write!(f, ": {}", inner_94)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterAlreadyExistsFault {}
/// See [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
pub mod global_cluster_already_exists_fault {
    /// A builder for [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
        pub fn build(self) -> crate::error::GlobalClusterAlreadyExistsFault {
            crate::error::GlobalClusterAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
    pub fn builder() -> crate::error::global_cluster_already_exists_fault::Builder {
        crate::error::global_cluster_already_exists_fault::Builder::default()
    }
}

/// <p>The supplied subscription name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionAlreadyExistFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionAlreadyExistFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionAlreadyExistFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionAlreadyExistFault")?;
        if let Some(inner_95) = &self.message {
            write!(f, ": {}", inner_95)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionAlreadyExistFault {}
/// See [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
pub mod subscription_already_exist_fault {
    /// A builder for [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
        pub fn build(self) -> crate::error::SubscriptionAlreadyExistFault {
            crate::error::SubscriptionAlreadyExistFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionAlreadyExistFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
    pub fn builder() -> crate::error::subscription_already_exist_fault::Builder {
        crate::error::subscription_already_exist_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB subnet
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetGroupQuotaExceededFault")?;
        if let Some(inner_96) = &self.message {
            write!(f, ": {}", inner_96)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetGroupQuotaExceededFault {}
/// See [`DBSubnetGroupQuotaExceededFault`](crate::error::DBSubnetGroupQuotaExceededFault)
pub mod db_subnet_group_quota_exceeded_fault {
    /// A builder for [`DBSubnetGroupQuotaExceededFault`](crate::error::DBSubnetGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetGroupQuotaExceededFault`](crate::error::DBSubnetGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DBSubnetGroupQuotaExceededFault {
            crate::error::DBSubnetGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBSubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBSubnetGroupQuotaExceededFault`](crate::error::DBSubnetGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_subnet_group_quota_exceeded_fault::Builder {
        crate::error::db_subnet_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSubnetGroupName</code> is already used by an existing DB subnet group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetGroupAlreadyExistsFault")?;
        if let Some(inner_97) = &self.message {
            write!(f, ": {}", inner_97)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetGroupAlreadyExistsFault {}
/// See [`DBSubnetGroupAlreadyExistsFault`](crate::error::DBSubnetGroupAlreadyExistsFault)
pub mod db_subnet_group_already_exists_fault {
    /// A builder for [`DBSubnetGroupAlreadyExistsFault`](crate::error::DBSubnetGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetGroupAlreadyExistsFault`](crate::error::DBSubnetGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBSubnetGroupAlreadyExistsFault {
            crate::error::DBSubnetGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBSubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBSubnetGroupAlreadyExistsFault`](crate::error::DBSubnetGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_subnet_group_already_exists_fault::Builder {
        crate::error::db_subnet_group_already_exists_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB security
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSecurityGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSecurityGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSecurityGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSecurityGroupQuotaExceededFault")?;
        if let Some(inner_98) = &self.message {
            write!(f, ": {}", inner_98)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSecurityGroupQuotaExceededFault {}
/// See [`DBSecurityGroupQuotaExceededFault`](crate::error::DBSecurityGroupQuotaExceededFault)
pub mod db_security_group_quota_exceeded_fault {
    /// A builder for [`DBSecurityGroupQuotaExceededFault`](crate::error::DBSecurityGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSecurityGroupQuotaExceededFault`](crate::error::DBSecurityGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DBSecurityGroupQuotaExceededFault {
            crate::error::DBSecurityGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBSecurityGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBSecurityGroupQuotaExceededFault`](crate::error::DBSecurityGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_security_group_quota_exceeded_fault::Builder {
        crate::error::db_security_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A DB security group isn't allowed for this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSecurityGroupNotSupportedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSecurityGroupNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSecurityGroupNotSupportedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSecurityGroupNotSupportedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSecurityGroupNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSecurityGroupNotSupportedFault")?;
        if let Some(inner_99) = &self.message {
            write!(f, ": {}", inner_99)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSecurityGroupNotSupportedFault {}
/// See [`DBSecurityGroupNotSupportedFault`](crate::error::DBSecurityGroupNotSupportedFault)
pub mod db_security_group_not_supported_fault {
    /// A builder for [`DBSecurityGroupNotSupportedFault`](crate::error::DBSecurityGroupNotSupportedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSecurityGroupNotSupportedFault`](crate::error::DBSecurityGroupNotSupportedFault)
        pub fn build(self) -> crate::error::DBSecurityGroupNotSupportedFault {
            crate::error::DBSecurityGroupNotSupportedFault {
                message: self.message,
            }
        }
    }
}
impl DBSecurityGroupNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`DBSecurityGroupNotSupportedFault`](crate::error::DBSecurityGroupNotSupportedFault)
    pub fn builder() -> crate::error::db_security_group_not_supported_fault::Builder {
        crate::error::db_security_group_not_supported_fault::Builder::default()
    }
}

/// <p>
/// A DB security group with the name specified in
/// <code>DBSecurityGroupName</code> already exists.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSecurityGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSecurityGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSecurityGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSecurityGroupAlreadyExistsFault")?;
        if let Some(inner_100) = &self.message {
            write!(f, ": {}", inner_100)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSecurityGroupAlreadyExistsFault {}
/// See [`DBSecurityGroupAlreadyExistsFault`](crate::error::DBSecurityGroupAlreadyExistsFault)
pub mod db_security_group_already_exists_fault {
    /// A builder for [`DBSecurityGroupAlreadyExistsFault`](crate::error::DBSecurityGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSecurityGroupAlreadyExistsFault`](crate::error::DBSecurityGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBSecurityGroupAlreadyExistsFault {
            crate::error::DBSecurityGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBSecurityGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBSecurityGroupAlreadyExistsFault`](crate::error::DBSecurityGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_security_group_already_exists_fault::Builder {
        crate::error::db_security_group_already_exists_fault::Builder::default()
    }
}

/// <p>The DB proxy already has the maximum number of endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyEndpointQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyEndpointQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyEndpointQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyEndpointQuotaExceededFault")?;
        if let Some(inner_101) = &self.message {
            write!(f, ": {}", inner_101)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyEndpointQuotaExceededFault {}
/// See [`DBProxyEndpointQuotaExceededFault`](crate::error::DBProxyEndpointQuotaExceededFault)
pub mod db_proxy_endpoint_quota_exceeded_fault {
    /// A builder for [`DBProxyEndpointQuotaExceededFault`](crate::error::DBProxyEndpointQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyEndpointQuotaExceededFault`](crate::error::DBProxyEndpointQuotaExceededFault)
        pub fn build(self) -> crate::error::DBProxyEndpointQuotaExceededFault {
            crate::error::DBProxyEndpointQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyEndpointQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBProxyEndpointQuotaExceededFault`](crate::error::DBProxyEndpointQuotaExceededFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder {
        crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder::default()
    }
}

/// <p>Your AWS account already has the maximum number of proxies in the specified AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBProxyQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBProxyQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBProxyQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBProxyQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBProxyQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBProxyQuotaExceededFault")?;
        if let Some(inner_102) = &self.message {
            write!(f, ": {}", inner_102)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBProxyQuotaExceededFault {}
/// See [`DBProxyQuotaExceededFault`](crate::error::DBProxyQuotaExceededFault)
pub mod db_proxy_quota_exceeded_fault {
    /// A builder for [`DBProxyQuotaExceededFault`](crate::error::DBProxyQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBProxyQuotaExceededFault`](crate::error::DBProxyQuotaExceededFault)
        pub fn build(self) -> crate::error::DBProxyQuotaExceededFault {
            crate::error::DBProxyQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBProxyQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBProxyQuotaExceededFault`](crate::error::DBProxyQuotaExceededFault)
    pub fn builder() -> crate::error::db_proxy_quota_exceeded_fault::Builder {
        crate::error::db_proxy_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB parameter
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBParameterGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBParameterGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBParameterGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBParameterGroupQuotaExceededFault")?;
        if let Some(inner_103) = &self.message {
            write!(f, ": {}", inner_103)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBParameterGroupQuotaExceededFault {}
/// See [`DBParameterGroupQuotaExceededFault`](crate::error::DBParameterGroupQuotaExceededFault)
pub mod db_parameter_group_quota_exceeded_fault {
    /// A builder for [`DBParameterGroupQuotaExceededFault`](crate::error::DBParameterGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBParameterGroupQuotaExceededFault`](crate::error::DBParameterGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DBParameterGroupQuotaExceededFault {
            crate::error::DBParameterGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBParameterGroupQuotaExceededFault`](crate::error::DBParameterGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_parameter_group_quota_exceeded_fault::Builder {
        crate::error::db_parameter_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A DB parameter group with the same name exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBParameterGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBParameterGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBParameterGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBParameterGroupAlreadyExistsFault")?;
        if let Some(inner_104) = &self.message {
            write!(f, ": {}", inner_104)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBParameterGroupAlreadyExistsFault {}
/// See [`DBParameterGroupAlreadyExistsFault`](crate::error::DBParameterGroupAlreadyExistsFault)
pub mod db_parameter_group_already_exists_fault {
    /// A builder for [`DBParameterGroupAlreadyExistsFault`](crate::error::DBParameterGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBParameterGroupAlreadyExistsFault`](crate::error::DBParameterGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBParameterGroupAlreadyExistsFault {
            crate::error::DBParameterGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBParameterGroupAlreadyExistsFault`](crate::error::DBParameterGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_parameter_group_already_exists_fault::Builder {
        crate::error::db_parameter_group_already_exists_fault::Builder::default()
    }
}

/// <p>The DBSubnetGroup doesn't belong to the same VPC as that of an existing
/// cross-region read replica of the same source instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDBSubnetGroupFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDBSubnetGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDBSubnetGroupFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDBSubnetGroupFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDBSubnetGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDBSubnetGroupFault")?;
        if let Some(inner_105) = &self.message {
            write!(f, ": {}", inner_105)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDBSubnetGroupFault {}
/// See [`InvalidDBSubnetGroupFault`](crate::error::InvalidDBSubnetGroupFault)
pub mod invalid_db_subnet_group_fault {
    /// A builder for [`InvalidDBSubnetGroupFault`](crate::error::InvalidDBSubnetGroupFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDBSubnetGroupFault`](crate::error::InvalidDBSubnetGroupFault)
        pub fn build(self) -> crate::error::InvalidDBSubnetGroupFault {
            crate::error::InvalidDBSubnetGroupFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDBSubnetGroupFault {
    /// Creates a new builder-style object to manufacture [`InvalidDBSubnetGroupFault`](crate::error::InvalidDBSubnetGroupFault)
    pub fn builder() -> crate::error::invalid_db_subnet_group_fault::Builder {
        crate::error::invalid_db_subnet_group_fault::Builder::default()
    }
}

/// <p>The DBSubnetGroup shouldn't be specified while creating read replicas that lie
/// in the same region as the source instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBSubnetGroupNotAllowedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBSubnetGroupNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBSubnetGroupNotAllowedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBSubnetGroupNotAllowedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBSubnetGroupNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBSubnetGroupNotAllowedFault")?;
        if let Some(inner_106) = &self.message {
            write!(f, ": {}", inner_106)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBSubnetGroupNotAllowedFault {}
/// See [`DBSubnetGroupNotAllowedFault`](crate::error::DBSubnetGroupNotAllowedFault)
pub mod db_subnet_group_not_allowed_fault {
    /// A builder for [`DBSubnetGroupNotAllowedFault`](crate::error::DBSubnetGroupNotAllowedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBSubnetGroupNotAllowedFault`](crate::error::DBSubnetGroupNotAllowedFault)
        pub fn build(self) -> crate::error::DBSubnetGroupNotAllowedFault {
            crate::error::DBSubnetGroupNotAllowedFault {
                message: self.message,
            }
        }
    }
}
impl DBSubnetGroupNotAllowedFault {
    /// Creates a new builder-style object to manufacture [`DBSubnetGroupNotAllowedFault`](crate::error::DBSubnetGroupNotAllowedFault)
    pub fn builder() -> crate::error::db_subnet_group_not_allowed_fault::Builder {
        crate::error::db_subnet_group_not_allowed_fault::Builder::default()
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterEndpointQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterEndpointQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterEndpointQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterEndpointQuotaExceededFault")?;
        if let Some(inner_107) = &self.message {
            write!(f, ": {}", inner_107)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterEndpointQuotaExceededFault {}
/// See [`DBClusterEndpointQuotaExceededFault`](crate::error::DBClusterEndpointQuotaExceededFault)
pub mod db_cluster_endpoint_quota_exceeded_fault {
    /// A builder for [`DBClusterEndpointQuotaExceededFault`](crate::error::DBClusterEndpointQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterEndpointQuotaExceededFault`](crate::error::DBClusterEndpointQuotaExceededFault)
        pub fn build(self) -> crate::error::DBClusterEndpointQuotaExceededFault {
            crate::error::DBClusterEndpointQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterEndpointQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBClusterEndpointQuotaExceededFault`](crate::error::DBClusterEndpointQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder {
        crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified custom endpoint can't be created because it already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterEndpointAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterEndpointAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterEndpointAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterEndpointAlreadyExistsFault")?;
        if let Some(inner_108) = &self.message {
            write!(f, ": {}", inner_108)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterEndpointAlreadyExistsFault {}
/// See [`DBClusterEndpointAlreadyExistsFault`](crate::error::DBClusterEndpointAlreadyExistsFault)
pub mod db_cluster_endpoint_already_exists_fault {
    /// A builder for [`DBClusterEndpointAlreadyExistsFault`](crate::error::DBClusterEndpointAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterEndpointAlreadyExistsFault`](crate::error::DBClusterEndpointAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBClusterEndpointAlreadyExistsFault {
            crate::error::DBClusterEndpointAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterEndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBClusterEndpointAlreadyExistsFault`](crate::error::DBClusterEndpointAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_already_exists_fault::Builder {
        crate::error::db_cluster_endpoint_already_exists_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of custom Availability Zones.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneQuotaExceededFault")?;
        if let Some(inner_109) = &self.message {
            write!(f, ": {}", inner_109)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneQuotaExceededFault {}
/// See [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
pub mod custom_availability_zone_quota_exceeded_fault {
    /// A builder for [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneQuotaExceededFault {
            crate::error::CustomAvailabilityZoneQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
    pub fn builder() -> crate::error::custom_availability_zone_quota_exceeded_fault::Builder {
        crate::error::custom_availability_zone_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>CustomAvailabilityZoneName</code> is already used by an existing custom
/// Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneAlreadyExistsFault")?;
        if let Some(inner_110) = &self.message {
            write!(f, ": {}", inner_110)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneAlreadyExistsFault {}
/// See [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
pub mod custom_availability_zone_already_exists_fault {
    /// A builder for [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneAlreadyExistsFault {
            crate::error::CustomAvailabilityZoneAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
    pub fn builder() -> crate::error::custom_availability_zone_already_exists_fault::Builder {
        crate::error::custom_availability_zone_already_exists_fault::Builder::default()
    }
}

/// <p>You can't cancel an export task that has completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportTaskStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportTaskStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportTaskStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportTaskStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportTaskStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportTaskStateFault")?;
        if let Some(inner_111) = &self.message {
            write!(f, ": {}", inner_111)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportTaskStateFault {}
/// See [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
pub mod invalid_export_task_state_fault {
    /// A builder for [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
        pub fn build(self) -> crate::error::InvalidExportTaskStateFault {
            crate::error::InvalidExportTaskStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportTaskStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
    pub fn builder() -> crate::error::invalid_export_task_state_fault::Builder {
        crate::error::invalid_export_task_state_fault::Builder::default()
    }
}

/// <p>The DB security group authorization quota has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationQuotaExceededFault")?;
        if let Some(inner_112) = &self.message {
            write!(f, ": {}", inner_112)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationQuotaExceededFault {}
/// See [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
pub mod authorization_quota_exceeded_fault {
    /// A builder for [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
        pub fn build(self) -> crate::error::AuthorizationQuotaExceededFault {
            crate::error::AuthorizationQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
    pub fn builder() -> crate::error::authorization_quota_exceeded_fault::Builder {
        crate::error::authorization_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group is already authorized for
/// the specified DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationAlreadyExistsFault")?;
        if let Some(inner_113) = &self.message {
            write!(f, ": {}", inner_113)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationAlreadyExistsFault {}
/// See [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
pub mod authorization_already_exists_fault {
    /// A builder for [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
        pub fn build(self) -> crate::error::AuthorizationAlreadyExistsFault {
            crate::error::AuthorizationAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    pub fn builder() -> crate::error::authorization_already_exists_fault::Builder {
        crate::error::authorization_already_exists_fault::Builder::default()
    }
}

/// <p>You can't associate any more AWS Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceRoleQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceRoleQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceRoleQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceRoleQuotaExceededFault")?;
        if let Some(inner_114) = &self.message {
            write!(f, ": {}", inner_114)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceRoleQuotaExceededFault {}
/// See [`DBInstanceRoleQuotaExceededFault`](crate::error::DBInstanceRoleQuotaExceededFault)
pub mod db_instance_role_quota_exceeded_fault {
    /// A builder for [`DBInstanceRoleQuotaExceededFault`](crate::error::DBInstanceRoleQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceRoleQuotaExceededFault`](crate::error::DBInstanceRoleQuotaExceededFault)
        pub fn build(self) -> crate::error::DBInstanceRoleQuotaExceededFault {
            crate::error::DBInstanceRoleQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceRoleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceRoleQuotaExceededFault`](crate::error::DBInstanceRoleQuotaExceededFault)
    pub fn builder() -> crate::error::db_instance_role_quota_exceeded_fault::Builder {
        crate::error::db_instance_role_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified <code>RoleArn</code> or <code>FeatureName</code> value is already associated with the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBInstanceRoleAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBInstanceRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBInstanceRoleAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBInstanceRoleAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBInstanceRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBInstanceRoleAlreadyExistsFault")?;
        if let Some(inner_115) = &self.message {
            write!(f, ": {}", inner_115)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBInstanceRoleAlreadyExistsFault {}
/// See [`DBInstanceRoleAlreadyExistsFault`](crate::error::DBInstanceRoleAlreadyExistsFault)
pub mod db_instance_role_already_exists_fault {
    /// A builder for [`DBInstanceRoleAlreadyExistsFault`](crate::error::DBInstanceRoleAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBInstanceRoleAlreadyExistsFault`](crate::error::DBInstanceRoleAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBInstanceRoleAlreadyExistsFault {
            crate::error::DBInstanceRoleAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBInstanceRoleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBInstanceRoleAlreadyExistsFault`](crate::error::DBInstanceRoleAlreadyExistsFault)
    pub fn builder() -> crate::error::db_instance_role_already_exists_fault::Builder {
        crate::error::db_instance_role_already_exists_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterRoleQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterRoleQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterRoleQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterRoleQuotaExceededFault")?;
        if let Some(inner_116) = &self.message {
            write!(f, ": {}", inner_116)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterRoleQuotaExceededFault {}
/// See [`DBClusterRoleQuotaExceededFault`](crate::error::DBClusterRoleQuotaExceededFault)
pub mod db_cluster_role_quota_exceeded_fault {
    /// A builder for [`DBClusterRoleQuotaExceededFault`](crate::error::DBClusterRoleQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterRoleQuotaExceededFault`](crate::error::DBClusterRoleQuotaExceededFault)
        pub fn build(self) -> crate::error::DBClusterRoleQuotaExceededFault {
            crate::error::DBClusterRoleQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterRoleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DBClusterRoleQuotaExceededFault`](crate::error::DBClusterRoleQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_role_quota_exceeded_fault::Builder {
        crate::error::db_cluster_role_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DBClusterRoleAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DBClusterRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DBClusterRoleAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DBClusterRoleAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DBClusterRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DBClusterRoleAlreadyExistsFault")?;
        if let Some(inner_117) = &self.message {
            write!(f, ": {}", inner_117)?;
        }
        Ok(())
    }
}
impl std::error::Error for DBClusterRoleAlreadyExistsFault {}
/// See [`DBClusterRoleAlreadyExistsFault`](crate::error::DBClusterRoleAlreadyExistsFault)
pub mod db_cluster_role_already_exists_fault {
    /// A builder for [`DBClusterRoleAlreadyExistsFault`](crate::error::DBClusterRoleAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DBClusterRoleAlreadyExistsFault`](crate::error::DBClusterRoleAlreadyExistsFault)
        pub fn build(self) -> crate::error::DBClusterRoleAlreadyExistsFault {
            crate::error::DBClusterRoleAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DBClusterRoleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DBClusterRoleAlreadyExistsFault`](crate::error::DBClusterRoleAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_role_already_exists_fault::Builder {
        crate::error::db_cluster_role_already_exists_fault::Builder::default()
    }
}
