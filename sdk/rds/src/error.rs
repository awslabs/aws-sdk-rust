// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToDBClusterError {
    pub kind: AddRoleToDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterRoleAlreadyExistsFault(crate::error::DbClusterRoleAlreadyExistsFault),
    DbClusterRoleQuotaExceededFault(crate::error::DbClusterRoleQuotaExceededFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::DbClusterRoleAlreadyExistsFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::DbClusterRoleQuotaExceededFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            AddRoleToDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToDBClusterError {
    fn code(&self) -> Option<&str> {
        AddRoleToDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToDBClusterError {
    pub fn new(kind: AddRoleToDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_role_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DbClusterRoleAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_role_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::DbClusterRoleQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for AddRoleToDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::DbClusterRoleAlreadyExistsFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::DbClusterRoleQuotaExceededFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            AddRoleToDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToDBInstanceError {
    pub kind: AddRoleToDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToDBInstanceErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbInstanceRoleAlreadyExistsFault(crate::error::DbInstanceRoleAlreadyExistsFault),
    DbInstanceRoleQuotaExceededFault(crate::error::DbInstanceRoleQuotaExceededFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::DbInstanceRoleAlreadyExistsFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::DbInstanceRoleQuotaExceededFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            AddRoleToDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToDBInstanceError {
    fn code(&self) -> Option<&str> {
        AddRoleToDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToDBInstanceError {
    pub fn new(kind: AddRoleToDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_instance_role_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DbInstanceRoleAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_role_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::DbInstanceRoleQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for AddRoleToDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::DbInstanceRoleAlreadyExistsFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::DbInstanceRoleQuotaExceededFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            AddRoleToDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddSourceIdentifierToSubscriptionError {
    pub kind: AddSourceIdentifierToSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddSourceIdentifierToSubscriptionErrorKind {
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddSourceIdentifierToSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AddSourceIdentifierToSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddSourceIdentifierToSubscriptionError {
    fn code(&self) -> Option<&str> {
        AddSourceIdentifierToSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddSourceIdentifierToSubscriptionError {
    pub fn new(
        kind: AddSourceIdentifierToSubscriptionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddSourceIdentifierToSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddSourceIdentifierToSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for AddSourceIdentifierToSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault(_inner) => Some(_inner),
            AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                Some(_inner)
            }
            AddSourceIdentifierToSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsToResourceError {
    pub kind: AddTagsToResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsToResourceErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        AddTagsToResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    pub fn new(kind: AddTagsToResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsToResourceErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ApplyPendingMaintenanceActionError {
    pub kind: ApplyPendingMaintenanceActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ApplyPendingMaintenanceActionErrorKind {
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ApplyPendingMaintenanceActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ApplyPendingMaintenanceActionErrorKind::InvalidDbClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            ApplyPendingMaintenanceActionErrorKind::InvalidDbInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            ApplyPendingMaintenanceActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ApplyPendingMaintenanceActionError {
    fn code(&self) -> Option<&str> {
        ApplyPendingMaintenanceActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ApplyPendingMaintenanceActionError {
    pub fn new(kind: ApplyPendingMaintenanceActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ApplyPendingMaintenanceActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ApplyPendingMaintenanceActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for ApplyPendingMaintenanceActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ApplyPendingMaintenanceActionErrorKind::InvalidDbClusterStateFault(_inner) => {
                Some(_inner)
            }
            ApplyPendingMaintenanceActionErrorKind::InvalidDbInstanceStateFault(_inner) => {
                Some(_inner)
            }
            ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            ApplyPendingMaintenanceActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AuthorizeDBSecurityGroupIngressError {
    pub kind: AuthorizeDBSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeDBSecurityGroupIngressErrorKind {
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    AuthorizationQuotaExceededFault(crate::error::AuthorizationQuotaExceededFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AuthorizeDBSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AuthorizeDBSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        AuthorizeDBSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeDBSecurityGroupIngressError {
    pub fn new(kind: AuthorizeDBSecurityGroupIngressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_)
        )
    }
    pub fn is_authorization_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for AuthorizeDBSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            AuthorizeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BacktrackDBClusterError {
    pub kind: BacktrackDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BacktrackDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BacktrackDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BacktrackDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            BacktrackDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            BacktrackDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BacktrackDBClusterError {
    fn code(&self) -> Option<&str> {
        BacktrackDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BacktrackDBClusterError {
    pub fn new(kind: BacktrackDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BacktrackDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BacktrackDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            BacktrackDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            BacktrackDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for BacktrackDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BacktrackDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            BacktrackDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            BacktrackDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelExportTaskError {
    pub kind: CancelExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelExportTaskErrorKind {
    ExportTaskNotFoundFault(crate::error::ExportTaskNotFoundFault),
    InvalidExportTaskStateFault(crate::error::InvalidExportTaskStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelExportTaskError {
    fn code(&self) -> Option<&str> {
        CancelExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelExportTaskError {
    pub fn new(kind: CancelExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_export_task_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_)
        )
    }
    pub fn is_invalid_export_task_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_)
        )
    }
}
impl std::error::Error for CancelExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelExportTaskErrorKind::ExportTaskNotFoundFault(_inner) => Some(_inner),
            CancelExportTaskErrorKind::InvalidExportTaskStateFault(_inner) => Some(_inner),
            CancelExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBClusterParameterGroupError {
    pub kind: CopyDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterParameterGroupErrorKind {
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        CopyDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterParameterGroupError {
    pub fn new(kind: CopyDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBClusterSnapshotError {
    pub kind: CopyDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterSnapshotErrorKind {
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        CopyDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterSnapshotError {
    pub fn new(kind: CopyDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            CopyDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CopyDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBParameterGroupError {
    pub kind: CopyDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBParameterGroupErrorKind {
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CopyDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        CopyDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBParameterGroupError {
    pub fn new(kind: CopyDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CopyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            CopyDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CopyDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyDBSnapshotError {
    pub kind: CopyDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBSnapshotErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    DbSnapshotAlreadyExistsFault(crate::error::DbSnapshotAlreadyExistsFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyDBSnapshotError {
    fn code(&self) -> Option<&str> {
        CopyDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBSnapshotError {
    pub fn new(kind: CopyDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyDBSnapshotErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CopyDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyOptionGroupError {
    pub kind: CopyOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyOptionGroupErrorKind {
    OptionGroupAlreadyExistsFault(crate::error::OptionGroupAlreadyExistsFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    OptionGroupQuotaExceededFault(crate::error::OptionGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CopyOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyOptionGroupError {
    fn code(&self) -> Option<&str> {
        CopyOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyOptionGroupError {
    pub fn new(kind: CopyOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_option_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CopyOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => Some(_inner),
            CopyOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomAvailabilityZoneError {
    pub kind: CreateCustomAvailabilityZoneErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomAvailabilityZoneErrorKind {
    CustomAvailabilityZoneAlreadyExistsFault(
        crate::error::CustomAvailabilityZoneAlreadyExistsFault,
    ),
    CustomAvailabilityZoneQuotaExceededFault(
        crate::error::CustomAvailabilityZoneQuotaExceededFault,
    ),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomAvailabilityZoneError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(
                _inner,
            ) => _inner.fmt(f),
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(
                _inner,
            ) => _inner.fmt(f),
            CreateCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomAvailabilityZoneErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomAvailabilityZoneError {
    fn code(&self) -> Option<&str> {
        CreateCustomAvailabilityZoneError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomAvailabilityZoneError {
    pub fn new(kind: CreateCustomAvailabilityZoneErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(_)
        )
    }
    pub fn is_custom_availability_zone_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for CreateCustomAvailabilityZoneError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneAlreadyExistsFault(
                _inner,
            ) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneQuotaExceededFault(
                _inner,
            ) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateCustomAvailabilityZoneErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterError {
    pub kind: CreateDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterErrorKind {
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterErrorKind::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterError {
    pub fn new(kind: CreateDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(&self.kind, CreateDBClusterErrorKind::DomainNotFoundFault(_))
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBClusterErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterErrorKind::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbClusterQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterEndpointError {
    pub kind: CreateDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterEndpointErrorKind {
    DbClusterEndpointAlreadyExistsFault(crate::error::DbClusterEndpointAlreadyExistsFault),
    DbClusterEndpointQuotaExceededFault(crate::error::DbClusterEndpointQuotaExceededFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterEndpointErrorKind::DbClusterEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterEndpointErrorKind::DbClusterEndpointQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterEndpointErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterEndpointError {
    pub fn new(kind: CreateDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DbClusterEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_endpoint_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DbClusterEndpointQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterEndpointErrorKind::DbClusterEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterEndpointErrorKind::DbClusterEndpointQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterEndpointErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            CreateDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterParameterGroupError {
    pub kind: CreateDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterParameterGroupErrorKind {
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterParameterGroupError {
    pub fn new(kind: CreateDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBClusterSnapshotError {
    pub kind: CreateDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterSnapshotErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBClusterSnapshotErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterSnapshotError {
    pub fn new(kind: CreateDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBClusterSnapshotErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBClusterSnapshotErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CreateDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBInstanceError {
    pub kind: CreateDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            CreateDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBInstanceError {
    fn code(&self) -> Option<&str> {
        CreateDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBInstanceError {
    pub fn new(kind: CreateDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBInstanceErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for CreateDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InstanceQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            CreateDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBInstanceReadReplicaError {
    pub kind: CreateDBInstanceReadReplicaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBInstanceReadReplicaErrorKind {
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotAllowedFault(crate::error::DbSubnetGroupNotAllowedFault),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidDbSubnetGroupFault(crate::error::InvalidDbSubnetGroupFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBInstanceReadReplicaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBInstanceReadReplicaErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotAllowedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InsufficientDbInstanceCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDbInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDbSubnetGroupFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBInstanceReadReplicaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBInstanceReadReplicaError {
    fn code(&self) -> Option<&str> {
        CreateDBInstanceReadReplicaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBInstanceReadReplicaError {
    pub fn new(kind: CreateDBInstanceReadReplicaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBInstanceReadReplicaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBInstanceReadReplicaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_allowed_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotAllowedFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidDbSubnetGroupFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for CreateDBInstanceReadReplicaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBInstanceReadReplicaErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotAllowedFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InsufficientDbInstanceCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDbInstanceStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::InvalidDbSubnetGroupFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            CreateDBInstanceReadReplicaErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            CreateDBInstanceReadReplicaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBParameterGroupError {
    pub kind: CreateDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBParameterGroupErrorKind {
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBParameterGroupError {
    pub fn new(kind: CreateDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBParameterGroupErrorKind::DbParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBProxyError {
    pub kind: CreateDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBProxyErrorKind {
    DbProxyAlreadyExistsFault(crate::error::DbProxyAlreadyExistsFault),
    DbProxyQuotaExceededFault(crate::error::DbProxyQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBProxyErrorKind::DbProxyAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::DbProxyQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBProxyError {
    fn code(&self) -> Option<&str> {
        CreateDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBProxyError {
    pub fn new(kind: CreateDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyErrorKind::DbProxyAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyErrorKind::DbProxyQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBProxyErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBProxyErrorKind::DbProxyAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBProxyErrorKind::DbProxyQuotaExceededFault(_inner) => Some(_inner),
            CreateDBProxyErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBProxyEndpointError {
    pub kind: CreateDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBProxyEndpointErrorKind {
    DbProxyEndpointAlreadyExistsFault(crate::error::DbProxyEndpointAlreadyExistsFault),
    DbProxyEndpointQuotaExceededFault(crate::error::DbProxyEndpointQuotaExceededFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBProxyEndpointErrorKind::DbProxyEndpointQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBProxyEndpointErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        CreateDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBProxyEndpointError {
    pub fn new(kind: CreateDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_endpoint_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DbProxyEndpointQuotaExceededFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBProxyEndpointErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBProxyEndpointErrorKind::DbProxyEndpointQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBProxyEndpointErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSecurityGroupError {
    pub kind: CreateDBSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSecurityGroupErrorKind {
    DbSecurityGroupAlreadyExistsFault(crate::error::DbSecurityGroupAlreadyExistsFault),
    DbSecurityGroupNotSupportedFault(crate::error::DbSecurityGroupNotSupportedFault),
    DbSecurityGroupQuotaExceededFault(crate::error::DbSecurityGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSecurityGroupErrorKind::DbSecurityGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::DbSecurityGroupNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::DbSecurityGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSecurityGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSecurityGroupError {
    pub fn new(kind: CreateDBSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DbSecurityGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_security_group_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DbSecurityGroupNotSupportedFault(_)
        )
    }
    pub fn is_db_security_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSecurityGroupErrorKind::DbSecurityGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSecurityGroupErrorKind::DbSecurityGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::DbSecurityGroupNotSupportedFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::DbSecurityGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateDBSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSnapshotError {
    pub kind: CreateDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSnapshotErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbSnapshotAlreadyExistsFault(crate::error::DbSnapshotAlreadyExistsFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSnapshotErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSnapshotError {
    pub fn new(kind: CreateDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSnapshotErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::DbSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDBSubnetGroupError {
    pub kind: CreateDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSubnetGroupErrorKind {
    DbSubnetGroupAlreadyExistsFault(crate::error::DbSubnetGroupAlreadyExistsFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupQuotaExceededFault(crate::error::DbSubnetGroupQuotaExceededFault),
    DbSubnetQuotaExceededFault(crate::error::DbSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDBSubnetGroupErrorKind::DbSubnetGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            CreateDBSubnetGroupErrorKind::DbSubnetGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        CreateDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSubnetGroupError {
    pub fn new(kind: CreateDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DbSubnetGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DbSubnetGroupQuotaExceededFault(_)
        )
    }
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, CreateDBSubnetGroupErrorKind::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDBSubnetGroupErrorKind::DbSubnetGroupAlreadyExistsFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            CreateDBSubnetGroupErrorKind::DbSubnetGroupQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEventSubscriptionError {
    pub kind: CreateEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSubscriptionErrorKind {
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionAlreadyExistFault(crate::error::SubscriptionAlreadyExistFault),
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_inner) => _inner.fmt(f),
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        CreateEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventSubscriptionError {
    pub fn new(kind: CreateEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_)
        )
    }
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SnsInvalidTopicFault(_)
        )
    }
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault(_)
        )
    }
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_)
        )
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_already_exist_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_)
        )
    }
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_)
        )
    }
}
impl std::error::Error for CreateEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateEventSubscriptionErrorKind::SnsInvalidTopicFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SourceNotFoundFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault(_inner) => Some(_inner),
            CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGlobalClusterError {
    pub kind: CreateGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGlobalClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    GlobalClusterAlreadyExistsFault(crate::error::GlobalClusterAlreadyExistsFault),
    GlobalClusterQuotaExceededFault(crate::error::GlobalClusterQuotaExceededFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            CreateGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGlobalClusterError {
    fn code(&self) -> Option<&str> {
        CreateGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGlobalClusterError {
    pub fn new(kind: CreateGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_global_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for CreateGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            CreateGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOptionGroupError {
    pub kind: CreateOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOptionGroupErrorKind {
    OptionGroupAlreadyExistsFault(crate::error::OptionGroupAlreadyExistsFault),
    OptionGroupQuotaExceededFault(crate::error::OptionGroupQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOptionGroupError {
    fn code(&self) -> Option<&str> {
        CreateOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOptionGroupError {
    pub fn new(kind: CreateOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_option_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for CreateOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOptionGroupErrorKind::OptionGroupAlreadyExistsFault(_inner) => Some(_inner),
            CreateOptionGroupErrorKind::OptionGroupQuotaExceededFault(_inner) => Some(_inner),
            CreateOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomAvailabilityZoneError {
    pub kind: DeleteCustomAvailabilityZoneErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomAvailabilityZoneErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomAvailabilityZoneError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomAvailabilityZoneErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomAvailabilityZoneError {
    fn code(&self) -> Option<&str> {
        DeleteCustomAvailabilityZoneError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomAvailabilityZoneError {
    pub fn new(kind: DeleteCustomAvailabilityZoneErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomAvailabilityZoneErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for DeleteCustomAvailabilityZoneError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomAvailabilityZoneErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteCustomAvailabilityZoneErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            DeleteCustomAvailabilityZoneErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterError {
    pub kind: DeleteDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterError {
    pub fn new(kind: DeleteDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::DbClusterSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::DbClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterEndpointError {
    pub kind: DeleteDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterEndpointErrorKind {
    DbClusterEndpointNotFoundFault(crate::error::DbClusterEndpointNotFoundFault),
    InvalidDbClusterEndpointStateFault(crate::error::InvalidDbClusterEndpointStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterEndpointError {
    pub fn new(kind: DeleteDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            DeleteDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterParameterGroupError {
    pub kind: DeleteDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterParameterGroupError {
    pub fn new(kind: DeleteDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBClusterSnapshotError {
    pub kind: DeleteDBClusterSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterSnapshotErrorKind {
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBClusterSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteDBClusterSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterSnapshotError {
    pub fn new(kind: DeleteDBClusterSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBClusterSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBClusterSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBClusterSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBInstanceError {
    pub kind: DeleteDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBInstanceErrorKind {
    DbInstanceAutomatedBackupQuotaExceededFault(
        crate::error::DbInstanceAutomatedBackupQuotaExceededFault,
    ),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbSnapshotAlreadyExistsFault(crate::error::DbSnapshotAlreadyExistsFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBInstanceErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBInstanceError {
    pub fn new(kind: DeleteDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBInstanceErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            DeleteDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBInstanceAutomatedBackupError {
    pub kind: DeleteDBInstanceAutomatedBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBInstanceAutomatedBackupErrorKind {
    DbInstanceAutomatedBackupNotFoundFault(crate::error::DbInstanceAutomatedBackupNotFoundFault),
    InvalidDbInstanceAutomatedBackupStateFault(
        crate::error::InvalidDbInstanceAutomatedBackupStateFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBInstanceAutomatedBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBInstanceAutomatedBackupErrorKind::DbInstanceAutomatedBackupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDbInstanceAutomatedBackupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBInstanceAutomatedBackupError {
    fn code(&self) -> Option<&str> {
        DeleteDBInstanceAutomatedBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBInstanceAutomatedBackupError {
    pub fn new(kind: DeleteDBInstanceAutomatedBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceAutomatedBackupErrorKind::DbInstanceAutomatedBackupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_automated_backup_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDbInstanceAutomatedBackupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBInstanceAutomatedBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBInstanceAutomatedBackupErrorKind::DbInstanceAutomatedBackupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::InvalidDbInstanceAutomatedBackupStateFault(_inner) =>
            Some(_inner)
            ,
            DeleteDBInstanceAutomatedBackupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBParameterGroupError {
    pub kind: DeleteDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBParameterGroupError {
    pub fn new(kind: DeleteDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBProxyError {
    pub kind: DeleteDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBProxyErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBProxyErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBProxyErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            DeleteDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBProxyError {
    fn code(&self) -> Option<&str> {
        DeleteDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBProxyError {
    pub fn new(kind: DeleteDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(&self.kind, DeleteDBProxyErrorKind::DbProxyNotFoundFault(_))
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBProxyErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DeleteDBProxyErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            DeleteDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBProxyEndpointError {
    pub kind: DeleteDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBProxyEndpointErrorKind {
    DbProxyEndpointNotFoundFault(crate::error::DbProxyEndpointNotFoundFault),
    InvalidDbProxyEndpointStateFault(crate::error::InvalidDbProxyEndpointStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBProxyEndpointError {
    pub fn new(kind: DeleteDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_inner) => Some(_inner),
            DeleteDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSecurityGroupError {
    pub kind: DeleteDBSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSecurityGroupErrorKind {
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSecurityGroupErrorKind::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSecurityGroupErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteDBSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSecurityGroupError {
    pub fn new(kind: DeleteDBSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSecurityGroupErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSecurityGroupErrorKind::InvalidDbSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSecurityGroupErrorKind::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBSecurityGroupErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteDBSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSnapshotError {
    pub kind: DeleteDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSnapshotErrorKind {
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => _inner.fmt(f),
            DeleteDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSnapshotError {
    pub fn new(kind: DeleteDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSnapshotErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            DeleteDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => Some(_inner),
            DeleteDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDBSubnetGroupError {
    pub kind: DeleteDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSubnetGroupErrorKind {
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    InvalidDbSubnetStateFault(crate::error::InvalidDbSubnetStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetStateFault(_inner) => _inner.fmt(f),
            DeleteDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSubnetGroupError {
    pub fn new(kind: DeleteDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetStateFault(_)
        )
    }
}
impl std::error::Error for DeleteDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::InvalidDbSubnetStateFault(_inner) => Some(_inner),
            DeleteDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventSubscriptionError {
    pub kind: DeleteEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSubscriptionErrorKind {
    InvalidEventSubscriptionStateFault(crate::error::InvalidEventSubscriptionStateFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            DeleteEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        DeleteEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventSubscriptionError {
    pub fn new(kind: DeleteEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_event_subscription_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(_inner) => {
                Some(_inner)
            }
            DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            DeleteEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGlobalClusterError {
    pub kind: DeleteGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGlobalClusterErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            DeleteGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGlobalClusterError {
    fn code(&self) -> Option<&str> {
        DeleteGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGlobalClusterError {
    pub fn new(kind: DeleteGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for DeleteGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            DeleteGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstallationMediaError {
    pub kind: DeleteInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstallationMediaErrorKind {
    InstallationMediaNotFoundFault(crate::error::InstallationMediaNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstallationMediaError {
    fn code(&self) -> Option<&str> {
        DeleteInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstallationMediaError {
    pub fn new(kind: DeleteInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_installation_media_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOptionGroupError {
    pub kind: DeleteOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOptionGroupErrorKind {
    InvalidOptionGroupStateFault(crate::error::InvalidOptionGroupStateFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => _inner.fmt(f),
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOptionGroupError {
    fn code(&self) -> Option<&str> {
        DeleteOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOptionGroupError {
    pub fn new(kind: DeleteOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_option_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => Some(_inner),
            DeleteOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            DeleteOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterDBProxyTargetsError {
    pub kind: DeregisterDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterDBProxyTargetsErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    DbProxyTargetNotFoundFault(crate::error::DbProxyTargetNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            DeregisterDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        DeregisterDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterDBProxyTargetsError {
    pub fn new(kind: DeregisterDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for DeregisterDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeregisterDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            DeregisterDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAttributesError {
    pub kind: DescribeAccountAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAttributesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAttributesError {
    pub fn new(kind: DescribeAccountAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeAccountAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificatesError {
    pub kind: DescribeCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificatesErrorKind {
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            DescribeCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCertificatesError {
    fn code(&self) -> Option<&str> {
        DescribeCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificatesError {
    pub fn new(kind: DescribeCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificatesErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            DescribeCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomAvailabilityZonesError {
    pub kind: DescribeCustomAvailabilityZonesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomAvailabilityZonesErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomAvailabilityZonesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeCustomAvailabilityZonesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomAvailabilityZonesError {
    fn code(&self) -> Option<&str> {
        DescribeCustomAvailabilityZonesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomAvailabilityZonesError {
    pub fn new(kind: DescribeCustomAvailabilityZonesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomAvailabilityZonesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomAvailabilityZonesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeCustomAvailabilityZonesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomAvailabilityZonesErrorKind::CustomAvailabilityZoneNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeCustomAvailabilityZonesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterBacktracksError {
    pub kind: DescribeDBClusterBacktracksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterBacktracksErrorKind {
    DbClusterBacktrackNotFoundFault(crate::error::DbClusterBacktrackNotFoundFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterBacktracksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterBacktracksErrorKind::DbClusterBacktrackNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterBacktracksErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClusterBacktracksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterBacktracksError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterBacktracksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterBacktracksError {
    pub fn new(kind: DescribeDBClusterBacktracksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterBacktracksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterBacktracksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_backtrack_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterBacktracksErrorKind::DbClusterBacktrackNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterBacktracksErrorKind::DbClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterBacktracksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterBacktracksErrorKind::DbClusterBacktrackNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterBacktracksErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClusterBacktracksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterEndpointsError {
    pub kind: DescribeDBClusterEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterEndpointsErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterEndpointsErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClusterEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterEndpointsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterEndpointsError {
    pub fn new(kind: DescribeDBClusterEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterEndpointsErrorKind::DbClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterEndpointsErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClusterEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterParameterGroupsError {
    pub kind: DescribeDBClusterParameterGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParameterGroupsErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterParameterGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterParameterGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterParameterGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParameterGroupsError {
    pub fn new(kind: DescribeDBClusterParameterGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterParameterGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterParameterGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterParameterGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterParametersError {
    pub kind: DescribeDBClusterParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParametersErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterParametersErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterParametersError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParametersError {
    pub fn new(kind: DescribeDBClusterParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterParametersErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterParametersErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClustersError {
    pub kind: DescribeDBClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClustersErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClustersErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClustersError {
    fn code(&self) -> Option<&str> {
        DescribeDBClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClustersError {
    pub fn new(kind: DescribeDBClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClustersErrorKind::DbClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClustersErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            DescribeDBClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterSnapshotAttributesError {
    pub kind: DescribeDBClusterSnapshotAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotAttributesErrorKind {
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterSnapshotAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterSnapshotAttributesErrorKind::DbClusterSnapshotNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterSnapshotAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotAttributesError {
    pub fn new(
        kind: DescribeDBClusterSnapshotAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterSnapshotAttributesErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterSnapshotAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterSnapshotAttributesErrorKind::DbClusterSnapshotNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeDBClusterSnapshotAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBClusterSnapshotsError {
    pub kind: DescribeDBClusterSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotsErrorKind {
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBClusterSnapshotsErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBClusterSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeDBClusterSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotsError {
    pub fn new(kind: DescribeDBClusterSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBClusterSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBClusterSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBClusterSnapshotsErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBClusterSnapshotsErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBClusterSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBEngineVersionsError {
    pub kind: DescribeDBEngineVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBEngineVersionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBEngineVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBEngineVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBEngineVersionsError {
    fn code(&self) -> Option<&str> {
        DescribeDBEngineVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBEngineVersionsError {
    pub fn new(kind: DescribeDBEngineVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBEngineVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBEngineVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeDBEngineVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBEngineVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBInstanceAutomatedBackupsError {
    pub kind: DescribeDBInstanceAutomatedBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBInstanceAutomatedBackupsErrorKind {
    DbInstanceAutomatedBackupNotFoundFault(crate::error::DbInstanceAutomatedBackupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBInstanceAutomatedBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBInstanceAutomatedBackupsErrorKind::DbInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBInstanceAutomatedBackupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBInstanceAutomatedBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBInstanceAutomatedBackupsError {
    pub fn new(
        kind: DescribeDBInstanceAutomatedBackupsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBInstanceAutomatedBackupsErrorKind::DbInstanceAutomatedBackupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBInstanceAutomatedBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBInstanceAutomatedBackupsErrorKind::DbInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeDBInstanceAutomatedBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBInstancesError {
    pub kind: DescribeDBInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBInstancesErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBInstancesErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeDBInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBInstancesError {
    pub fn new(kind: DescribeDBInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBInstancesErrorKind::DbInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBInstancesErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            DescribeDBInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBLogFilesError {
    pub kind: DescribeDBLogFilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBLogFilesErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBLogFilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBLogFilesErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBLogFilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBLogFilesError {
    fn code(&self) -> Option<&str> {
        DescribeDBLogFilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBLogFilesError {
    pub fn new(kind: DescribeDBLogFilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBLogFilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBLogFilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBLogFilesErrorKind::DbInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBLogFilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBLogFilesErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            DescribeDBLogFilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBParameterGroupsError {
    pub kind: DescribeDBParameterGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParameterGroupsErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBParameterGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBParameterGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBParameterGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParameterGroupsError {
    pub fn new(kind: DescribeDBParameterGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBParameterGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBParameterGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBParameterGroupsErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBParameterGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBParametersError {
    pub kind: DescribeDBParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParametersErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBParametersErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBParametersError {
    fn code(&self) -> Option<&str> {
        DescribeDBParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParametersError {
    pub fn new(kind: DescribeDBParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBParametersErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBParametersErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxiesError {
    pub kind: DescribeDBProxiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxiesErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxiesErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxiesError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxiesError {
    pub fn new(kind: DescribeDBProxiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxiesErrorKind::DbProxyNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxiesErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyEndpointsError {
    pub kind: DescribeDBProxyEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyEndpointsErrorKind {
    DbProxyEndpointNotFoundFault(crate::error::DbProxyEndpointNotFoundFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyEndpointsErrorKind::DbProxyEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyEndpointsErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyEndpointsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyEndpointsError {
    pub fn new(kind: DescribeDBProxyEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyEndpointsErrorKind::DbProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyEndpointsErrorKind::DbProxyNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyEndpointsErrorKind::DbProxyEndpointNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyEndpointsErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyTargetGroupsError {
    pub kind: DescribeDBProxyTargetGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyTargetGroupsErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyTargetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyTargetGroupsErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetGroupsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyTargetGroupsErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyTargetGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyTargetGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyTargetGroupsError {
    pub fn new(kind: DescribeDBProxyTargetGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyTargetGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyTargetGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetGroupsErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyTargetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyTargetGroupsErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetGroupsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBProxyTargetGroupsErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            DescribeDBProxyTargetGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBProxyTargetsError {
    pub kind: DescribeDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBProxyTargetsErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    DbProxyTargetNotFoundFault(crate::error::DbProxyTargetNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            DescribeDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBProxyTargetsError {
    pub fn new(kind: DescribeDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for DescribeDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeDBProxyTargetsErrorKind::DbProxyTargetNotFoundFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            DescribeDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSecurityGroupsError {
    pub kind: DescribeDBSecurityGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSecurityGroupsErrorKind {
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSecurityGroupsErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeDBSecurityGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSecurityGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSecurityGroupsError {
    pub fn new(kind: DescribeDBSecurityGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSecurityGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSecurityGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSecurityGroupsErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSecurityGroupsErrorKind::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBSecurityGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSnapshotAttributesError {
    pub kind: DescribeDBSnapshotAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSnapshotAttributesErrorKind {
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSnapshotAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSnapshotAttributesErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSnapshotAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSnapshotAttributesError {
    fn code(&self) -> Option<&str> {
        DescribeDBSnapshotAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSnapshotAttributesError {
    pub fn new(kind: DescribeDBSnapshotAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSnapshotAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSnapshotAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSnapshotAttributesErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSnapshotAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSnapshotAttributesErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            DescribeDBSnapshotAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSnapshotsError {
    pub kind: DescribeDBSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSnapshotsErrorKind {
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSnapshotsErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSnapshotsError {
    pub fn new(kind: DescribeDBSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSnapshotsErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSnapshotsErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            DescribeDBSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDBSubnetGroupsError {
    pub kind: DescribeDBSubnetGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSubnetGroupsErrorKind {
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDBSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDBSubnetGroupsErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeDBSubnetGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDBSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeDBSubnetGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSubnetGroupsError {
    pub fn new(kind: DescribeDBSubnetGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDBSubnetGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDBSubnetGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDBSubnetGroupsErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeDBSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDBSubnetGroupsErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            DescribeDBSubnetGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEngineDefaultClusterParametersError {
    pub kind: DescribeEngineDefaultClusterParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultClusterParametersErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEngineDefaultClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEngineDefaultClusterParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultClusterParametersError {
    fn code(&self) -> Option<&str> {
        DescribeEngineDefaultClusterParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultClusterParametersError {
    pub fn new(
        kind: DescribeEngineDefaultClusterParametersErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEngineDefaultClusterParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEngineDefaultClusterParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEngineDefaultClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEngineDefaultClusterParametersErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEngineDefaultParametersError {
    pub kind: DescribeEngineDefaultParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultParametersErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEngineDefaultParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultParametersError {
    fn code(&self) -> Option<&str> {
        DescribeEngineDefaultParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultParametersError {
    pub fn new(kind: DescribeEngineDefaultParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEngineDefaultParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventCategoriesError {
    pub kind: DescribeEventCategoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventCategoriesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventCategoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventCategoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventCategoriesError {
    fn code(&self) -> Option<&str> {
        DescribeEventCategoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventCategoriesError {
    pub fn new(kind: DescribeEventCategoriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventCategoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventCategoriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEventCategoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventCategoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventsError {
    pub kind: DescribeEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        DescribeEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    pub fn new(kind: DescribeEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventSubscriptionsError {
    pub kind: DescribeEventSubscriptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventSubscriptionsErrorKind {
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            DescribeEventSubscriptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventSubscriptionsError {
    fn code(&self) -> Option<&str> {
        DescribeEventSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventSubscriptionsError {
    pub fn new(kind: DescribeEventSubscriptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventSubscriptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventSubscriptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeEventSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            DescribeEventSubscriptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportTasksError {
    pub kind: DescribeExportTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportTasksErrorKind {
    ExportTaskNotFoundFault(crate::error::ExportTaskNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportTasksError {
    fn code(&self) -> Option<&str> {
        DescribeExportTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportTasksError {
    pub fn new(kind: DescribeExportTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_export_task_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeExportTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportTasksErrorKind::ExportTaskNotFoundFault(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalClustersError {
    pub kind: DescribeGlobalClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalClustersErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeGlobalClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalClustersError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalClustersError {
    pub fn new(kind: DescribeGlobalClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeGlobalClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            DescribeGlobalClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstallationMediaError {
    pub kind: DescribeInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstallationMediaErrorKind {
    InstallationMediaNotFoundFault(crate::error::InstallationMediaNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstallationMediaError {
    fn code(&self) -> Option<&str> {
        DescribeInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstallationMediaError {
    pub fn new(kind: DescribeInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_installation_media_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstallationMediaErrorKind::InstallationMediaNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOptionGroupOptionsError {
    pub kind: DescribeOptionGroupOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOptionGroupOptionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOptionGroupOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOptionGroupOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOptionGroupOptionsError {
    fn code(&self) -> Option<&str> {
        DescribeOptionGroupOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOptionGroupOptionsError {
    pub fn new(kind: DescribeOptionGroupOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOptionGroupOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOptionGroupOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeOptionGroupOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOptionGroupOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOptionGroupsError {
    pub kind: DescribeOptionGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOptionGroupsErrorKind {
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOptionGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeOptionGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOptionGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeOptionGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOptionGroupsError {
    pub fn new(kind: DescribeOptionGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOptionGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOptionGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeOptionGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOptionGroupsErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            DescribeOptionGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrderableDBInstanceOptionsError {
    pub kind: DescribeOrderableDBInstanceOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrderableDBInstanceOptionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrderableDBInstanceOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrderableDBInstanceOptionsError {
    fn code(&self) -> Option<&str> {
        DescribeOrderableDBInstanceOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrderableDBInstanceOptionsError {
    pub fn new(
        kind: DescribeOrderableDBInstanceOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeOrderableDBInstanceOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrderableDBInstanceOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePendingMaintenanceActionsError {
    pub kind: DescribePendingMaintenanceActionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePendingMaintenanceActionsErrorKind {
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePendingMaintenanceActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribePendingMaintenanceActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePendingMaintenanceActionsError {
    fn code(&self) -> Option<&str> {
        DescribePendingMaintenanceActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePendingMaintenanceActionsError {
    pub fn new(
        kind: DescribePendingMaintenanceActionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePendingMaintenanceActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePendingMaintenanceActionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribePendingMaintenanceActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribePendingMaintenanceActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedDBInstancesError {
    pub kind: DescribeReservedDBInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedDBInstancesErrorKind {
    ReservedDbInstanceNotFoundFault(crate::error::ReservedDbInstanceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedDBInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedDBInstancesErrorKind::ReservedDbInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeReservedDBInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedDBInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeReservedDBInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedDBInstancesError {
    pub fn new(kind: DescribeReservedDBInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedDBInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedDBInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedDBInstancesErrorKind::ReservedDbInstanceNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeReservedDBInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedDBInstancesErrorKind::ReservedDbInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeReservedDBInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedDBInstancesOfferingsError {
    pub kind: DescribeReservedDBInstancesOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedDBInstancesOfferingsErrorKind {
    ReservedDbInstancesOfferingNotFoundFault(
        crate::error::ReservedDbInstancesOfferingNotFoundFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedDBInstancesOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDbInstancesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedDBInstancesOfferingsError {
    fn code(&self) -> Option<&str> {
        DescribeReservedDBInstancesOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedDBInstancesOfferingsError {
    pub fn new(
        kind: DescribeReservedDBInstancesOfferingsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instances_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDbInstancesOfferingNotFoundFault(
                _
            )
        )
    }
}
impl std::error::Error for DescribeReservedDBInstancesOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedDBInstancesOfferingsErrorKind::ReservedDbInstancesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DescribeReservedDBInstancesOfferingsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSourceRegionsError {
    pub kind: DescribeSourceRegionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSourceRegionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSourceRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSourceRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSourceRegionsError {
    fn code(&self) -> Option<&str> {
        DescribeSourceRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSourceRegionsError {
    pub fn new(kind: DescribeSourceRegionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSourceRegionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSourceRegionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeSourceRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSourceRegionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeValidDBInstanceModificationsError {
    pub kind: DescribeValidDBInstanceModificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeValidDBInstanceModificationsErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeValidDBInstanceModificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeValidDBInstanceModificationsErrorKind::DbInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeValidDBInstanceModificationsErrorKind::InvalidDbInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeValidDBInstanceModificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeValidDBInstanceModificationsError {
    fn code(&self) -> Option<&str> {
        DescribeValidDBInstanceModificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeValidDBInstanceModificationsError {
    pub fn new(
        kind: DescribeValidDBInstanceModificationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeValidDBInstanceModificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeValidDBInstanceModificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeValidDBInstanceModificationsErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeValidDBInstanceModificationsErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for DescribeValidDBInstanceModificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeValidDBInstanceModificationsErrorKind::DbInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeValidDBInstanceModificationsErrorKind::InvalidDbInstanceStateFault(_inner) => {
                Some(_inner)
            }
            DescribeValidDBInstanceModificationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DownloadDBLogFilePortionError {
    pub kind: DownloadDBLogFilePortionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DownloadDBLogFilePortionErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbLogFileNotFoundFault(crate::error::DbLogFileNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DownloadDBLogFilePortionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DownloadDBLogFilePortionErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            DownloadDBLogFilePortionErrorKind::DbLogFileNotFoundFault(_inner) => _inner.fmt(f),
            DownloadDBLogFilePortionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DownloadDBLogFilePortionError {
    fn code(&self) -> Option<&str> {
        DownloadDBLogFilePortionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DownloadDBLogFilePortionError {
    pub fn new(kind: DownloadDBLogFilePortionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DownloadDBLogFilePortionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DownloadDBLogFilePortionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDBLogFilePortionErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_log_file_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDBLogFilePortionErrorKind::DbLogFileNotFoundFault(_)
        )
    }
}
impl std::error::Error for DownloadDBLogFilePortionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DownloadDBLogFilePortionErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            DownloadDBLogFilePortionErrorKind::DbLogFileNotFoundFault(_inner) => Some(_inner),
            DownloadDBLogFilePortionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FailoverDBClusterError {
    pub kind: FailoverDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FailoverDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FailoverDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            FailoverDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FailoverDBClusterError {
    fn code(&self) -> Option<&str> {
        FailoverDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverDBClusterError {
    pub fn new(kind: FailoverDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FailoverDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FailoverDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverDBClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for FailoverDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FailoverDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            FailoverDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FailoverGlobalClusterError {
    pub kind: FailoverGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverGlobalClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FailoverGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FailoverGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            FailoverGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FailoverGlobalClusterError {
    fn code(&self) -> Option<&str> {
        FailoverGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverGlobalClusterError {
    pub fn new(kind: FailoverGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FailoverGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FailoverGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for FailoverGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FailoverGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            FailoverGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportInstallationMediaError {
    pub kind: ImportInstallationMediaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportInstallationMediaErrorKind {
    CustomAvailabilityZoneNotFoundFault(crate::error::CustomAvailabilityZoneNotFoundFault),
    InstallationMediaAlreadyExistsFault(crate::error::InstallationMediaAlreadyExistsFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportInstallationMediaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            ImportInstallationMediaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportInstallationMediaError {
    fn code(&self) -> Option<&str> {
        ImportInstallationMediaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportInstallationMediaError {
    pub fn new(kind: ImportInstallationMediaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportInstallationMediaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportInstallationMediaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_availability_zone_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_)
        )
    }
    pub fn is_installation_media_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_)
        )
    }
}
impl std::error::Error for ImportInstallationMediaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportInstallationMediaErrorKind::CustomAvailabilityZoneNotFoundFault(_inner) => {
                Some(_inner)
            }
            ImportInstallationMediaErrorKind::InstallationMediaAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            ImportInstallationMediaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCertificatesError {
    pub kind: ModifyCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCertificatesErrorKind {
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCertificatesError {
    fn code(&self) -> Option<&str> {
        ModifyCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCertificatesError {
    pub fn new(kind: ModifyCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCertificatesErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            ModifyCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCurrentDBClusterCapacityError {
    pub kind: ModifyCurrentDBClusterCapacityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCurrentDBClusterCapacityErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterCapacityFault(crate::error::InvalidDbClusterCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCurrentDBClusterCapacityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCurrentDBClusterCapacityErrorKind::DbClusterNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCurrentDBClusterCapacityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCurrentDBClusterCapacityError {
    fn code(&self) -> Option<&str> {
        ModifyCurrentDBClusterCapacityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCurrentDBClusterCapacityError {
    pub fn new(kind: ModifyCurrentDBClusterCapacityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCurrentDBClusterCapacityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCurrentDBClusterCapacityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for ModifyCurrentDBClusterCapacityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCurrentDBClusterCapacityErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            ModifyCurrentDBClusterCapacityErrorKind::InvalidDbClusterStateFault(_inner) => {
                Some(_inner)
            }
            ModifyCurrentDBClusterCapacityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterError {
    pub kind: ModifyDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterErrorKind {
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterErrorKind::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDbSecurityGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterError {
    pub fn new(kind: ModifyDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DbClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyDBClusterErrorKind::DomainNotFoundFault(_))
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDbSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, ModifyDBClusterErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterErrorKind::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDbSecurityGroupStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidSubnet(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterEndpointError {
    pub kind: ModifyDBClusterEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterEndpointErrorKind {
    DbClusterEndpointNotFoundFault(crate::error::DbClusterEndpointNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbClusterEndpointStateFault(crate::error::InvalidDbClusterEndpointStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBClusterEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterEndpointError {
    pub fn new(kind: ModifyDBClusterEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterEndpointErrorKind::DbClusterEndpointNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterEndpointErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterEndpointStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterEndpointErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            ModifyDBClusterEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterParameterGroupError {
    pub kind: ModifyDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterParameterGroupError {
    pub fn new(kind: ModifyDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBClusterSnapshotAttributeError {
    pub kind: ModifyDBClusterSnapshotAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterSnapshotAttributeErrorKind {
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    SharedSnapshotQuotaExceededFault(crate::error::SharedSnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBClusterSnapshotAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBClusterSnapshotAttributeErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDbClusterSnapshotStateFault(
                _inner,
            ) => _inner.fmt(f),
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBClusterSnapshotAttributeError {
    fn code(&self) -> Option<&str> {
        ModifyDBClusterSnapshotAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterSnapshotAttributeError {
    pub fn new(kind: ModifyDBClusterSnapshotAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_shared_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBClusterSnapshotAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBClusterSnapshotAttributeErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::InvalidDbClusterSnapshotStateFault(
                _inner,
            ) => Some(_inner),
            ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyDBClusterSnapshotAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBInstanceError {
    pub kind: ModifyDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbUpgradeDependencyFailureFault(crate::error::DbUpgradeDependencyFailureFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DbUpgradeDependencyFailureFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidDbSecurityGroupStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            ModifyDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBInstanceError {
    fn code(&self) -> Option<&str> {
        ModifyDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBInstanceError {
    pub fn new(kind: ModifyDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_upgrade_dependency_failure_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DbUpgradeDependencyFailureFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidDbSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for ModifyDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::CertificateNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DbInstanceAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DbUpgradeDependencyFailureFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidDbSecurityGroupStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            ModifyDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBParameterGroupError {
    pub kind: ModifyDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBParameterGroupError {
    pub fn new(kind: ModifyDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyError {
    pub kind: ModifyDBProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyErrorKind {
    DbProxyAlreadyExistsFault(crate::error::DbProxyAlreadyExistsFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyErrorKind::DbProxyAlreadyExistsFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyError {
    pub fn new(kind: ModifyDBProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyErrorKind::DbProxyAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyDBProxyErrorKind::DbProxyNotFoundFault(_))
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyErrorKind::DbProxyAlreadyExistsFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyEndpointError {
    pub kind: ModifyDBProxyEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyEndpointErrorKind {
    DbProxyEndpointAlreadyExistsFault(crate::error::DbProxyEndpointAlreadyExistsFault),
    DbProxyEndpointNotFoundFault(crate::error::DbProxyEndpointNotFoundFault),
    InvalidDbProxyEndpointStateFault(crate::error::InvalidDbProxyEndpointStateFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyEndpointError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyEndpointError {
    pub fn new(kind: ModifyDBProxyEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_endpoint_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_)
        )
    }
    pub fn is_db_proxy_endpoint_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_endpoint_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyEndpointErrorKind::DbProxyEndpointNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyEndpointStateFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyEndpointErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBProxyTargetGroupError {
    pub kind: ModifyDBProxyTargetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBProxyTargetGroupErrorKind {
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBProxyTargetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBProxyTargetGroupErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBProxyTargetGroupErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBProxyTargetGroupErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            ModifyDBProxyTargetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBProxyTargetGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBProxyTargetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBProxyTargetGroupError {
    pub fn new(kind: ModifyDBProxyTargetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBProxyTargetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBProxyTargetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBProxyTargetGroupErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for ModifyDBProxyTargetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBProxyTargetGroupErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            ModifyDBProxyTargetGroupErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyDBProxyTargetGroupErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            ModifyDBProxyTargetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSnapshotError {
    pub kind: ModifyDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSnapshotErrorKind {
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSnapshotError {
    fn code(&self) -> Option<&str> {
        ModifyDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSnapshotError {
    pub fn new(kind: ModifyDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            ModifyDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSnapshotAttributeError {
    pub kind: ModifyDBSnapshotAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSnapshotAttributeErrorKind {
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    SharedSnapshotQuotaExceededFault(crate::error::SharedSnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSnapshotAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSnapshotAttributeErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSnapshotAttributeErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSnapshotAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSnapshotAttributeError {
    fn code(&self) -> Option<&str> {
        ModifyDBSnapshotAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSnapshotAttributeError {
    pub fn new(kind: ModifyDBSnapshotAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSnapshotAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSnapshotAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
    pub fn is_shared_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyDBSnapshotAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSnapshotAttributeErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            ModifyDBSnapshotAttributeErrorKind::InvalidDbSnapshotStateFault(_inner) => Some(_inner),
            ModifyDBSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyDBSnapshotAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDBSubnetGroupError {
    pub kind: ModifyDBSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSubnetGroupErrorKind {
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DbSubnetQuotaExceededFault(crate::error::DbSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    SubnetAlreadyInUse(crate::error::SubnetAlreadyInUse),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_inner) => _inner.fmt(f),
            ModifyDBSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        ModifyDBSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSubnetGroupError {
    pub fn new(kind: ModifyDBSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDBSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDBSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, ModifyDBSubnetGroupErrorKind::InvalidSubnet(_))
    }
    pub fn is_subnet_already_in_use(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_)
        )
    }
}
impl std::error::Error for ModifyDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            ModifyDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse(_inner) => Some(_inner),
            ModifyDBSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyEventSubscriptionError {
    pub kind: ModifyEventSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyEventSubscriptionErrorKind {
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            ModifyEventSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        ModifyEventSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyEventSubscriptionError {
    pub fn new(kind: ModifyEventSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyEventSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyEventSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_)
        )
    }
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault(_)
        )
    }
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault(_)
        )
    }
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_)
        )
    }
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => Some(_inner),
            ModifyEventSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyGlobalClusterError {
    pub kind: ModifyGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyGlobalClusterErrorKind {
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            ModifyGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyGlobalClusterError {
    fn code(&self) -> Option<&str> {
        ModifyGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyGlobalClusterError {
    pub fn new(kind: ModifyGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for ModifyGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            ModifyGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyOptionGroupError {
    pub kind: ModifyOptionGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyOptionGroupErrorKind {
    InvalidOptionGroupStateFault(crate::error::InvalidOptionGroupStateFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyOptionGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => _inner.fmt(f),
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyOptionGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyOptionGroupError {
    fn code(&self) -> Option<&str> {
        ModifyOptionGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyOptionGroupError {
    pub fn new(kind: ModifyOptionGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyOptionGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyOptionGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_option_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyOptionGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyOptionGroupErrorKind::InvalidOptionGroupStateFault(_inner) => Some(_inner),
            ModifyOptionGroupErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            ModifyOptionGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PromoteReadReplicaError {
    pub kind: PromoteReadReplicaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PromoteReadReplicaErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PromoteReadReplicaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PromoteReadReplicaErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PromoteReadReplicaError {
    fn code(&self) -> Option<&str> {
        PromoteReadReplicaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PromoteReadReplicaError {
    pub fn new(kind: PromoteReadReplicaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PromoteReadReplicaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PromoteReadReplicaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for PromoteReadReplicaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PromoteReadReplicaErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            PromoteReadReplicaErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            PromoteReadReplicaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PromoteReadReplicaDBClusterError {
    pub kind: PromoteReadReplicaDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PromoteReadReplicaDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PromoteReadReplicaDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PromoteReadReplicaDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            PromoteReadReplicaDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            PromoteReadReplicaDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PromoteReadReplicaDBClusterError {
    fn code(&self) -> Option<&str> {
        PromoteReadReplicaDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PromoteReadReplicaDBClusterError {
    pub fn new(kind: PromoteReadReplicaDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PromoteReadReplicaDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PromoteReadReplicaDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            PromoteReadReplicaDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for PromoteReadReplicaDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PromoteReadReplicaDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            PromoteReadReplicaDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => {
                Some(_inner)
            }
            PromoteReadReplicaDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseReservedDBInstancesOfferingError {
    pub kind: PurchaseReservedDBInstancesOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedDBInstancesOfferingErrorKind {
    ReservedDbInstanceAlreadyExistsFault(crate::error::ReservedDbInstanceAlreadyExistsFault),
    ReservedDbInstanceQuotaExceededFault(crate::error::ReservedDbInstanceQuotaExceededFault),
    ReservedDbInstancesOfferingNotFoundFault(
        crate::error::ReservedDbInstancesOfferingNotFoundFault,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseReservedDBInstancesOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstancesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseReservedDBInstancesOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseReservedDBInstancesOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedDBInstancesOfferingError {
    pub fn new(
        kind: PurchaseReservedDBInstancesOfferingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_reserved_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_reserved_db_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceQuotaExceededFault(_)
        )
    }
    pub fn is_reserved_db_instances_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstancesOfferingNotFoundFault(
                _
            )
        )
    }
}
impl std::error::Error for PurchaseReservedDBInstancesOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstanceQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::ReservedDbInstancesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedDBInstancesOfferingErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootDBInstanceError {
    pub kind: RebootDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootDBInstanceErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RebootDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            RebootDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootDBInstanceError {
    fn code(&self) -> Option<&str> {
        RebootDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootDBInstanceError {
    pub fn new(kind: RebootDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for RebootDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            RebootDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            RebootDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterDBProxyTargetsError {
    pub kind: RegisterDBProxyTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDBProxyTargetsErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetAlreadyRegisteredFault(crate::error::DbProxyTargetAlreadyRegisteredFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    InsufficientAvailableIPsInSubnetFault(crate::error::InsufficientAvailableIPsInSubnetFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidDbProxyStateFault(crate::error::InvalidDbProxyStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterDBProxyTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterDBProxyTargetsErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::DbProxyTargetAlreadyRegisteredFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_inner) => {
                _inner.fmt(f)
            }
            RegisterDBProxyTargetsErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => _inner.fmt(f),
            RegisterDBProxyTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterDBProxyTargetsError {
    fn code(&self) -> Option<&str> {
        RegisterDBProxyTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDBProxyTargetsError {
    pub fn new(kind: RegisterDBProxyTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterDBProxyTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterDBProxyTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_already_registered_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DbProxyTargetAlreadyRegisteredFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_available_i_ps_in_subnet_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_db_proxy_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_)
        )
    }
}
impl std::error::Error for RegisterDBProxyTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterDBProxyTargetsErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::DbProxyTargetAlreadyRegisteredFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::InsufficientAvailableIPsInSubnetFault(_inner) => {
                Some(_inner)
            }
            RegisterDBProxyTargetsErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::InvalidDbProxyStateFault(_inner) => Some(_inner),
            RegisterDBProxyTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveFromGlobalClusterError {
    pub kind: RemoveFromGlobalClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveFromGlobalClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveFromGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveFromGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveFromGlobalClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveFromGlobalClusterError {
    fn code(&self) -> Option<&str> {
        RemoveFromGlobalClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveFromGlobalClusterError {
    pub fn new(kind: RemoveFromGlobalClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveFromGlobalClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveFromGlobalClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_)
        )
    }
}
impl std::error::Error for RemoveFromGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveFromGlobalClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault(_inner) => {
                Some(_inner)
            }
            RemoveFromGlobalClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromDBClusterError {
    pub kind: RemoveRoleFromDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterRoleNotFoundFault(crate::error::DbClusterRoleNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::DbClusterRoleNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromDBClusterError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromDBClusterError {
    pub fn new(kind: RemoveRoleFromDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::DbClusterRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::DbClusterRoleNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            RemoveRoleFromDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromDBInstanceError {
    pub kind: RemoveRoleFromDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromDBInstanceErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbInstanceRoleNotFoundFault(crate::error::DbInstanceRoleNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::DbInstanceRoleNotFoundFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            RemoveRoleFromDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromDBInstanceError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromDBInstanceError {
    pub fn new(kind: RemoveRoleFromDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_instance_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::DbInstanceRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::DbInstanceRoleNotFoundFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            RemoveRoleFromDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveSourceIdentifierFromSubscriptionError {
    pub kind: RemoveSourceIdentifierFromSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveSourceIdentifierFromSubscriptionErrorKind {
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveSourceIdentifierFromSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveSourceIdentifierFromSubscriptionError {
    fn code(&self) -> Option<&str> {
        RemoveSourceIdentifierFromSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveSourceIdentifierFromSubscriptionError {
    pub fn new(
        kind: RemoveSourceIdentifierFromSubscriptionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_)
        )
    }
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_)
        )
    }
}
impl std::error::Error for RemoveSourceIdentifierFromSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveSourceIdentifierFromSubscriptionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsFromResourceError {
    pub kind: RemoveTagsFromResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbProxyNotFoundFault(crate::error::DbProxyNotFoundFault),
    DbProxyTargetGroupNotFoundFault(crate::error::DbProxyTargetGroupNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DbProxyNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    pub fn new(kind: RemoveTagsFromResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DbProxyNotFoundFault(_)
        )
    }
    pub fn is_db_proxy_target_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DbProxyTargetGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DbProxyNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::DbProxyTargetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveTagsFromResourceErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetDBClusterParameterGroupError {
    pub kind: ResetDBClusterParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBClusterParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBClusterParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        ResetDBClusterParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBClusterParameterGroupError {
    pub fn new(kind: ResetDBClusterParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetDBClusterParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetDBClusterParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ResetDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ResetDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetDBClusterParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetDBParameterGroupError {
    pub kind: ResetDBParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBParameterGroupErrorKind {
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ResetDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetDBParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        ResetDBParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBParameterGroupError {
    pub fn new(kind: ResetDBParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetDBParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetDBParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_)
        )
    }
}
impl std::error::Error for ResetDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetDBParameterGroupErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            ResetDBParameterGroupErrorKind::InvalidDbParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetDBParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterFromS3Error {
    pub kind: RestoreDBClusterFromS3ErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterFromS3ErrorKind {
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterFromS3Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterFromS3ErrorKind::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidDbSubnetGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromS3ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromS3Error {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterFromS3Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterFromS3Error {
    pub fn new(kind: RestoreDBClusterFromS3ErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterFromS3ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterFromS3ErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DbClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DbClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DbClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidDbSubnetGroupStateFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterFromS3Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterFromS3ErrorKind::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromS3ErrorKind::DbClusterQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InsufficientStorageClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromS3ErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBClusterFromS3ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterFromSnapshotError {
    pub kind: RestoreDBClusterFromSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterFromSnapshotErrorKind {
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDbClusterCapacityFault(crate::error::InsufficientDbClusterCapacityFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterFromSnapshotErrorKind::DbClusterAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDbClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterFromSnapshotErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterFromSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromSnapshotError {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterFromSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterFromSnapshotError {
    pub fn new(kind: RestoreDBClusterFromSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterFromSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterFromSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDbClusterCapacityFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterFromSnapshotErrorKind::DbClusterAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InsufficientDbClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterFromSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBClusterToPointInTimeError {
    pub kind: RestoreDBClusterToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterToPointInTimeErrorKind {
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InsufficientDbClusterCapacityFault(crate::error::InsufficientDbClusterCapacityFault),
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBClusterToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBClusterToPointInTimeErrorKind::DbClusterAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::DbClusterParameterGroupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::DbClusterQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDbClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBClusterToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBClusterToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBClusterToPointInTimeError {
    fn code(&self) -> Option<&str> {
        RestoreDBClusterToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterToPointInTimeError {
    pub fn new(kind: RestoreDBClusterToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBClusterToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBClusterToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbClusterParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbClusterQuotaExceededFault(_)
        )
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDbClusterCapacityFault(_)
        )
    }
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for RestoreDBClusterToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBClusterToPointInTimeErrorKind::DbClusterAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::DbClusterParameterGroupNotFoundFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::DbClusterQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbClusterSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InsufficientDbClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBClusterToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBClusterToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceFromDBSnapshotError {
    pub kind: RestoreDBInstanceFromDBSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceFromDBSnapshotErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceFromDBSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDbInstanceCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAzFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceFromDBSnapshotError {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceFromDBSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceFromDBSnapshotError {
    pub fn new(kind: RestoreDBInstanceFromDBSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceFromDBSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceFromDBSnapshotErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::BackupPolicyNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSnapshotNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InsufficientDbInstanceCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidDbSnapshotStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::ProvisionedIopsNotAvailableInAzFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromDBSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceFromS3Error {
    pub kind: RestoreDBInstanceFromS3ErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceFromS3ErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceFromS3Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DbInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InsufficientDbInstanceCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceFromS3ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceFromS3Error {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceFromS3Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceFromS3Error {
    pub fn new(kind: RestoreDBInstanceFromS3ErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceFromS3ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceFromS3ErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceFromS3Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceFromS3ErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::BackupPolicyNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DbInstanceAlreadyExistsFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InstanceQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InsufficientDbInstanceCapacityFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::OptionGroupNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceFromS3ErrorKind::StorageQuotaExceededFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            RestoreDBInstanceFromS3ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDBInstanceToPointInTimeError {
    pub kind: RestoreDBInstanceToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBInstanceToPointInTimeErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    BackupPolicyNotFoundFault(crate::error::BackupPolicyNotFoundFault),
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    DbInstanceAutomatedBackupNotFoundFault(crate::error::DbInstanceAutomatedBackupNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    PointInTimeRestoreNotEnabledFault(crate::error::PointInTimeRestoreNotEnabledFault),
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDBInstanceToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDbInstanceCapacityFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDbInstanceStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAzFault(
                _inner,
            ) => _inner.fmt(f),
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            RestoreDBInstanceToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDBInstanceToPointInTimeError {
    fn code(&self) -> Option<&str> {
        RestoreDBInstanceToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBInstanceToPointInTimeError {
    pub fn new(kind: RestoreDBInstanceToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDBInstanceToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDBInstanceToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_backup_policy_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_)
        )
    }
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAlreadyExistsFault(_)
        )
    }
    pub fn is_db_instance_automated_backup_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAutomatedBackupNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_)
        )
    }
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_)
        )
    }
    pub fn is_point_in_time_restore_not_enabled_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_)
        )
    }
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAzFault(_)
        )
    }
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for RestoreDBInstanceToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDBInstanceToPointInTimeErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::BackupPolicyNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceAutomatedBackupNotFoundFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::DbInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DbSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::DomainNotFoundFault(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InstanceQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InsufficientDbInstanceCapacityFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidDbInstanceStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::InvalidRestoreFault(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidSubnet(_inner) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::InvalidVpcNetworkStateFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::KmsKeyNotAccessibleFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::OptionGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::PointInTimeRestoreNotEnabledFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::ProvisionedIopsNotAvailableInAzFault(
                _inner,
            ) => Some(_inner),
            RestoreDBInstanceToPointInTimeErrorKind::StorageQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::StorageTypeNotSupportedFault(_inner) => {
                Some(_inner)
            }
            RestoreDBInstanceToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeDBSecurityGroupIngressError {
    pub kind: RevokeDBSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeDBSecurityGroupIngressErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeDBSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeDBSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        RevokeDBSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeDBSecurityGroupIngressError {
    pub fn new(kind: RevokeDBSecurityGroupIngressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeDBSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_)
        )
    }
}
impl std::error::Error for RevokeDBSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeDBSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::DbSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::InvalidDbSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            RevokeDBSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartActivityStreamError {
    pub kind: StartActivityStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartActivityStreamErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartActivityStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartActivityStreamErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            StartActivityStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartActivityStreamError {
    fn code(&self) -> Option<&str> {
        StartActivityStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartActivityStreamError {
    pub fn new(kind: StartActivityStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartActivityStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartActivityStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartActivityStreamErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for StartActivityStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartActivityStreamErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            StartActivityStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBClusterError {
    pub kind: StartDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StartDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBClusterError {
    fn code(&self) -> Option<&str> {
        StartDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBClusterError {
    pub fn new(kind: StartDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StartDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StartDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBInstanceError {
    pub kind: StartDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBInstanceErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBInstanceError {
    fn code(&self) -> Option<&str> {
        StartDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBInstanceError {
    pub fn new(kind: StartDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_)
        )
    }
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(&self.kind, StartDBInstanceErrorKind::InvalidSubnet(_))
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for StartDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBInstanceErrorKind::AuthorizationNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            StartDBInstanceErrorKind::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InsufficientDbInstanceCapacityFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidSubnet(_inner) => Some(_inner),
            StartDBInstanceErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            StartDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDBInstanceAutomatedBackupsReplicationError {
    pub kind: StartDBInstanceAutomatedBackupsReplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBInstanceAutomatedBackupsReplicationErrorKind {
    DbInstanceAutomatedBackupQuotaExceededFault(
        crate::error::DbInstanceAutomatedBackupQuotaExceededFault,
    ),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDBInstanceAutomatedBackupsReplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KmsKeyNotAccessibleFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_inner) =>
            _inner.fmt(f)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDBInstanceAutomatedBackupsReplicationError {
    fn code(&self) -> Option<&str> {
        StartDBInstanceAutomatedBackupsReplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBInstanceAutomatedBackupsReplicationError {
    pub fn new(
        kind: StartDBInstanceAutomatedBackupsReplicationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_automated_backup_quota_exceeded_fault(&self) -> bool {
        matches!(&self.kind, StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_))
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_)
        )
    }
}
impl std::error::Error for StartDBInstanceAutomatedBackupsReplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceAutomatedBackupQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::KmsKeyNotAccessibleFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::StorageTypeNotSupportedFault(_inner) =>
            Some(_inner)
            ,
            StartDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartExportTaskError {
    pub kind: StartExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartExportTaskErrorKind {
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    ExportTaskAlreadyExistsFault(crate::error::ExportTaskAlreadyExistsFault),
    IamRoleMissingPermissionsFault(crate::error::IamRoleMissingPermissionsFault),
    IamRoleNotFoundFault(crate::error::IamRoleNotFoundFault),
    InvalidExportOnlyFault(crate::error::InvalidExportOnlyFault),
    InvalidExportSourceStateFault(crate::error::InvalidExportSourceStateFault),
    InvalidS3BucketFault(crate::error::InvalidS3BucketFault),
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartExportTaskErrorKind::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::IamRoleNotFoundFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidExportOnlyFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::InvalidS3BucketFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            StartExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartExportTaskError {
    fn code(&self) -> Option<&str> {
        StartExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartExportTaskError {
    pub fn new(kind: StartExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::DbClusterSnapshotNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::DbSnapshotNotFoundFault(_)
        )
    }
    pub fn is_export_task_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_)
        )
    }
    pub fn is_iam_role_missing_permissions_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_)
        )
    }
    pub fn is_iam_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::IamRoleNotFoundFault(_)
        )
    }
    pub fn is_invalid_export_only_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidExportOnlyFault(_)
        )
    }
    pub fn is_invalid_export_source_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_)
        )
    }
    pub fn is_invalid_s3_bucket_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::InvalidS3BucketFault(_)
        )
    }
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartExportTaskErrorKind::KmsKeyNotAccessibleFault(_)
        )
    }
}
impl std::error::Error for StartExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartExportTaskErrorKind::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::ExportTaskAlreadyExistsFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::IamRoleMissingPermissionsFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::IamRoleNotFoundFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidExportOnlyFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidExportSourceStateFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::InvalidS3BucketFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            StartExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopActivityStreamError {
    pub kind: StopActivityStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopActivityStreamErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopActivityStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopActivityStreamErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            StopActivityStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopActivityStreamError {
    fn code(&self) -> Option<&str> {
        StopActivityStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopActivityStreamError {
    pub fn new(kind: StopActivityStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopActivityStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopActivityStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopActivityStreamErrorKind::ResourceNotFoundFault(_)
        )
    }
}
impl std::error::Error for StopActivityStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopActivityStreamErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::ResourceNotFoundFault(_inner) => Some(_inner),
            StopActivityStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBClusterError {
    pub kind: StopDBClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBClusterErrorKind {
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBClusterErrorKind::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StopDBClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBClusterError {
    fn code(&self) -> Option<&str> {
        StopDBClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBClusterError {
    pub fn new(kind: StopDBClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::DbClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBClusterErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StopDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBClusterErrorKind::DbClusterNotFoundFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StopDBClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBInstanceError {
    pub kind: StopDBInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBInstanceErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    DbSnapshotAlreadyExistsFault(crate::error::DbSnapshotAlreadyExistsFault),
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            StopDBInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBInstanceError {
    fn code(&self) -> Option<&str> {
        StopDBInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBInstanceError {
    pub fn new(kind: StopDBInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::InvalidDbClusterStateFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for StopDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBInstanceErrorKind::DbInstanceNotFoundFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::DbSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::InvalidDbClusterStateFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            StopDBInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDBInstanceAutomatedBackupsReplicationError {
    pub kind: StopDBInstanceAutomatedBackupsReplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBInstanceAutomatedBackupsReplicationErrorKind {
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDBInstanceAutomatedBackupsReplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(
                _inner,
            ) => _inner.fmt(f),
            StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDBInstanceAutomatedBackupsReplicationError {
    fn code(&self) -> Option<&str> {
        StopDBInstanceAutomatedBackupsReplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBInstanceAutomatedBackupsReplicationError {
    pub fn new(
        kind: StopDBInstanceAutomatedBackupsReplicationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_)
        )
    }
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(_)
        )
    }
}
impl std::error::Error for StopDBInstanceAutomatedBackupsReplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDBInstanceAutomatedBackupsReplicationErrorKind::DbInstanceNotFoundFault(_inner) => {
                Some(_inner)
            }
            StopDBInstanceAutomatedBackupsReplicationErrorKind::InvalidDbInstanceStateFault(
                _inner,
            ) => Some(_inner),
            StopDBInstanceAutomatedBackupsReplicationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// <p>The DB instance isn't in a valid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbInstanceStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbInstanceStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbInstanceStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbInstanceStateFault [InvalidDBInstanceStateFault]"
        )?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbInstanceStateFault {}
/// See [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault)
pub mod invalid_db_instance_state_fault {
    /// A builder for [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault)
        pub fn build(self) -> crate::error::InvalidDbInstanceStateFault {
            crate::error::InvalidDbInstanceStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbInstanceStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault)
    pub fn builder() -> crate::error::invalid_db_instance_state_fault::Builder {
        crate::error::invalid_db_instance_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBInstanceIdentifier</code> doesn't refer to an existing DB instance.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbInstanceNotFoundFault [DBInstanceNotFoundFault]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceNotFoundFault {}
/// See [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault)
pub mod db_instance_not_found_fault {
    /// A builder for [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault)
        pub fn build(self) -> crate::error::DbInstanceNotFoundFault {
            crate::error::DbInstanceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault)
    pub fn builder() -> crate::error::db_instance_not_found_fault::Builder {
        crate::error::db_instance_not_found_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
/// snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotQuotaExceededFault")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotQuotaExceededFault {}
/// See [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
pub mod snapshot_quota_exceeded_fault {
    /// A builder for [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
        pub fn build(self) -> crate::error::SnapshotQuotaExceededFault {
            crate::error::SnapshotQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    pub fn builder() -> crate::error::snapshot_quota_exceeded_fault::Builder {
        crate::error::snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed while the cluster is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbClusterStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbClusterStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbClusterStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbClusterStateFault [InvalidDBClusterStateFault]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterStateFault {}
/// See [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault)
pub mod invalid_db_cluster_state_fault {
    /// A builder for [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault)
        pub fn build(self) -> crate::error::InvalidDbClusterStateFault {
            crate::error::InvalidDbClusterStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_state_fault::Builder {
        crate::error::invalid_db_cluster_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSnapshotIdentifier</code> is already used by an existing snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSnapshotAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSnapshotAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSnapshotAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSnapshotAlreadyExistsFault [DBSnapshotAlreadyExistsFault]"
        )?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSnapshotAlreadyExistsFault {}
/// See [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault)
pub mod db_snapshot_already_exists_fault {
    /// A builder for [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbSnapshotAlreadyExistsFault {
            crate::error::DbSnapshotAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault)
    pub fn builder() -> crate::error::db_snapshot_already_exists_fault::Builder {
        crate::error::db_snapshot_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterIdentifier</code> doesn't refer to an existing DB cluster.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbClusterNotFoundFault [DBClusterNotFoundFault]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterNotFoundFault {}
/// See [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault)
pub mod db_cluster_not_found_fault {
    /// A builder for [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterNotFoundFault {
            crate::error::DbClusterNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_not_found_fault::Builder {
        crate::error::db_cluster_not_found_fault::Builder::default()
    }
}

/// <p>The specified resource ID was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundFault")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundFault {}
/// See [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
pub mod resource_not_found_fault {
    /// A builder for [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
        pub fn build(self) -> crate::error::ResourceNotFoundFault {
            crate::error::ResourceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault)
    pub fn builder() -> crate::error::resource_not_found_fault::Builder {
        crate::error::resource_not_found_fault::Builder::default()
    }
}

/// <p>An error occurred accessing an Amazon Web Services KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsKeyNotAccessibleFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsKeyNotAccessibleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsKeyNotAccessibleFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsKeyNotAccessibleFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsKeyNotAccessibleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsKeyNotAccessibleFault [KMSKeyNotAccessibleFault]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsKeyNotAccessibleFault {}
/// See [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault)
pub mod kms_key_not_accessible_fault {
    /// A builder for [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault)
        pub fn build(self) -> crate::error::KmsKeyNotAccessibleFault {
            crate::error::KmsKeyNotAccessibleFault {
                message: self.message,
            }
        }
    }
}
impl KmsKeyNotAccessibleFault {
    /// Creates a new builder-style object to manufacture [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault)
    pub fn builder() -> crate::error::kms_key_not_accessible_fault::Builder {
        crate::error::kms_key_not_accessible_fault::Builder::default()
    }
}

/// <p>The specified Amazon S3 bucket name can't be found or Amazon RDS isn't
/// authorized to access the specified Amazon S3 bucket. Verify the <b>SourceS3BucketName</b> and <b>S3IngestionRoleArn</b> values and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3BucketFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3BucketFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3BucketFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3BucketFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3BucketFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3BucketFault")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3BucketFault {}
/// See [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
pub mod invalid_s3_bucket_fault {
    /// A builder for [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
        pub fn build(self) -> crate::error::InvalidS3BucketFault {
            crate::error::InvalidS3BucketFault {
                message: self.message,
            }
        }
    }
}
impl InvalidS3BucketFault {
    /// Creates a new builder-style object to manufacture [`InvalidS3BucketFault`](crate::error::InvalidS3BucketFault)
    pub fn builder() -> crate::error::invalid_s3_bucket_fault::Builder {
        crate::error::invalid_s3_bucket_fault::Builder::default()
    }
}

/// <p>The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportSourceStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportSourceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportSourceStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportSourceStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportSourceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportSourceStateFault")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportSourceStateFault {}
/// See [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
pub mod invalid_export_source_state_fault {
    /// A builder for [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
        pub fn build(self) -> crate::error::InvalidExportSourceStateFault {
            crate::error::InvalidExportSourceStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportSourceStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportSourceStateFault`](crate::error::InvalidExportSourceStateFault)
    pub fn builder() -> crate::error::invalid_export_source_state_fault::Builder {
        crate::error::invalid_export_source_state_fault::Builder::default()
    }
}

/// <p>The export is invalid for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportOnlyFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportOnlyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportOnlyFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportOnlyFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportOnlyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportOnlyFault")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportOnlyFault {}
/// See [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
pub mod invalid_export_only_fault {
    /// A builder for [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
        pub fn build(self) -> crate::error::InvalidExportOnlyFault {
            crate::error::InvalidExportOnlyFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportOnlyFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportOnlyFault`](crate::error::InvalidExportOnlyFault)
    pub fn builder() -> crate::error::invalid_export_only_fault::Builder {
        crate::error::invalid_export_only_fault::Builder::default()
    }
}

/// <p>The IAM role is missing for exporting to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IamRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamRoleNotFoundFault")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IamRoleNotFoundFault {}
/// See [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
pub mod iam_role_not_found_fault {
    /// A builder for [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
        pub fn build(self) -> crate::error::IamRoleNotFoundFault {
            crate::error::IamRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl IamRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`IamRoleNotFoundFault`](crate::error::IamRoleNotFoundFault)
    pub fn builder() -> crate::error::iam_role_not_found_fault::Builder {
        crate::error::iam_role_not_found_fault::Builder::default()
    }
}

/// <p>The IAM role requires additional permissions to export to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamRoleMissingPermissionsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamRoleMissingPermissionsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamRoleMissingPermissionsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IamRoleMissingPermissionsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamRoleMissingPermissionsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamRoleMissingPermissionsFault")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for IamRoleMissingPermissionsFault {}
/// See [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
pub mod iam_role_missing_permissions_fault {
    /// A builder for [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
        pub fn build(self) -> crate::error::IamRoleMissingPermissionsFault {
            crate::error::IamRoleMissingPermissionsFault {
                message: self.message,
            }
        }
    }
}
impl IamRoleMissingPermissionsFault {
    /// Creates a new builder-style object to manufacture [`IamRoleMissingPermissionsFault`](crate::error::IamRoleMissingPermissionsFault)
    pub fn builder() -> crate::error::iam_role_missing_permissions_fault::Builder {
        crate::error::iam_role_missing_permissions_fault::Builder::default()
    }
}

/// <p>You can't start an export task that's already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportTaskAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportTaskAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportTaskAlreadyExistsFault")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportTaskAlreadyExistsFault {}
/// See [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
pub mod export_task_already_exists_fault {
    /// A builder for [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
        pub fn build(self) -> crate::error::ExportTaskAlreadyExistsFault {
            crate::error::ExportTaskAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ExportTaskAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ExportTaskAlreadyExistsFault`](crate::error::ExportTaskAlreadyExistsFault)
    pub fn builder() -> crate::error::export_task_already_exists_fault::Builder {
        crate::error::export_task_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSnapshotIdentifier</code> doesn't refer to an existing DB snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSnapshotNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSnapshotNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSnapshotNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSnapshotNotFoundFault [DBSnapshotNotFoundFault]")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSnapshotNotFoundFault {}
/// See [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault)
pub mod db_snapshot_not_found_fault {
    /// A builder for [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault)
        pub fn build(self) -> crate::error::DbSnapshotNotFoundFault {
            crate::error::DbSnapshotNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault)
    pub fn builder() -> crate::error::db_snapshot_not_found_fault::Builder {
        crate::error::db_snapshot_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterSnapshotIdentifier</code> doesn't refer to an existing DB cluster snapshot.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterSnapshotNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterSnapshotNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterSnapshotNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterSnapshotNotFoundFault [DBClusterSnapshotNotFoundFault]"
        )?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterSnapshotNotFoundFault {}
/// See [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault)
pub mod db_cluster_snapshot_not_found_fault {
    /// A builder for [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterSnapshotNotFoundFault {
            crate::error::DbClusterSnapshotNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_snapshot_not_found_fault::Builder {
        crate::error::db_cluster_snapshot_not_found_fault::Builder::default()
    }
}

/// <p>Storage of the <code>StorageType</code> specified can't be associated
/// with the DB instance. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageTypeNotSupportedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StorageTypeNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageTypeNotSupportedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StorageTypeNotSupportedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageTypeNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageTypeNotSupportedFault")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for StorageTypeNotSupportedFault {}
/// See [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
pub mod storage_type_not_supported_fault {
    /// A builder for [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
        pub fn build(self) -> crate::error::StorageTypeNotSupportedFault {
            crate::error::StorageTypeNotSupportedFault {
                message: self.message,
            }
        }
    }
}
impl StorageTypeNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault)
    pub fn builder() -> crate::error::storage_type_not_supported_fault::Builder {
        crate::error::storage_type_not_supported_fault::Builder::default()
    }
}

/// <p>The quota for retained automated backups was exceeded. This prevents you
/// from retaining any additional automated backups. The retained automated backups
/// quota is the same as your DB Instance quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceAutomatedBackupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceAutomatedBackupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceAutomatedBackupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceAutomatedBackupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceAutomatedBackupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbInstanceAutomatedBackupQuotaExceededFault [DBInstanceAutomatedBackupQuotaExceededFault]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceAutomatedBackupQuotaExceededFault {}
/// See [`DbInstanceAutomatedBackupQuotaExceededFault`](crate::error::DbInstanceAutomatedBackupQuotaExceededFault)
pub mod db_instance_automated_backup_quota_exceeded_fault {
    /// A builder for [`DbInstanceAutomatedBackupQuotaExceededFault`](crate::error::DbInstanceAutomatedBackupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceAutomatedBackupQuotaExceededFault`](crate::error::DbInstanceAutomatedBackupQuotaExceededFault)
        pub fn build(self) -> crate::error::DbInstanceAutomatedBackupQuotaExceededFault {
            crate::error::DbInstanceAutomatedBackupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceAutomatedBackupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceAutomatedBackupQuotaExceededFault`](crate::error::DbInstanceAutomatedBackupQuotaExceededFault)
    pub fn builder() -> crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder {
        crate::error::db_instance_automated_backup_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The DB subnet group doesn't cover all Availability Zones after it's
/// created because of users' change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidVpcNetworkStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidVpcNetworkStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidVpcNetworkStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidVpcNetworkStateFault [InvalidVPCNetworkStateFault]"
        )?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVpcNetworkStateFault {}
/// See [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
pub mod invalid_vpc_network_state_fault {
    /// A builder for [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
        pub fn build(self) -> crate::error::InvalidVpcNetworkStateFault {
            crate::error::InvalidVpcNetworkStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidVpcNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSubnet {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSubnet");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSubnet {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
/// See [`InvalidSubnet`](crate::error::InvalidSubnet)
pub mod invalid_subnet {
    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet)
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
            }
        }
    }
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet)
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}

/// <p>The specified DB instance class isn't available in the specified Availability
/// Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDbInstanceCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDbInstanceCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientDbInstanceCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDbInstanceCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDbInstanceCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InsufficientDbInstanceCapacityFault [InsufficientDBInstanceCapacityFault]"
        )?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDbInstanceCapacityFault {}
/// See [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault)
pub mod insufficient_db_instance_capacity_fault {
    /// A builder for [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault)
        pub fn build(self) -> crate::error::InsufficientDbInstanceCapacityFault {
            crate::error::InsufficientDbInstanceCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientDbInstanceCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault)
    pub fn builder() -> crate::error::insufficient_db_instance_capacity_fault::Builder {
        crate::error::insufficient_db_instance_capacity_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSubnetGroupName</code> doesn't refer to an existing DB subnet group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSubnetGroupNotFoundFault [DBSubnetGroupNotFoundFault]")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupNotFoundFault {}
/// See [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault)
pub mod db_subnet_group_not_found_fault {
    /// A builder for [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault)
        pub fn build(self) -> crate::error::DbSubnetGroupNotFoundFault {
            crate::error::DbSubnetGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbSubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault)
    pub fn builder() -> crate::error::db_subnet_group_not_found_fault::Builder {
        crate::error::db_subnet_group_not_found_fault::Builder::default()
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetGroupDoesNotCoverEnoughAZs {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetGroupDoesNotCoverEnoughAZs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetGroupDoesNotCoverEnoughAZs");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetGroupDoesNotCoverEnoughAZs {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupDoesNotCoverEnoughAZs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupDoesNotCoverEnoughAZs [DBSubnetGroupDoesNotCoverEnoughAZs]"
        )?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupDoesNotCoverEnoughAZs {}
/// See [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs)
pub mod db_subnet_group_does_not_cover_enough_a_zs {
    /// A builder for [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs)
        pub fn build(self) -> crate::error::DbSubnetGroupDoesNotCoverEnoughAZs {
            crate::error::DbSubnetGroupDoesNotCoverEnoughAZs {
                message: self.message,
            }
        }
    }
}
impl DbSubnetGroupDoesNotCoverEnoughAZs {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs)
    pub fn builder() -> crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder {
        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default()
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group might not be authorized
/// for the specified DB security group.</p>
/// <p>Or, RDS might not be authorized to perform necessary actions using IAM on your
/// behalf.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationNotFoundFault")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationNotFoundFault {}
/// See [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
pub mod authorization_not_found_fault {
    /// A builder for [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
        pub fn build(self) -> crate::error::AuthorizationNotFoundFault {
            crate::error::AuthorizationNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    pub fn builder() -> crate::error::authorization_not_found_fault::Builder {
        crate::error::authorization_not_found_fault::Builder::default()
    }
}

/// <p>The state of the DB security group doesn't allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbSecurityGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbSecurityGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbSecurityGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSecurityGroupStateFault [InvalidDBSecurityGroupStateFault]"
        )?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSecurityGroupStateFault {}
/// See [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault)
pub mod invalid_db_security_group_state_fault {
    /// A builder for [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDbSecurityGroupStateFault {
            crate::error::InvalidDbSecurityGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbSecurityGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_security_group_state_fault::Builder {
        crate::error::invalid_db_security_group_state_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSecurityGroupName</code> doesn't refer to an existing DB security group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSecurityGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSecurityGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSecurityGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSecurityGroupNotFoundFault [DBSecurityGroupNotFoundFault]"
        )?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSecurityGroupNotFoundFault {}
/// See [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault)
pub mod db_security_group_not_found_fault {
    /// A builder for [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault)
        pub fn build(self) -> crate::error::DbSecurityGroupNotFoundFault {
            crate::error::DbSecurityGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbSecurityGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault)
    pub fn builder() -> crate::error::db_security_group_not_found_fault::Builder {
        crate::error::db_security_group_not_found_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed amount of storage
/// available across all DB instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StorageQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StorageQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageQuotaExceededFault")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for StorageQuotaExceededFault {}
/// See [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
pub mod storage_quota_exceeded_fault {
    /// A builder for [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
        pub fn build(self) -> crate::error::StorageQuotaExceededFault {
            crate::error::StorageQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl StorageQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault)
    pub fn builder() -> crate::error::storage_quota_exceeded_fault::Builder {
        crate::error::storage_quota_exceeded_fault::Builder::default()
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedIopsNotAvailableInAzFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedIopsNotAvailableInAzFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedIopsNotAvailableInAzFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedIopsNotAvailableInAzFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedIopsNotAvailableInAzFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ProvisionedIopsNotAvailableInAzFault [ProvisionedIopsNotAvailableInAZFault]"
        )?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedIopsNotAvailableInAzFault {}
/// See [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault)
pub mod provisioned_iops_not_available_in_az_fault {
    /// A builder for [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault)
        pub fn build(self) -> crate::error::ProvisionedIopsNotAvailableInAzFault {
            crate::error::ProvisionedIopsNotAvailableInAzFault {
                message: self.message,
            }
        }
    }
}
impl ProvisionedIopsNotAvailableInAzFault {
    /// Creates a new builder-style object to manufacture [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault)
    pub fn builder() -> crate::error::provisioned_iops_not_available_in_az_fault::Builder {
        crate::error::provisioned_iops_not_available_in_az_fault::Builder::default()
    }
}

/// <p>
/// <code>SourceDBInstanceIdentifier</code>
/// refers to a DB instance with
/// <code>BackupRetentionPeriod</code> equal to 0.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PointInTimeRestoreNotEnabledFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PointInTimeRestoreNotEnabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PointInTimeRestoreNotEnabledFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PointInTimeRestoreNotEnabledFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PointInTimeRestoreNotEnabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PointInTimeRestoreNotEnabledFault")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for PointInTimeRestoreNotEnabledFault {}
/// See [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
pub mod point_in_time_restore_not_enabled_fault {
    /// A builder for [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
        pub fn build(self) -> crate::error::PointInTimeRestoreNotEnabledFault {
            crate::error::PointInTimeRestoreNotEnabledFault {
                message: self.message,
            }
        }
    }
}
impl PointInTimeRestoreNotEnabledFault {
    /// Creates a new builder-style object to manufacture [`PointInTimeRestoreNotEnabledFault`](crate::error::PointInTimeRestoreNotEnabledFault)
    pub fn builder() -> crate::error::point_in_time_restore_not_enabled_fault::Builder {
        crate::error::point_in_time_restore_not_enabled_fault::Builder::default()
    }
}

/// <p>The specified option group could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupNotFoundFault")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupNotFoundFault {}
/// See [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
pub mod option_group_not_found_fault {
    /// A builder for [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
        pub fn build(self) -> crate::error::OptionGroupNotFoundFault {
            crate::error::OptionGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault)
    pub fn builder() -> crate::error::option_group_not_found_fault::Builder {
        crate::error::option_group_not_found_fault::Builder::default()
    }
}

/// <p>Cannot restore from VPC backup to non-VPC DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRestoreFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRestoreFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRestoreFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreFault")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRestoreFault {}
/// See [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
pub mod invalid_restore_fault {
    /// A builder for [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
        pub fn build(self) -> crate::error::InvalidRestoreFault {
            crate::error::InvalidRestoreFault {
                message: self.message,
            }
        }
    }
}
impl InvalidRestoreFault {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreFault`](crate::error::InvalidRestoreFault)
    pub fn builder() -> crate::error::invalid_restore_fault::Builder {
        crate::error::invalid_restore_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
/// instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstanceQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceQuotaExceededFault")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstanceQuotaExceededFault {}
/// See [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
pub mod instance_quota_exceeded_fault {
    /// A builder for [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
        pub fn build(self) -> crate::error::InstanceQuotaExceededFault {
            crate::error::InstanceQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl InstanceQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault)
    pub fn builder() -> crate::error::instance_quota_exceeded_fault::Builder {
        crate::error::instance_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>Domain</code> doesn't refer to an existing Active Directory domain.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DomainNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainNotFoundFault")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainNotFoundFault {}
/// See [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
pub mod domain_not_found_fault {
    /// A builder for [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
        pub fn build(self) -> crate::error::DomainNotFoundFault {
            crate::error::DomainNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DomainNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DomainNotFoundFault`](crate::error::DomainNotFoundFault)
    pub fn builder() -> crate::error::domain_not_found_fault::Builder {
        crate::error::domain_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>DBParameterGroupName</code> doesn't refer to an
/// existing DB parameter group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbParameterGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbParameterGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbParameterGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupNotFoundFault [DBParameterGroupNotFoundFault]"
        )?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupNotFoundFault {}
/// See [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault)
pub mod db_parameter_group_not_found_fault {
    /// A builder for [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault)
        pub fn build(self) -> crate::error::DbParameterGroupNotFoundFault {
            crate::error::DbParameterGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault)
    pub fn builder() -> crate::error::db_parameter_group_not_found_fault::Builder {
        crate::error::db_parameter_group_not_found_fault::Builder::default()
    }
}

/// <p>No automated backup for this DB instance was found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceAutomatedBackupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceAutomatedBackupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceAutomatedBackupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceAutomatedBackupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceAutomatedBackupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceAutomatedBackupNotFoundFault [DBInstanceAutomatedBackupNotFoundFault]"
        )?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceAutomatedBackupNotFoundFault {}
/// See [`DbInstanceAutomatedBackupNotFoundFault`](crate::error::DbInstanceAutomatedBackupNotFoundFault)
pub mod db_instance_automated_backup_not_found_fault {
    /// A builder for [`DbInstanceAutomatedBackupNotFoundFault`](crate::error::DbInstanceAutomatedBackupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceAutomatedBackupNotFoundFault`](crate::error::DbInstanceAutomatedBackupNotFoundFault)
        pub fn build(self) -> crate::error::DbInstanceAutomatedBackupNotFoundFault {
            crate::error::DbInstanceAutomatedBackupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceAutomatedBackupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceAutomatedBackupNotFoundFault`](crate::error::DbInstanceAutomatedBackupNotFoundFault)
    pub fn builder() -> crate::error::db_instance_automated_backup_not_found_fault::Builder {
        crate::error::db_instance_automated_backup_not_found_fault::Builder::default()
    }
}

/// <p>The user already has a DB instance with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceAlreadyExistsFault [DBInstanceAlreadyExistsFault]"
        )?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceAlreadyExistsFault {}
/// See [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault)
pub mod db_instance_already_exists_fault {
    /// A builder for [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbInstanceAlreadyExistsFault {
            crate::error::DbInstanceAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault)
    pub fn builder() -> crate::error::db_instance_already_exists_fault::Builder {
        crate::error::db_instance_already_exists_fault::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupPolicyNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupPolicyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupPolicyNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupPolicyNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupPolicyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupPolicyNotFoundFault")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupPolicyNotFoundFault {}
/// See [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
pub mod backup_policy_not_found_fault {
    /// A builder for [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
        pub fn build(self) -> crate::error::BackupPolicyNotFoundFault {
            crate::error::BackupPolicyNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl BackupPolicyNotFoundFault {
    /// Creates a new builder-style object to manufacture [`BackupPolicyNotFoundFault`](crate::error::BackupPolicyNotFoundFault)
    pub fn builder() -> crate::error::backup_policy_not_found_fault::Builder {
        crate::error::backup_policy_not_found_fault::Builder::default()
    }
}

/// <p>The state of the DB snapshot doesn't allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbSnapshotStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbSnapshotStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbSnapshotStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSnapshotStateFault [InvalidDBSnapshotStateFault]"
        )?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSnapshotStateFault {}
/// See [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault)
pub mod invalid_db_snapshot_state_fault {
    /// A builder for [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault)
        pub fn build(self) -> crate::error::InvalidDbSnapshotStateFault {
            crate::error::InvalidDbSnapshotStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault)
    pub fn builder() -> crate::error::invalid_db_snapshot_state_fault::Builder {
        crate::error::invalid_db_snapshot_state_fault::Builder::default()
    }
}

/// <p>The supplied value isn't a valid DB cluster snapshot state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbClusterSnapshotStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbClusterSnapshotStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbClusterSnapshotStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbClusterSnapshotStateFault [InvalidDBClusterSnapshotStateFault]"
        )?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterSnapshotStateFault {}
/// See [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault)
pub mod invalid_db_cluster_snapshot_state_fault {
    /// A builder for [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault)
        pub fn build(self) -> crate::error::InvalidDbClusterSnapshotStateFault {
            crate::error::InvalidDbClusterSnapshotStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbClusterSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_snapshot_state_fault::Builder {
        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default()
    }
}

/// <p>There is insufficient storage available for the current action. You might be able to
/// resolve this error by updating your subnet group to use different Availability Zones
/// that have more storage available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientStorageClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientStorageClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientStorageClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientStorageClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientStorageClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientStorageClusterCapacityFault")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientStorageClusterCapacityFault {}
/// See [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
pub mod insufficient_storage_cluster_capacity_fault {
    /// A builder for [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
        pub fn build(self) -> crate::error::InsufficientStorageClusterCapacityFault {
            crate::error::InsufficientStorageClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientStorageClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault)
    pub fn builder() -> crate::error::insufficient_storage_cluster_capacity_fault::Builder {
        crate::error::insufficient_storage_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The DB cluster doesn't have enough capacity for the current operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDbClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDbClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientDbClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDbClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDbClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InsufficientDbClusterCapacityFault [InsufficientDBClusterCapacityFault]"
        )?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDbClusterCapacityFault {}
/// See [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault)
pub mod insufficient_db_cluster_capacity_fault {
    /// A builder for [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault)
        pub fn build(self) -> crate::error::InsufficientDbClusterCapacityFault {
            crate::error::InsufficientDbClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientDbClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault)
    pub fn builder() -> crate::error::insufficient_db_cluster_capacity_fault::Builder {
        crate::error::insufficient_db_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The user attempted to create a new DB cluster and the user has already reached the
/// maximum allowed DB cluster quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterQuotaExceededFault [DBClusterQuotaExceededFault]"
        )?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterQuotaExceededFault {}
/// See [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault)
pub mod db_cluster_quota_exceeded_fault {
    /// A builder for [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault)
        pub fn build(self) -> crate::error::DbClusterQuotaExceededFault {
            crate::error::DbClusterQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_quota_exceeded_fault::Builder {
        crate::error::db_cluster_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>DBClusterParameterGroupName</code> doesn't refer to an existing DB
/// cluster parameter group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterParameterGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterParameterGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterParameterGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterParameterGroupNotFoundFault [DBClusterParameterGroupNotFoundFault]"
        )?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterParameterGroupNotFoundFault {}
/// See [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault)
pub mod db_cluster_parameter_group_not_found_fault {
    /// A builder for [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterParameterGroupNotFoundFault {
            crate::error::DbClusterParameterGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_parameter_group_not_found_fault::Builder {
        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default()
    }
}

/// <p>The user already has a DB cluster with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterAlreadyExistsFault [DBClusterAlreadyExistsFault]"
        )?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterAlreadyExistsFault {}
/// See [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault)
pub mod db_cluster_already_exists_fault {
    /// A builder for [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbClusterAlreadyExistsFault {
            crate::error::DbClusterAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_already_exists_fault::Builder {
        crate::error::db_cluster_already_exists_fault::Builder::default()
    }
}

/// <p>The DB subnet group cannot be deleted because it's in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbSubnetGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbSubnetGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbSubnetGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSubnetGroupStateFault [InvalidDBSubnetGroupStateFault]"
        )?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSubnetGroupStateFault {}
/// See [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault)
pub mod invalid_db_subnet_group_state_fault {
    /// A builder for [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDbSubnetGroupStateFault {
            crate::error::InvalidDbSubnetGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbSubnetGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_subnet_group_state_fault::Builder {
        crate::error::invalid_db_subnet_group_state_fault::Builder::default()
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting
/// to delete the parameter group, you can't delete it when the parameter group is in
/// this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbParameterGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbParameterGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbParameterGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbParameterGroupStateFault [InvalidDBParameterGroupStateFault]"
        )?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbParameterGroupStateFault {}
/// See [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault)
pub mod invalid_db_parameter_group_state_fault {
    /// A builder for [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault)
        pub fn build(self) -> crate::error::InvalidDbParameterGroupStateFault {
            crate::error::InvalidDbParameterGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault)
    pub fn builder() -> crate::error::invalid_db_parameter_group_state_fault::Builder {
        crate::error::invalid_db_parameter_group_state_fault::Builder::default()
    }
}

/// <p>The specified target group isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyTargetGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyTargetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyTargetGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyTargetGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyTargetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbProxyTargetGroupNotFoundFault [DBProxyTargetGroupNotFoundFault]"
        )?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyTargetGroupNotFoundFault {}
/// See [`DbProxyTargetGroupNotFoundFault`](crate::error::DbProxyTargetGroupNotFoundFault)
pub mod db_proxy_target_group_not_found_fault {
    /// A builder for [`DbProxyTargetGroupNotFoundFault`](crate::error::DbProxyTargetGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyTargetGroupNotFoundFault`](crate::error::DbProxyTargetGroupNotFoundFault)
        pub fn build(self) -> crate::error::DbProxyTargetGroupNotFoundFault {
            crate::error::DbProxyTargetGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyTargetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbProxyTargetGroupNotFoundFault`](crate::error::DbProxyTargetGroupNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_target_group_not_found_fault::Builder {
        crate::error::db_proxy_target_group_not_found_fault::Builder::default()
    }
}

/// <p>The specified proxy name doesn't correspond to a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbProxyNotFoundFault [DBProxyNotFoundFault]")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyNotFoundFault {}
/// See [`DbProxyNotFoundFault`](crate::error::DbProxyNotFoundFault)
pub mod db_proxy_not_found_fault {
    /// A builder for [`DbProxyNotFoundFault`](crate::error::DbProxyNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyNotFoundFault`](crate::error::DbProxyNotFoundFault)
        pub fn build(self) -> crate::error::DbProxyNotFoundFault {
            crate::error::DbProxyNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbProxyNotFoundFault`](crate::error::DbProxyNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_not_found_fault::Builder {
        crate::error::db_proxy_not_found_fault::Builder::default()
    }
}

/// <p>The subscription name does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionNotFoundFault")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionNotFoundFault {}
/// See [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
pub mod subscription_not_found_fault {
    /// A builder for [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
        pub fn build(self) -> crate::error::SubscriptionNotFoundFault {
            crate::error::SubscriptionNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault)
    pub fn builder() -> crate::error::subscription_not_found_fault::Builder {
        crate::error::subscription_not_found_fault::Builder::default()
    }
}

/// <p>The requested source could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceNotFoundFault")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceNotFoundFault {}
/// See [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
pub mod source_not_found_fault {
    /// A builder for [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
        pub fn build(self) -> crate::error::SourceNotFoundFault {
            crate::error::SourceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SourceNotFoundFault`](crate::error::SourceNotFoundFault)
    pub fn builder() -> crate::error::source_not_found_fault::Builder {
        crate::error::source_not_found_fault::Builder::default()
    }
}

/// <p>The specified <code>RoleArn</code> value doesn't match the specified feature for
/// the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceRoleNotFoundFault [DBInstanceRoleNotFoundFault]"
        )?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceRoleNotFoundFault {}
/// See [`DbInstanceRoleNotFoundFault`](crate::error::DbInstanceRoleNotFoundFault)
pub mod db_instance_role_not_found_fault {
    /// A builder for [`DbInstanceRoleNotFoundFault`](crate::error::DbInstanceRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceRoleNotFoundFault`](crate::error::DbInstanceRoleNotFoundFault)
        pub fn build(self) -> crate::error::DbInstanceRoleNotFoundFault {
            crate::error::DbInstanceRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceRoleNotFoundFault`](crate::error::DbInstanceRoleNotFoundFault)
    pub fn builder() -> crate::error::db_instance_role_not_found_fault::Builder {
        crate::error::db_instance_role_not_found_fault::Builder::default()
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbClusterRoleNotFoundFault [DBClusterRoleNotFoundFault]")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleNotFoundFault {}
/// See [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault)
pub mod db_cluster_role_not_found_fault {
    /// A builder for [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterRoleNotFoundFault {
            crate::error::DbClusterRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_role_not_found_fault::Builder {
        crate::error::db_cluster_role_not_found_fault::Builder::default()
    }
}

/// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGlobalClusterStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGlobalClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGlobalClusterStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGlobalClusterStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGlobalClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGlobalClusterStateFault")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGlobalClusterStateFault {}
/// See [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
pub mod invalid_global_cluster_state_fault {
    /// A builder for [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
        pub fn build(self) -> crate::error::InvalidGlobalClusterStateFault {
            crate::error::InvalidGlobalClusterStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidGlobalClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault)
    pub fn builder() -> crate::error::invalid_global_cluster_state_fault::Builder {
        crate::error::invalid_global_cluster_state_fault::Builder::default()
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterNotFoundFault")?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterNotFoundFault {}
/// See [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
pub mod global_cluster_not_found_fault {
    /// A builder for [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
        pub fn build(self) -> crate::error::GlobalClusterNotFoundFault {
            crate::error::GlobalClusterNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault)
    pub fn builder() -> crate::error::global_cluster_not_found_fault::Builder {
        crate::error::global_cluster_not_found_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed while the proxy is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbProxyStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbProxyStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbProxyStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbProxyStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbProxyStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbProxyStateFault [InvalidDBProxyStateFault]")?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbProxyStateFault {}
/// See [`InvalidDbProxyStateFault`](crate::error::InvalidDbProxyStateFault)
pub mod invalid_db_proxy_state_fault {
    /// A builder for [`InvalidDbProxyStateFault`](crate::error::InvalidDbProxyStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbProxyStateFault`](crate::error::InvalidDbProxyStateFault)
        pub fn build(self) -> crate::error::InvalidDbProxyStateFault {
            crate::error::InvalidDbProxyStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbProxyStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbProxyStateFault`](crate::error::InvalidDbProxyStateFault)
    pub fn builder() -> crate::error::invalid_db_proxy_state_fault::Builder {
        crate::error::invalid_db_proxy_state_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed because there aren't enough available IP addresses
/// in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required
/// from the subnets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientAvailableIPsInSubnetFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientAvailableIPsInSubnetFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientAvailableIPsInSubnetFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientAvailableIPsInSubnetFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientAvailableIPsInSubnetFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientAvailableIPsInSubnetFault")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientAvailableIPsInSubnetFault {}
/// See [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
pub mod insufficient_available_i_ps_in_subnet_fault {
    /// A builder for [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
        pub fn build(self) -> crate::error::InsufficientAvailableIPsInSubnetFault {
            crate::error::InsufficientAvailableIPsInSubnetFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientAvailableIPsInSubnetFault {
    /// Creates a new builder-style object to manufacture [`InsufficientAvailableIPsInSubnetFault`](crate::error::InsufficientAvailableIPsInSubnetFault)
    pub fn builder() -> crate::error::insufficient_available_i_ps_in_subnet_fault::Builder {
        crate::error::insufficient_available_i_ps_in_subnet_fault::Builder::default()
    }
}

/// <p>The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyTargetAlreadyRegisteredFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyTargetAlreadyRegisteredFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyTargetAlreadyRegisteredFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyTargetAlreadyRegisteredFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyTargetAlreadyRegisteredFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbProxyTargetAlreadyRegisteredFault [DBProxyTargetAlreadyRegisteredFault]"
        )?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyTargetAlreadyRegisteredFault {}
/// See [`DbProxyTargetAlreadyRegisteredFault`](crate::error::DbProxyTargetAlreadyRegisteredFault)
pub mod db_proxy_target_already_registered_fault {
    /// A builder for [`DbProxyTargetAlreadyRegisteredFault`](crate::error::DbProxyTargetAlreadyRegisteredFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyTargetAlreadyRegisteredFault`](crate::error::DbProxyTargetAlreadyRegisteredFault)
        pub fn build(self) -> crate::error::DbProxyTargetAlreadyRegisteredFault {
            crate::error::DbProxyTargetAlreadyRegisteredFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyTargetAlreadyRegisteredFault {
    /// Creates a new builder-style object to manufacture [`DbProxyTargetAlreadyRegisteredFault`](crate::error::DbProxyTargetAlreadyRegisteredFault)
    pub fn builder() -> crate::error::db_proxy_target_already_registered_fault::Builder {
        crate::error::db_proxy_target_already_registered_fault::Builder::default()
    }
}

/// <p>Specified offering does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDbInstancesOfferingNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDbInstancesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDbInstancesOfferingNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDbInstancesOfferingNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDbInstancesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReservedDbInstancesOfferingNotFoundFault [ReservedDBInstancesOfferingNotFoundFault]"
        )?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDbInstancesOfferingNotFoundFault {}
/// See [`ReservedDbInstancesOfferingNotFoundFault`](crate::error::ReservedDbInstancesOfferingNotFoundFault)
pub mod reserved_db_instances_offering_not_found_fault {
    /// A builder for [`ReservedDbInstancesOfferingNotFoundFault`](crate::error::ReservedDbInstancesOfferingNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDbInstancesOfferingNotFoundFault`](crate::error::ReservedDbInstancesOfferingNotFoundFault)
        pub fn build(self) -> crate::error::ReservedDbInstancesOfferingNotFoundFault {
            crate::error::ReservedDbInstancesOfferingNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDbInstancesOfferingNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedDbInstancesOfferingNotFoundFault`](crate::error::ReservedDbInstancesOfferingNotFoundFault)
    pub fn builder() -> crate::error::reserved_db_instances_offering_not_found_fault::Builder {
        crate::error::reserved_db_instances_offering_not_found_fault::Builder::default()
    }
}

/// <p>Request would exceed the user's DB Instance quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDbInstanceQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDbInstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDbInstanceQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDbInstanceQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDbInstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReservedDbInstanceQuotaExceededFault [ReservedDBInstanceQuotaExceededFault]"
        )?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDbInstanceQuotaExceededFault {}
/// See [`ReservedDbInstanceQuotaExceededFault`](crate::error::ReservedDbInstanceQuotaExceededFault)
pub mod reserved_db_instance_quota_exceeded_fault {
    /// A builder for [`ReservedDbInstanceQuotaExceededFault`](crate::error::ReservedDbInstanceQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDbInstanceQuotaExceededFault`](crate::error::ReservedDbInstanceQuotaExceededFault)
        pub fn build(self) -> crate::error::ReservedDbInstanceQuotaExceededFault {
            crate::error::ReservedDbInstanceQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDbInstanceQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ReservedDbInstanceQuotaExceededFault`](crate::error::ReservedDbInstanceQuotaExceededFault)
    pub fn builder() -> crate::error::reserved_db_instance_quota_exceeded_fault::Builder {
        crate::error::reserved_db_instance_quota_exceeded_fault::Builder::default()
    }
}

/// <p>User already has a reservation with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDbInstanceAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDbInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDbInstanceAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDbInstanceAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDbInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReservedDbInstanceAlreadyExistsFault [ReservedDBInstanceAlreadyExistsFault]"
        )?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDbInstanceAlreadyExistsFault {}
/// See [`ReservedDbInstanceAlreadyExistsFault`](crate::error::ReservedDbInstanceAlreadyExistsFault)
pub mod reserved_db_instance_already_exists_fault {
    /// A builder for [`ReservedDbInstanceAlreadyExistsFault`](crate::error::ReservedDbInstanceAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDbInstanceAlreadyExistsFault`](crate::error::ReservedDbInstanceAlreadyExistsFault)
        pub fn build(self) -> crate::error::ReservedDbInstanceAlreadyExistsFault {
            crate::error::ReservedDbInstanceAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDbInstanceAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReservedDbInstanceAlreadyExistsFault`](crate::error::ReservedDbInstanceAlreadyExistsFault)
    pub fn builder() -> crate::error::reserved_db_instance_already_exists_fault::Builder {
        crate::error::reserved_db_instance_already_exists_fault::Builder::default()
    }
}

/// <p>
/// The option group isn't in the <i>available</i> state.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOptionGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOptionGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOptionGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOptionGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOptionGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOptionGroupStateFault")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOptionGroupStateFault {}
/// See [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
pub mod invalid_option_group_state_fault {
    /// A builder for [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
        pub fn build(self) -> crate::error::InvalidOptionGroupStateFault {
            crate::error::InvalidOptionGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidOptionGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidOptionGroupStateFault`](crate::error::InvalidOptionGroupStateFault)
    pub fn builder() -> crate::error::invalid_option_group_state_fault::Builder {
        crate::error::invalid_option_group_state_fault::Builder::default()
    }
}

/// <p>The supplied category does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionCategoryNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionCategoryNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionCategoryNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionCategoryNotFoundFault")?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionCategoryNotFoundFault {}
/// See [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
pub mod subscription_category_not_found_fault {
    /// A builder for [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
        pub fn build(self) -> crate::error::SubscriptionCategoryNotFoundFault {
            crate::error::SubscriptionCategoryNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionCategoryNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault)
    pub fn builder() -> crate::error::subscription_category_not_found_fault::Builder {
        crate::error::subscription_category_not_found_fault::Builder::default()
    }
}

/// <p>The SNS topic ARN does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnsTopicArnNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnsTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnsTopicArnNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnsTopicArnNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsTopicArnNotFoundFault [SNSTopicArnNotFoundFault]")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnsTopicArnNotFoundFault {}
/// See [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault)
pub mod sns_topic_arn_not_found_fault {
    /// A builder for [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault)
        pub fn build(self) -> crate::error::SnsTopicArnNotFoundFault {
            crate::error::SnsTopicArnNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SnsTopicArnNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault)
    pub fn builder() -> crate::error::sns_topic_arn_not_found_fault::Builder {
        crate::error::sns_topic_arn_not_found_fault::Builder::default()
    }
}

/// <p>You do not have permission to publish to the SNS topic ARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnsNoAuthorizationFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnsNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnsNoAuthorizationFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnsNoAuthorizationFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsNoAuthorizationFault [SNSNoAuthorizationFault]")?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnsNoAuthorizationFault {}
/// See [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault)
pub mod sns_no_authorization_fault {
    /// A builder for [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault)
        pub fn build(self) -> crate::error::SnsNoAuthorizationFault {
            crate::error::SnsNoAuthorizationFault {
                message: self.message,
            }
        }
    }
}
impl SnsNoAuthorizationFault {
    /// Creates a new builder-style object to manufacture [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault)
    pub fn builder() -> crate::error::sns_no_authorization_fault::Builder {
        crate::error::sns_no_authorization_fault::Builder::default()
    }
}

/// <p>SNS has responded that there is a problem with the SND topic specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnsInvalidTopicFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnsInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnsInvalidTopicFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnsInvalidTopicFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsInvalidTopicFault [SNSInvalidTopicFault]")?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnsInvalidTopicFault {}
/// See [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault)
pub mod sns_invalid_topic_fault {
    /// A builder for [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault)
        pub fn build(self) -> crate::error::SnsInvalidTopicFault {
            crate::error::SnsInvalidTopicFault {
                message: self.message,
            }
        }
    }
}
impl SnsInvalidTopicFault {
    /// Creates a new builder-style object to manufacture [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault)
    pub fn builder() -> crate::error::sns_invalid_topic_fault::Builder {
        crate::error::sns_invalid_topic_fault::Builder::default()
    }
}

/// <p>You have reached the maximum number of event subscriptions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventSubscriptionQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventSubscriptionQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EventSubscriptionQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EventSubscriptionQuotaExceededFault")?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for EventSubscriptionQuotaExceededFault {}
/// See [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
pub mod event_subscription_quota_exceeded_fault {
    /// A builder for [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
        pub fn build(self) -> crate::error::EventSubscriptionQuotaExceededFault {
            crate::error::EventSubscriptionQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl EventSubscriptionQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault)
    pub fn builder() -> crate::error::event_subscription_quota_exceeded_fault::Builder {
        crate::error::event_subscription_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetAlreadyInUse {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetAlreadyInUse");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetAlreadyInUse {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetAlreadyInUse")?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetAlreadyInUse {}
/// See [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
pub mod subnet_already_in_use {
    /// A builder for [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
        pub fn build(self) -> crate::error::SubnetAlreadyInUse {
            crate::error::SubnetAlreadyInUse {
                message: self.message,
            }
        }
    }
}
impl SubnetAlreadyInUse {
    /// Creates a new builder-style object to manufacture [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse)
    pub fn builder() -> crate::error::subnet_already_in_use::Builder {
        crate::error::subnet_already_in_use::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of subnets in a
/// DB subnet groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSubnetQuotaExceededFault [DBSubnetQuotaExceededFault]")?;
        if let Some(inner_68) = &self.message {
            write!(f, ": {}", inner_68)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetQuotaExceededFault {}
/// See [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault)
pub mod db_subnet_quota_exceeded_fault {
    /// A builder for [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault)
        pub fn build(self) -> crate::error::DbSubnetQuotaExceededFault {
            crate::error::DbSubnetQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbSubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault)
    pub fn builder() -> crate::error::db_subnet_quota_exceeded_fault::Builder {
        crate::error::db_subnet_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharedSnapshotQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SharedSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharedSnapshotQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SharedSnapshotQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SharedSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SharedSnapshotQuotaExceededFault")?;
        if let Some(inner_69) = &self.message {
            write!(f, ": {}", inner_69)?;
        }
        Ok(())
    }
}
impl std::error::Error for SharedSnapshotQuotaExceededFault {}
/// See [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
pub mod shared_snapshot_quota_exceeded_fault {
    /// A builder for [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
        pub fn build(self) -> crate::error::SharedSnapshotQuotaExceededFault {
            crate::error::SharedSnapshotQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl SharedSnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault)
    pub fn builder() -> crate::error::shared_snapshot_quota_exceeded_fault::Builder {
        crate::error::shared_snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You can't perform this operation while the DB proxy endpoint is in a particular state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbProxyEndpointStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbProxyEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbProxyEndpointStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbProxyEndpointStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbProxyEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbProxyEndpointStateFault [InvalidDBProxyEndpointStateFault]"
        )?;
        if let Some(inner_70) = &self.message {
            write!(f, ": {}", inner_70)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbProxyEndpointStateFault {}
/// See [`InvalidDbProxyEndpointStateFault`](crate::error::InvalidDbProxyEndpointStateFault)
pub mod invalid_db_proxy_endpoint_state_fault {
    /// A builder for [`InvalidDbProxyEndpointStateFault`](crate::error::InvalidDbProxyEndpointStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbProxyEndpointStateFault`](crate::error::InvalidDbProxyEndpointStateFault)
        pub fn build(self) -> crate::error::InvalidDbProxyEndpointStateFault {
            crate::error::InvalidDbProxyEndpointStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbProxyEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbProxyEndpointStateFault`](crate::error::InvalidDbProxyEndpointStateFault)
    pub fn builder() -> crate::error::invalid_db_proxy_endpoint_state_fault::Builder {
        crate::error::invalid_db_proxy_endpoint_state_fault::Builder::default()
    }
}

/// <p>The DB proxy endpoint doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyEndpointNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyEndpointNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyEndpointNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbProxyEndpointNotFoundFault [DBProxyEndpointNotFoundFault]"
        )?;
        if let Some(inner_71) = &self.message {
            write!(f, ": {}", inner_71)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyEndpointNotFoundFault {}
/// See [`DbProxyEndpointNotFoundFault`](crate::error::DbProxyEndpointNotFoundFault)
pub mod db_proxy_endpoint_not_found_fault {
    /// A builder for [`DbProxyEndpointNotFoundFault`](crate::error::DbProxyEndpointNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyEndpointNotFoundFault`](crate::error::DbProxyEndpointNotFoundFault)
        pub fn build(self) -> crate::error::DbProxyEndpointNotFoundFault {
            crate::error::DbProxyEndpointNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyEndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbProxyEndpointNotFoundFault`](crate::error::DbProxyEndpointNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_not_found_fault::Builder {
        crate::error::db_proxy_endpoint_not_found_fault::Builder::default()
    }
}

/// <p>The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your Amazon Web Services account in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyEndpointAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyEndpointAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyEndpointAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbProxyEndpointAlreadyExistsFault [DBProxyEndpointAlreadyExistsFault]"
        )?;
        if let Some(inner_72) = &self.message {
            write!(f, ": {}", inner_72)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyEndpointAlreadyExistsFault {}
/// See [`DbProxyEndpointAlreadyExistsFault`](crate::error::DbProxyEndpointAlreadyExistsFault)
pub mod db_proxy_endpoint_already_exists_fault {
    /// A builder for [`DbProxyEndpointAlreadyExistsFault`](crate::error::DbProxyEndpointAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyEndpointAlreadyExistsFault`](crate::error::DbProxyEndpointAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbProxyEndpointAlreadyExistsFault {
            crate::error::DbProxyEndpointAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyEndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbProxyEndpointAlreadyExistsFault`](crate::error::DbProxyEndpointAlreadyExistsFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_already_exists_fault::Builder {
        crate::error::db_proxy_endpoint_already_exists_fault::Builder::default()
    }
}

/// <p>The specified proxy name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbProxyAlreadyExistsFault [DBProxyAlreadyExistsFault]")?;
        if let Some(inner_73) = &self.message {
            write!(f, ": {}", inner_73)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyAlreadyExistsFault {}
/// See [`DbProxyAlreadyExistsFault`](crate::error::DbProxyAlreadyExistsFault)
pub mod db_proxy_already_exists_fault {
    /// A builder for [`DbProxyAlreadyExistsFault`](crate::error::DbProxyAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyAlreadyExistsFault`](crate::error::DbProxyAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbProxyAlreadyExistsFault {
            crate::error::DbProxyAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbProxyAlreadyExistsFault`](crate::error::DbProxyAlreadyExistsFault)
    pub fn builder() -> crate::error::db_proxy_already_exists_fault::Builder {
        crate::error::db_proxy_already_exists_fault::Builder::default()
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on can't be
/// modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbUpgradeDependencyFailureFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbUpgradeDependencyFailureFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbUpgradeDependencyFailureFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbUpgradeDependencyFailureFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbUpgradeDependencyFailureFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbUpgradeDependencyFailureFault [DBUpgradeDependencyFailureFault]"
        )?;
        if let Some(inner_74) = &self.message {
            write!(f, ": {}", inner_74)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbUpgradeDependencyFailureFault {}
/// See [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault)
pub mod db_upgrade_dependency_failure_fault {
    /// A builder for [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault)
        pub fn build(self) -> crate::error::DbUpgradeDependencyFailureFault {
            crate::error::DbUpgradeDependencyFailureFault {
                message: self.message,
            }
        }
    }
}
impl DbUpgradeDependencyFailureFault {
    /// Creates a new builder-style object to manufacture [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault)
    pub fn builder() -> crate::error::db_upgrade_dependency_failure_fault::Builder {
        crate::error::db_upgrade_dependency_failure_fault::Builder::default()
    }
}

/// <p>
/// <code>CertificateIdentifier</code> doesn't refer to an
/// existing certificate.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateNotFoundFault")?;
        if let Some(inner_75) = &self.message {
            write!(f, ": {}", inner_75)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateNotFoundFault {}
/// See [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
pub mod certificate_not_found_fault {
    /// A builder for [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
        pub fn build(self) -> crate::error::CertificateNotFoundFault {
            crate::error::CertificateNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CertificateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault)
    pub fn builder() -> crate::error::certificate_not_found_fault::Builder {
        crate::error::certificate_not_found_fault::Builder::default()
    }
}

/// <p>The requested operation can't be performed on the endpoint while the endpoint is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbClusterEndpointStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbClusterEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbClusterEndpointStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbClusterEndpointStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbClusterEndpointStateFault [InvalidDBClusterEndpointStateFault]"
        )?;
        if let Some(inner_76) = &self.message {
            write!(f, ": {}", inner_76)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterEndpointStateFault {}
/// See [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault)
pub mod invalid_db_cluster_endpoint_state_fault {
    /// A builder for [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault)
        pub fn build(self) -> crate::error::InvalidDbClusterEndpointStateFault {
            crate::error::InvalidDbClusterEndpointStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbClusterEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault)
    pub fn builder() -> crate::error::invalid_db_cluster_endpoint_state_fault::Builder {
        crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default()
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterEndpointNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterEndpointNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterEndpointNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointNotFoundFault [DBClusterEndpointNotFoundFault]"
        )?;
        if let Some(inner_77) = &self.message {
            write!(f, ": {}", inner_77)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointNotFoundFault {}
/// See [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault)
pub mod db_cluster_endpoint_not_found_fault {
    /// A builder for [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterEndpointNotFoundFault {
            crate::error::DbClusterEndpointNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterEndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_not_found_fault::Builder {
        crate::error::db_cluster_endpoint_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>Capacity</code> isn't a valid Aurora Serverless DB cluster
/// capacity. Valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>,
/// <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbClusterCapacityFault [InvalidDBClusterCapacityFault]"
        )?;
        if let Some(inner_78) = &self.message {
            write!(f, ": {}", inner_78)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterCapacityFault {}
/// See [`InvalidDbClusterCapacityFault`](crate::error::InvalidDbClusterCapacityFault)
pub mod invalid_db_cluster_capacity_fault {
    /// A builder for [`InvalidDbClusterCapacityFault`](crate::error::InvalidDbClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterCapacityFault`](crate::error::InvalidDbClusterCapacityFault)
        pub fn build(self) -> crate::error::InvalidDbClusterCapacityFault {
            crate::error::InvalidDbClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterCapacityFault`](crate::error::InvalidDbClusterCapacityFault)
    pub fn builder() -> crate::error::invalid_db_cluster_capacity_fault::Builder {
        crate::error::invalid_db_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The specified installation medium has already been imported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstallationMediaAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstallationMediaAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstallationMediaAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstallationMediaAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstallationMediaAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstallationMediaAlreadyExistsFault")?;
        if let Some(inner_79) = &self.message {
            write!(f, ": {}", inner_79)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstallationMediaAlreadyExistsFault {}
/// See [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
pub mod installation_media_already_exists_fault {
    /// A builder for [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
        pub fn build(self) -> crate::error::InstallationMediaAlreadyExistsFault {
            crate::error::InstallationMediaAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl InstallationMediaAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`InstallationMediaAlreadyExistsFault`](crate::error::InstallationMediaAlreadyExistsFault)
    pub fn builder() -> crate::error::installation_media_already_exists_fault::Builder {
        crate::error::installation_media_already_exists_fault::Builder::default()
    }
}

/// <p>
/// <code>CustomAvailabilityZoneId</code> doesn't refer to an existing custom
/// Availability Zone identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneNotFoundFault")?;
        if let Some(inner_80) = &self.message {
            write!(f, ": {}", inner_80)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneNotFoundFault {}
/// See [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
pub mod custom_availability_zone_not_found_fault {
    /// A builder for [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneNotFoundFault {
            crate::error::CustomAvailabilityZoneNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneNotFoundFault`](crate::error::CustomAvailabilityZoneNotFoundFault)
    pub fn builder() -> crate::error::custom_availability_zone_not_found_fault::Builder {
        crate::error::custom_availability_zone_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>LogFileName</code> doesn't refer to an existing DB log file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbLogFileNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbLogFileNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbLogFileNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbLogFileNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbLogFileNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbLogFileNotFoundFault [DBLogFileNotFoundFault]")?;
        if let Some(inner_81) = &self.message {
            write!(f, ": {}", inner_81)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbLogFileNotFoundFault {}
/// See [`DbLogFileNotFoundFault`](crate::error::DbLogFileNotFoundFault)
pub mod db_log_file_not_found_fault {
    /// A builder for [`DbLogFileNotFoundFault`](crate::error::DbLogFileNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbLogFileNotFoundFault`](crate::error::DbLogFileNotFoundFault)
        pub fn build(self) -> crate::error::DbLogFileNotFoundFault {
            crate::error::DbLogFileNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbLogFileNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbLogFileNotFoundFault`](crate::error::DbLogFileNotFoundFault)
    pub fn builder() -> crate::error::db_log_file_not_found_fault::Builder {
        crate::error::db_log_file_not_found_fault::Builder::default()
    }
}

/// <p>The specified reserved DB Instance not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedDbInstanceNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedDbInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedDbInstanceNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedDbInstanceNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedDbInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReservedDbInstanceNotFoundFault [ReservedDBInstanceNotFoundFault]"
        )?;
        if let Some(inner_82) = &self.message {
            write!(f, ": {}", inner_82)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedDbInstanceNotFoundFault {}
/// See [`ReservedDbInstanceNotFoundFault`](crate::error::ReservedDbInstanceNotFoundFault)
pub mod reserved_db_instance_not_found_fault {
    /// A builder for [`ReservedDbInstanceNotFoundFault`](crate::error::ReservedDbInstanceNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedDbInstanceNotFoundFault`](crate::error::ReservedDbInstanceNotFoundFault)
        pub fn build(self) -> crate::error::ReservedDbInstanceNotFoundFault {
            crate::error::ReservedDbInstanceNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedDbInstanceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedDbInstanceNotFoundFault`](crate::error::ReservedDbInstanceNotFoundFault)
    pub fn builder() -> crate::error::reserved_db_instance_not_found_fault::Builder {
        crate::error::reserved_db_instance_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>InstallationMediaID</code> doesn't refer to an existing installation medium.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstallationMediaNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstallationMediaNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstallationMediaNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InstallationMediaNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstallationMediaNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstallationMediaNotFoundFault")?;
        if let Some(inner_83) = &self.message {
            write!(f, ": {}", inner_83)?;
        }
        Ok(())
    }
}
impl std::error::Error for InstallationMediaNotFoundFault {}
/// See [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
pub mod installation_media_not_found_fault {
    /// A builder for [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
        pub fn build(self) -> crate::error::InstallationMediaNotFoundFault {
            crate::error::InstallationMediaNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl InstallationMediaNotFoundFault {
    /// Creates a new builder-style object to manufacture [`InstallationMediaNotFoundFault`](crate::error::InstallationMediaNotFoundFault)
    pub fn builder() -> crate::error::installation_media_not_found_fault::Builder {
        crate::error::installation_media_not_found_fault::Builder::default()
    }
}

/// <p>The export task doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportTaskNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportTaskNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportTaskNotFoundFault")?;
        if let Some(inner_84) = &self.message {
            write!(f, ": {}", inner_84)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportTaskNotFoundFault {}
/// See [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
pub mod export_task_not_found_fault {
    /// A builder for [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
        pub fn build(self) -> crate::error::ExportTaskNotFoundFault {
            crate::error::ExportTaskNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ExportTaskNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ExportTaskNotFoundFault`](crate::error::ExportTaskNotFoundFault)
    pub fn builder() -> crate::error::export_task_not_found_fault::Builder {
        crate::error::export_task_not_found_fault::Builder::default()
    }
}

/// <p>The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyTargetNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyTargetNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyTargetNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyTargetNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyTargetNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbProxyTargetNotFoundFault [DBProxyTargetNotFoundFault]")?;
        if let Some(inner_85) = &self.message {
            write!(f, ": {}", inner_85)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyTargetNotFoundFault {}
/// See [`DbProxyTargetNotFoundFault`](crate::error::DbProxyTargetNotFoundFault)
pub mod db_proxy_target_not_found_fault {
    /// A builder for [`DbProxyTargetNotFoundFault`](crate::error::DbProxyTargetNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyTargetNotFoundFault`](crate::error::DbProxyTargetNotFoundFault)
        pub fn build(self) -> crate::error::DbProxyTargetNotFoundFault {
            crate::error::DbProxyTargetNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyTargetNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbProxyTargetNotFoundFault`](crate::error::DbProxyTargetNotFoundFault)
    pub fn builder() -> crate::error::db_proxy_target_not_found_fault::Builder {
        crate::error::db_proxy_target_not_found_fault::Builder::default()
    }
}

/// <p>
/// <code>BacktrackIdentifier</code> doesn't refer to an existing backtrack. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterBacktrackNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterBacktrackNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterBacktrackNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterBacktrackNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterBacktrackNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterBacktrackNotFoundFault [DBClusterBacktrackNotFoundFault]"
        )?;
        if let Some(inner_86) = &self.message {
            write!(f, ": {}", inner_86)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterBacktrackNotFoundFault {}
/// See [`DbClusterBacktrackNotFoundFault`](crate::error::DbClusterBacktrackNotFoundFault)
pub mod db_cluster_backtrack_not_found_fault {
    /// A builder for [`DbClusterBacktrackNotFoundFault`](crate::error::DbClusterBacktrackNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterBacktrackNotFoundFault`](crate::error::DbClusterBacktrackNotFoundFault)
        pub fn build(self) -> crate::error::DbClusterBacktrackNotFoundFault {
            crate::error::DbClusterBacktrackNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterBacktrackNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterBacktrackNotFoundFault`](crate::error::DbClusterBacktrackNotFoundFault)
    pub fn builder() -> crate::error::db_cluster_backtrack_not_found_fault::Builder {
        crate::error::db_cluster_backtrack_not_found_fault::Builder::default()
    }
}

/// <p>This error can occur if someone else is modifying a subscription. You should retry the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEventSubscriptionStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEventSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEventSubscriptionStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEventSubscriptionStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventSubscriptionStateFault")?;
        if let Some(inner_87) = &self.message {
            write!(f, ": {}", inner_87)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventSubscriptionStateFault {}
/// See [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
pub mod invalid_event_subscription_state_fault {
    /// A builder for [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
        pub fn build(self) -> crate::error::InvalidEventSubscriptionStateFault {
            crate::error::InvalidEventSubscriptionStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidEventSubscriptionStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault)
    pub fn builder() -> crate::error::invalid_event_subscription_state_fault::Builder {
        crate::error::invalid_event_subscription_state_fault::Builder::default()
    }
}

/// <p>
/// The DB subnet isn't in the <i>available</i> state.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbSubnetStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbSubnetStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbSubnetStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbSubnetStateFault [InvalidDBSubnetStateFault]")?;
        if let Some(inner_88) = &self.message {
            write!(f, ": {}", inner_88)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSubnetStateFault {}
/// See [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault)
pub mod invalid_db_subnet_state_fault {
    /// A builder for [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault)
        pub fn build(self) -> crate::error::InvalidDbSubnetStateFault {
            crate::error::InvalidDbSubnetStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbSubnetStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault)
    pub fn builder() -> crate::error::invalid_db_subnet_state_fault::Builder {
        crate::error::invalid_db_subnet_state_fault::Builder::default()
    }
}

/// <p>The automated backup is in an invalid state.
/// For example, this automated backup is associated with an active instance. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbInstanceAutomatedBackupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbInstanceAutomatedBackupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbInstanceAutomatedBackupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbInstanceAutomatedBackupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbInstanceAutomatedBackupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbInstanceAutomatedBackupStateFault [InvalidDBInstanceAutomatedBackupStateFault]")?;
        if let Some(inner_89) = &self.message {
            write!(f, ": {}", inner_89)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbInstanceAutomatedBackupStateFault {}
/// See [`InvalidDbInstanceAutomatedBackupStateFault`](crate::error::InvalidDbInstanceAutomatedBackupStateFault)
pub mod invalid_db_instance_automated_backup_state_fault {
    /// A builder for [`InvalidDbInstanceAutomatedBackupStateFault`](crate::error::InvalidDbInstanceAutomatedBackupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbInstanceAutomatedBackupStateFault`](crate::error::InvalidDbInstanceAutomatedBackupStateFault)
        pub fn build(self) -> crate::error::InvalidDbInstanceAutomatedBackupStateFault {
            crate::error::InvalidDbInstanceAutomatedBackupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbInstanceAutomatedBackupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbInstanceAutomatedBackupStateFault`](crate::error::InvalidDbInstanceAutomatedBackupStateFault)
    pub fn builder() -> crate::error::invalid_db_instance_automated_backup_state_fault::Builder {
        crate::error::invalid_db_instance_automated_backup_state_fault::Builder::default()
    }
}

/// <p>The user already has a DB cluster snapshot with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterSnapshotAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterSnapshotAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterSnapshotAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterSnapshotAlreadyExistsFault [DBClusterSnapshotAlreadyExistsFault]"
        )?;
        if let Some(inner_90) = &self.message {
            write!(f, ": {}", inner_90)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterSnapshotAlreadyExistsFault {}
/// See [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault)
pub mod db_cluster_snapshot_already_exists_fault {
    /// A builder for [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbClusterSnapshotAlreadyExistsFault {
            crate::error::DbClusterSnapshotAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_snapshot_already_exists_fault::Builder {
        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default()
    }
}

/// <p>The quota of 20 option groups was exceeded for this Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupQuotaExceededFault")?;
        if let Some(inner_91) = &self.message {
            write!(f, ": {}", inner_91)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupQuotaExceededFault {}
/// See [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
pub mod option_group_quota_exceeded_fault {
    /// A builder for [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::OptionGroupQuotaExceededFault {
            crate::error::OptionGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupQuotaExceededFault`](crate::error::OptionGroupQuotaExceededFault)
    pub fn builder() -> crate::error::option_group_quota_exceeded_fault::Builder {
        crate::error::option_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The option group you are trying to create already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OptionGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OptionGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupAlreadyExistsFault")?;
        if let Some(inner_92) = &self.message {
            write!(f, ": {}", inner_92)?;
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupAlreadyExistsFault {}
/// See [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
pub mod option_group_already_exists_fault {
    /// A builder for [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::OptionGroupAlreadyExistsFault {
            crate::error::OptionGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl OptionGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupAlreadyExistsFault`](crate::error::OptionGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::option_group_already_exists_fault::Builder {
        crate::error::option_group_already_exists_fault::Builder::default()
    }
}

/// <p>The number of global database clusters for this account is already at the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterQuotaExceededFault")?;
        if let Some(inner_93) = &self.message {
            write!(f, ": {}", inner_93)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterQuotaExceededFault {}
/// See [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
pub mod global_cluster_quota_exceeded_fault {
    /// A builder for [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
        pub fn build(self) -> crate::error::GlobalClusterQuotaExceededFault {
            crate::error::GlobalClusterQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault)
    pub fn builder() -> crate::error::global_cluster_quota_exceeded_fault::Builder {
        crate::error::global_cluster_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> already exists. Choose a new global database identifier (unique name) to create a new global database cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalClusterAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalClusterAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalClusterAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterAlreadyExistsFault")?;
        if let Some(inner_94) = &self.message {
            write!(f, ": {}", inner_94)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterAlreadyExistsFault {}
/// See [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
pub mod global_cluster_already_exists_fault {
    /// A builder for [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
        pub fn build(self) -> crate::error::GlobalClusterAlreadyExistsFault {
            crate::error::GlobalClusterAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl GlobalClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault)
    pub fn builder() -> crate::error::global_cluster_already_exists_fault::Builder {
        crate::error::global_cluster_already_exists_fault::Builder::default()
    }
}

/// <p>The supplied subscription name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionAlreadyExistFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionAlreadyExistFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionAlreadyExistFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionAlreadyExistFault")?;
        if let Some(inner_95) = &self.message {
            write!(f, ": {}", inner_95)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionAlreadyExistFault {}
/// See [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
pub mod subscription_already_exist_fault {
    /// A builder for [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
        pub fn build(self) -> crate::error::SubscriptionAlreadyExistFault {
            crate::error::SubscriptionAlreadyExistFault {
                message: self.message,
            }
        }
    }
}
impl SubscriptionAlreadyExistFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault)
    pub fn builder() -> crate::error::subscription_already_exist_fault::Builder {
        crate::error::subscription_already_exist_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB subnet
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupQuotaExceededFault [DBSubnetGroupQuotaExceededFault]"
        )?;
        if let Some(inner_96) = &self.message {
            write!(f, ": {}", inner_96)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupQuotaExceededFault {}
/// See [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault)
pub mod db_subnet_group_quota_exceeded_fault {
    /// A builder for [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DbSubnetGroupQuotaExceededFault {
            crate::error::DbSubnetGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbSubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_subnet_group_quota_exceeded_fault::Builder {
        crate::error::db_subnet_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>DBSubnetGroupName</code> is already used by an existing DB subnet group.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupAlreadyExistsFault [DBSubnetGroupAlreadyExistsFault]"
        )?;
        if let Some(inner_97) = &self.message {
            write!(f, ": {}", inner_97)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupAlreadyExistsFault {}
/// See [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault)
pub mod db_subnet_group_already_exists_fault {
    /// A builder for [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbSubnetGroupAlreadyExistsFault {
            crate::error::DbSubnetGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbSubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_subnet_group_already_exists_fault::Builder {
        crate::error::db_subnet_group_already_exists_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB security
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSecurityGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSecurityGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSecurityGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSecurityGroupQuotaExceededFault [DBSecurityGroupQuotaExceededFault]"
        )?;
        if let Some(inner_98) = &self.message {
            write!(f, ": {}", inner_98)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSecurityGroupQuotaExceededFault {}
/// See [`DbSecurityGroupQuotaExceededFault`](crate::error::DbSecurityGroupQuotaExceededFault)
pub mod db_security_group_quota_exceeded_fault {
    /// A builder for [`DbSecurityGroupQuotaExceededFault`](crate::error::DbSecurityGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSecurityGroupQuotaExceededFault`](crate::error::DbSecurityGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DbSecurityGroupQuotaExceededFault {
            crate::error::DbSecurityGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbSecurityGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbSecurityGroupQuotaExceededFault`](crate::error::DbSecurityGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_security_group_quota_exceeded_fault::Builder {
        crate::error::db_security_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A DB security group isn't allowed for this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSecurityGroupNotSupportedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSecurityGroupNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSecurityGroupNotSupportedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSecurityGroupNotSupportedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSecurityGroupNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSecurityGroupNotSupportedFault [DBSecurityGroupNotSupportedFault]"
        )?;
        if let Some(inner_99) = &self.message {
            write!(f, ": {}", inner_99)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSecurityGroupNotSupportedFault {}
/// See [`DbSecurityGroupNotSupportedFault`](crate::error::DbSecurityGroupNotSupportedFault)
pub mod db_security_group_not_supported_fault {
    /// A builder for [`DbSecurityGroupNotSupportedFault`](crate::error::DbSecurityGroupNotSupportedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSecurityGroupNotSupportedFault`](crate::error::DbSecurityGroupNotSupportedFault)
        pub fn build(self) -> crate::error::DbSecurityGroupNotSupportedFault {
            crate::error::DbSecurityGroupNotSupportedFault {
                message: self.message,
            }
        }
    }
}
impl DbSecurityGroupNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`DbSecurityGroupNotSupportedFault`](crate::error::DbSecurityGroupNotSupportedFault)
    pub fn builder() -> crate::error::db_security_group_not_supported_fault::Builder {
        crate::error::db_security_group_not_supported_fault::Builder::default()
    }
}

/// <p>
/// A DB security group with the name specified in
/// <code>DBSecurityGroupName</code> already exists.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSecurityGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSecurityGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSecurityGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSecurityGroupAlreadyExistsFault [DBSecurityGroupAlreadyExistsFault]"
        )?;
        if let Some(inner_100) = &self.message {
            write!(f, ": {}", inner_100)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSecurityGroupAlreadyExistsFault {}
/// See [`DbSecurityGroupAlreadyExistsFault`](crate::error::DbSecurityGroupAlreadyExistsFault)
pub mod db_security_group_already_exists_fault {
    /// A builder for [`DbSecurityGroupAlreadyExistsFault`](crate::error::DbSecurityGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSecurityGroupAlreadyExistsFault`](crate::error::DbSecurityGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbSecurityGroupAlreadyExistsFault {
            crate::error::DbSecurityGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbSecurityGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbSecurityGroupAlreadyExistsFault`](crate::error::DbSecurityGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_security_group_already_exists_fault::Builder {
        crate::error::db_security_group_already_exists_fault::Builder::default()
    }
}

/// <p>The DB proxy already has the maximum number of endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyEndpointQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyEndpointQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyEndpointQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbProxyEndpointQuotaExceededFault [DBProxyEndpointQuotaExceededFault]"
        )?;
        if let Some(inner_101) = &self.message {
            write!(f, ": {}", inner_101)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyEndpointQuotaExceededFault {}
/// See [`DbProxyEndpointQuotaExceededFault`](crate::error::DbProxyEndpointQuotaExceededFault)
pub mod db_proxy_endpoint_quota_exceeded_fault {
    /// A builder for [`DbProxyEndpointQuotaExceededFault`](crate::error::DbProxyEndpointQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyEndpointQuotaExceededFault`](crate::error::DbProxyEndpointQuotaExceededFault)
        pub fn build(self) -> crate::error::DbProxyEndpointQuotaExceededFault {
            crate::error::DbProxyEndpointQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyEndpointQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbProxyEndpointQuotaExceededFault`](crate::error::DbProxyEndpointQuotaExceededFault)
    pub fn builder() -> crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder {
        crate::error::db_proxy_endpoint_quota_exceeded_fault::Builder::default()
    }
}

/// <p>Your Amazon Web Services account already has the maximum number of proxies in the specified Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbProxyQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbProxyQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbProxyQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbProxyQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbProxyQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbProxyQuotaExceededFault [DBProxyQuotaExceededFault]")?;
        if let Some(inner_102) = &self.message {
            write!(f, ": {}", inner_102)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbProxyQuotaExceededFault {}
/// See [`DbProxyQuotaExceededFault`](crate::error::DbProxyQuotaExceededFault)
pub mod db_proxy_quota_exceeded_fault {
    /// A builder for [`DbProxyQuotaExceededFault`](crate::error::DbProxyQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbProxyQuotaExceededFault`](crate::error::DbProxyQuotaExceededFault)
        pub fn build(self) -> crate::error::DbProxyQuotaExceededFault {
            crate::error::DbProxyQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbProxyQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbProxyQuotaExceededFault`](crate::error::DbProxyQuotaExceededFault)
    pub fn builder() -> crate::error::db_proxy_quota_exceeded_fault::Builder {
        crate::error::db_proxy_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB parameter
/// groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbParameterGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbParameterGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbParameterGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupQuotaExceededFault [DBParameterGroupQuotaExceededFault]"
        )?;
        if let Some(inner_103) = &self.message {
            write!(f, ": {}", inner_103)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupQuotaExceededFault {}
/// See [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault)
pub mod db_parameter_group_quota_exceeded_fault {
    /// A builder for [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::DbParameterGroupQuotaExceededFault {
            crate::error::DbParameterGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault)
    pub fn builder() -> crate::error::db_parameter_group_quota_exceeded_fault::Builder {
        crate::error::db_parameter_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A DB parameter group with the same name exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbParameterGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbParameterGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbParameterGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupAlreadyExistsFault [DBParameterGroupAlreadyExistsFault]"
        )?;
        if let Some(inner_104) = &self.message {
            write!(f, ": {}", inner_104)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupAlreadyExistsFault {}
/// See [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault)
pub mod db_parameter_group_already_exists_fault {
    /// A builder for [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbParameterGroupAlreadyExistsFault {
            crate::error::DbParameterGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::db_parameter_group_already_exists_fault::Builder {
        crate::error::db_parameter_group_already_exists_fault::Builder::default()
    }
}

/// <p>The DBSubnetGroup doesn't belong to the same VPC as that of an existing
/// cross-region read replica of the same source instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDbSubnetGroupFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDbSubnetGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDbSubnetGroupFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDbSubnetGroupFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSubnetGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbSubnetGroupFault [InvalidDBSubnetGroupFault]")?;
        if let Some(inner_105) = &self.message {
            write!(f, ": {}", inner_105)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSubnetGroupFault {}
/// See [`InvalidDbSubnetGroupFault`](crate::error::InvalidDbSubnetGroupFault)
pub mod invalid_db_subnet_group_fault {
    /// A builder for [`InvalidDbSubnetGroupFault`](crate::error::InvalidDbSubnetGroupFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSubnetGroupFault`](crate::error::InvalidDbSubnetGroupFault)
        pub fn build(self) -> crate::error::InvalidDbSubnetGroupFault {
            crate::error::InvalidDbSubnetGroupFault {
                message: self.message,
            }
        }
    }
}
impl InvalidDbSubnetGroupFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSubnetGroupFault`](crate::error::InvalidDbSubnetGroupFault)
    pub fn builder() -> crate::error::invalid_db_subnet_group_fault::Builder {
        crate::error::invalid_db_subnet_group_fault::Builder::default()
    }
}

/// <p>The DBSubnetGroup shouldn't be specified while creating read replicas that lie
/// in the same region as the source instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbSubnetGroupNotAllowedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbSubnetGroupNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbSubnetGroupNotAllowedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbSubnetGroupNotAllowedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupNotAllowedFault [DBSubnetGroupNotAllowedFault]"
        )?;
        if let Some(inner_106) = &self.message {
            write!(f, ": {}", inner_106)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupNotAllowedFault {}
/// See [`DbSubnetGroupNotAllowedFault`](crate::error::DbSubnetGroupNotAllowedFault)
pub mod db_subnet_group_not_allowed_fault {
    /// A builder for [`DbSubnetGroupNotAllowedFault`](crate::error::DbSubnetGroupNotAllowedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupNotAllowedFault`](crate::error::DbSubnetGroupNotAllowedFault)
        pub fn build(self) -> crate::error::DbSubnetGroupNotAllowedFault {
            crate::error::DbSubnetGroupNotAllowedFault {
                message: self.message,
            }
        }
    }
}
impl DbSubnetGroupNotAllowedFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupNotAllowedFault`](crate::error::DbSubnetGroupNotAllowedFault)
    pub fn builder() -> crate::error::db_subnet_group_not_allowed_fault::Builder {
        crate::error::db_subnet_group_not_allowed_fault::Builder::default()
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterEndpointQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterEndpointQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterEndpointQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointQuotaExceededFault [DBClusterEndpointQuotaExceededFault]"
        )?;
        if let Some(inner_107) = &self.message {
            write!(f, ": {}", inner_107)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointQuotaExceededFault {}
/// See [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault)
pub mod db_cluster_endpoint_quota_exceeded_fault {
    /// A builder for [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault)
        pub fn build(self) -> crate::error::DbClusterEndpointQuotaExceededFault {
            crate::error::DbClusterEndpointQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterEndpointQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder {
        crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified custom endpoint can't be created because it already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterEndpointAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterEndpointAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterEndpointAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointAlreadyExistsFault [DBClusterEndpointAlreadyExistsFault]"
        )?;
        if let Some(inner_108) = &self.message {
            write!(f, ": {}", inner_108)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointAlreadyExistsFault {}
/// See [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault)
pub mod db_cluster_endpoint_already_exists_fault {
    /// A builder for [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbClusterEndpointAlreadyExistsFault {
            crate::error::DbClusterEndpointAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterEndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_endpoint_already_exists_fault::Builder {
        crate::error::db_cluster_endpoint_already_exists_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of custom Availability Zones.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneQuotaExceededFault")?;
        if let Some(inner_109) = &self.message {
            write!(f, ": {}", inner_109)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneQuotaExceededFault {}
/// See [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
pub mod custom_availability_zone_quota_exceeded_fault {
    /// A builder for [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneQuotaExceededFault {
            crate::error::CustomAvailabilityZoneQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneQuotaExceededFault`](crate::error::CustomAvailabilityZoneQuotaExceededFault)
    pub fn builder() -> crate::error::custom_availability_zone_quota_exceeded_fault::Builder {
        crate::error::custom_availability_zone_quota_exceeded_fault::Builder::default()
    }
}

/// <p>
/// <code>CustomAvailabilityZoneName</code> is already used by an existing custom
/// Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomAvailabilityZoneAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomAvailabilityZoneAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomAvailabilityZoneAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomAvailabilityZoneAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomAvailabilityZoneAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomAvailabilityZoneAlreadyExistsFault")?;
        if let Some(inner_110) = &self.message {
            write!(f, ": {}", inner_110)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomAvailabilityZoneAlreadyExistsFault {}
/// See [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
pub mod custom_availability_zone_already_exists_fault {
    /// A builder for [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
        pub fn build(self) -> crate::error::CustomAvailabilityZoneAlreadyExistsFault {
            crate::error::CustomAvailabilityZoneAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CustomAvailabilityZoneAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CustomAvailabilityZoneAlreadyExistsFault`](crate::error::CustomAvailabilityZoneAlreadyExistsFault)
    pub fn builder() -> crate::error::custom_availability_zone_already_exists_fault::Builder {
        crate::error::custom_availability_zone_already_exists_fault::Builder::default()
    }
}

/// <p>You can't cancel an export task that has completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportTaskStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportTaskStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportTaskStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportTaskStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportTaskStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportTaskStateFault")?;
        if let Some(inner_111) = &self.message {
            write!(f, ": {}", inner_111)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportTaskStateFault {}
/// See [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
pub mod invalid_export_task_state_fault {
    /// A builder for [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
        pub fn build(self) -> crate::error::InvalidExportTaskStateFault {
            crate::error::InvalidExportTaskStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidExportTaskStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidExportTaskStateFault`](crate::error::InvalidExportTaskStateFault)
    pub fn builder() -> crate::error::invalid_export_task_state_fault::Builder {
        crate::error::invalid_export_task_state_fault::Builder::default()
    }
}

/// <p>The DB security group authorization quota has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationQuotaExceededFault")?;
        if let Some(inner_112) = &self.message {
            write!(f, ": {}", inner_112)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationQuotaExceededFault {}
/// See [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
pub mod authorization_quota_exceeded_fault {
    /// A builder for [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
        pub fn build(self) -> crate::error::AuthorizationQuotaExceededFault {
            crate::error::AuthorizationQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault)
    pub fn builder() -> crate::error::authorization_quota_exceeded_fault::Builder {
        crate::error::authorization_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group is already authorized for
/// the specified DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationAlreadyExistsFault")?;
        if let Some(inner_113) = &self.message {
            write!(f, ": {}", inner_113)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationAlreadyExistsFault {}
/// See [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
pub mod authorization_already_exists_fault {
    /// A builder for [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
        pub fn build(self) -> crate::error::AuthorizationAlreadyExistsFault {
            crate::error::AuthorizationAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    pub fn builder() -> crate::error::authorization_already_exists_fault::Builder {
        crate::error::authorization_already_exists_fault::Builder::default()
    }
}

/// <p>You can't associate any more Amazon Web Services Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceRoleQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceRoleQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceRoleQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceRoleQuotaExceededFault [DBInstanceRoleQuotaExceededFault]"
        )?;
        if let Some(inner_114) = &self.message {
            write!(f, ": {}", inner_114)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceRoleQuotaExceededFault {}
/// See [`DbInstanceRoleQuotaExceededFault`](crate::error::DbInstanceRoleQuotaExceededFault)
pub mod db_instance_role_quota_exceeded_fault {
    /// A builder for [`DbInstanceRoleQuotaExceededFault`](crate::error::DbInstanceRoleQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceRoleQuotaExceededFault`](crate::error::DbInstanceRoleQuotaExceededFault)
        pub fn build(self) -> crate::error::DbInstanceRoleQuotaExceededFault {
            crate::error::DbInstanceRoleQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceRoleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceRoleQuotaExceededFault`](crate::error::DbInstanceRoleQuotaExceededFault)
    pub fn builder() -> crate::error::db_instance_role_quota_exceeded_fault::Builder {
        crate::error::db_instance_role_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified <code>RoleArn</code> or <code>FeatureName</code> value is already associated with the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbInstanceRoleAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbInstanceRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbInstanceRoleAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbInstanceRoleAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceRoleAlreadyExistsFault [DBInstanceRoleAlreadyExistsFault]"
        )?;
        if let Some(inner_115) = &self.message {
            write!(f, ": {}", inner_115)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceRoleAlreadyExistsFault {}
/// See [`DbInstanceRoleAlreadyExistsFault`](crate::error::DbInstanceRoleAlreadyExistsFault)
pub mod db_instance_role_already_exists_fault {
    /// A builder for [`DbInstanceRoleAlreadyExistsFault`](crate::error::DbInstanceRoleAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceRoleAlreadyExistsFault`](crate::error::DbInstanceRoleAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbInstanceRoleAlreadyExistsFault {
            crate::error::DbInstanceRoleAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbInstanceRoleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceRoleAlreadyExistsFault`](crate::error::DbInstanceRoleAlreadyExistsFault)
    pub fn builder() -> crate::error::db_instance_role_already_exists_fault::Builder {
        crate::error::db_instance_role_already_exists_fault::Builder::default()
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterRoleQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterRoleQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterRoleQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterRoleQuotaExceededFault [DBClusterRoleQuotaExceededFault]"
        )?;
        if let Some(inner_116) = &self.message {
            write!(f, ": {}", inner_116)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleQuotaExceededFault {}
/// See [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault)
pub mod db_cluster_role_quota_exceeded_fault {
    /// A builder for [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault)
        pub fn build(self) -> crate::error::DbClusterRoleQuotaExceededFault {
            crate::error::DbClusterRoleQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterRoleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault)
    pub fn builder() -> crate::error::db_cluster_role_quota_exceeded_fault::Builder {
        crate::error::db_cluster_role_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DbClusterRoleAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DbClusterRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DbClusterRoleAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DbClusterRoleAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterRoleAlreadyExistsFault [DBClusterRoleAlreadyExistsFault]"
        )?;
        if let Some(inner_117) = &self.message {
            write!(f, ": {}", inner_117)?;
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleAlreadyExistsFault {}
/// See [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault)
pub mod db_cluster_role_already_exists_fault {
    /// A builder for [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault)
        pub fn build(self) -> crate::error::DbClusterRoleAlreadyExistsFault {
            crate::error::DbClusterRoleAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DbClusterRoleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault)
    pub fn builder() -> crate::error::db_cluster_role_already_exists_fault::Builder {
        crate::error::db_cluster_role_already_exists_fault::Builder::default()
    }
}
