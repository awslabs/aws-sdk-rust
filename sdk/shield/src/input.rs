// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AssociateDrtLogBucketInput`](crate::input::AssociateDrtLogBucketInput)
pub mod associate_drt_log_bucket_input {
    /// A builder for [`AssociateDrtLogBucketInput`](crate::input::AssociateDrtLogBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_bucket: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket that contains the logs that you want to share.</p>
        pub fn log_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_bucket = Some(input.into());
            self
        }
        pub fn set_log_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateDrtLogBucketInput`](crate::input::AssociateDrtLogBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateDrtLogBucketInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateDrtLogBucketInput {
                log_bucket: self.log_bucket,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateDrtLogBucketInputOperationOutputAlias = crate::operation::AssociateDRTLogBucket;
#[doc(hidden)]
pub type AssociateDrtLogBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssociateDrtLogBucketInput {
    /// Consumes the builder and constructs an Operation<[`AssociateDRTLogBucket`](crate::operation::AssociateDRTLogBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateDRTLogBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateDrtLogBucketInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateDrtLogBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateDrtLogBucketInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.AssociateDRTLogBucket",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_drt_log_bucket(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateDRTLogBucket::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "AssociateDRTLogBucket",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateDrtLogBucketInput`](crate::input::AssociateDrtLogBucketInput)
    pub fn builder() -> crate::input::associate_drt_log_bucket_input::Builder {
        crate::input::associate_drt_log_bucket_input::Builder::default()
    }
}

/// See [`AssociateDrtRoleInput`](crate::input::AssociateDrtRoleInput)
pub mod associate_drt_role_input {
    /// A builder for [`AssociateDrtRoleInput`](crate::input::AssociateDrtRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role the SRT will use to access your Amazon Web Services account.</p>
        /// <p>Prior to making the <code>AssociateDRTRole</code> request, you must attach the <a href="https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy">AWSShieldDRTAccessPolicy</a> managed policy to this role.  For more information see <a href=" https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html">Attaching and Detaching IAM Policies</a>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateDrtRoleInput`](crate::input::AssociateDrtRoleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateDrtRoleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateDrtRoleInput {
                role_arn: self.role_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateDrtRoleInputOperationOutputAlias = crate::operation::AssociateDRTRole;
#[doc(hidden)]
pub type AssociateDrtRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssociateDrtRoleInput {
    /// Consumes the builder and constructs an Operation<[`AssociateDRTRole`](crate::operation::AssociateDRTRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateDRTRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateDrtRoleInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateDrtRoleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateDrtRoleInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.AssociateDRTRole",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_drt_role(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateDRTRole::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "AssociateDRTRole",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateDrtRoleInput`](crate::input::AssociateDrtRoleInput)
    pub fn builder() -> crate::input::associate_drt_role_input::Builder {
        crate::input::associate_drt_role_input::Builder::default()
    }
}

/// See [`AssociateHealthCheckInput`](crate::input::AssociateHealthCheckInput)
pub mod associate_health_check_input {
    /// A builder for [`AssociateHealthCheckInput`](crate::input::AssociateHealthCheckInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_id: std::option::Option<std::string::String>,
        pub(crate) health_check_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier (ID) for the <a>Protection</a> object to add the health check association to. </p>
        pub fn protection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_id = Some(input.into());
            self
        }
        pub fn set_protection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the health check to associate with the protection.</p>
        pub fn health_check_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_check_arn = Some(input.into());
            self
        }
        pub fn set_health_check_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_check_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateHealthCheckInput`](crate::input::AssociateHealthCheckInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateHealthCheckInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateHealthCheckInput {
                protection_id: self.protection_id,
                health_check_arn: self.health_check_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateHealthCheckInputOperationOutputAlias = crate::operation::AssociateHealthCheck;
#[doc(hidden)]
pub type AssociateHealthCheckInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssociateHealthCheckInput {
    /// Consumes the builder and constructs an Operation<[`AssociateHealthCheck`](crate::operation::AssociateHealthCheck)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateHealthCheck,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateHealthCheckInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateHealthCheckInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateHealthCheckInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.AssociateHealthCheck",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_health_check(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateHealthCheck::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "AssociateHealthCheck",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateHealthCheckInput`](crate::input::AssociateHealthCheckInput)
    pub fn builder() -> crate::input::associate_health_check_input::Builder {
        crate::input::associate_health_check_input::Builder::default()
    }
}

/// See [`AssociateProactiveEngagementDetailsInput`](crate::input::AssociateProactiveEngagementDetailsInput)
pub mod associate_proactive_engagement_details_input {
    /// A builder for [`AssociateProactiveEngagementDetailsInput`](crate::input::AssociateProactiveEngagementDetailsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) emergency_contact_list:
            std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
    }
    impl Builder {
        pub fn emergency_contact_list(
            mut self,
            input: impl Into<crate::model::EmergencyContact>,
        ) -> Self {
            let mut v = self.emergency_contact_list.unwrap_or_default();
            v.push(input.into());
            self.emergency_contact_list = Some(v);
            self
        }
        pub fn set_emergency_contact_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
        ) -> Self {
            self.emergency_contact_list = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateProactiveEngagementDetailsInput`](crate::input::AssociateProactiveEngagementDetailsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateProactiveEngagementDetailsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateProactiveEngagementDetailsInput {
                emergency_contact_list: self.emergency_contact_list,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateProactiveEngagementDetailsInputOperationOutputAlias =
    crate::operation::AssociateProactiveEngagementDetails;
#[doc(hidden)]
pub type AssociateProactiveEngagementDetailsInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl AssociateProactiveEngagementDetailsInput {
    /// Consumes the builder and constructs an Operation<[`AssociateProactiveEngagementDetails`](crate::operation::AssociateProactiveEngagementDetails)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateProactiveEngagementDetails,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateProactiveEngagementDetailsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateProactiveEngagementDetailsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateProactiveEngagementDetailsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.AssociateProactiveEngagementDetails",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_proactive_engagement_details(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateProactiveEngagementDetails::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "AssociateProactiveEngagementDetails",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateProactiveEngagementDetailsInput`](crate::input::AssociateProactiveEngagementDetailsInput)
    pub fn builder() -> crate::input::associate_proactive_engagement_details_input::Builder {
        crate::input::associate_proactive_engagement_details_input::Builder::default()
    }
}

/// See [`CreateProtectionInput`](crate::input::CreateProtectionInput)
pub mod create_protection_input {
    /// A builder for [`CreateProtectionInput`](crate::input::CreateProtectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>Friendly name for the <code>Protection</code> you are creating.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN (Amazon Resource Name) of the resource to be protected.</p>
        /// <p>The ARN should be in one of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Elastic Load Balancer (Classic Load Balancer): <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/<i>load-balancer-name</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Amazon CloudFront distribution: <code>arn:aws:cloudfront::<i>account-id</i>:distribution/<i>distribution-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Global Accelerator accelerator: <code>arn:aws:globalaccelerator::<i>account-id</i>:accelerator/<i>accelerator-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For Amazon Route 53: <code>arn:aws:route53:::hostedzone/<i>hosted-zone-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Elastic IP address: <code>arn:aws:ec2:<i>region</i>:<i>account-id</i>:eip-allocation/<i>allocation-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProtectionInput`](crate::input::CreateProtectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProtectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProtectionInput {
                name: self.name,
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProtectionInputOperationOutputAlias = crate::operation::CreateProtection;
#[doc(hidden)]
pub type CreateProtectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProtectionInput {
    /// Consumes the builder and constructs an Operation<[`CreateProtection`](crate::operation::CreateProtection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateProtection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateProtectionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateProtectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateProtectionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.CreateProtection",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_protection(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProtection::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateProtection",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProtectionInput`](crate::input::CreateProtectionInput)
    pub fn builder() -> crate::input::create_protection_input::Builder {
        crate::input::create_protection_input::Builder::default()
    }
}

/// See [`CreateProtectionGroupInput`](crate::input::CreateProtectionGroupInput)
pub mod create_protection_group_input {
    /// A builder for [`CreateProtectionGroupInput`](crate::input::CreateProtectionGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_group_id: std::option::Option<std::string::String>,
        pub(crate) aggregation: std::option::Option<crate::model::ProtectionGroupAggregation>,
        pub(crate) pattern: std::option::Option<crate::model::ProtectionGroupPattern>,
        pub(crate) resource_type: std::option::Option<crate::model::ProtectedResourceType>,
        pub(crate) members: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
        pub fn protection_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_group_id = Some(input.into());
            self
        }
        pub fn set_protection_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_group_id = input;
            self
        }
        /// <p>Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
        /// <ul>
        /// <li>
        /// <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
        /// </li>
        /// <li>
        /// <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
        /// </li>
        /// <li>
        /// <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront and origin resources for CloudFront distributions.</p>
        /// </li>
        /// </ul>
        pub fn aggregation(mut self, input: crate::model::ProtectionGroupAggregation) -> Self {
            self.aggregation = Some(input);
            self
        }
        pub fn set_aggregation(
            mut self,
            input: std::option::Option<crate::model::ProtectionGroupAggregation>,
        ) -> Self {
            self.aggregation = input;
            self
        }
        /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type. </p>
        pub fn pattern(mut self, input: crate::model::ProtectionGroupPattern) -> Self {
            self.pattern = Some(input);
            self
        }
        pub fn set_pattern(
            mut self,
            input: std::option::Option<crate::model::ProtectionGroupPattern>,
        ) -> Self {
            self.pattern = input;
            self
        }
        /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group.
        /// You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
        pub fn resource_type(mut self, input: crate::model::ProtectedResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ProtectedResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn members(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.members.unwrap_or_default();
            v.push(input.into());
            self.members = Some(v);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.members = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProtectionGroupInput`](crate::input::CreateProtectionGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProtectionGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProtectionGroupInput {
                protection_group_id: self.protection_group_id,
                aggregation: self.aggregation,
                pattern: self.pattern,
                resource_type: self.resource_type,
                members: self.members,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProtectionGroupInputOperationOutputAlias = crate::operation::CreateProtectionGroup;
#[doc(hidden)]
pub type CreateProtectionGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProtectionGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateProtectionGroup`](crate::operation::CreateProtectionGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateProtectionGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateProtectionGroupInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateProtectionGroupInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateProtectionGroupInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.CreateProtectionGroup",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_protection_group(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProtectionGroup::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateProtectionGroup",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProtectionGroupInput`](crate::input::CreateProtectionGroupInput)
    pub fn builder() -> crate::input::create_protection_group_input::Builder {
        crate::input::create_protection_group_input::Builder::default()
    }
}

/// See [`CreateSubscriptionInput`](crate::input::CreateSubscriptionInput)
pub mod create_subscription_input {
    /// A builder for [`CreateSubscriptionInput`](crate::input::CreateSubscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateSubscriptionInput`](crate::input::CreateSubscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSubscriptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSubscriptionInput {})
        }
    }
}
#[doc(hidden)]
pub type CreateSubscriptionInputOperationOutputAlias = crate::operation::CreateSubscription;
#[doc(hidden)]
pub type CreateSubscriptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscription`](crate::operation::CreateSubscription)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateSubscription,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateSubscriptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateSubscriptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateSubscriptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.CreateSubscription",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_subscription(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSubscription::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateSubscription",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriptionInput`](crate::input::CreateSubscriptionInput)
    pub fn builder() -> crate::input::create_subscription_input::Builder {
        crate::input::create_subscription_input::Builder::default()
    }
}

/// See [`DeleteProtectionInput`](crate::input::DeleteProtectionInput)
pub mod delete_protection_input {
    /// A builder for [`DeleteProtectionInput`](crate::input::DeleteProtectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier (ID) for the <a>Protection</a> object to be
        /// deleted.</p>
        pub fn protection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_id = Some(input.into());
            self
        }
        pub fn set_protection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProtectionInput`](crate::input::DeleteProtectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProtectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProtectionInput {
                protection_id: self.protection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProtectionInputOperationOutputAlias = crate::operation::DeleteProtection;
#[doc(hidden)]
pub type DeleteProtectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProtectionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProtection`](crate::operation::DeleteProtection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProtection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteProtectionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteProtectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteProtectionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DeleteProtection",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_protection(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProtection::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteProtection",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProtectionInput`](crate::input::DeleteProtectionInput)
    pub fn builder() -> crate::input::delete_protection_input::Builder {
        crate::input::delete_protection_input::Builder::default()
    }
}

/// See [`DeleteProtectionGroupInput`](crate::input::DeleteProtectionGroupInput)
pub mod delete_protection_group_input {
    /// A builder for [`DeleteProtectionGroupInput`](crate::input::DeleteProtectionGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
        pub fn protection_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_group_id = Some(input.into());
            self
        }
        pub fn set_protection_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProtectionGroupInput`](crate::input::DeleteProtectionGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProtectionGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProtectionGroupInput {
                protection_group_id: self.protection_group_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProtectionGroupInputOperationOutputAlias = crate::operation::DeleteProtectionGroup;
#[doc(hidden)]
pub type DeleteProtectionGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProtectionGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProtectionGroup`](crate::operation::DeleteProtectionGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProtectionGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteProtectionGroupInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteProtectionGroupInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteProtectionGroupInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DeleteProtectionGroup",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_protection_group(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProtectionGroup::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteProtectionGroup",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProtectionGroupInput`](crate::input::DeleteProtectionGroupInput)
    pub fn builder() -> crate::input::delete_protection_group_input::Builder {
        crate::input::delete_protection_group_input::Builder::default()
    }
}

/// See [`DeleteSubscriptionInput`](crate::input::DeleteSubscriptionInput)
pub mod delete_subscription_input {
    /// A builder for [`DeleteSubscriptionInput`](crate::input::DeleteSubscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteSubscriptionInput`](crate::input::DeleteSubscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSubscriptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSubscriptionInput {})
        }
    }
}
#[doc(hidden)]
pub type DeleteSubscriptionInputOperationOutputAlias = crate::operation::DeleteSubscription;
#[doc(hidden)]
pub type DeleteSubscriptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscription`](crate::operation::DeleteSubscription)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSubscription,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteSubscriptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteSubscriptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteSubscriptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DeleteSubscription",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_subscription(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSubscription::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteSubscription",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionInput`](crate::input::DeleteSubscriptionInput)
    pub fn builder() -> crate::input::delete_subscription_input::Builder {
        crate::input::delete_subscription_input::Builder::default()
    }
}

/// See [`DescribeAttackInput`](crate::input::DescribeAttackInput)
pub mod describe_attack_input {
    /// A builder for [`DescribeAttackInput`](crate::input::DescribeAttackInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attack_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier (ID) for the attack that to be described.</p>
        pub fn attack_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attack_id = Some(input.into());
            self
        }
        pub fn set_attack_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attack_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAttackInput`](crate::input::DescribeAttackInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAttackInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAttackInput {
                attack_id: self.attack_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAttackInputOperationOutputAlias = crate::operation::DescribeAttack;
#[doc(hidden)]
pub type DescribeAttackInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAttackInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAttack`](crate::operation::DescribeAttack)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeAttack,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAttackInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAttackInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAttackInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeAttack",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_describe_attack(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAttack::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeAttack",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAttackInput`](crate::input::DescribeAttackInput)
    pub fn builder() -> crate::input::describe_attack_input::Builder {
        crate::input::describe_attack_input::Builder::default()
    }
}

/// See [`DescribeAttackStatisticsInput`](crate::input::DescribeAttackStatisticsInput)
pub mod describe_attack_statistics_input {
    /// A builder for [`DescribeAttackStatisticsInput`](crate::input::DescribeAttackStatisticsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeAttackStatisticsInput`](crate::input::DescribeAttackStatisticsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAttackStatisticsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAttackStatisticsInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeAttackStatisticsInputOperationOutputAlias =
    crate::operation::DescribeAttackStatistics;
#[doc(hidden)]
pub type DescribeAttackStatisticsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAttackStatisticsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAttackStatistics`](crate::operation::DescribeAttackStatistics)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeAttackStatistics,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAttackStatisticsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAttackStatisticsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAttackStatisticsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeAttackStatistics",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_attack_statistics(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAttackStatistics::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeAttackStatistics",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAttackStatisticsInput`](crate::input::DescribeAttackStatisticsInput)
    pub fn builder() -> crate::input::describe_attack_statistics_input::Builder {
        crate::input::describe_attack_statistics_input::Builder::default()
    }
}

/// See [`DescribeDrtAccessInput`](crate::input::DescribeDrtAccessInput)
pub mod describe_drt_access_input {
    /// A builder for [`DescribeDrtAccessInput`](crate::input::DescribeDrtAccessInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeDrtAccessInput`](crate::input::DescribeDrtAccessInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDrtAccessInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDrtAccessInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeDrtAccessInputOperationOutputAlias = crate::operation::DescribeDRTAccess;
#[doc(hidden)]
pub type DescribeDrtAccessInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeDrtAccessInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDRTAccess`](crate::operation::DescribeDRTAccess)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeDRTAccess,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeDrtAccessInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeDrtAccessInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeDrtAccessInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeDRTAccess",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_drt_access(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDRTAccess::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeDRTAccess",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeDrtAccessInput`](crate::input::DescribeDrtAccessInput)
    pub fn builder() -> crate::input::describe_drt_access_input::Builder {
        crate::input::describe_drt_access_input::Builder::default()
    }
}

/// See [`DescribeEmergencyContactSettingsInput`](crate::input::DescribeEmergencyContactSettingsInput)
pub mod describe_emergency_contact_settings_input {
    /// A builder for [`DescribeEmergencyContactSettingsInput`](crate::input::DescribeEmergencyContactSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeEmergencyContactSettingsInput`](crate::input::DescribeEmergencyContactSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeEmergencyContactSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeEmergencyContactSettingsInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeEmergencyContactSettingsInputOperationOutputAlias =
    crate::operation::DescribeEmergencyContactSettings;
#[doc(hidden)]
pub type DescribeEmergencyContactSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeEmergencyContactSettingsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeEmergencyContactSettings`](crate::operation::DescribeEmergencyContactSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeEmergencyContactSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeEmergencyContactSettingsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeEmergencyContactSettingsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeEmergencyContactSettingsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeEmergencyContactSettings",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_emergency_contact_settings(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeEmergencyContactSettings::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeEmergencyContactSettings",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeEmergencyContactSettingsInput`](crate::input::DescribeEmergencyContactSettingsInput)
    pub fn builder() -> crate::input::describe_emergency_contact_settings_input::Builder {
        crate::input::describe_emergency_contact_settings_input::Builder::default()
    }
}

/// See [`DescribeProtectionInput`](crate::input::DescribeProtectionInput)
pub mod describe_protection_input {
    /// A builder for [`DescribeProtectionInput`](crate::input::DescribeProtectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier (ID) for the <a>Protection</a> object that is
        /// described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
        pub fn protection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_id = Some(input.into());
            self
        }
        pub fn set_protection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_id = input;
            self
        }
        /// <p>The ARN (Amazon Resource Name) of the Amazon Web Services resource for the <a>Protection</a> object that is
        /// described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProtectionInput`](crate::input::DescribeProtectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProtectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProtectionInput {
                protection_id: self.protection_id,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProtectionInputOperationOutputAlias = crate::operation::DescribeProtection;
#[doc(hidden)]
pub type DescribeProtectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProtectionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProtection`](crate::operation::DescribeProtection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeProtection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeProtectionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeProtectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeProtectionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeProtection",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_protection(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProtection::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeProtection",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProtectionInput`](crate::input::DescribeProtectionInput)
    pub fn builder() -> crate::input::describe_protection_input::Builder {
        crate::input::describe_protection_input::Builder::default()
    }
}

/// See [`DescribeProtectionGroupInput`](crate::input::DescribeProtectionGroupInput)
pub mod describe_protection_group_input {
    /// A builder for [`DescribeProtectionGroupInput`](crate::input::DescribeProtectionGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
        pub fn protection_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_group_id = Some(input.into());
            self
        }
        pub fn set_protection_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProtectionGroupInput`](crate::input::DescribeProtectionGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProtectionGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProtectionGroupInput {
                protection_group_id: self.protection_group_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProtectionGroupInputOperationOutputAlias =
    crate::operation::DescribeProtectionGroup;
#[doc(hidden)]
pub type DescribeProtectionGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProtectionGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProtectionGroup`](crate::operation::DescribeProtectionGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeProtectionGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeProtectionGroupInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeProtectionGroupInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeProtectionGroupInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeProtectionGroup",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_protection_group(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProtectionGroup::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeProtectionGroup",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProtectionGroupInput`](crate::input::DescribeProtectionGroupInput)
    pub fn builder() -> crate::input::describe_protection_group_input::Builder {
        crate::input::describe_protection_group_input::Builder::default()
    }
}

/// See [`DescribeSubscriptionInput`](crate::input::DescribeSubscriptionInput)
pub mod describe_subscription_input {
    /// A builder for [`DescribeSubscriptionInput`](crate::input::DescribeSubscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeSubscriptionInput`](crate::input::DescribeSubscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeSubscriptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeSubscriptionInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeSubscriptionInputOperationOutputAlias = crate::operation::DescribeSubscription;
#[doc(hidden)]
pub type DescribeSubscriptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSubscription`](crate::operation::DescribeSubscription)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeSubscription,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeSubscriptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeSubscriptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeSubscriptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DescribeSubscription",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_subscription(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeSubscription::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeSubscription",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeSubscriptionInput`](crate::input::DescribeSubscriptionInput)
    pub fn builder() -> crate::input::describe_subscription_input::Builder {
        crate::input::describe_subscription_input::Builder::default()
    }
}

/// See [`DisableProactiveEngagementInput`](crate::input::DisableProactiveEngagementInput)
pub mod disable_proactive_engagement_input {
    /// A builder for [`DisableProactiveEngagementInput`](crate::input::DisableProactiveEngagementInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DisableProactiveEngagementInput`](crate::input::DisableProactiveEngagementInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisableProactiveEngagementInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisableProactiveEngagementInput {})
        }
    }
}
#[doc(hidden)]
pub type DisableProactiveEngagementInputOperationOutputAlias =
    crate::operation::DisableProactiveEngagement;
#[doc(hidden)]
pub type DisableProactiveEngagementInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisableProactiveEngagementInput {
    /// Consumes the builder and constructs an Operation<[`DisableProactiveEngagement`](crate::operation::DisableProactiveEngagement)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisableProactiveEngagement,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisableProactiveEngagementInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisableProactiveEngagementInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisableProactiveEngagementInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DisableProactiveEngagement",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disable_proactive_engagement(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DisableProactiveEngagement::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DisableProactiveEngagement",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisableProactiveEngagementInput`](crate::input::DisableProactiveEngagementInput)
    pub fn builder() -> crate::input::disable_proactive_engagement_input::Builder {
        crate::input::disable_proactive_engagement_input::Builder::default()
    }
}

/// See [`DisassociateDrtLogBucketInput`](crate::input::DisassociateDrtLogBucketInput)
pub mod disassociate_drt_log_bucket_input {
    /// A builder for [`DisassociateDrtLogBucketInput`](crate::input::DisassociateDrtLogBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_bucket: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket that contains the logs that you want to share.</p>
        pub fn log_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_bucket = Some(input.into());
            self
        }
        pub fn set_log_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateDrtLogBucketInput`](crate::input::DisassociateDrtLogBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateDrtLogBucketInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateDrtLogBucketInput {
                log_bucket: self.log_bucket,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateDrtLogBucketInputOperationOutputAlias =
    crate::operation::DisassociateDRTLogBucket;
#[doc(hidden)]
pub type DisassociateDrtLogBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateDrtLogBucketInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateDRTLogBucket`](crate::operation::DisassociateDRTLogBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateDRTLogBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateDrtLogBucketInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateDrtLogBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateDrtLogBucketInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DisassociateDRTLogBucket",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disassociate_drt_log_bucket(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateDRTLogBucket::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DisassociateDRTLogBucket",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateDrtLogBucketInput`](crate::input::DisassociateDrtLogBucketInput)
    pub fn builder() -> crate::input::disassociate_drt_log_bucket_input::Builder {
        crate::input::disassociate_drt_log_bucket_input::Builder::default()
    }
}

/// See [`DisassociateDrtRoleInput`](crate::input::DisassociateDrtRoleInput)
pub mod disassociate_drt_role_input {
    /// A builder for [`DisassociateDrtRoleInput`](crate::input::DisassociateDrtRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateDrtRoleInput`](crate::input::DisassociateDrtRoleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateDrtRoleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateDrtRoleInput {})
        }
    }
}
#[doc(hidden)]
pub type DisassociateDrtRoleInputOperationOutputAlias = crate::operation::DisassociateDRTRole;
#[doc(hidden)]
pub type DisassociateDrtRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateDrtRoleInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateDRTRole`](crate::operation::DisassociateDRTRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateDRTRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateDrtRoleInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateDrtRoleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateDrtRoleInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DisassociateDRTRole",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disassociate_drt_role(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateDRTRole::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DisassociateDRTRole",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateDrtRoleInput`](crate::input::DisassociateDrtRoleInput)
    pub fn builder() -> crate::input::disassociate_drt_role_input::Builder {
        crate::input::disassociate_drt_role_input::Builder::default()
    }
}

/// See [`DisassociateHealthCheckInput`](crate::input::DisassociateHealthCheckInput)
pub mod disassociate_health_check_input {
    /// A builder for [`DisassociateHealthCheckInput`](crate::input::DisassociateHealthCheckInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_id: std::option::Option<std::string::String>,
        pub(crate) health_check_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier (ID) for the <a>Protection</a> object to remove the health check association from. </p>
        pub fn protection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_id = Some(input.into());
            self
        }
        pub fn set_protection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the health check that is associated with the protection.</p>
        pub fn health_check_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_check_arn = Some(input.into());
            self
        }
        pub fn set_health_check_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_check_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateHealthCheckInput`](crate::input::DisassociateHealthCheckInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateHealthCheckInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateHealthCheckInput {
                protection_id: self.protection_id,
                health_check_arn: self.health_check_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateHealthCheckInputOperationOutputAlias =
    crate::operation::DisassociateHealthCheck;
#[doc(hidden)]
pub type DisassociateHealthCheckInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateHealthCheckInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateHealthCheck`](crate::operation::DisassociateHealthCheck)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateHealthCheck,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateHealthCheckInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateHealthCheckInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateHealthCheckInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.DisassociateHealthCheck",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disassociate_health_check(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateHealthCheck::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DisassociateHealthCheck",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateHealthCheckInput`](crate::input::DisassociateHealthCheckInput)
    pub fn builder() -> crate::input::disassociate_health_check_input::Builder {
        crate::input::disassociate_health_check_input::Builder::default()
    }
}

/// See [`EnableProactiveEngagementInput`](crate::input::EnableProactiveEngagementInput)
pub mod enable_proactive_engagement_input {
    /// A builder for [`EnableProactiveEngagementInput`](crate::input::EnableProactiveEngagementInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EnableProactiveEngagementInput`](crate::input::EnableProactiveEngagementInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::EnableProactiveEngagementInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::EnableProactiveEngagementInput {})
        }
    }
}
#[doc(hidden)]
pub type EnableProactiveEngagementInputOperationOutputAlias =
    crate::operation::EnableProactiveEngagement;
#[doc(hidden)]
pub type EnableProactiveEngagementInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl EnableProactiveEngagementInput {
    /// Consumes the builder and constructs an Operation<[`EnableProactiveEngagement`](crate::operation::EnableProactiveEngagement)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::EnableProactiveEngagement,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::EnableProactiveEngagementInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::EnableProactiveEngagementInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::EnableProactiveEngagementInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.EnableProactiveEngagement",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_enable_proactive_engagement(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::EnableProactiveEngagement::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "EnableProactiveEngagement",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`EnableProactiveEngagementInput`](crate::input::EnableProactiveEngagementInput)
    pub fn builder() -> crate::input::enable_proactive_engagement_input::Builder {
        crate::input::enable_proactive_engagement_input::Builder::default()
    }
}

/// See [`GetSubscriptionStateInput`](crate::input::GetSubscriptionStateInput)
pub mod get_subscription_state_input {
    /// A builder for [`GetSubscriptionStateInput`](crate::input::GetSubscriptionStateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetSubscriptionStateInput`](crate::input::GetSubscriptionStateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSubscriptionStateInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSubscriptionStateInput {})
        }
    }
}
#[doc(hidden)]
pub type GetSubscriptionStateInputOperationOutputAlias = crate::operation::GetSubscriptionState;
#[doc(hidden)]
pub type GetSubscriptionStateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSubscriptionStateInput {
    /// Consumes the builder and constructs an Operation<[`GetSubscriptionState`](crate::operation::GetSubscriptionState)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetSubscriptionState,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetSubscriptionStateInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetSubscriptionStateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetSubscriptionStateInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.GetSubscriptionState",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_subscription_state(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSubscriptionState::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetSubscriptionState",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSubscriptionStateInput`](crate::input::GetSubscriptionStateInput)
    pub fn builder() -> crate::input::get_subscription_state_input::Builder {
        crate::input::get_subscription_state_input::Builder::default()
    }
}

/// See [`ListAttacksInput`](crate::input::ListAttacksInput)
pub mod list_attacks_input {
    /// A builder for [`ListAttacksInput`](crate::input::ListAttacksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) start_time: std::option::Option<crate::model::TimeRange>,
        pub(crate) end_time: std::option::Option<crate::model::TimeRange>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        pub fn resource_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arns.unwrap_or_default();
            v.push(input.into());
            self.resource_arns = Some(v);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arns = input;
            self
        }
        /// <p>The start of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
        pub fn start_time(mut self, input: crate::model::TimeRange) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(
            mut self,
            input: std::option::Option<crate::model::TimeRange>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
        pub fn end_time(mut self, input: crate::model::TimeRange) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<crate::model::TimeRange>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The <code>ListAttacksRequest.NextMarker</code> value from a previous call to <code>ListAttacksRequest</code>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of <a>AttackSummary</a> objects to return. If you leave this blank,
        /// Shield Advanced returns the first 20 results.</p>
        /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttacksInput`](crate::input::ListAttacksInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListAttacksInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAttacksInput {
                resource_arns: self.resource_arns,
                start_time: self.start_time,
                end_time: self.end_time,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttacksInputOperationOutputAlias = crate::operation::ListAttacks;
#[doc(hidden)]
pub type ListAttacksInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAttacksInput {
    /// Consumes the builder and constructs an Operation<[`ListAttacks`](crate::operation::ListAttacks)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListAttacks,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListAttacksInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListAttacksInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListAttacksInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.ListAttacks",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_attacks(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListAttacks::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "ListAttacks",
                    "shield",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAttacksInput`](crate::input::ListAttacksInput)
    pub fn builder() -> crate::input::list_attacks_input::Builder {
        crate::input::list_attacks_input::Builder::default()
    }
}

/// See [`ListProtectionGroupsInput`](crate::input::ListProtectionGroupsInput)
pub mod list_protection_groups_input {
    /// A builder for [`ListProtectionGroupsInput`](crate::input::ListProtectionGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The next token value from a previous call to <code>ListProtectionGroups</code>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of <a>ProtectionGroup</a> objects to return. If you leave this blank,
        /// Shield Advanced returns the first 20 results.</p>
        /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProtectionGroupsInput`](crate::input::ListProtectionGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProtectionGroupsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProtectionGroupsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProtectionGroupsInputOperationOutputAlias = crate::operation::ListProtectionGroups;
#[doc(hidden)]
pub type ListProtectionGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProtectionGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListProtectionGroups`](crate::operation::ListProtectionGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProtectionGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListProtectionGroupsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListProtectionGroupsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListProtectionGroupsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.ListProtectionGroups",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_protection_groups(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProtectionGroups::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListProtectionGroups",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProtectionGroupsInput`](crate::input::ListProtectionGroupsInput)
    pub fn builder() -> crate::input::list_protection_groups_input::Builder {
        crate::input::list_protection_groups_input::Builder::default()
    }
}

/// See [`ListProtectionsInput`](crate::input::ListProtectionsInput)
pub mod list_protections_input {
    /// A builder for [`ListProtectionsInput`](crate::input::ListProtectionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The <code>ListProtectionsRequest.NextToken</code> value from a previous call to <code>ListProtections</code>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of <a>Protection</a> objects to return. If you leave this blank,
        /// Shield Advanced returns the first 20 results.</p>
        /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProtectionsInput`](crate::input::ListProtectionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProtectionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProtectionsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProtectionsInputOperationOutputAlias = crate::operation::ListProtections;
#[doc(hidden)]
pub type ListProtectionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProtectionsInput {
    /// Consumes the builder and constructs an Operation<[`ListProtections`](crate::operation::ListProtections)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProtections,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListProtectionsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListProtectionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListProtectionsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.ListProtections",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_protections(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProtections::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListProtections",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProtectionsInput`](crate::input::ListProtectionsInput)
    pub fn builder() -> crate::input::list_protections_input::Builder {
        crate::input::list_protections_input::Builder::default()
    }
}

/// See [`ListResourcesInProtectionGroupInput`](crate::input::ListResourcesInProtectionGroupInput)
pub mod list_resources_in_protection_group_input {
    /// A builder for [`ListResourcesInProtectionGroupInput`](crate::input::ListResourcesInProtectionGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_group_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
        pub fn protection_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_group_id = Some(input.into());
            self
        }
        pub fn set_protection_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_group_id = input;
            self
        }
        /// <p>The next token value from a previous call to <code>ListResourcesInProtectionGroup</code>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of resource ARN objects to return. If you leave this blank,
        /// Shield Advanced returns the first 20 results.</p>
        /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListResourcesInProtectionGroupInput`](crate::input::ListResourcesInProtectionGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListResourcesInProtectionGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListResourcesInProtectionGroupInput {
                protection_group_id: self.protection_group_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListResourcesInProtectionGroupInputOperationOutputAlias =
    crate::operation::ListResourcesInProtectionGroup;
#[doc(hidden)]
pub type ListResourcesInProtectionGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListResourcesInProtectionGroupInput {
    /// Consumes the builder and constructs an Operation<[`ListResourcesInProtectionGroup`](crate::operation::ListResourcesInProtectionGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListResourcesInProtectionGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListResourcesInProtectionGroupInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListResourcesInProtectionGroupInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListResourcesInProtectionGroupInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.ListResourcesInProtectionGroup",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_resources_in_protection_group(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListResourcesInProtectionGroup::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListResourcesInProtectionGroup",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListResourcesInProtectionGroupInput`](crate::input::ListResourcesInProtectionGroupInput)
    pub fn builder() -> crate::input::list_resources_in_protection_group_input::Builder {
        crate::input::list_resources_in_protection_group_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.ListTagsForResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.TagResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "TagResource",
                    "shield",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.UntagResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "UntagResource",
                    "shield",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateEmergencyContactSettingsInput`](crate::input::UpdateEmergencyContactSettingsInput)
pub mod update_emergency_contact_settings_input {
    /// A builder for [`UpdateEmergencyContactSettingsInput`](crate::input::UpdateEmergencyContactSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) emergency_contact_list:
            std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
    }
    impl Builder {
        pub fn emergency_contact_list(
            mut self,
            input: impl Into<crate::model::EmergencyContact>,
        ) -> Self {
            let mut v = self.emergency_contact_list.unwrap_or_default();
            v.push(input.into());
            self.emergency_contact_list = Some(v);
            self
        }
        pub fn set_emergency_contact_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
        ) -> Self {
            self.emergency_contact_list = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateEmergencyContactSettingsInput`](crate::input::UpdateEmergencyContactSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateEmergencyContactSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateEmergencyContactSettingsInput {
                emergency_contact_list: self.emergency_contact_list,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateEmergencyContactSettingsInputOperationOutputAlias =
    crate::operation::UpdateEmergencyContactSettings;
#[doc(hidden)]
pub type UpdateEmergencyContactSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateEmergencyContactSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateEmergencyContactSettings`](crate::operation::UpdateEmergencyContactSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateEmergencyContactSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateEmergencyContactSettingsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateEmergencyContactSettingsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateEmergencyContactSettingsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.UpdateEmergencyContactSettings",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_emergency_contact_settings(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateEmergencyContactSettings::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateEmergencyContactSettings",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateEmergencyContactSettingsInput`](crate::input::UpdateEmergencyContactSettingsInput)
    pub fn builder() -> crate::input::update_emergency_contact_settings_input::Builder {
        crate::input::update_emergency_contact_settings_input::Builder::default()
    }
}

/// See [`UpdateProtectionGroupInput`](crate::input::UpdateProtectionGroupInput)
pub mod update_protection_group_input {
    /// A builder for [`UpdateProtectionGroupInput`](crate::input::UpdateProtectionGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protection_group_id: std::option::Option<std::string::String>,
        pub(crate) aggregation: std::option::Option<crate::model::ProtectionGroupAggregation>,
        pub(crate) pattern: std::option::Option<crate::model::ProtectionGroupPattern>,
        pub(crate) resource_type: std::option::Option<crate::model::ProtectedResourceType>,
        pub(crate) members: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
        pub fn protection_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.protection_group_id = Some(input.into());
            self
        }
        pub fn set_protection_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protection_group_id = input;
            self
        }
        /// <p>Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
        /// <ul>
        /// <li>
        /// <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
        /// </li>
        /// <li>
        /// <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
        /// </li>
        /// <li>
        /// <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.</p>
        /// </li>
        /// </ul>
        pub fn aggregation(mut self, input: crate::model::ProtectionGroupAggregation) -> Self {
            self.aggregation = Some(input);
            self
        }
        pub fn set_aggregation(
            mut self,
            input: std::option::Option<crate::model::ProtectionGroupAggregation>,
        ) -> Self {
            self.aggregation = input;
            self
        }
        /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.</p>
        pub fn pattern(mut self, input: crate::model::ProtectionGroupPattern) -> Self {
            self.pattern = Some(input);
            self
        }
        pub fn set_pattern(
            mut self,
            input: std::option::Option<crate::model::ProtectionGroupPattern>,
        ) -> Self {
            self.pattern = input;
            self
        }
        /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group.
        /// You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
        pub fn resource_type(mut self, input: crate::model::ProtectedResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ProtectedResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn members(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.members.unwrap_or_default();
            v.push(input.into());
            self.members = Some(v);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.members = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProtectionGroupInput`](crate::input::UpdateProtectionGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateProtectionGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateProtectionGroupInput {
                protection_group_id: self.protection_group_id,
                aggregation: self.aggregation,
                pattern: self.pattern,
                resource_type: self.resource_type,
                members: self.members,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateProtectionGroupInputOperationOutputAlias = crate::operation::UpdateProtectionGroup;
#[doc(hidden)]
pub type UpdateProtectionGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateProtectionGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProtectionGroup`](crate::operation::UpdateProtectionGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateProtectionGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateProtectionGroupInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateProtectionGroupInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateProtectionGroupInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.UpdateProtectionGroup",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_protection_group(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateProtectionGroup::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateProtectionGroup",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateProtectionGroupInput`](crate::input::UpdateProtectionGroupInput)
    pub fn builder() -> crate::input::update_protection_group_input::Builder {
        crate::input::update_protection_group_input::Builder::default()
    }
}

/// See [`UpdateSubscriptionInput`](crate::input::UpdateSubscriptionInput)
pub mod update_subscription_input {
    /// A builder for [`UpdateSubscriptionInput`](crate::input::UpdateSubscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_renew: std::option::Option<crate::model::AutoRenew>,
    }
    impl Builder {
        /// <p>When you initally create a subscription, <code>AutoRenew</code> is set to <code>ENABLED</code>. If <code>ENABLED</code>, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an <code>UpdateSubscription</code> request. If the <code>UpdateSubscription</code> request does not included a value for <code>AutoRenew</code>, the existing value for <code>AutoRenew</code> remains unchanged.</p>
        pub fn auto_renew(mut self, input: crate::model::AutoRenew) -> Self {
            self.auto_renew = Some(input);
            self
        }
        pub fn set_auto_renew(
            mut self,
            input: std::option::Option<crate::model::AutoRenew>,
        ) -> Self {
            self.auto_renew = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSubscriptionInput`](crate::input::UpdateSubscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSubscriptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSubscriptionInput {
                auto_renew: self.auto_renew,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSubscriptionInputOperationOutputAlias = crate::operation::UpdateSubscription;
#[doc(hidden)]
pub type UpdateSubscriptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSubscription`](crate::operation::UpdateSubscription)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSubscription,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateSubscriptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateSubscriptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateSubscriptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSShield_20160616.UpdateSubscription",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_subscription(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSubscription::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateSubscription",
            "shield",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSubscriptionInput`](crate::input::UpdateSubscriptionInput)
    pub fn builder() -> crate::input::update_subscription_input::Builder {
        crate::input::update_subscription_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSubscriptionInput {
    /// <p>When you initally create a subscription, <code>AutoRenew</code> is set to <code>ENABLED</code>. If <code>ENABLED</code>, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an <code>UpdateSubscription</code> request. If the <code>UpdateSubscription</code> request does not included a value for <code>AutoRenew</code>, the existing value for <code>AutoRenew</code> remains unchanged.</p>
    pub auto_renew: std::option::Option<crate::model::AutoRenew>,
}
impl std::fmt::Debug for UpdateSubscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSubscriptionInput");
        formatter.field("auto_renew", &self.auto_renew);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateProtectionGroupInput {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    pub protection_group_id: std::option::Option<std::string::String>,
    /// <p>Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
    /// <ul>
    /// <li>
    /// <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
    /// </li>
    /// <li>
    /// <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
    /// </li>
    /// <li>
    /// <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.</p>
    /// </li>
    /// </ul>
    pub aggregation: std::option::Option<crate::model::ProtectionGroupAggregation>,
    /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.</p>
    pub pattern: std::option::Option<crate::model::ProtectionGroupPattern>,
    /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group.
    /// You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    pub resource_type: std::option::Option<crate::model::ProtectedResourceType>,
    /// <p>The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set <code>Pattern</code> to <code>ARBITRARY</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    pub members: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UpdateProtectionGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateProtectionGroupInput");
        formatter.field("protection_group_id", &self.protection_group_id);
        formatter.field("aggregation", &self.aggregation);
        formatter.field("pattern", &self.pattern);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("members", &self.members);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEmergencyContactSettingsInput {
    /// <p>A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.</p>
    /// <p>If you have proactive engagement enabled, the contact list must include at least one phone number.</p>
    pub emergency_contact_list: std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
}
impl std::fmt::Debug for UpdateEmergencyContactSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEmergencyContactSettingsInput");
        formatter.field("emergency_contact_list", &self.emergency_contact_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags that you want to modify or add to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourcesInProtectionGroupInput {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    pub protection_group_id: std::option::Option<std::string::String>,
    /// <p>The next token value from a previous call to <code>ListResourcesInProtectionGroup</code>. Pass null if this is the first call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of resource ARN objects to return. If you leave this blank,
    /// Shield Advanced returns the first 20 results.</p>
    /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListResourcesInProtectionGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourcesInProtectionGroupInput");
        formatter.field("protection_group_id", &self.protection_group_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProtectionsInput {
    /// <p>The <code>ListProtectionsRequest.NextToken</code> value from a previous call to <code>ListProtections</code>. Pass null if this is the first call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of <a>Protection</a> objects to return. If you leave this blank,
    /// Shield Advanced returns the first 20 results.</p>
    /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListProtectionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProtectionsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProtectionGroupsInput {
    /// <p>The next token value from a previous call to <code>ListProtectionGroups</code>. Pass null if this is the first call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of <a>ProtectionGroup</a> objects to return. If you leave this blank,
    /// Shield Advanced returns the first 20 results.</p>
    /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListProtectionGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProtectionGroupsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttacksInput {
    /// <p>The ARN (Amazon Resource Name) of the resource that was attacked. If this is left
    /// blank, all applicable resources for this account will be included.</p>
    pub resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The start of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
    pub start_time: std::option::Option<crate::model::TimeRange>,
    /// <p>The end of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
    pub end_time: std::option::Option<crate::model::TimeRange>,
    /// <p>The <code>ListAttacksRequest.NextMarker</code> value from a previous call to <code>ListAttacksRequest</code>. Pass null if this is the first call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of <a>AttackSummary</a> objects to return. If you leave this blank,
    /// Shield Advanced returns the first 20 results.</p>
    /// <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAttacksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttacksInput");
        formatter.field("resource_arns", &self.resource_arns);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSubscriptionStateInput {}
impl std::fmt::Debug for GetSubscriptionStateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSubscriptionStateInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableProactiveEngagementInput {}
impl std::fmt::Debug for EnableProactiveEngagementInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableProactiveEngagementInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateHealthCheckInput {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to remove the health check association from. </p>
    pub protection_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the health check that is associated with the protection.</p>
    pub health_check_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateHealthCheckInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateHealthCheckInput");
        formatter.field("protection_id", &self.protection_id);
        formatter.field("health_check_arn", &self.health_check_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateDrtRoleInput {}
impl std::fmt::Debug for DisassociateDrtRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateDrtRoleInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateDrtLogBucketInput {
    /// <p>The Amazon S3 bucket that contains the logs that you want to share.</p>
    pub log_bucket: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateDrtLogBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateDrtLogBucketInput");
        formatter.field("log_bucket", &self.log_bucket);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableProactiveEngagementInput {}
impl std::fmt::Debug for DisableProactiveEngagementInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableProactiveEngagementInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscriptionInput {}
impl std::fmt::Debug for DescribeSubscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscriptionInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProtectionGroupInput {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    pub protection_group_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeProtectionGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProtectionGroupInput");
        formatter.field("protection_group_id", &self.protection_group_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProtectionInput {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object that is
    /// described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
    pub protection_id: std::option::Option<std::string::String>,
    /// <p>The ARN (Amazon Resource Name) of the Amazon Web Services resource for the <a>Protection</a> object that is
    /// described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeProtectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProtectionInput");
        formatter.field("protection_id", &self.protection_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEmergencyContactSettingsInput {}
impl std::fmt::Debug for DescribeEmergencyContactSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEmergencyContactSettingsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDrtAccessInput {}
impl std::fmt::Debug for DescribeDrtAccessInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDrtAccessInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAttackStatisticsInput {}
impl std::fmt::Debug for DescribeAttackStatisticsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAttackStatisticsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAttackInput {
    /// <p>The unique identifier (ID) for the attack that to be described.</p>
    pub attack_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAttackInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAttackInput");
        formatter.field("attack_id", &self.attack_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSubscriptionInput {}
impl std::fmt::Debug for DeleteSubscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSubscriptionInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProtectionGroupInput {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    pub protection_group_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProtectionGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProtectionGroupInput");
        formatter.field("protection_group_id", &self.protection_group_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProtectionInput {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to be
    /// deleted.</p>
    pub protection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProtectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProtectionInput");
        formatter.field("protection_id", &self.protection_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSubscriptionInput {}
impl std::fmt::Debug for CreateSubscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSubscriptionInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProtectionGroupInput {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    pub protection_group_id: std::option::Option<std::string::String>,
    /// <p>Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
    /// <ul>
    /// <li>
    /// <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
    /// </li>
    /// <li>
    /// <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
    /// </li>
    /// <li>
    /// <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront and origin resources for CloudFront distributions.</p>
    /// </li>
    /// </ul>
    pub aggregation: std::option::Option<crate::model::ProtectionGroupAggregation>,
    /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type. </p>
    pub pattern: std::option::Option<crate::model::ProtectionGroupPattern>,
    /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group.
    /// You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    pub resource_type: std::option::Option<crate::model::ProtectedResourceType>,
    /// <p>The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set <code>Pattern</code> to <code>ARBITRARY</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    pub members: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more tag key-value pairs for the protection group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateProtectionGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProtectionGroupInput");
        formatter.field("protection_group_id", &self.protection_group_id);
        formatter.field("aggregation", &self.aggregation);
        formatter.field("pattern", &self.pattern);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("members", &self.members);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProtectionInput {
    /// <p>Friendly name for the <code>Protection</code> you are creating.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN (Amazon Resource Name) of the resource to be protected.</p>
    /// <p>The ARN should be in one of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Elastic Load Balancer (Classic Load Balancer): <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/<i>load-balancer-name</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Amazon CloudFront distribution: <code>arn:aws:cloudfront::<i>account-id</i>:distribution/<i>distribution-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Global Accelerator accelerator: <code>arn:aws:globalaccelerator::<i>account-id</i>:accelerator/<i>accelerator-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For Amazon Route 53: <code>arn:aws:route53:::hostedzone/<i>hosted-zone-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Elastic IP address: <code>arn:aws:ec2:<i>region</i>:<i>account-id</i>:eip-allocation/<i>allocation-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// </ul>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>One or more tag key-value pairs for the <a>Protection</a> object that is created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateProtectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProtectionInput");
        formatter.field("name", &self.name);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateProactiveEngagementDetailsInput {
    /// <p>A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you for escalations to the SRT and to initiate proactive customer support. </p>
    /// <p>To enable proactive engagement, the contact list must include at least one phone number.</p>
    /// <note>
    /// <p>The contacts that you provide here replace any contacts that were already defined. If you already have contacts defined and want to use them, retrieve the list using <code>DescribeEmergencyContactSettings</code> and then provide it here.  </p>
    /// </note>
    pub emergency_contact_list: std::option::Option<std::vec::Vec<crate::model::EmergencyContact>>,
}
impl std::fmt::Debug for AssociateProactiveEngagementDetailsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateProactiveEngagementDetailsInput");
        formatter.field("emergency_contact_list", &self.emergency_contact_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateHealthCheckInput {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to add the health check association to. </p>
    pub protection_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the health check to associate with the protection.</p>
    pub health_check_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateHealthCheckInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateHealthCheckInput");
        formatter.field("protection_id", &self.protection_id);
        formatter.field("health_check_arn", &self.health_check_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateDrtRoleInput {
    /// <p>The Amazon Resource Name (ARN) of the role the SRT will use to access your Amazon Web Services account.</p>
    /// <p>Prior to making the <code>AssociateDRTRole</code> request, you must attach the <a href="https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy">AWSShieldDRTAccessPolicy</a> managed policy to this role.  For more information see <a href=" https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html">Attaching and Detaching IAM Policies</a>.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateDrtRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateDrtRoleInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateDrtLogBucketInput {
    /// <p>The Amazon S3 bucket that contains the logs that you want to share.</p>
    pub log_bucket: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateDrtLogBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateDrtLogBucketInput");
        formatter.field("log_bucket", &self.log_bucket);
        formatter.finish()
    }
}
