// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Returns the current configuration items for resources that are present in your AWS Config aggregator. The operation also returns a list of resources that are not processed in the current request.
/// If there are no unprocessed resources, the operation returns an empty <code>unprocessedResourceIdentifiers</code> list. </p>
/// <note>
/// <ul>
/// <li>
/// <p>The API does not return results for deleted resources.</p>
/// </li>
/// <li>
/// <p> The API does not return tags and relationships.</p>
/// </li>
/// </ul>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetAggregateResourceConfig {
    _private: (),
}
impl BatchGetAggregateResourceConfig {
    /// Creates a new builder-style object to manufacture [`BatchGetAggregateResourceConfigInput`](crate::input::BatchGetAggregateResourceConfigInput)
    pub fn builder() -> crate::input::batch_get_aggregate_resource_config_input::Builder {
        crate::input::batch_get_aggregate_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetAggregateResourceConfig {
    type Output = std::result::Result<
        crate::output::BatchGetAggregateResourceConfigOutput,
        crate::error::BatchGetAggregateResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_aggregate_resource_config_error(response)
        } else {
            crate::operation_deser::parse_batch_get_aggregate_resource_config_response(response)
        }
    }
}

/// <p>Returns the current configuration for one or more requested
/// resources. The operation also returns a list of resources that are
/// not processed in the current request. If there are no unprocessed
/// resources, the operation returns an empty unprocessedResourceKeys
/// list. </p>
/// <note>
/// <ul>
/// <li>
/// <p>The API does not return results for deleted
/// resources.</p>
/// </li>
/// <li>
/// <p> The API does not return any tags for the requested
/// resources. This information is filtered out of the
/// supplementaryConfiguration section of the API
/// response.</p>
/// </li>
/// </ul>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetResourceConfig {
    _private: (),
}
impl BatchGetResourceConfig {
    /// Creates a new builder-style object to manufacture [`BatchGetResourceConfigInput`](crate::input::BatchGetResourceConfigInput)
    pub fn builder() -> crate::input::batch_get_resource_config_input::Builder {
        crate::input::batch_get_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetResourceConfig {
    type Output = std::result::Result<
        crate::output::BatchGetResourceConfigOutput,
        crate::error::BatchGetResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_resource_config_error(response)
        } else {
            crate::operation_deser::parse_batch_get_resource_config_response(response)
        }
    }
}

/// <p>Deletes the authorization granted to the specified
/// configuration aggregator account in a specified region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAggregationAuthorization {
    _private: (),
}
impl DeleteAggregationAuthorization {
    /// Creates a new builder-style object to manufacture [`DeleteAggregationAuthorizationInput`](crate::input::DeleteAggregationAuthorizationInput)
    pub fn builder() -> crate::input::delete_aggregation_authorization_input::Builder {
        crate::input::delete_aggregation_authorization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAggregationAuthorization {
    type Output = std::result::Result<
        crate::output::DeleteAggregationAuthorizationOutput,
        crate::error::DeleteAggregationAuthorizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_aggregation_authorization_error(response)
        } else {
            crate::operation_deser::parse_delete_aggregation_authorization_response(response)
        }
    }
}

/// <p>Deletes the specified AWS Config rule and all of its evaluation
/// results.</p>
/// <p>AWS Config sets the state of a rule to <code>DELETING</code>
/// until the deletion is complete. You cannot update a rule while it is
/// in this state. If you make a <code>PutConfigRule</code> or
/// <code>DeleteConfigRule</code> request for the rule, you will
/// receive a <code>ResourceInUseException</code>.</p>
/// <p>You can check the state of a rule by using the
/// <code>DescribeConfigRules</code> request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigRule {
    _private: (),
}
impl DeleteConfigRule {
    /// Creates a new builder-style object to manufacture [`DeleteConfigRuleInput`](crate::input::DeleteConfigRuleInput)
    pub fn builder() -> crate::input::delete_config_rule_input::Builder {
        crate::input::delete_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigRule {
    type Output = std::result::Result<
        crate::output::DeleteConfigRuleOutput,
        crate::error::DeleteConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_config_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_config_rule_response(response)
        }
    }
}

/// <p>Deletes the specified configuration aggregator and the
/// aggregated data associated with the aggregator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationAggregator {
    _private: (),
}
impl DeleteConfigurationAggregator {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationAggregatorInput`](crate::input::DeleteConfigurationAggregatorInput)
    pub fn builder() -> crate::input::delete_configuration_aggregator_input::Builder {
        crate::input::delete_configuration_aggregator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationAggregator {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationAggregatorOutput,
        crate::error::DeleteConfigurationAggregatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_configuration_aggregator_error(response)
        } else {
            crate::operation_deser::parse_delete_configuration_aggregator_response(response)
        }
    }
}

/// <p>Deletes the configuration recorder.</p>
/// <p>After the configuration recorder is deleted, AWS Config will
/// not record resource configuration changes until you create a new
/// configuration recorder.</p>
/// <p>This action does not delete the configuration information that
/// was previously recorded. You will be able to access the previously
/// recorded information by using the
/// <code>GetResourceConfigHistory</code> action, but you will not
/// be able to access this information in the AWS Config console until
/// you create a new configuration recorder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationRecorder {
    _private: (),
}
impl DeleteConfigurationRecorder {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationRecorderInput`](crate::input::DeleteConfigurationRecorderInput)
    pub fn builder() -> crate::input::delete_configuration_recorder_input::Builder {
        crate::input::delete_configuration_recorder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationRecorder {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationRecorderOutput,
        crate::error::DeleteConfigurationRecorderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_configuration_recorder_error(response)
        } else {
            crate::operation_deser::parse_delete_configuration_recorder_response(response)
        }
    }
}

/// <p>Deletes the specified conformance pack and all the AWS Config rules, remediation actions, and all evaluation results within that
/// conformance pack.</p>
/// <p>AWS Config sets the conformance pack to <code>DELETE_IN_PROGRESS</code> until the deletion is complete.
/// You cannot update a conformance pack while it is in this state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConformancePack {
    _private: (),
}
impl DeleteConformancePack {
    /// Creates a new builder-style object to manufacture [`DeleteConformancePackInput`](crate::input::DeleteConformancePackInput)
    pub fn builder() -> crate::input::delete_conformance_pack_input::Builder {
        crate::input::delete_conformance_pack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConformancePack {
    type Output = std::result::Result<
        crate::output::DeleteConformancePackOutput,
        crate::error::DeleteConformancePackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_conformance_pack_error(response)
        } else {
            crate::operation_deser::parse_delete_conformance_pack_response(response)
        }
    }
}

/// <p>Deletes the delivery channel.</p>
/// <p>Before you can delete the delivery channel, you must stop the
/// configuration recorder by using the <a>StopConfigurationRecorder</a> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDeliveryChannel {
    _private: (),
}
impl DeleteDeliveryChannel {
    /// Creates a new builder-style object to manufacture [`DeleteDeliveryChannelInput`](crate::input::DeleteDeliveryChannelInput)
    pub fn builder() -> crate::input::delete_delivery_channel_input::Builder {
        crate::input::delete_delivery_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDeliveryChannel {
    type Output = std::result::Result<
        crate::output::DeleteDeliveryChannelOutput,
        crate::error::DeleteDeliveryChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_delivery_channel_error(response)
        } else {
            crate::operation_deser::parse_delete_delivery_channel_response(response)
        }
    }
}

/// <p>Deletes the evaluation results for the specified AWS Config
/// rule. You can specify one AWS Config rule per request. After you
/// delete the evaluation results, you can call the <a>StartConfigRulesEvaluation</a> API to start evaluating
/// your AWS resources against the rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEvaluationResults {
    _private: (),
}
impl DeleteEvaluationResults {
    /// Creates a new builder-style object to manufacture [`DeleteEvaluationResultsInput`](crate::input::DeleteEvaluationResultsInput)
    pub fn builder() -> crate::input::delete_evaluation_results_input::Builder {
        crate::input::delete_evaluation_results_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEvaluationResults {
    type Output = std::result::Result<
        crate::output::DeleteEvaluationResultsOutput,
        crate::error::DeleteEvaluationResultsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_evaluation_results_error(response)
        } else {
            crate::operation_deser::parse_delete_evaluation_results_response(response)
        }
    }
}

/// <p>Deletes the specified organization config rule and all of its evaluation results from all member accounts in that organization. </p>
/// <p>Only a master account and a delegated administrator account can delete an organization config rule.
/// When calling this API with a delegated administrator, you must ensure AWS Organizations
/// <code>ListDelegatedAdministrator</code> permissions are added.</p>
/// <p>AWS Config sets the state of a rule to DELETE_IN_PROGRESS until the deletion is complete.
/// You cannot update a rule while it is in this state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOrganizationConfigRule {
    _private: (),
}
impl DeleteOrganizationConfigRule {
    /// Creates a new builder-style object to manufacture [`DeleteOrganizationConfigRuleInput`](crate::input::DeleteOrganizationConfigRuleInput)
    pub fn builder() -> crate::input::delete_organization_config_rule_input::Builder {
        crate::input::delete_organization_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOrganizationConfigRule {
    type Output = std::result::Result<
        crate::output::DeleteOrganizationConfigRuleOutput,
        crate::error::DeleteOrganizationConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_organization_config_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_organization_config_rule_response(response)
        }
    }
}

/// <p>Deletes the specified organization conformance pack and all of the config rules and remediation actions from
/// all member accounts in that organization. </p>
/// <p> Only a master account or a delegated administrator account can delete an organization conformance pack.
/// When calling this API with a delegated administrator, you must ensure AWS Organizations
/// <code>ListDelegatedAdministrator</code> permissions are added.</p>
/// <p>AWS Config sets the state of a conformance pack to DELETE_IN_PROGRESS until the deletion is complete.
/// You cannot update a conformance pack while it is in this state. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOrganizationConformancePack {
    _private: (),
}
impl DeleteOrganizationConformancePack {
    /// Creates a new builder-style object to manufacture [`DeleteOrganizationConformancePackInput`](crate::input::DeleteOrganizationConformancePackInput)
    pub fn builder() -> crate::input::delete_organization_conformance_pack_input::Builder {
        crate::input::delete_organization_conformance_pack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOrganizationConformancePack {
    type Output = std::result::Result<
        crate::output::DeleteOrganizationConformancePackOutput,
        crate::error::DeleteOrganizationConformancePackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_organization_conformance_pack_error(response)
        } else {
            crate::operation_deser::parse_delete_organization_conformance_pack_response(response)
        }
    }
}

/// <p>Deletes pending authorization requests for a specified
/// aggregator account in a specified region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePendingAggregationRequest {
    _private: (),
}
impl DeletePendingAggregationRequest {
    /// Creates a new builder-style object to manufacture [`DeletePendingAggregationRequestInput`](crate::input::DeletePendingAggregationRequestInput)
    pub fn builder() -> crate::input::delete_pending_aggregation_request_input::Builder {
        crate::input::delete_pending_aggregation_request_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePendingAggregationRequest {
    type Output = std::result::Result<
        crate::output::DeletePendingAggregationRequestOutput,
        crate::error::DeletePendingAggregationRequestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_pending_aggregation_request_error(response)
        } else {
            crate::operation_deser::parse_delete_pending_aggregation_request_response(response)
        }
    }
}

/// <p>Deletes the remediation configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRemediationConfiguration {
    _private: (),
}
impl DeleteRemediationConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteRemediationConfigurationInput`](crate::input::DeleteRemediationConfigurationInput)
    pub fn builder() -> crate::input::delete_remediation_configuration_input::Builder {
        crate::input::delete_remediation_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRemediationConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteRemediationConfigurationOutput,
        crate::error::DeleteRemediationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_remediation_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_remediation_configuration_response(response)
        }
    }
}

/// <p>Deletes one or more remediation exceptions mentioned in the resource keys.</p>
/// <note>
/// <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
/// Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRemediationExceptions {
    _private: (),
}
impl DeleteRemediationExceptions {
    /// Creates a new builder-style object to manufacture [`DeleteRemediationExceptionsInput`](crate::input::DeleteRemediationExceptionsInput)
    pub fn builder() -> crate::input::delete_remediation_exceptions_input::Builder {
        crate::input::delete_remediation_exceptions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRemediationExceptions {
    type Output = std::result::Result<
        crate::output::DeleteRemediationExceptionsOutput,
        crate::error::DeleteRemediationExceptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_remediation_exceptions_error(response)
        } else {
            crate::operation_deser::parse_delete_remediation_exceptions_response(response)
        }
    }
}

/// <p>Records the configuration state for a custom resource that has been deleted.  This API records a new ConfigurationItem with a ResourceDeleted status. You can retrieve the ConfigurationItems recorded for this resource in your AWS Config History.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourceConfig {
    _private: (),
}
impl DeleteResourceConfig {
    /// Creates a new builder-style object to manufacture [`DeleteResourceConfigInput`](crate::input::DeleteResourceConfigInput)
    pub fn builder() -> crate::input::delete_resource_config_input::Builder {
        crate::input::delete_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourceConfig {
    type Output = std::result::Result<
        crate::output::DeleteResourceConfigOutput,
        crate::error::DeleteResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resource_config_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_config_response(response)
        }
    }
}

/// <p>Deletes the retention configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRetentionConfiguration {
    _private: (),
}
impl DeleteRetentionConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteRetentionConfigurationInput`](crate::input::DeleteRetentionConfigurationInput)
    pub fn builder() -> crate::input::delete_retention_configuration_input::Builder {
        crate::input::delete_retention_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRetentionConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteRetentionConfigurationOutput,
        crate::error::DeleteRetentionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_retention_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_retention_configuration_response(response)
        }
    }
}

/// <p>Deletes the stored query for a single AWS account and a single AWS Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStoredQuery {
    _private: (),
}
impl DeleteStoredQuery {
    /// Creates a new builder-style object to manufacture [`DeleteStoredQueryInput`](crate::input::DeleteStoredQueryInput)
    pub fn builder() -> crate::input::delete_stored_query_input::Builder {
        crate::input::delete_stored_query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStoredQuery {
    type Output = std::result::Result<
        crate::output::DeleteStoredQueryOutput,
        crate::error::DeleteStoredQueryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_stored_query_error(response)
        } else {
            crate::operation_deser::parse_delete_stored_query_response(response)
        }
    }
}

/// <p>Schedules delivery of a configuration snapshot to the Amazon S3
/// bucket in the specified delivery channel. After the delivery has
/// started, AWS Config sends the following notifications using an
/// Amazon SNS topic that you have specified.</p>
/// <ul>
/// <li>
/// <p>Notification of the start of the delivery.</p>
/// </li>
/// <li>
/// <p>Notification of the completion of the delivery, if the
/// delivery was successfully completed.</p>
/// </li>
/// <li>
/// <p>Notification of delivery failure, if the delivery
/// failed.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeliverConfigSnapshot {
    _private: (),
}
impl DeliverConfigSnapshot {
    /// Creates a new builder-style object to manufacture [`DeliverConfigSnapshotInput`](crate::input::DeliverConfigSnapshotInput)
    pub fn builder() -> crate::input::deliver_config_snapshot_input::Builder {
        crate::input::deliver_config_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeliverConfigSnapshot {
    type Output = std::result::Result<
        crate::output::DeliverConfigSnapshotOutput,
        crate::error::DeliverConfigSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deliver_config_snapshot_error(response)
        } else {
            crate::operation_deser::parse_deliver_config_snapshot_response(response)
        }
    }
}

/// <p>Returns a list of compliant and noncompliant rules with the
/// number of resources for compliant and noncompliant rules.
/// </p>
/// <note>
/// <p>The results can return an empty result page, but if you
/// have a <code>nextToken</code>, the results are displayed on the next
/// page.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAggregateComplianceByConfigRules {
    _private: (),
}
impl DescribeAggregateComplianceByConfigRules {
    /// Creates a new builder-style object to manufacture [`DescribeAggregateComplianceByConfigRulesInput`](crate::input::DescribeAggregateComplianceByConfigRulesInput)
    pub fn builder() -> crate::input::describe_aggregate_compliance_by_config_rules_input::Builder {
        crate::input::describe_aggregate_compliance_by_config_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAggregateComplianceByConfigRules {
    type Output = std::result::Result<
        crate::output::DescribeAggregateComplianceByConfigRulesOutput,
        crate::error::DescribeAggregateComplianceByConfigRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_aggregate_compliance_by_config_rules_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_aggregate_compliance_by_config_rules_response(
                response,
            )
        }
    }
}

/// <p>Returns a list of the conformance packs and their associated compliance status with the count of compliant and noncompliant AWS Config rules within each conformance pack.
/// Also returns the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data.</p>
/// <note>
/// <p>The results can return an empty result page, but if you have a <code>nextToken</code>, the results are displayed on the next page.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAggregateComplianceByConformancePacks {
    _private: (),
}
impl DescribeAggregateComplianceByConformancePacks {
    /// Creates a new builder-style object to manufacture [`DescribeAggregateComplianceByConformancePacksInput`](crate::input::DescribeAggregateComplianceByConformancePacksInput)
    pub fn builder(
    ) -> crate::input::describe_aggregate_compliance_by_conformance_packs_input::Builder {
        crate::input::describe_aggregate_compliance_by_conformance_packs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAggregateComplianceByConformancePacks {
    type Output = std::result::Result<
        crate::output::DescribeAggregateComplianceByConformancePacksOutput,
        crate::error::DescribeAggregateComplianceByConformancePacksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_aggregate_compliance_by_conformance_packs_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_aggregate_compliance_by_conformance_packs_response(response)
        }
    }
}

/// <p>Returns a list of authorizations granted to various aggregator
/// accounts and regions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAggregationAuthorizations {
    _private: (),
}
impl DescribeAggregationAuthorizations {
    /// Creates a new builder-style object to manufacture [`DescribeAggregationAuthorizationsInput`](crate::input::DescribeAggregationAuthorizationsInput)
    pub fn builder() -> crate::input::describe_aggregation_authorizations_input::Builder {
        crate::input::describe_aggregation_authorizations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAggregationAuthorizations {
    type Output = std::result::Result<
        crate::output::DescribeAggregationAuthorizationsOutput,
        crate::error::DescribeAggregationAuthorizationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_aggregation_authorizations_error(response)
        } else {
            crate::operation_deser::parse_describe_aggregation_authorizations_response(response)
        }
    }
}

/// <p>Indicates whether the specified AWS Config rules are compliant.
/// If a rule is noncompliant, this action returns the number of AWS
/// resources that do not comply with the rule.</p>
/// <p>A rule is compliant if all of the evaluated resources comply
/// with it. It is noncompliant if any of these resources do not
/// comply.</p>
/// <p>If AWS Config has no current evaluation results for the rule,
/// it returns <code>INSUFFICIENT_DATA</code>. This result might
/// indicate one of the following conditions:</p>
/// <ul>
/// <li>
/// <p>AWS Config has never invoked an evaluation for the
/// rule. To check whether it has, use the
/// <code>DescribeConfigRuleEvaluationStatus</code> action
/// to get the <code>LastSuccessfulInvocationTime</code> and
/// <code>LastFailedInvocationTime</code>.</p>
/// </li>
/// <li>
/// <p>The rule's AWS Lambda function is failing to send
/// evaluation results to AWS Config. Verify that the role you
/// assigned to your configuration recorder includes the
/// <code>config:PutEvaluations</code> permission. If the
/// rule is a custom rule, verify that the AWS Lambda execution
/// role includes the <code>config:PutEvaluations</code>
/// permission.</p>
/// </li>
/// <li>
/// <p>The rule's AWS Lambda function has returned
/// <code>NOT_APPLICABLE</code> for all evaluation results.
/// This can occur if the resources were deleted or removed from
/// the rule's scope.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeComplianceByConfigRule {
    _private: (),
}
impl DescribeComplianceByConfigRule {
    /// Creates a new builder-style object to manufacture [`DescribeComplianceByConfigRuleInput`](crate::input::DescribeComplianceByConfigRuleInput)
    pub fn builder() -> crate::input::describe_compliance_by_config_rule_input::Builder {
        crate::input::describe_compliance_by_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeComplianceByConfigRule {
    type Output = std::result::Result<
        crate::output::DescribeComplianceByConfigRuleOutput,
        crate::error::DescribeComplianceByConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_compliance_by_config_rule_error(response)
        } else {
            crate::operation_deser::parse_describe_compliance_by_config_rule_response(response)
        }
    }
}

/// <p>Indicates whether the specified AWS resources are compliant. If
/// a resource is noncompliant, this action returns the number of AWS
/// Config rules that the resource does not comply with.</p>
/// <p>A resource is compliant if it complies with all the AWS Config
/// rules that evaluate it. It is noncompliant if it does not comply
/// with one or more of these rules.</p>
/// <p>If AWS Config has no current evaluation results for the
/// resource, it returns <code>INSUFFICIENT_DATA</code>. This result
/// might indicate one of the following conditions about the rules that
/// evaluate the resource:</p>
/// <ul>
/// <li>
/// <p>AWS Config has never invoked an evaluation for the
/// rule. To check whether it has, use the
/// <code>DescribeConfigRuleEvaluationStatus</code> action
/// to get the <code>LastSuccessfulInvocationTime</code> and
/// <code>LastFailedInvocationTime</code>.</p>
/// </li>
/// <li>
/// <p>The rule's AWS Lambda function is failing to send
/// evaluation results to AWS Config. Verify that the role that
/// you assigned to your configuration recorder includes the
/// <code>config:PutEvaluations</code> permission. If the
/// rule is a custom rule, verify that the AWS Lambda execution
/// role includes the <code>config:PutEvaluations</code>
/// permission.</p>
/// </li>
/// <li>
/// <p>The rule's AWS Lambda function has returned
/// <code>NOT_APPLICABLE</code> for all evaluation results.
/// This can occur if the resources were deleted or removed from
/// the rule's scope.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeComplianceByResource {
    _private: (),
}
impl DescribeComplianceByResource {
    /// Creates a new builder-style object to manufacture [`DescribeComplianceByResourceInput`](crate::input::DescribeComplianceByResourceInput)
    pub fn builder() -> crate::input::describe_compliance_by_resource_input::Builder {
        crate::input::describe_compliance_by_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeComplianceByResource {
    type Output = std::result::Result<
        crate::output::DescribeComplianceByResourceOutput,
        crate::error::DescribeComplianceByResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_compliance_by_resource_error(response)
        } else {
            crate::operation_deser::parse_describe_compliance_by_resource_response(response)
        }
    }
}

/// <p>Returns status information for each of your AWS managed Config
/// rules. The status includes information such as the last time AWS
/// Config invoked the rule, the last time AWS Config failed to invoke
/// the rule, and the related error for the last failure.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigRuleEvaluationStatus {
    _private: (),
}
impl DescribeConfigRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`DescribeConfigRuleEvaluationStatusInput`](crate::input::DescribeConfigRuleEvaluationStatusInput)
    pub fn builder() -> crate::input::describe_config_rule_evaluation_status_input::Builder {
        crate::input::describe_config_rule_evaluation_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigRuleEvaluationStatus {
    type Output = std::result::Result<
        crate::output::DescribeConfigRuleEvaluationStatusOutput,
        crate::error::DescribeConfigRuleEvaluationStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_config_rule_evaluation_status_error(response)
        } else {
            crate::operation_deser::parse_describe_config_rule_evaluation_status_response(response)
        }
    }
}

/// <p>Returns details about your AWS Config rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigRules {
    _private: (),
}
impl DescribeConfigRules {
    /// Creates a new builder-style object to manufacture [`DescribeConfigRulesInput`](crate::input::DescribeConfigRulesInput)
    pub fn builder() -> crate::input::describe_config_rules_input::Builder {
        crate::input::describe_config_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigRules {
    type Output = std::result::Result<
        crate::output::DescribeConfigRulesOutput,
        crate::error::DescribeConfigRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_config_rules_error(response)
        } else {
            crate::operation_deser::parse_describe_config_rules_response(response)
        }
    }
}

/// <p>Returns the details of one or more configuration aggregators.
/// If the configuration aggregator is not specified, this action
/// returns the details for all the configuration aggregators associated
/// with the account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigurationAggregators {
    _private: (),
}
impl DescribeConfigurationAggregators {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationAggregatorsInput`](crate::input::DescribeConfigurationAggregatorsInput)
    pub fn builder() -> crate::input::describe_configuration_aggregators_input::Builder {
        crate::input::describe_configuration_aggregators_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigurationAggregators {
    type Output = std::result::Result<
        crate::output::DescribeConfigurationAggregatorsOutput,
        crate::error::DescribeConfigurationAggregatorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_configuration_aggregators_error(response)
        } else {
            crate::operation_deser::parse_describe_configuration_aggregators_response(response)
        }
    }
}

/// <p>Returns status information for sources within an aggregator.
/// The status includes information about the last time AWS Config verified authorization between the source account and an aggregator account. In case of a failure, the status contains the related error code or message. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigurationAggregatorSourcesStatus {
    _private: (),
}
impl DescribeConfigurationAggregatorSourcesStatus {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationAggregatorSourcesStatusInput`](crate::input::DescribeConfigurationAggregatorSourcesStatusInput)
    pub fn builder() -> crate::input::describe_configuration_aggregator_sources_status_input::Builder
    {
        crate::input::describe_configuration_aggregator_sources_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigurationAggregatorSourcesStatus {
    type Output = std::result::Result<
        crate::output::DescribeConfigurationAggregatorSourcesStatusOutput,
        crate::error::DescribeConfigurationAggregatorSourcesStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_configuration_aggregator_sources_status_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_configuration_aggregator_sources_status_response(
                response,
            )
        }
    }
}

/// <p>Returns the details for the specified configuration recorders.
/// If the configuration recorder is not specified, this action returns
/// the details for all configuration recorders associated with the
/// account.</p>
/// <note>
/// <p>Currently, you can specify only one configuration recorder
/// per region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigurationRecorders {
    _private: (),
}
impl DescribeConfigurationRecorders {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationRecordersInput`](crate::input::DescribeConfigurationRecordersInput)
    pub fn builder() -> crate::input::describe_configuration_recorders_input::Builder {
        crate::input::describe_configuration_recorders_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigurationRecorders {
    type Output = std::result::Result<
        crate::output::DescribeConfigurationRecordersOutput,
        crate::error::DescribeConfigurationRecordersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_configuration_recorders_error(response)
        } else {
            crate::operation_deser::parse_describe_configuration_recorders_response(response)
        }
    }
}

/// <p>Returns the current status of the specified configuration
/// recorder. If a configuration recorder is not specified, this action
/// returns the status of all configuration recorders associated with
/// the account.</p>
/// <note>
/// <p>Currently, you can specify only one configuration recorder
/// per region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigurationRecorderStatus {
    _private: (),
}
impl DescribeConfigurationRecorderStatus {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationRecorderStatusInput`](crate::input::DescribeConfigurationRecorderStatusInput)
    pub fn builder() -> crate::input::describe_configuration_recorder_status_input::Builder {
        crate::input::describe_configuration_recorder_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigurationRecorderStatus {
    type Output = std::result::Result<
        crate::output::DescribeConfigurationRecorderStatusOutput,
        crate::error::DescribeConfigurationRecorderStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_configuration_recorder_status_error(response)
        } else {
            crate::operation_deser::parse_describe_configuration_recorder_status_response(response)
        }
    }
}

/// <p>Returns compliance details for each rule in that conformance pack.</p>
/// <note>
/// <p>You must provide exact rule names.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConformancePackCompliance {
    _private: (),
}
impl DescribeConformancePackCompliance {
    /// Creates a new builder-style object to manufacture [`DescribeConformancePackComplianceInput`](crate::input::DescribeConformancePackComplianceInput)
    pub fn builder() -> crate::input::describe_conformance_pack_compliance_input::Builder {
        crate::input::describe_conformance_pack_compliance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConformancePackCompliance {
    type Output = std::result::Result<
        crate::output::DescribeConformancePackComplianceOutput,
        crate::error::DescribeConformancePackComplianceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_conformance_pack_compliance_error(response)
        } else {
            crate::operation_deser::parse_describe_conformance_pack_compliance_response(response)
        }
    }
}

/// <p>Returns a list of one or more conformance packs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConformancePacks {
    _private: (),
}
impl DescribeConformancePacks {
    /// Creates a new builder-style object to manufacture [`DescribeConformancePacksInput`](crate::input::DescribeConformancePacksInput)
    pub fn builder() -> crate::input::describe_conformance_packs_input::Builder {
        crate::input::describe_conformance_packs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConformancePacks {
    type Output = std::result::Result<
        crate::output::DescribeConformancePacksOutput,
        crate::error::DescribeConformancePacksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_conformance_packs_error(response)
        } else {
            crate::operation_deser::parse_describe_conformance_packs_response(response)
        }
    }
}

/// <p>Provides one or more conformance packs deployment status.</p>
/// <note>
/// <p>If there are no conformance packs then you will see an empty result.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConformancePackStatus {
    _private: (),
}
impl DescribeConformancePackStatus {
    /// Creates a new builder-style object to manufacture [`DescribeConformancePackStatusInput`](crate::input::DescribeConformancePackStatusInput)
    pub fn builder() -> crate::input::describe_conformance_pack_status_input::Builder {
        crate::input::describe_conformance_pack_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConformancePackStatus {
    type Output = std::result::Result<
        crate::output::DescribeConformancePackStatusOutput,
        crate::error::DescribeConformancePackStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_conformance_pack_status_error(response)
        } else {
            crate::operation_deser::parse_describe_conformance_pack_status_response(response)
        }
    }
}

/// <p>Returns details about the specified delivery channel. If a
/// delivery channel is not specified, this action returns the details
/// of all delivery channels associated with the account.</p>
/// <note>
/// <p>Currently, you can specify only one delivery channel per
/// region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDeliveryChannels {
    _private: (),
}
impl DescribeDeliveryChannels {
    /// Creates a new builder-style object to manufacture [`DescribeDeliveryChannelsInput`](crate::input::DescribeDeliveryChannelsInput)
    pub fn builder() -> crate::input::describe_delivery_channels_input::Builder {
        crate::input::describe_delivery_channels_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDeliveryChannels {
    type Output = std::result::Result<
        crate::output::DescribeDeliveryChannelsOutput,
        crate::error::DescribeDeliveryChannelsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_delivery_channels_error(response)
        } else {
            crate::operation_deser::parse_describe_delivery_channels_response(response)
        }
    }
}

/// <p>Returns the current status of the specified delivery channel.
/// If a delivery channel is not specified, this action returns the
/// current status of all delivery channels associated with the
/// account.</p>
/// <note>
/// <p>Currently, you can specify only one delivery channel per
/// region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDeliveryChannelStatus {
    _private: (),
}
impl DescribeDeliveryChannelStatus {
    /// Creates a new builder-style object to manufacture [`DescribeDeliveryChannelStatusInput`](crate::input::DescribeDeliveryChannelStatusInput)
    pub fn builder() -> crate::input::describe_delivery_channel_status_input::Builder {
        crate::input::describe_delivery_channel_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDeliveryChannelStatus {
    type Output = std::result::Result<
        crate::output::DescribeDeliveryChannelStatusOutput,
        crate::error::DescribeDeliveryChannelStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_delivery_channel_status_error(response)
        } else {
            crate::operation_deser::parse_describe_delivery_channel_status_response(response)
        }
    }
}

/// <p>Returns a list of organization config rules. </p>
/// <note>
/// <p>When you specify the limit and the next token, you receive a paginated response.
/// Limit and next token are not applicable if you specify organization config rule names.
/// It is only applicable, when you request all the organization config rules.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOrganizationConfigRules {
    _private: (),
}
impl DescribeOrganizationConfigRules {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationConfigRulesInput`](crate::input::DescribeOrganizationConfigRulesInput)
    pub fn builder() -> crate::input::describe_organization_config_rules_input::Builder {
        crate::input::describe_organization_config_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOrganizationConfigRules {
    type Output = std::result::Result<
        crate::output::DescribeOrganizationConfigRulesOutput,
        crate::error::DescribeOrganizationConfigRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_organization_config_rules_error(response)
        } else {
            crate::operation_deser::parse_describe_organization_config_rules_response(response)
        }
    }
}

/// <p>Provides organization config rule deployment status for an organization.</p>
/// <note>
/// <p>The status is not considered successful until organization config rule is successfully deployed in all the member
/// accounts with an exception of excluded accounts.</p>
/// <p>When you specify the limit and the next token, you receive a paginated response.
/// Limit and next token are not applicable if you specify organization config rule names.
/// It is only applicable, when you request all the organization config rules.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOrganizationConfigRuleStatuses {
    _private: (),
}
impl DescribeOrganizationConfigRuleStatuses {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationConfigRuleStatusesInput`](crate::input::DescribeOrganizationConfigRuleStatusesInput)
    pub fn builder() -> crate::input::describe_organization_config_rule_statuses_input::Builder {
        crate::input::describe_organization_config_rule_statuses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOrganizationConfigRuleStatuses {
    type Output = std::result::Result<
        crate::output::DescribeOrganizationConfigRuleStatusesOutput,
        crate::error::DescribeOrganizationConfigRuleStatusesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_organization_config_rule_statuses_error(response)
        } else {
            crate::operation_deser::parse_describe_organization_config_rule_statuses_response(
                response,
            )
        }
    }
}

/// <p>Returns a list of organization conformance packs. </p>
/// <note>
/// <p>When you specify the limit and the next token, you receive a paginated response. </p>
/// <p>Limit and next token are not applicable if you specify organization conformance packs names. They are only applicable,
/// when you request all the organization conformance packs. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOrganizationConformancePacks {
    _private: (),
}
impl DescribeOrganizationConformancePacks {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationConformancePacksInput`](crate::input::DescribeOrganizationConformancePacksInput)
    pub fn builder() -> crate::input::describe_organization_conformance_packs_input::Builder {
        crate::input::describe_organization_conformance_packs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOrganizationConformancePacks {
    type Output = std::result::Result<
        crate::output::DescribeOrganizationConformancePacksOutput,
        crate::error::DescribeOrganizationConformancePacksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_organization_conformance_packs_error(response)
        } else {
            crate::operation_deser::parse_describe_organization_conformance_packs_response(response)
        }
    }
}

/// <p>Provides organization conformance pack deployment status for an organization. </p>
/// <note>
/// <p>The status is not considered successful until organization conformance pack is successfully
/// deployed in all the member accounts with an exception of excluded accounts.</p>
/// <p>When you specify the limit and the next token, you receive a paginated response.
/// Limit and next token are not applicable if you specify organization conformance pack names.
/// They are only applicable, when you request all the organization conformance packs.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOrganizationConformancePackStatuses {
    _private: (),
}
impl DescribeOrganizationConformancePackStatuses {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationConformancePackStatusesInput`](crate::input::DescribeOrganizationConformancePackStatusesInput)
    pub fn builder() -> crate::input::describe_organization_conformance_pack_statuses_input::Builder
    {
        crate::input::describe_organization_conformance_pack_statuses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOrganizationConformancePackStatuses {
    type Output = std::result::Result<
        crate::output::DescribeOrganizationConformancePackStatusesOutput,
        crate::error::DescribeOrganizationConformancePackStatusesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_organization_conformance_pack_statuses_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_organization_conformance_pack_statuses_response(
                response,
            )
        }
    }
}

/// <p>Returns a list of all pending aggregation requests.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePendingAggregationRequests {
    _private: (),
}
impl DescribePendingAggregationRequests {
    /// Creates a new builder-style object to manufacture [`DescribePendingAggregationRequestsInput`](crate::input::DescribePendingAggregationRequestsInput)
    pub fn builder() -> crate::input::describe_pending_aggregation_requests_input::Builder {
        crate::input::describe_pending_aggregation_requests_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePendingAggregationRequests {
    type Output = std::result::Result<
        crate::output::DescribePendingAggregationRequestsOutput,
        crate::error::DescribePendingAggregationRequestsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_pending_aggregation_requests_error(response)
        } else {
            crate::operation_deser::parse_describe_pending_aggregation_requests_response(response)
        }
    }
}

/// <p>Returns the details of one or more remediation configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRemediationConfigurations {
    _private: (),
}
impl DescribeRemediationConfigurations {
    /// Creates a new builder-style object to manufacture [`DescribeRemediationConfigurationsInput`](crate::input::DescribeRemediationConfigurationsInput)
    pub fn builder() -> crate::input::describe_remediation_configurations_input::Builder {
        crate::input::describe_remediation_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRemediationConfigurations {
    type Output = std::result::Result<
        crate::output::DescribeRemediationConfigurationsOutput,
        crate::error::DescribeRemediationConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_remediation_configurations_error(response)
        } else {
            crate::operation_deser::parse_describe_remediation_configurations_response(response)
        }
    }
}

/// <p>Returns the details of one or more remediation exceptions. A detailed view of a remediation exception for a set of resources that includes an explanation of an exception and the time when the exception will be deleted.
/// When you specify the limit and the next token, you receive a paginated response. </p>
/// <note>
/// <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
/// Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
/// <p>When you specify the limit and the next token, you receive a paginated response. </p>
/// <p>Limit and next token are not applicable if you request resources in batch. It is only applicable, when you request all resources.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRemediationExceptions {
    _private: (),
}
impl DescribeRemediationExceptions {
    /// Creates a new builder-style object to manufacture [`DescribeRemediationExceptionsInput`](crate::input::DescribeRemediationExceptionsInput)
    pub fn builder() -> crate::input::describe_remediation_exceptions_input::Builder {
        crate::input::describe_remediation_exceptions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRemediationExceptions {
    type Output = std::result::Result<
        crate::output::DescribeRemediationExceptionsOutput,
        crate::error::DescribeRemediationExceptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_remediation_exceptions_error(response)
        } else {
            crate::operation_deser::parse_describe_remediation_exceptions_response(response)
        }
    }
}

/// <p>Provides a detailed view of a Remediation Execution for a set of resources including state, timestamps for when steps for the remediation execution occur, and any error messages for steps that have failed.
/// When you specify the limit and the next token, you receive a paginated response.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRemediationExecutionStatus {
    _private: (),
}
impl DescribeRemediationExecutionStatus {
    /// Creates a new builder-style object to manufacture [`DescribeRemediationExecutionStatusInput`](crate::input::DescribeRemediationExecutionStatusInput)
    pub fn builder() -> crate::input::describe_remediation_execution_status_input::Builder {
        crate::input::describe_remediation_execution_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRemediationExecutionStatus {
    type Output = std::result::Result<
        crate::output::DescribeRemediationExecutionStatusOutput,
        crate::error::DescribeRemediationExecutionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_remediation_execution_status_error(response)
        } else {
            crate::operation_deser::parse_describe_remediation_execution_status_response(response)
        }
    }
}

/// <p>Returns the details of one or more retention configurations. If
/// the retention configuration name is not specified, this action
/// returns the details for all the retention configurations for that
/// account.</p>
/// <note>
/// <p>Currently, AWS Config supports only one retention
/// configuration per region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRetentionConfigurations {
    _private: (),
}
impl DescribeRetentionConfigurations {
    /// Creates a new builder-style object to manufacture [`DescribeRetentionConfigurationsInput`](crate::input::DescribeRetentionConfigurationsInput)
    pub fn builder() -> crate::input::describe_retention_configurations_input::Builder {
        crate::input::describe_retention_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRetentionConfigurations {
    type Output = std::result::Result<
        crate::output::DescribeRetentionConfigurationsOutput,
        crate::error::DescribeRetentionConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_retention_configurations_error(response)
        } else {
            crate::operation_deser::parse_describe_retention_configurations_response(response)
        }
    }
}

/// <p>Returns the evaluation results for the specified AWS Config
/// rule for a specific resource in a rule. The results indicate which
/// AWS resources were evaluated by the rule, when each resource was
/// last evaluated, and whether each resource complies with the rule. </p>
/// <note>
/// <p>The results can return an empty result page. But if you
/// have a <code>nextToken</code>, the results are displayed on the next
/// page.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAggregateComplianceDetailsByConfigRule {
    _private: (),
}
impl GetAggregateComplianceDetailsByConfigRule {
    /// Creates a new builder-style object to manufacture [`GetAggregateComplianceDetailsByConfigRuleInput`](crate::input::GetAggregateComplianceDetailsByConfigRuleInput)
    pub fn builder() -> crate::input::get_aggregate_compliance_details_by_config_rule_input::Builder
    {
        crate::input::get_aggregate_compliance_details_by_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAggregateComplianceDetailsByConfigRule {
    type Output = std::result::Result<
        crate::output::GetAggregateComplianceDetailsByConfigRuleOutput,
        crate::error::GetAggregateComplianceDetailsByConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_aggregate_compliance_details_by_config_rule_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_aggregate_compliance_details_by_config_rule_response(
                response,
            )
        }
    }
}

/// <p>Returns the number of compliant and noncompliant rules for one
/// or more accounts and regions in an aggregator.</p>
/// <note>
/// <p>The results can return an empty result page, but if you
/// have a nextToken, the results are displayed on the next
/// page.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAggregateConfigRuleComplianceSummary {
    _private: (),
}
impl GetAggregateConfigRuleComplianceSummary {
    /// Creates a new builder-style object to manufacture [`GetAggregateConfigRuleComplianceSummaryInput`](crate::input::GetAggregateConfigRuleComplianceSummaryInput)
    pub fn builder() -> crate::input::get_aggregate_config_rule_compliance_summary_input::Builder {
        crate::input::get_aggregate_config_rule_compliance_summary_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAggregateConfigRuleComplianceSummary {
    type Output = std::result::Result<
        crate::output::GetAggregateConfigRuleComplianceSummaryOutput,
        crate::error::GetAggregateConfigRuleComplianceSummaryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_aggregate_config_rule_compliance_summary_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_aggregate_config_rule_compliance_summary_response(
                response,
            )
        }
    }
}

/// <p>Returns the count of compliant and noncompliant conformance packs across all AWS Accounts and AWS Regions in an aggregator. You can filter based on AWS Account ID or AWS Region.</p>
/// <note>
/// <p>The results can return an empty result page, but if you have a nextToken, the results are displayed on the next page.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAggregateConformancePackComplianceSummary {
    _private: (),
}
impl GetAggregateConformancePackComplianceSummary {
    /// Creates a new builder-style object to manufacture [`GetAggregateConformancePackComplianceSummaryInput`](crate::input::GetAggregateConformancePackComplianceSummaryInput)
    pub fn builder(
    ) -> crate::input::get_aggregate_conformance_pack_compliance_summary_input::Builder {
        crate::input::get_aggregate_conformance_pack_compliance_summary_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAggregateConformancePackComplianceSummary {
    type Output = std::result::Result<
        crate::output::GetAggregateConformancePackComplianceSummaryOutput,
        crate::error::GetAggregateConformancePackComplianceSummaryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_aggregate_conformance_pack_compliance_summary_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_aggregate_conformance_pack_compliance_summary_response(
                response,
            )
        }
    }
}

/// <p>Returns the resource counts across accounts and regions that are present in your AWS Config aggregator. You can request the resource counts by providing filters and GroupByKey.</p>
/// <p>For example, if the input contains accountID 12345678910 and region us-east-1 in filters, the API returns the count of resources in account ID 12345678910 and region us-east-1.
/// If the input contains ACCOUNT_ID as a GroupByKey, the API returns resource counts for all source accounts that are present in your aggregator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAggregateDiscoveredResourceCounts {
    _private: (),
}
impl GetAggregateDiscoveredResourceCounts {
    /// Creates a new builder-style object to manufacture [`GetAggregateDiscoveredResourceCountsInput`](crate::input::GetAggregateDiscoveredResourceCountsInput)
    pub fn builder() -> crate::input::get_aggregate_discovered_resource_counts_input::Builder {
        crate::input::get_aggregate_discovered_resource_counts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAggregateDiscoveredResourceCounts {
    type Output = std::result::Result<
        crate::output::GetAggregateDiscoveredResourceCountsOutput,
        crate::error::GetAggregateDiscoveredResourceCountsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_aggregate_discovered_resource_counts_error(response)
        } else {
            crate::operation_deser::parse_get_aggregate_discovered_resource_counts_response(
                response,
            )
        }
    }
}

/// <p>Returns configuration item that is aggregated for your specific resource in a specific source account and region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAggregateResourceConfig {
    _private: (),
}
impl GetAggregateResourceConfig {
    /// Creates a new builder-style object to manufacture [`GetAggregateResourceConfigInput`](crate::input::GetAggregateResourceConfigInput)
    pub fn builder() -> crate::input::get_aggregate_resource_config_input::Builder {
        crate::input::get_aggregate_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAggregateResourceConfig {
    type Output = std::result::Result<
        crate::output::GetAggregateResourceConfigOutput,
        crate::error::GetAggregateResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_aggregate_resource_config_error(response)
        } else {
            crate::operation_deser::parse_get_aggregate_resource_config_response(response)
        }
    }
}

/// <p>Returns the evaluation results for the specified AWS Config
/// rule. The results indicate which AWS resources were evaluated by the
/// rule, when each resource was last evaluated, and whether each
/// resource complies with the rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComplianceDetailsByConfigRule {
    _private: (),
}
impl GetComplianceDetailsByConfigRule {
    /// Creates a new builder-style object to manufacture [`GetComplianceDetailsByConfigRuleInput`](crate::input::GetComplianceDetailsByConfigRuleInput)
    pub fn builder() -> crate::input::get_compliance_details_by_config_rule_input::Builder {
        crate::input::get_compliance_details_by_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComplianceDetailsByConfigRule {
    type Output = std::result::Result<
        crate::output::GetComplianceDetailsByConfigRuleOutput,
        crate::error::GetComplianceDetailsByConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compliance_details_by_config_rule_error(response)
        } else {
            crate::operation_deser::parse_get_compliance_details_by_config_rule_response(response)
        }
    }
}

/// <p>Returns the evaluation results for the specified AWS resource.
/// The results indicate which AWS Config rules were used to evaluate
/// the resource, when each rule was last used, and whether the resource
/// complies with each rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComplianceDetailsByResource {
    _private: (),
}
impl GetComplianceDetailsByResource {
    /// Creates a new builder-style object to manufacture [`GetComplianceDetailsByResourceInput`](crate::input::GetComplianceDetailsByResourceInput)
    pub fn builder() -> crate::input::get_compliance_details_by_resource_input::Builder {
        crate::input::get_compliance_details_by_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComplianceDetailsByResource {
    type Output = std::result::Result<
        crate::output::GetComplianceDetailsByResourceOutput,
        crate::error::GetComplianceDetailsByResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compliance_details_by_resource_error(response)
        } else {
            crate::operation_deser::parse_get_compliance_details_by_resource_response(response)
        }
    }
}

/// <p>Returns the number of AWS Config rules that are compliant and
/// noncompliant, up to a maximum of 25 for each.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComplianceSummaryByConfigRule {
    _private: (),
}
impl GetComplianceSummaryByConfigRule {
    /// Creates a new builder-style object to manufacture [`GetComplianceSummaryByConfigRuleInput`](crate::input::GetComplianceSummaryByConfigRuleInput)
    pub fn builder() -> crate::input::get_compliance_summary_by_config_rule_input::Builder {
        crate::input::get_compliance_summary_by_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComplianceSummaryByConfigRule {
    type Output = std::result::Result<
        crate::output::GetComplianceSummaryByConfigRuleOutput,
        crate::error::GetComplianceSummaryByConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compliance_summary_by_config_rule_error(response)
        } else {
            crate::operation_deser::parse_get_compliance_summary_by_config_rule_response(response)
        }
    }
}

/// <p>Returns the number of resources that are compliant and the
/// number that are noncompliant. You can specify one or more resource
/// types to get these numbers for each resource type. The maximum
/// number returned is 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComplianceSummaryByResourceType {
    _private: (),
}
impl GetComplianceSummaryByResourceType {
    /// Creates a new builder-style object to manufacture [`GetComplianceSummaryByResourceTypeInput`](crate::input::GetComplianceSummaryByResourceTypeInput)
    pub fn builder() -> crate::input::get_compliance_summary_by_resource_type_input::Builder {
        crate::input::get_compliance_summary_by_resource_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComplianceSummaryByResourceType {
    type Output = std::result::Result<
        crate::output::GetComplianceSummaryByResourceTypeOutput,
        crate::error::GetComplianceSummaryByResourceTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compliance_summary_by_resource_type_error(response)
        } else {
            crate::operation_deser::parse_get_compliance_summary_by_resource_type_response(response)
        }
    }
}

/// <p>Returns compliance details of a conformance pack for all AWS resources that are monitered by conformance pack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConformancePackComplianceDetails {
    _private: (),
}
impl GetConformancePackComplianceDetails {
    /// Creates a new builder-style object to manufacture [`GetConformancePackComplianceDetailsInput`](crate::input::GetConformancePackComplianceDetailsInput)
    pub fn builder() -> crate::input::get_conformance_pack_compliance_details_input::Builder {
        crate::input::get_conformance_pack_compliance_details_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConformancePackComplianceDetails {
    type Output = std::result::Result<
        crate::output::GetConformancePackComplianceDetailsOutput,
        crate::error::GetConformancePackComplianceDetailsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_conformance_pack_compliance_details_error(response)
        } else {
            crate::operation_deser::parse_get_conformance_pack_compliance_details_response(response)
        }
    }
}

/// <p>Returns compliance details for the conformance pack based on the cumulative compliance results of all the rules in that conformance pack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConformancePackComplianceSummary {
    _private: (),
}
impl GetConformancePackComplianceSummary {
    /// Creates a new builder-style object to manufacture [`GetConformancePackComplianceSummaryInput`](crate::input::GetConformancePackComplianceSummaryInput)
    pub fn builder() -> crate::input::get_conformance_pack_compliance_summary_input::Builder {
        crate::input::get_conformance_pack_compliance_summary_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConformancePackComplianceSummary {
    type Output = std::result::Result<
        crate::output::GetConformancePackComplianceSummaryOutput,
        crate::error::GetConformancePackComplianceSummaryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_conformance_pack_compliance_summary_error(response)
        } else {
            crate::operation_deser::parse_get_conformance_pack_compliance_summary_response(response)
        }
    }
}

/// <p>Returns the resource types, the number of each resource type,
/// and the total number of resources that AWS Config is recording in
/// this region for your AWS account. </p>
/// <p class="title">
/// <b>Example</b>
/// </p>
/// <ol>
/// <li>
/// <p>AWS Config is recording three resource types in the US
/// East (Ohio) Region for your account: 25 EC2 instances, 20
/// IAM users, and 15 S3 buckets.</p>
/// </li>
/// <li>
/// <p>You make a call to the
/// <code>GetDiscoveredResourceCounts</code> action and
/// specify that you want all resource types. </p>
/// </li>
/// <li>
/// <p>AWS Config returns the following:</p>
/// <ul>
/// <li>
/// <p>The resource types (EC2 instances, IAM users,
/// and S3 buckets).</p>
/// </li>
/// <li>
/// <p>The number of each resource type (25, 20, and
/// 15).</p>
/// </li>
/// <li>
/// <p>The total number of all resources
/// (60).</p>
/// </li>
/// </ul>
/// </li>
/// </ol>
/// <p>The response is paginated. By default, AWS Config lists 100
/// <a>ResourceCount</a> objects on each page. You can
/// customize this number with the <code>limit</code> parameter. The
/// response includes a <code>nextToken</code> string. To get the next
/// page of results, run the request again and specify the string for
/// the <code>nextToken</code> parameter.</p>
/// <note>
/// <p>If you make a call to the <a>GetDiscoveredResourceCounts</a> action, you might
/// not immediately receive resource counts in the following
/// situations:</p>
/// <ul>
/// <li>
/// <p>You are a new AWS Config customer.</p>
/// </li>
/// <li>
/// <p>You just enabled resource recording.</p>
/// </li>
/// </ul>
/// <p>It might take a few minutes for AWS Config to record and
/// count your resources. Wait a few minutes and then retry the
/// <a>GetDiscoveredResourceCounts</a> action.
/// </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDiscoveredResourceCounts {
    _private: (),
}
impl GetDiscoveredResourceCounts {
    /// Creates a new builder-style object to manufacture [`GetDiscoveredResourceCountsInput`](crate::input::GetDiscoveredResourceCountsInput)
    pub fn builder() -> crate::input::get_discovered_resource_counts_input::Builder {
        crate::input::get_discovered_resource_counts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDiscoveredResourceCounts {
    type Output = std::result::Result<
        crate::output::GetDiscoveredResourceCountsOutput,
        crate::error::GetDiscoveredResourceCountsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_discovered_resource_counts_error(response)
        } else {
            crate::operation_deser::parse_get_discovered_resource_counts_response(response)
        }
    }
}

/// <p>Returns detailed status for each member account within an organization for a given organization config rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOrganizationConfigRuleDetailedStatus {
    _private: (),
}
impl GetOrganizationConfigRuleDetailedStatus {
    /// Creates a new builder-style object to manufacture [`GetOrganizationConfigRuleDetailedStatusInput`](crate::input::GetOrganizationConfigRuleDetailedStatusInput)
    pub fn builder() -> crate::input::get_organization_config_rule_detailed_status_input::Builder {
        crate::input::get_organization_config_rule_detailed_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOrganizationConfigRuleDetailedStatus {
    type Output = std::result::Result<
        crate::output::GetOrganizationConfigRuleDetailedStatusOutput,
        crate::error::GetOrganizationConfigRuleDetailedStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_organization_config_rule_detailed_status_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_organization_config_rule_detailed_status_response(
                response,
            )
        }
    }
}

/// <p>Returns detailed status for each member account within an organization for a given organization conformance pack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOrganizationConformancePackDetailedStatus {
    _private: (),
}
impl GetOrganizationConformancePackDetailedStatus {
    /// Creates a new builder-style object to manufacture [`GetOrganizationConformancePackDetailedStatusInput`](crate::input::GetOrganizationConformancePackDetailedStatusInput)
    pub fn builder(
    ) -> crate::input::get_organization_conformance_pack_detailed_status_input::Builder {
        crate::input::get_organization_conformance_pack_detailed_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOrganizationConformancePackDetailedStatus {
    type Output = std::result::Result<
        crate::output::GetOrganizationConformancePackDetailedStatusOutput,
        crate::error::GetOrganizationConformancePackDetailedStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_organization_conformance_pack_detailed_status_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_organization_conformance_pack_detailed_status_response(
                response,
            )
        }
    }
}

/// <p>Returns a list of configuration items for the specified
/// resource. The list contains details about each state of the resource
/// during the specified time interval. If you specified a retention
/// period to retain your <code>ConfigurationItems</code> between a
/// minimum of 30 days and a maximum of 7 years (2557 days), AWS Config
/// returns the <code>ConfigurationItems</code> for the specified
/// retention period. </p>
/// <p>The response is paginated. By default, AWS Config returns a
/// limit of 10 configuration items per page. You can customize this
/// number with the <code>limit</code> parameter. The response includes
/// a <code>nextToken</code> string. To get the next page of results,
/// run the request again and specify the string for the
/// <code>nextToken</code> parameter.</p>
/// <note>
/// <p>Each call to the API is limited to span a duration of seven
/// days. It is likely that the number of records returned is
/// smaller than the specified <code>limit</code>. In such cases,
/// you can make another call, using the
/// <code>nextToken</code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResourceConfigHistory {
    _private: (),
}
impl GetResourceConfigHistory {
    /// Creates a new builder-style object to manufacture [`GetResourceConfigHistoryInput`](crate::input::GetResourceConfigHistoryInput)
    pub fn builder() -> crate::input::get_resource_config_history_input::Builder {
        crate::input::get_resource_config_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResourceConfigHistory {
    type Output = std::result::Result<
        crate::output::GetResourceConfigHistoryOutput,
        crate::error::GetResourceConfigHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resource_config_history_error(response)
        } else {
            crate::operation_deser::parse_get_resource_config_history_response(response)
        }
    }
}

/// <p>Returns the details of a specific stored query.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStoredQuery {
    _private: (),
}
impl GetStoredQuery {
    /// Creates a new builder-style object to manufacture [`GetStoredQueryInput`](crate::input::GetStoredQueryInput)
    pub fn builder() -> crate::input::get_stored_query_input::Builder {
        crate::input::get_stored_query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStoredQuery {
    type Output =
        std::result::Result<crate::output::GetStoredQueryOutput, crate::error::GetStoredQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_stored_query_error(response)
        } else {
            crate::operation_deser::parse_get_stored_query_response(response)
        }
    }
}

/// <p>Accepts a resource type and returns a list of resource identifiers that are aggregated for a specific resource type across accounts and regions.
/// A resource identifier includes the resource type, ID, (if available) the custom resource name, source account, and source region.
/// You can narrow the results to include only resources that have specific resource IDs, or a resource name, or source account ID, or source region.</p>
/// <p>For example, if the input consists of accountID 12345678910 and the region is us-east-1 for resource type <code>AWS::EC2::Instance</code> then the API returns all the EC2 instance identifiers of accountID 12345678910 and region us-east-1.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAggregateDiscoveredResources {
    _private: (),
}
impl ListAggregateDiscoveredResources {
    /// Creates a new builder-style object to manufacture [`ListAggregateDiscoveredResourcesInput`](crate::input::ListAggregateDiscoveredResourcesInput)
    pub fn builder() -> crate::input::list_aggregate_discovered_resources_input::Builder {
        crate::input::list_aggregate_discovered_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAggregateDiscoveredResources {
    type Output = std::result::Result<
        crate::output::ListAggregateDiscoveredResourcesOutput,
        crate::error::ListAggregateDiscoveredResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_aggregate_discovered_resources_error(response)
        } else {
            crate::operation_deser::parse_list_aggregate_discovered_resources_response(response)
        }
    }
}

/// <p>Accepts a resource type and returns a list of resource
/// identifiers for the resources of that type. A resource identifier
/// includes the resource type, ID, and (if available) the custom
/// resource name. The results consist of resources that AWS Config has
/// discovered, including those that AWS Config is not currently
/// recording. You can narrow the results to include only resources that
/// have specific resource IDs or a resource name.</p>
/// <note>
/// <p>You can specify either resource IDs or a resource name, but
/// not both, in the same request.</p>
/// </note>
/// <p>The response is paginated. By default, AWS Config lists 100
/// resource identifiers on each page. You can customize this number
/// with the <code>limit</code> parameter. The response includes a
/// <code>nextToken</code> string. To get the next page of results,
/// run the request again and specify the string for the
/// <code>nextToken</code> parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDiscoveredResources {
    _private: (),
}
impl ListDiscoveredResources {
    /// Creates a new builder-style object to manufacture [`ListDiscoveredResourcesInput`](crate::input::ListDiscoveredResourcesInput)
    pub fn builder() -> crate::input::list_discovered_resources_input::Builder {
        crate::input::list_discovered_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDiscoveredResources {
    type Output = std::result::Result<
        crate::output::ListDiscoveredResourcesOutput,
        crate::error::ListDiscoveredResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_discovered_resources_error(response)
        } else {
            crate::operation_deser::parse_list_discovered_resources_response(response)
        }
    }
}

/// <p>Lists the stored queries for a single AWS account and a single AWS Region. The default is 100. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStoredQueries {
    _private: (),
}
impl ListStoredQueries {
    /// Creates a new builder-style object to manufacture [`ListStoredQueriesInput`](crate::input::ListStoredQueriesInput)
    pub fn builder() -> crate::input::list_stored_queries_input::Builder {
        crate::input::list_stored_queries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStoredQueries {
    type Output = std::result::Result<
        crate::output::ListStoredQueriesOutput,
        crate::error::ListStoredQueriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_stored_queries_error(response)
        } else {
            crate::operation_deser::parse_list_stored_queries_response(response)
        }
    }
}

/// <p>List the tags for AWS Config resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Authorizes the aggregator account and region to collect data
/// from the source account and region. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAggregationAuthorization {
    _private: (),
}
impl PutAggregationAuthorization {
    /// Creates a new builder-style object to manufacture [`PutAggregationAuthorizationInput`](crate::input::PutAggregationAuthorizationInput)
    pub fn builder() -> crate::input::put_aggregation_authorization_input::Builder {
        crate::input::put_aggregation_authorization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAggregationAuthorization {
    type Output = std::result::Result<
        crate::output::PutAggregationAuthorizationOutput,
        crate::error::PutAggregationAuthorizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_aggregation_authorization_error(response)
        } else {
            crate::operation_deser::parse_put_aggregation_authorization_response(response)
        }
    }
}

/// <p>Adds or updates an AWS Config rule for evaluating whether your
/// AWS resources comply with your desired configurations.</p>
/// <p>You can use this action for custom AWS Config rules and AWS
/// managed Config rules. A custom AWS Config rule is a rule that you
/// develop and maintain. An AWS managed Config rule is a customizable,
/// predefined rule that AWS Config provides.</p>
/// <p>If you are adding a new custom AWS Config rule, you must first
/// create the AWS Lambda function that the rule invokes to evaluate
/// your resources. When you use the <code>PutConfigRule</code> action
/// to add the rule to AWS Config, you must specify the Amazon Resource
/// Name (ARN) that AWS Lambda assigns to the function. Specify the ARN
/// for the <code>SourceIdentifier</code> key. This key is part of the
/// <code>Source</code> object, which is part of the
/// <code>ConfigRule</code> object. </p>
/// <p>If you are adding an AWS managed Config rule, specify the
/// rule's identifier for the <code>SourceIdentifier</code> key. To
/// reference AWS managed Config rule identifiers, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">About AWS Managed Config Rules</a>.</p>
/// <p>For any new rule that you add, specify the
/// <code>ConfigRuleName</code> in the <code>ConfigRule</code>
/// object. Do not specify the <code>ConfigRuleArn</code> or the
/// <code>ConfigRuleId</code>. These values are generated by AWS
/// Config for new rules.</p>
/// <p>If you are updating a rule that you added previously, you can
/// specify the rule by <code>ConfigRuleName</code>,
/// <code>ConfigRuleId</code>, or <code>ConfigRuleArn</code> in the
/// <code>ConfigRule</code> data type that you use in this
/// request.</p>
/// <p>The maximum number of rules that AWS Config supports is 150.</p>
/// <p>For information about requesting a rule limit increase, see
/// <a href="http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config">AWS Config Limits</a> in the <i>AWS General
/// Reference Guide</i>.</p>
/// <p>For more information about developing and using AWS Config
/// rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating AWS Resource Configurations with AWS Config</a>
/// in the <i>AWS Config Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigRule {
    _private: (),
}
impl PutConfigRule {
    /// Creates a new builder-style object to manufacture [`PutConfigRuleInput`](crate::input::PutConfigRuleInput)
    pub fn builder() -> crate::input::put_config_rule_input::Builder {
        crate::input::put_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigRule {
    type Output =
        std::result::Result<crate::output::PutConfigRuleOutput, crate::error::PutConfigRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_config_rule_error(response)
        } else {
            crate::operation_deser::parse_put_config_rule_response(response)
        }
    }
}

/// <p>Creates and updates the configuration aggregator with the
/// selected source accounts and regions. The source account can be
/// individual account(s) or an organization.</p>
/// <p>
/// <code>accountIds</code> that are passed will be replaced with existing accounts.
/// If you want to add additional accounts into the aggregator, call <code>DescribeAggregator</code> to get the previous accounts and then append new ones.</p>
/// <note>
/// <p>AWS Config should be enabled in source accounts and regions
/// you want to aggregate.</p>
/// <p>If your source type is an organization, you must be signed in to the management account or a registered delegated administrator and all the features must be enabled in your organization.
/// If the caller is a management account, AWS Config calls <code>EnableAwsServiceAccess</code> API to enable integration between AWS Config and AWS Organizations.
/// If the caller is a registered delegated administrator, AWS Config calls <code>ListDelegatedAdministrators</code> API to verify whether the caller is a valid delegated administrator.</p>
/// <p>To register a delegated administrator, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/set-up-aggregator-cli.html#register-a-delegated-administrator-cli">Register a Delegated Administrator</a> in the AWS Config developer guide. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationAggregator {
    _private: (),
}
impl PutConfigurationAggregator {
    /// Creates a new builder-style object to manufacture [`PutConfigurationAggregatorInput`](crate::input::PutConfigurationAggregatorInput)
    pub fn builder() -> crate::input::put_configuration_aggregator_input::Builder {
        crate::input::put_configuration_aggregator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationAggregator {
    type Output = std::result::Result<
        crate::output::PutConfigurationAggregatorOutput,
        crate::error::PutConfigurationAggregatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_aggregator_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_aggregator_response(response)
        }
    }
}

/// <p>Creates a new configuration recorder to record the selected
/// resource configurations.</p>
/// <p>You can use this action to change the role <code>roleARN</code>
/// or the <code>recordingGroup</code> of an existing recorder. To
/// change the role, call the action on the existing configuration
/// recorder and specify a role.</p>
/// <note>
/// <p>Currently, you can specify only one configuration recorder
/// per region in your account.</p>
/// <p>If <code>ConfigurationRecorder</code> does not have the
/// <b>recordingGroup</b> parameter
/// specified, the default is to record all supported resource
/// types.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationRecorder {
    _private: (),
}
impl PutConfigurationRecorder {
    /// Creates a new builder-style object to manufacture [`PutConfigurationRecorderInput`](crate::input::PutConfigurationRecorderInput)
    pub fn builder() -> crate::input::put_configuration_recorder_input::Builder {
        crate::input::put_configuration_recorder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationRecorder {
    type Output = std::result::Result<
        crate::output::PutConfigurationRecorderOutput,
        crate::error::PutConfigurationRecorderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_recorder_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_recorder_response(response)
        }
    }
}

/// <p>Creates or updates a conformance pack. A conformance pack is a collection of AWS Config rules that can be easily deployed in an account and a region and across AWS Organization.</p>
/// <p>This API creates a service linked role <code>AWSServiceRoleForConfigConforms</code> in your account.
/// The service linked role is created only when the role does not exist in your account. </p>
/// <note>
/// <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
/// If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConformancePack {
    _private: (),
}
impl PutConformancePack {
    /// Creates a new builder-style object to manufacture [`PutConformancePackInput`](crate::input::PutConformancePackInput)
    pub fn builder() -> crate::input::put_conformance_pack_input::Builder {
        crate::input::put_conformance_pack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConformancePack {
    type Output = std::result::Result<
        crate::output::PutConformancePackOutput,
        crate::error::PutConformancePackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_conformance_pack_error(response)
        } else {
            crate::operation_deser::parse_put_conformance_pack_response(response)
        }
    }
}

/// <p>Creates a delivery channel object to deliver configuration
/// information to an Amazon S3 bucket and Amazon SNS topic.</p>
/// <p>Before you can create a delivery channel, you must create a
/// configuration recorder.</p>
/// <p>You can use this action to change the Amazon S3 bucket or an
/// Amazon SNS topic of the existing delivery channel. To change the
/// Amazon S3 bucket or an Amazon SNS topic, call this action and
/// specify the changed values for the S3 bucket and the SNS topic. If
/// you specify a different value for either the S3 bucket or the SNS
/// topic, this action will keep the existing value for the parameter
/// that is not changed.</p>
/// <note>
/// <p>You can have only one delivery channel per region in your
/// account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDeliveryChannel {
    _private: (),
}
impl PutDeliveryChannel {
    /// Creates a new builder-style object to manufacture [`PutDeliveryChannelInput`](crate::input::PutDeliveryChannelInput)
    pub fn builder() -> crate::input::put_delivery_channel_input::Builder {
        crate::input::put_delivery_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDeliveryChannel {
    type Output = std::result::Result<
        crate::output::PutDeliveryChannelOutput,
        crate::error::PutDeliveryChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_delivery_channel_error(response)
        } else {
            crate::operation_deser::parse_put_delivery_channel_response(response)
        }
    }
}

/// <p>Used by an AWS Lambda function to deliver evaluation results to
/// AWS Config. This action is required in every AWS Lambda function
/// that is invoked by an AWS Config rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEvaluations {
    _private: (),
}
impl PutEvaluations {
    /// Creates a new builder-style object to manufacture [`PutEvaluationsInput`](crate::input::PutEvaluationsInput)
    pub fn builder() -> crate::input::put_evaluations_input::Builder {
        crate::input::put_evaluations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEvaluations {
    type Output =
        std::result::Result<crate::output::PutEvaluationsOutput, crate::error::PutEvaluationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_evaluations_error(response)
        } else {
            crate::operation_deser::parse_put_evaluations_response(response)
        }
    }
}

/// <p>Add or updates the evaluations for process checks.    
/// This API checks if the rule is a process check when the name of the AWS Config rule is provided.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutExternalEvaluation {
    _private: (),
}
impl PutExternalEvaluation {
    /// Creates a new builder-style object to manufacture [`PutExternalEvaluationInput`](crate::input::PutExternalEvaluationInput)
    pub fn builder() -> crate::input::put_external_evaluation_input::Builder {
        crate::input::put_external_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutExternalEvaluation {
    type Output = std::result::Result<
        crate::output::PutExternalEvaluationOutput,
        crate::error::PutExternalEvaluationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_external_evaluation_error(response)
        } else {
            crate::operation_deser::parse_put_external_evaluation_response(response)
        }
    }
}

/// <p>Adds or updates organization config rule for your entire organization evaluating whether your AWS resources comply with your
/// desired configurations.</p>
/// <p> Only a master account and a delegated administrator can create or update an organization config rule.
/// When calling this API with a delegated administrator, you must ensure AWS Organizations
/// <code>ListDelegatedAdministrator</code> permissions are added. </p>
/// <p>This API enables organization service access through the <code>EnableAWSServiceAccess</code> action and creates a service linked
/// role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
/// The service linked role is created only when the role does not exist in the caller account.
/// AWS Config verifies the existence of role with <code>GetRole</code> action.</p>
/// <p>To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
/// <code>register-delegated-administrator</code> for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
/// <p>You can use this action to create both custom AWS Config rules and AWS managed Config rules.
/// If you are adding a new custom AWS Config rule, you must first create AWS Lambda function in the master account or a delegated
/// administrator that the rule invokes to evaluate your resources.
/// When you use the <code>PutOrganizationConfigRule</code> action to add the rule to AWS Config, you must
/// specify the Amazon Resource Name (ARN) that AWS Lambda assigns to the function.
/// If you are adding an AWS managed Config rule, specify the rule's identifier for the <code>RuleIdentifier</code> key.</p>
/// <p>The maximum number of organization config rules that AWS Config supports is 150 and 3 delegated administrator per organization. </p>
/// <note>
/// <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
/// <p>Specify either <code>OrganizationCustomRuleMetadata</code> or <code>OrganizationManagedRuleMetadata</code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutOrganizationConfigRule {
    _private: (),
}
impl PutOrganizationConfigRule {
    /// Creates a new builder-style object to manufacture [`PutOrganizationConfigRuleInput`](crate::input::PutOrganizationConfigRuleInput)
    pub fn builder() -> crate::input::put_organization_config_rule_input::Builder {
        crate::input::put_organization_config_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutOrganizationConfigRule {
    type Output = std::result::Result<
        crate::output::PutOrganizationConfigRuleOutput,
        crate::error::PutOrganizationConfigRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_organization_config_rule_error(response)
        } else {
            crate::operation_deser::parse_put_organization_config_rule_response(response)
        }
    }
}

/// <p>Deploys conformance packs across member accounts in an AWS Organization.</p>
/// <p>Only a master account and a delegated administrator can call this API.
/// When calling this API with a delegated administrator, you must ensure AWS Organizations
/// <code>ListDelegatedAdministrator</code> permissions are added.</p>
/// <p>This API enables organization service access for <code>config-multiaccountsetup.amazonaws.com</code>
/// through the <code>EnableAWSServiceAccess</code> action and creates a
/// service linked role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
/// The service linked role is created only when the role does not exist in the caller account.
/// To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
/// <code>register-delegate-admin</code> for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
/// <note>
/// <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
/// <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
/// If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
/// <p>AWS Config sets the state of a conformance pack to CREATE_IN_PROGRESS and UPDATE_IN_PROGRESS until the conformance pack is created or updated.  
/// You cannot update a conformance pack while it is in this state.</p>
/// <p>You can create 50 conformance packs with 25 AWS Config rules in each pack and 3 delegated administrator per organization. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutOrganizationConformancePack {
    _private: (),
}
impl PutOrganizationConformancePack {
    /// Creates a new builder-style object to manufacture [`PutOrganizationConformancePackInput`](crate::input::PutOrganizationConformancePackInput)
    pub fn builder() -> crate::input::put_organization_conformance_pack_input::Builder {
        crate::input::put_organization_conformance_pack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutOrganizationConformancePack {
    type Output = std::result::Result<
        crate::output::PutOrganizationConformancePackOutput,
        crate::error::PutOrganizationConformancePackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_organization_conformance_pack_error(response)
        } else {
            crate::operation_deser::parse_put_organization_conformance_pack_response(response)
        }
    }
}

/// <p>Adds or updates the remediation configuration with a specific AWS Config rule with the
/// selected target or action.
/// The API creates the <code>RemediationConfiguration</code> object for the AWS Config rule.
/// The AWS Config rule must already exist for you to add a remediation configuration.
/// The target (SSM document) must exist and have permissions to use the target. </p>
/// <note>
/// <p>If you make backward incompatible changes to the SSM document,
/// you must call this again to ensure the remediations can run.</p>
/// <p>This API does not support adding remediation configurations for service-linked AWS Config Rules such as Organization Config rules,
/// the rules deployed by conformance packs, and rules deployed by AWS Security Hub.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRemediationConfigurations {
    _private: (),
}
impl PutRemediationConfigurations {
    /// Creates a new builder-style object to manufacture [`PutRemediationConfigurationsInput`](crate::input::PutRemediationConfigurationsInput)
    pub fn builder() -> crate::input::put_remediation_configurations_input::Builder {
        crate::input::put_remediation_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRemediationConfigurations {
    type Output = std::result::Result<
        crate::output::PutRemediationConfigurationsOutput,
        crate::error::PutRemediationConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_remediation_configurations_error(response)
        } else {
            crate::operation_deser::parse_put_remediation_configurations_response(response)
        }
    }
}

/// <p>A remediation exception is when a specific resource is no longer considered for auto-remediation.
/// This API adds a new exception or updates an existing exception for a specific resource with a specific AWS Config rule. </p>
/// <note>
/// <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
/// Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRemediationExceptions {
    _private: (),
}
impl PutRemediationExceptions {
    /// Creates a new builder-style object to manufacture [`PutRemediationExceptionsInput`](crate::input::PutRemediationExceptionsInput)
    pub fn builder() -> crate::input::put_remediation_exceptions_input::Builder {
        crate::input::put_remediation_exceptions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRemediationExceptions {
    type Output = std::result::Result<
        crate::output::PutRemediationExceptionsOutput,
        crate::error::PutRemediationExceptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_remediation_exceptions_error(response)
        } else {
            crate::operation_deser::parse_put_remediation_exceptions_response(response)
        }
    }
}

/// <p>Records the configuration state for the resource provided in the request.
/// The configuration state of a resource is represented in AWS Config as Configuration Items.
/// Once this API records the configuration item, you can retrieve the list of configuration items for the custom resource type using existing AWS Config APIs. </p>
/// <note>
/// <p>The custom resource type must be registered with AWS CloudFormation. This API accepts the configuration item registered with AWS CloudFormation.</p>
/// <p>When you call this API, AWS Config only stores configuration state of the resource provided in the request. This API does not change or remediate the configuration of the resource.
/// </p>
/// <p>Write-only schema properites are not recorded as part of the published configuration item.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResourceConfig {
    _private: (),
}
impl PutResourceConfig {
    /// Creates a new builder-style object to manufacture [`PutResourceConfigInput`](crate::input::PutResourceConfigInput)
    pub fn builder() -> crate::input::put_resource_config_input::Builder {
        crate::input::put_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResourceConfig {
    type Output = std::result::Result<
        crate::output::PutResourceConfigOutput,
        crate::error::PutResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resource_config_error(response)
        } else {
            crate::operation_deser::parse_put_resource_config_response(response)
        }
    }
}

/// <p>Creates and updates the retention configuration with details
/// about retention period (number of days) that AWS Config stores your
/// historical information. The API creates the
/// <code>RetentionConfiguration</code> object and names the object
/// as <b>default</b>. When you have a
/// <code>RetentionConfiguration</code> object named <b>default</b>, calling the API modifies the
/// default object. </p>
/// <note>
/// <p>Currently, AWS Config supports only one retention
/// configuration per region in your account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRetentionConfiguration {
    _private: (),
}
impl PutRetentionConfiguration {
    /// Creates a new builder-style object to manufacture [`PutRetentionConfigurationInput`](crate::input::PutRetentionConfigurationInput)
    pub fn builder() -> crate::input::put_retention_configuration_input::Builder {
        crate::input::put_retention_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRetentionConfiguration {
    type Output = std::result::Result<
        crate::output::PutRetentionConfigurationOutput,
        crate::error::PutRetentionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_retention_configuration_error(response)
        } else {
            crate::operation_deser::parse_put_retention_configuration_response(response)
        }
    }
}

/// <p>Saves a new query or updates an existing saved query. The <code>QueryName</code> must be unique for a single AWS account and a single AWS Region.
/// You can create upto 300 queries in a single AWS account and a single AWS Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutStoredQuery {
    _private: (),
}
impl PutStoredQuery {
    /// Creates a new builder-style object to manufacture [`PutStoredQueryInput`](crate::input::PutStoredQueryInput)
    pub fn builder() -> crate::input::put_stored_query_input::Builder {
        crate::input::put_stored_query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutStoredQuery {
    type Output =
        std::result::Result<crate::output::PutStoredQueryOutput, crate::error::PutStoredQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_stored_query_error(response)
        } else {
            crate::operation_deser::parse_put_stored_query_response(response)
        }
    }
}

/// <p>Accepts a structured query language (SQL) SELECT command and an aggregator to query configuration state of AWS resources across multiple accounts and regions,
/// performs the corresponding search, and returns resource configurations matching the properties.</p>
/// <p>For more information about query components, see the
/// <a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
/// <b>Query Components</b>
/// </a> section in the AWS Config Developer Guide.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SelectAggregateResourceConfig {
    _private: (),
}
impl SelectAggregateResourceConfig {
    /// Creates a new builder-style object to manufacture [`SelectAggregateResourceConfigInput`](crate::input::SelectAggregateResourceConfigInput)
    pub fn builder() -> crate::input::select_aggregate_resource_config_input::Builder {
        crate::input::select_aggregate_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SelectAggregateResourceConfig {
    type Output = std::result::Result<
        crate::output::SelectAggregateResourceConfigOutput,
        crate::error::SelectAggregateResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_select_aggregate_resource_config_error(response)
        } else {
            crate::operation_deser::parse_select_aggregate_resource_config_response(response)
        }
    }
}

/// <p>Accepts a structured query language (SQL) <code>SELECT</code> command, performs the corresponding search, and returns resource configurations matching the properties.</p>
/// <p>For more information about query components, see the
/// <a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
/// <b>Query Components</b>
/// </a> section in the AWS Config Developer Guide.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SelectResourceConfig {
    _private: (),
}
impl SelectResourceConfig {
    /// Creates a new builder-style object to manufacture [`SelectResourceConfigInput`](crate::input::SelectResourceConfigInput)
    pub fn builder() -> crate::input::select_resource_config_input::Builder {
        crate::input::select_resource_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SelectResourceConfig {
    type Output = std::result::Result<
        crate::output::SelectResourceConfigOutput,
        crate::error::SelectResourceConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_select_resource_config_error(response)
        } else {
            crate::operation_deser::parse_select_resource_config_response(response)
        }
    }
}

/// <p>Runs an on-demand evaluation for the specified AWS Config rules
/// against the last known configuration state of the resources. Use
/// <code>StartConfigRulesEvaluation</code> when you want to test
/// that a rule you updated is working as expected.
/// <code>StartConfigRulesEvaluation</code> does not re-record the
/// latest configuration state for your resources. It re-runs an
/// evaluation against the last known state of your resources. </p>
/// <p>You can specify up to 25 AWS Config rules per request. </p>
/// <p>An existing <code>StartConfigRulesEvaluation</code> call for
/// the specified rules must complete before you can call the API again.
/// If you chose to have AWS Config stream to an Amazon SNS topic, you
/// will receive a <code>ConfigRuleEvaluationStarted</code> notification
/// when the evaluation starts.</p>
/// <note>
/// <p>You don't need to call the
/// <code>StartConfigRulesEvaluation</code> API to run an
/// evaluation for a new rule. When you create a rule, AWS Config
/// evaluates your resources against the rule automatically.
/// </p>
/// </note>
/// <p>The <code>StartConfigRulesEvaluation</code> API is useful if
/// you want to run on-demand evaluations, such as the following
/// example:</p>
/// <ol>
/// <li>
/// <p>You have a custom rule that evaluates your IAM
/// resources every 24 hours.</p>
/// </li>
/// <li>
/// <p>You update your Lambda function to add additional
/// conditions to your rule.</p>
/// </li>
/// <li>
/// <p>Instead of waiting for the next periodic evaluation,
/// you call the <code>StartConfigRulesEvaluation</code>
/// API.</p>
/// </li>
/// <li>
/// <p>AWS Config invokes your Lambda function and evaluates
/// your IAM resources.</p>
/// </li>
/// <li>
/// <p>Your custom rule will still run periodic evaluations
/// every 24 hours.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartConfigRulesEvaluation {
    _private: (),
}
impl StartConfigRulesEvaluation {
    /// Creates a new builder-style object to manufacture [`StartConfigRulesEvaluationInput`](crate::input::StartConfigRulesEvaluationInput)
    pub fn builder() -> crate::input::start_config_rules_evaluation_input::Builder {
        crate::input::start_config_rules_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartConfigRulesEvaluation {
    type Output = std::result::Result<
        crate::output::StartConfigRulesEvaluationOutput,
        crate::error::StartConfigRulesEvaluationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_config_rules_evaluation_error(response)
        } else {
            crate::operation_deser::parse_start_config_rules_evaluation_response(response)
        }
    }
}

/// <p>Starts recording configurations of the AWS resources you have
/// selected to record in your AWS account.</p>
/// <p>You must have created at least one delivery channel to
/// successfully start the configuration recorder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartConfigurationRecorder {
    _private: (),
}
impl StartConfigurationRecorder {
    /// Creates a new builder-style object to manufacture [`StartConfigurationRecorderInput`](crate::input::StartConfigurationRecorderInput)
    pub fn builder() -> crate::input::start_configuration_recorder_input::Builder {
        crate::input::start_configuration_recorder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartConfigurationRecorder {
    type Output = std::result::Result<
        crate::output::StartConfigurationRecorderOutput,
        crate::error::StartConfigurationRecorderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_configuration_recorder_error(response)
        } else {
            crate::operation_deser::parse_start_configuration_recorder_response(response)
        }
    }
}

/// <p>Runs an on-demand remediation for the specified AWS Config rules against the last known remediation configuration. It runs an execution against the current state of your resources. Remediation execution is asynchronous.</p>
/// <p>You can specify up to 100 resource keys per request. An existing StartRemediationExecution call for the specified resource keys must complete before you can call the API again.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartRemediationExecution {
    _private: (),
}
impl StartRemediationExecution {
    /// Creates a new builder-style object to manufacture [`StartRemediationExecutionInput`](crate::input::StartRemediationExecutionInput)
    pub fn builder() -> crate::input::start_remediation_execution_input::Builder {
        crate::input::start_remediation_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartRemediationExecution {
    type Output = std::result::Result<
        crate::output::StartRemediationExecutionOutput,
        crate::error::StartRemediationExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_remediation_execution_error(response)
        } else {
            crate::operation_deser::parse_start_remediation_execution_response(response)
        }
    }
}

/// <p>Stops recording configurations of the AWS resources you have selected to record in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopConfigurationRecorder {
    _private: (),
}
impl StopConfigurationRecorder {
    /// Creates a new builder-style object to manufacture [`StopConfigurationRecorderInput`](crate::input::StopConfigurationRecorderInput)
    pub fn builder() -> crate::input::stop_configuration_recorder_input::Builder {
        crate::input::stop_configuration_recorder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopConfigurationRecorder {
    type Output = std::result::Result<
        crate::output::StopConfigurationRecorderOutput,
        crate::error::StopConfigurationRecorderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_configuration_recorder_error(response)
        } else {
            crate::operation_deser::parse_stop_configuration_recorder_response(response)
        }
    }
}

/// <p>Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed.
/// When a resource is deleted, the tags associated with that resource are deleted as well.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Deletes specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}
