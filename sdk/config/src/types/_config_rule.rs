// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Config rules evaluate the configuration settings of your Amazon Web Services resources. A rule can run when Config detects a configuration change to an Amazon Web Services resource or at a periodic frequency that you choose (for example, every 24 hours). There are two types of rules: Config Managed Rules and Config Custom Rules. Managed rules are predefined, customizable rules created by Config. For a list of managed rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p> 
/// <p>Custom rules are rules that you can create using either Guard or Lambda functions. Guard (<a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>) is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. Lambda uses custom code that you upload to evaluate a custom rule. It is invoked by events that are published to it by an event source, which Config invokes when the custom rule is initiated.</p> 
/// <p>For more information about developing and using Config rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating Amazon Web Services resource Configurations with Config</a> in the <i>Config Developer Guide</i>.</p> <note> 
/// <p>You can use the Amazon Web Services CLI and Amazon Web Services SDKs if you want to create a rule that triggers evaluations for your resources when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRule  {
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_id: std::option::Option<std::string::String>,
    /// <p>The description that you provide for the Config rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note> 
    /// <p>The scope can be empty. </p> 
    /// </note>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::types::Scope>,
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::types::Source>,
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p> 
    /// <ul> 
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li> 
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li> 
    /// </ul> <note> 
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p> 
    /// </note>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::types::MaximumExecutionFrequency>,
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p> 
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    #[doc(hidden)]
    pub config_rule_state: std::option::Option<crate::types::ConfigRuleState>,
    /// <p>Service principal name of the service that created the rule.</p> <note> 
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p> 
    /// </note>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    #[doc(hidden)]
    pub evaluation_modes: std::option::Option<std::vec::Vec<crate::types::EvaluationModeConfiguration>>,
}
impl ConfigRule {
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<& str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    pub fn config_rule_arn(&self) -> std::option::Option<& str> {
        self.config_rule_arn.as_deref()
    }
    /// <p>The ID of the Config rule.</p>
    pub fn config_rule_id(&self) -> std::option::Option<& str> {
        self.config_rule_id.as_deref()
    }
    /// <p>The description that you provide for the Config rule.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note> 
    /// <p>The scope can be empty. </p> 
    /// </note>
    pub fn scope(&self) -> std::option::Option<& crate::types::Scope> {
        self.scope.as_ref()
    }
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    pub fn source(&self) -> std::option::Option<& crate::types::Source> {
        self.source.as_ref()
    }
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    pub fn input_parameters(&self) -> std::option::Option<& str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p> 
    /// <ul> 
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li> 
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li> 
    /// </ul> <note> 
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p> 
    /// </note>
    pub fn maximum_execution_frequency(&self) -> std::option::Option<& crate::types::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p> 
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    pub fn config_rule_state(&self) -> std::option::Option<& crate::types::ConfigRuleState> {
        self.config_rule_state.as_ref()
    }
    /// <p>Service principal name of the service that created the rule.</p> <note> 
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p> 
    /// </note>
    pub fn created_by(&self) -> std::option::Option<& str> {
        self.created_by.as_deref()
    }
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    pub fn evaluation_modes(&self) -> std::option::Option<& [crate::types::EvaluationModeConfiguration]> {
        self.evaluation_modes.as_deref()
    }
}
impl ConfigRule {
    /// Creates a new builder-style object to manufacture [`ConfigRule`](crate::types::ConfigRule).
    pub fn builder() -> crate::types::builders::ConfigRuleBuilder {
        crate::types::builders::ConfigRuleBuilder::default()
    }
}

/// A builder for [`ConfigRule`](crate::types::ConfigRule).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ConfigRuleBuilder {
    pub(crate) config_rule_name: std::option::Option<std::string::String>,
    pub(crate) config_rule_arn: std::option::Option<std::string::String>,
    pub(crate) config_rule_id: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) scope: std::option::Option<crate::types::Scope>,
    pub(crate) source: std::option::Option<crate::types::Source>,
    pub(crate) input_parameters: std::option::Option<std::string::String>,
    pub(crate) maximum_execution_frequency: std::option::Option<crate::types::MaximumExecutionFrequency>,
    pub(crate) config_rule_state: std::option::Option<crate::types::ConfigRuleState>,
    pub(crate) created_by: std::option::Option<std::string::String>,
    pub(crate) evaluation_modes: std::option::Option<std::vec::Vec<crate::types::EvaluationModeConfiguration>>,
}
impl ConfigRuleBuilder {
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.config_rule_name = Some(input.into());
        self
    }
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    pub fn set_config_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.config_rule_name = input; self
    }
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    pub fn config_rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.config_rule_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    pub fn set_config_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.config_rule_arn = input; self
    }
    /// <p>The ID of the Config rule.</p>
    pub fn config_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.config_rule_id = Some(input.into());
        self
    }
    /// <p>The ID of the Config rule.</p>
    pub fn set_config_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.config_rule_id = input; self
    }
    /// <p>The description that you provide for the Config rule.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The description that you provide for the Config rule.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input; self
    }
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note> 
    /// <p>The scope can be empty. </p> 
    /// </note>
    pub fn scope(mut self, input: crate::types::Scope) -> Self {
        self.scope = Some(input);
        self
    }
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note> 
    /// <p>The scope can be empty. </p> 
    /// </note>
    pub fn set_scope(mut self, input: std::option::Option<crate::types::Scope>) -> Self {
        self.scope = input; self
    }
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    pub fn source(mut self, input: crate::types::Source) -> Self {
        self.source = Some(input);
        self
    }
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    pub fn set_source(mut self, input: std::option::Option<crate::types::Source>) -> Self {
        self.source = input; self
    }
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
        self.input_parameters = Some(input.into());
        self
    }
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    pub fn set_input_parameters(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.input_parameters = input; self
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p> 
    /// <ul> 
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li> 
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li> 
    /// </ul> <note> 
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p> 
    /// </note>
    pub fn maximum_execution_frequency(mut self, input: crate::types::MaximumExecutionFrequency) -> Self {
        self.maximum_execution_frequency = Some(input);
        self
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p> 
    /// <ul> 
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li> 
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li> 
    /// </ul> <note> 
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p> 
    /// </note>
    pub fn set_maximum_execution_frequency(mut self, input: std::option::Option<crate::types::MaximumExecutionFrequency>) -> Self {
        self.maximum_execution_frequency = input; self
    }
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p> 
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    pub fn config_rule_state(mut self, input: crate::types::ConfigRuleState) -> Self {
        self.config_rule_state = Some(input);
        self
    }
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p> 
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p> 
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    pub fn set_config_rule_state(mut self, input: std::option::Option<crate::types::ConfigRuleState>) -> Self {
        self.config_rule_state = input; self
    }
    /// <p>Service principal name of the service that created the rule.</p> <note> 
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p> 
    /// </note>
    pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
        self.created_by = Some(input.into());
        self
    }
    /// <p>Service principal name of the service that created the rule.</p> <note> 
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p> 
    /// </note>
    pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.created_by = input; self
    }
    /// Appends an item to `evaluation_modes`.
    ///
    /// To override the contents of this collection use [`set_evaluation_modes`](Self::set_evaluation_modes).
    ///
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    pub fn evaluation_modes(mut self, input: crate::types::EvaluationModeConfiguration) -> Self {
        let mut v = self.evaluation_modes.unwrap_or_default();
                        v.push(input);
                        self.evaluation_modes = Some(v);
                        self
    }
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    pub fn set_evaluation_modes(mut self, input: std::option::Option<std::vec::Vec<crate::types::EvaluationModeConfiguration>>) -> Self {
        self.evaluation_modes = input; self
    }
    /// Consumes the builder and constructs a [`ConfigRule`](crate::types::ConfigRule).
    pub fn build(self) -> crate::types::ConfigRule {
        crate::types::ConfigRule {
            config_rule_name: self.config_rule_name
            ,
            config_rule_arn: self.config_rule_arn
            ,
            config_rule_id: self.config_rule_id
            ,
            description: self.description
            ,
            scope: self.scope
            ,
            source: self.source
            ,
            input_parameters: self.input_parameters
            ,
            maximum_execution_frequency: self.maximum_execution_frequency
            ,
            config_rule_state: self.config_rule_state
            ,
            created_by: self.created_by
            ,
            evaluation_modes: self.evaluation_modes
            ,
        }
    }
}

