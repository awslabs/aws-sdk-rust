// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetAggregateResourceConfigError {
    pub kind: BatchGetAggregateResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetAggregateResourceConfigErrorKind {
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetAggregateResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => _inner.fmt(f),
            BatchGetAggregateResourceConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BatchGetAggregateResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetAggregateResourceConfigError {
    fn code(&self) -> Option<&str> {
        BatchGetAggregateResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetAggregateResourceConfigError {
    pub fn new(kind: BatchGetAggregateResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetAggregateResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetAggregateResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetAggregateResourceConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchGetAggregateResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => Some(_inner),
            BatchGetAggregateResourceConfigErrorKind::ValidationException(_inner) => Some(_inner),
            BatchGetAggregateResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetResourceConfigError {
    pub kind: BatchGetResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetResourceConfigErrorKind {
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetResourceConfigErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetResourceConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BatchGetResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetResourceConfigError {
    fn code(&self) -> Option<&str> {
        BatchGetResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetResourceConfigError {
    pub fn new(kind: BatchGetResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetResourceConfigErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetResourceConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchGetResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetResourceConfigErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            BatchGetResourceConfigErrorKind::ValidationException(_inner) => Some(_inner),
            BatchGetResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAggregationAuthorizationError {
    pub kind: DeleteAggregationAuthorizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAggregationAuthorizationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAggregationAuthorizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAggregationAuthorizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAggregationAuthorizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAggregationAuthorizationError {
    fn code(&self) -> Option<&str> {
        DeleteAggregationAuthorizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAggregationAuthorizationError {
    pub fn new(kind: DeleteAggregationAuthorizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAggregationAuthorizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAggregationAuthorizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAggregationAuthorizationErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DeleteAggregationAuthorizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAggregationAuthorizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteAggregationAuthorizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigRuleError {
    pub kind: DeleteConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigRuleErrorKind {
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            DeleteConfigRuleErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigRuleError {
    fn code(&self) -> Option<&str> {
        DeleteConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigRuleError {
    pub fn new(kind: DeleteConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigRuleErrorKind::NoSuchConfigRuleException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigRuleErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            DeleteConfigRuleErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationAggregatorError {
    pub kind: DeleteConfigurationAggregatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationAggregatorErrorKind {
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationAggregatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationAggregatorErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => _inner.fmt(f),
            DeleteConfigurationAggregatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationAggregatorError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationAggregatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationAggregatorError {
    pub fn new(kind: DeleteConfigurationAggregatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationAggregatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationAggregatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationAggregatorErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationAggregatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationAggregatorErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => Some(_inner),
            DeleteConfigurationAggregatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationRecorderError {
    pub kind: DeleteConfigurationRecorderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationRecorderErrorKind {
    NoSuchConfigurationRecorderException(crate::error::NoSuchConfigurationRecorderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationRecorderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationRecorderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationRecorderError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationRecorderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationRecorderError {
    pub fn new(kind: DeleteConfigurationRecorderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationRecorderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationRecorderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationRecorderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationRecorderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConformancePackError {
    pub kind: DeleteConformancePackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConformancePackErrorKind {
    NoSuchConformancePackException(crate::error::NoSuchConformancePackException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConformancePackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConformancePackErrorKind::NoSuchConformancePackException(_inner) => _inner.fmt(f),
            DeleteConformancePackErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteConformancePackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConformancePackError {
    fn code(&self) -> Option<&str> {
        DeleteConformancePackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConformancePackError {
    pub fn new(kind: DeleteConformancePackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConformancePackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConformancePackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConformancePackErrorKind::NoSuchConformancePackException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConformancePackErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteConformancePackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConformancePackErrorKind::NoSuchConformancePackException(_inner) => Some(_inner),
            DeleteConformancePackErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteConformancePackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDeliveryChannelError {
    pub kind: DeleteDeliveryChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeliveryChannelErrorKind {
    LastDeliveryChannelDeleteFailedException(
        crate::error::LastDeliveryChannelDeleteFailedException,
    ),
    NoSuchDeliveryChannelException(crate::error::NoSuchDeliveryChannelException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDeliveryChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDeliveryChannelErrorKind::LastDeliveryChannelDeleteFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDeliveryChannelErrorKind::NoSuchDeliveryChannelException(_inner) => _inner.fmt(f),
            DeleteDeliveryChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDeliveryChannelError {
    fn code(&self) -> Option<&str> {
        DeleteDeliveryChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDeliveryChannelError {
    pub fn new(kind: DeleteDeliveryChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDeliveryChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDeliveryChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_last_delivery_channel_delete_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeliveryChannelErrorKind::LastDeliveryChannelDeleteFailedException(_)
        )
    }
    pub fn is_no_such_delivery_channel_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeliveryChannelErrorKind::NoSuchDeliveryChannelException(_)
        )
    }
}
impl std::error::Error for DeleteDeliveryChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDeliveryChannelErrorKind::LastDeliveryChannelDeleteFailedException(_inner) => {
                Some(_inner)
            }
            DeleteDeliveryChannelErrorKind::NoSuchDeliveryChannelException(_inner) => Some(_inner),
            DeleteDeliveryChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEvaluationResultsError {
    pub kind: DeleteEvaluationResultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEvaluationResultsErrorKind {
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEvaluationResultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEvaluationResultsErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            DeleteEvaluationResultsErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteEvaluationResultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEvaluationResultsError {
    fn code(&self) -> Option<&str> {
        DeleteEvaluationResultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEvaluationResultsError {
    pub fn new(kind: DeleteEvaluationResultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEvaluationResultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEvaluationResultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEvaluationResultsErrorKind::NoSuchConfigRuleException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEvaluationResultsErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteEvaluationResultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEvaluationResultsErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            DeleteEvaluationResultsErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteEvaluationResultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOrganizationConfigRuleError {
    pub kind: DeleteOrganizationConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOrganizationConfigRuleErrorKind {
    NoSuchOrganizationConfigRuleException(crate::error::NoSuchOrganizationConfigRuleException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOrganizationConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOrganizationConfigRuleErrorKind::NoSuchOrganizationConfigRuleException(
                _inner,
            ) => _inner.fmt(f),
            DeleteOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteOrganizationConfigRuleErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteOrganizationConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOrganizationConfigRuleError {
    fn code(&self) -> Option<&str> {
        DeleteOrganizationConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOrganizationConfigRuleError {
    pub fn new(kind: DeleteOrganizationConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOrganizationConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOrganizationConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_organization_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConfigRuleErrorKind::NoSuchOrganizationConfigRuleException(_)
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConfigRuleErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteOrganizationConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOrganizationConfigRuleErrorKind::NoSuchOrganizationConfigRuleException(
                _inner,
            ) => Some(_inner),
            DeleteOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteOrganizationConfigRuleErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteOrganizationConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOrganizationConformancePackError {
    pub kind: DeleteOrganizationConformancePackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOrganizationConformancePackErrorKind {
    NoSuchOrganizationConformancePackException(
        crate::error::NoSuchOrganizationConformancePackException,
    ),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOrganizationConformancePackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOrganizationConformancePackErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteOrganizationConformancePackErrorKind::ResourceInUseException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteOrganizationConformancePackErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOrganizationConformancePackError {
    fn code(&self) -> Option<&str> {
        DeleteOrganizationConformancePackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOrganizationConformancePackError {
    pub fn new(
        kind: DeleteOrganizationConformancePackErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOrganizationConformancePackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOrganizationConformancePackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_organization_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConformancePackErrorKind::NoSuchOrganizationConformancePackException(
                _
            )
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOrganizationConformancePackErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteOrganizationConformancePackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOrganizationConformancePackErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            Some(_inner)
            ,
            DeleteOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteOrganizationConformancePackErrorKind::ResourceInUseException(_inner) =>
            Some(_inner)
            ,
            DeleteOrganizationConformancePackErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePendingAggregationRequestError {
    pub kind: DeletePendingAggregationRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePendingAggregationRequestErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePendingAggregationRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePendingAggregationRequestErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeletePendingAggregationRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePendingAggregationRequestError {
    fn code(&self) -> Option<&str> {
        DeletePendingAggregationRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePendingAggregationRequestError {
    pub fn new(kind: DeletePendingAggregationRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePendingAggregationRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePendingAggregationRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePendingAggregationRequestErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DeletePendingAggregationRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePendingAggregationRequestErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeletePendingAggregationRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRemediationConfigurationError {
    pub kind: DeleteRemediationConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRemediationConfigurationErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchRemediationConfigurationException(crate::error::NoSuchRemediationConfigurationException),
    RemediationInProgressException(crate::error::RemediationInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRemediationConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRemediationConfigurationErrorKind::InsufficientPermissionsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRemediationConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRemediationConfigurationErrorKind::NoSuchRemediationConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            DeleteRemediationConfigurationErrorKind::RemediationInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRemediationConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRemediationConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteRemediationConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRemediationConfigurationError {
    pub fn new(kind: DeleteRemediationConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRemediationConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRemediationConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemediationConfigurationErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemediationConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_remediation_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemediationConfigurationErrorKind::NoSuchRemediationConfigurationException(_)
        )
    }
    pub fn is_remediation_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemediationConfigurationErrorKind::RemediationInProgressException(_)
        )
    }
}
impl std::error::Error for DeleteRemediationConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRemediationConfigurationErrorKind::InsufficientPermissionsException(_inner) => {
                Some(_inner)
            }
            DeleteRemediationConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteRemediationConfigurationErrorKind::NoSuchRemediationConfigurationException(
                _inner,
            ) => Some(_inner),
            DeleteRemediationConfigurationErrorKind::RemediationInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteRemediationConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRemediationExceptionsError {
    pub kind: DeleteRemediationExceptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRemediationExceptionsErrorKind {
    NoSuchRemediationExceptionException(crate::error::NoSuchRemediationExceptionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRemediationExceptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRemediationExceptionsErrorKind::NoSuchRemediationExceptionException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRemediationExceptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRemediationExceptionsError {
    fn code(&self) -> Option<&str> {
        DeleteRemediationExceptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRemediationExceptionsError {
    pub fn new(kind: DeleteRemediationExceptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRemediationExceptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRemediationExceptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_remediation_exception_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemediationExceptionsErrorKind::NoSuchRemediationExceptionException(_)
        )
    }
}
impl std::error::Error for DeleteRemediationExceptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRemediationExceptionsErrorKind::NoSuchRemediationExceptionException(_inner) => {
                Some(_inner)
            }
            DeleteRemediationExceptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourceConfigError {
    pub kind: DeleteResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourceConfigErrorKind {
    NoRunningConfigurationRecorderException(crate::error::NoRunningConfigurationRecorderException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourceConfigErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResourceConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourceConfigError {
    fn code(&self) -> Option<&str> {
        DeleteResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourceConfigError {
    pub fn new(kind: DeleteResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_running_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceConfigErrorKind::NoRunningConfigurationRecorderException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourceConfigErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            DeleteResourceConfigErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRetentionConfigurationError {
    pub kind: DeleteRetentionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRetentionConfigurationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchRetentionConfigurationException(crate::error::NoSuchRetentionConfigurationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRetentionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRetentionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRetentionConfigurationErrorKind::NoSuchRetentionConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            DeleteRetentionConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRetentionConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteRetentionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRetentionConfigurationError {
    pub fn new(kind: DeleteRetentionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRetentionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRetentionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_retention_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionConfigurationErrorKind::NoSuchRetentionConfigurationException(_)
        )
    }
}
impl std::error::Error for DeleteRetentionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRetentionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteRetentionConfigurationErrorKind::NoSuchRetentionConfigurationException(
                _inner,
            ) => Some(_inner),
            DeleteRetentionConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStoredQueryError {
    pub kind: DeleteStoredQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStoredQueryErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStoredQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStoredQueryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteStoredQueryErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteStoredQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStoredQueryError {
    fn code(&self) -> Option<&str> {
        DeleteStoredQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStoredQueryError {
    pub fn new(kind: DeleteStoredQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStoredQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStoredQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStoredQueryErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStoredQueryErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteStoredQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStoredQueryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteStoredQueryErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteStoredQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeliverConfigSnapshotError {
    pub kind: DeliverConfigSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeliverConfigSnapshotErrorKind {
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    NoRunningConfigurationRecorderException(crate::error::NoRunningConfigurationRecorderException),
    NoSuchDeliveryChannelException(crate::error::NoSuchDeliveryChannelException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeliverConfigSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeliverConfigSnapshotErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            DeliverConfigSnapshotErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            DeliverConfigSnapshotErrorKind::NoSuchDeliveryChannelException(_inner) => _inner.fmt(f),
            DeliverConfigSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeliverConfigSnapshotError {
    fn code(&self) -> Option<&str> {
        DeliverConfigSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeliverConfigSnapshotError {
    pub fn new(kind: DeliverConfigSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeliverConfigSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeliverConfigSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeliverConfigSnapshotErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_no_running_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeliverConfigSnapshotErrorKind::NoRunningConfigurationRecorderException(_)
        )
    }
    pub fn is_no_such_delivery_channel_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeliverConfigSnapshotErrorKind::NoSuchDeliveryChannelException(_)
        )
    }
}
impl std::error::Error for DeliverConfigSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeliverConfigSnapshotErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            DeliverConfigSnapshotErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            DeliverConfigSnapshotErrorKind::NoSuchDeliveryChannelException(_inner) => Some(_inner),
            DeliverConfigSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAggregateComplianceByConfigRulesError {
    pub kind: DescribeAggregateComplianceByConfigRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAggregateComplianceByConfigRulesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAggregateComplianceByConfigRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAggregateComplianceByConfigRulesError {
    fn code(&self) -> Option<&str> {
        DescribeAggregateComplianceByConfigRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAggregateComplianceByConfigRulesError {
    pub fn new(
        kind: DescribeAggregateComplianceByConfigRulesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAggregateComplianceByConfigRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAggregateComplianceByConfigRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, DescribeAggregateComplianceByConfigRulesErrorKind::NoSuchConfigurationAggregatorException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConfigRulesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeAggregateComplianceByConfigRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConfigRulesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAggregateComplianceByConformancePacksError {
    pub kind: DescribeAggregateComplianceByConformancePacksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAggregateComplianceByConformancePacksErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAggregateComplianceByConformancePacksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAggregateComplianceByConformancePacksError {
    fn code(&self) -> Option<&str> {
        DescribeAggregateComplianceByConformancePacksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAggregateComplianceByConformancePacksError {
    pub fn new(
        kind: DescribeAggregateComplianceByConformancePacksErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAggregateComplianceByConformancePacksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAggregateComplianceByConformancePacksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, DescribeAggregateComplianceByConformancePacksErrorKind::NoSuchConfigurationAggregatorException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregateComplianceByConformancePacksErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeAggregateComplianceByConformancePacksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribeAggregateComplianceByConformancePacksErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAggregationAuthorizationsError {
    pub kind: DescribeAggregationAuthorizationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAggregationAuthorizationsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAggregationAuthorizationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAggregationAuthorizationsErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAggregationAuthorizationsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAggregationAuthorizationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAggregationAuthorizationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAggregationAuthorizationsError {
    fn code(&self) -> Option<&str> {
        DescribeAggregationAuthorizationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAggregationAuthorizationsError {
    pub fn new(
        kind: DescribeAggregationAuthorizationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAggregationAuthorizationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAggregationAuthorizationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregationAuthorizationsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregationAuthorizationsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAggregationAuthorizationsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeAggregationAuthorizationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAggregationAuthorizationsErrorKind::InvalidLimitException(_inner) => {
                Some(_inner)
            }
            DescribeAggregationAuthorizationsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeAggregationAuthorizationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeAggregationAuthorizationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeComplianceByConfigRuleError {
    pub kind: DescribeComplianceByConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeComplianceByConfigRuleErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeComplianceByConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeComplianceByConfigRuleErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeComplianceByConfigRuleErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeComplianceByConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => {
                _inner.fmt(f)
            }
            DescribeComplianceByConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeComplianceByConfigRuleError {
    fn code(&self) -> Option<&str> {
        DescribeComplianceByConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeComplianceByConfigRuleError {
    pub fn new(kind: DescribeComplianceByConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeComplianceByConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeComplianceByConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComplianceByConfigRuleErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComplianceByConfigRuleErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComplianceByConfigRuleErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for DescribeComplianceByConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeComplianceByConfigRuleErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeComplianceByConfigRuleErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeComplianceByConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => {
                Some(_inner)
            }
            DescribeComplianceByConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeComplianceByResourceError {
    pub kind: DescribeComplianceByResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeComplianceByResourceErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeComplianceByResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeComplianceByResourceErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeComplianceByResourceErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeComplianceByResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeComplianceByResourceError {
    fn code(&self) -> Option<&str> {
        DescribeComplianceByResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeComplianceByResourceError {
    pub fn new(kind: DescribeComplianceByResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeComplianceByResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeComplianceByResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComplianceByResourceErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComplianceByResourceErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeComplianceByResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeComplianceByResourceErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeComplianceByResourceErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeComplianceByResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigRuleEvaluationStatusError {
    pub kind: DescribeConfigRuleEvaluationStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigRuleEvaluationStatusErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigRuleEvaluationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::NoSuchConfigRuleException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigRuleEvaluationStatusError {
    fn code(&self) -> Option<&str> {
        DescribeConfigRuleEvaluationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigRuleEvaluationStatusError {
    pub fn new(
        kind: DescribeConfigRuleEvaluationStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigRuleEvaluationStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigRuleEvaluationStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigRuleEvaluationStatusErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for DescribeConfigRuleEvaluationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::NoSuchConfigRuleException(_inner) => {
                Some(_inner)
            }
            DescribeConfigRuleEvaluationStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigRulesError {
    pub kind: DescribeConfigRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigRulesErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigRulesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            DescribeConfigRulesErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            DescribeConfigRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigRulesError {
    fn code(&self) -> Option<&str> {
        DescribeConfigRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigRulesError {
    pub fn new(kind: DescribeConfigRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigRulesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigRulesErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for DescribeConfigRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigRulesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            DescribeConfigRulesErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            DescribeConfigRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationAggregatorsError {
    pub kind: DescribeConfigurationAggregatorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationAggregatorsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationAggregatorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationAggregatorsErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationAggregatorsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationAggregatorsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationAggregatorsErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => _inner.fmt(f),
            DescribeConfigurationAggregatorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationAggregatorsError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationAggregatorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationAggregatorsError {
    pub fn new(kind: DescribeConfigurationAggregatorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationAggregatorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationAggregatorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorsErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationAggregatorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationAggregatorsErrorKind::InvalidLimitException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationAggregatorsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationAggregatorsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationAggregatorsErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => Some(_inner),
            DescribeConfigurationAggregatorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationAggregatorSourcesStatusError {
    pub kind: DescribeConfigurationAggregatorSourcesStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationAggregatorSourcesStatusErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationAggregatorSourcesStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationAggregatorSourcesStatusError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationAggregatorSourcesStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationAggregatorSourcesStatusError {
    pub fn new(
        kind: DescribeConfigurationAggregatorSourcesStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationAggregatorSourcesStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationAggregatorSourcesStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidParameterValueException(
                _
            )
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, DescribeConfigurationAggregatorSourcesStatusErrorKind::NoSuchConfigurationAggregatorException(_))
    }
}
impl std::error::Error for DescribeConfigurationAggregatorSourcesStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            DescribeConfigurationAggregatorSourcesStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationRecordersError {
    pub kind: DescribeConfigurationRecordersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationRecordersErrorKind {
    NoSuchConfigurationRecorderException(crate::error::NoSuchConfigurationRecorderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationRecordersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationRecordersErrorKind::NoSuchConfigurationRecorderException(
                _inner,
            ) => _inner.fmt(f),
            DescribeConfigurationRecordersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationRecordersError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationRecordersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationRecordersError {
    pub fn new(kind: DescribeConfigurationRecordersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationRecordersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationRecordersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRecordersErrorKind::NoSuchConfigurationRecorderException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationRecordersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationRecordersErrorKind::NoSuchConfigurationRecorderException(
                _inner,
            ) => Some(_inner),
            DescribeConfigurationRecordersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationRecorderStatusError {
    pub kind: DescribeConfigurationRecorderStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationRecorderStatusErrorKind {
    NoSuchConfigurationRecorderException(crate::error::NoSuchConfigurationRecorderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationRecorderStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationRecorderStatusErrorKind::NoSuchConfigurationRecorderException(
                _inner,
            ) => _inner.fmt(f),
            DescribeConfigurationRecorderStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationRecorderStatusError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationRecorderStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationRecorderStatusError {
    pub fn new(
        kind: DescribeConfigurationRecorderStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationRecorderStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationRecorderStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRecorderStatusErrorKind::NoSuchConfigurationRecorderException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationRecorderStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationRecorderStatusErrorKind::NoSuchConfigurationRecorderException(
                _inner,
            ) => Some(_inner),
            DescribeConfigurationRecorderStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConformancePackComplianceError {
    pub kind: DescribeConformancePackComplianceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConformancePackComplianceErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleInConformancePackException(
        crate::error::NoSuchConfigRuleInConformancePackException,
    ),
    NoSuchConformancePackException(crate::error::NoSuchConformancePackException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConformancePackComplianceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConformancePackComplianceErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConformancePackComplianceErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConformancePackComplianceErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConformancePackComplianceErrorKind::NoSuchConfigRuleInConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConformancePackComplianceErrorKind::NoSuchConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeConformancePackComplianceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConformancePackComplianceError {
    fn code(&self) -> Option<&str> {
        DescribeConformancePackComplianceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConformancePackComplianceError {
    pub fn new(
        kind: DescribeConformancePackComplianceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConformancePackComplianceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConformancePackComplianceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackComplianceErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackComplianceErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackComplianceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_in_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackComplianceErrorKind::NoSuchConfigRuleInConformancePackException(
                _
            )
        )
    }
    pub fn is_no_such_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackComplianceErrorKind::NoSuchConformancePackException(_)
        )
    }
}
impl std::error::Error for DescribeConformancePackComplianceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConformancePackComplianceErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeConformancePackComplianceErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeConformancePackComplianceErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DescribeConformancePackComplianceErrorKind::NoSuchConfigRuleInConformancePackException(_inner) =>
            Some(_inner)
            ,
            DescribeConformancePackComplianceErrorKind::NoSuchConformancePackException(_inner) =>
            Some(_inner)
            ,
            DescribeConformancePackComplianceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConformancePacksError {
    pub kind: DescribeConformancePacksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConformancePacksErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConformancePackException(crate::error::NoSuchConformancePackException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConformancePacksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConformancePacksErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            DescribeConformancePacksErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            DescribeConformancePacksErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConformancePacksErrorKind::NoSuchConformancePackException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConformancePacksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConformancePacksError {
    fn code(&self) -> Option<&str> {
        DescribeConformancePacksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConformancePacksError {
    pub fn new(kind: DescribeConformancePacksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConformancePacksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConformancePacksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePacksErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePacksErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePacksErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePacksErrorKind::NoSuchConformancePackException(_)
        )
    }
}
impl std::error::Error for DescribeConformancePacksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConformancePacksErrorKind::InvalidLimitException(_inner) => Some(_inner),
            DescribeConformancePacksErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            DescribeConformancePacksErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeConformancePacksErrorKind::NoSuchConformancePackException(_inner) => {
                Some(_inner)
            }
            DescribeConformancePacksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConformancePackStatusError {
    pub kind: DescribeConformancePackStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConformancePackStatusErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConformancePackStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConformancePackStatusErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            DescribeConformancePackStatusErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConformancePackStatusErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConformancePackStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConformancePackStatusError {
    fn code(&self) -> Option<&str> {
        DescribeConformancePackStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConformancePackStatusError {
    pub fn new(kind: DescribeConformancePackStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConformancePackStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConformancePackStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackStatusErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConformancePackStatusErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeConformancePackStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConformancePackStatusErrorKind::InvalidLimitException(_inner) => Some(_inner),
            DescribeConformancePackStatusErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeConformancePackStatusErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeConformancePackStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDeliveryChannelsError {
    pub kind: DescribeDeliveryChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDeliveryChannelsErrorKind {
    NoSuchDeliveryChannelException(crate::error::NoSuchDeliveryChannelException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDeliveryChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDeliveryChannelsErrorKind::NoSuchDeliveryChannelException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDeliveryChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDeliveryChannelsError {
    fn code(&self) -> Option<&str> {
        DescribeDeliveryChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDeliveryChannelsError {
    pub fn new(kind: DescribeDeliveryChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDeliveryChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDeliveryChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_delivery_channel_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeliveryChannelsErrorKind::NoSuchDeliveryChannelException(_)
        )
    }
}
impl std::error::Error for DescribeDeliveryChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDeliveryChannelsErrorKind::NoSuchDeliveryChannelException(_inner) => {
                Some(_inner)
            }
            DescribeDeliveryChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDeliveryChannelStatusError {
    pub kind: DescribeDeliveryChannelStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDeliveryChannelStatusErrorKind {
    NoSuchDeliveryChannelException(crate::error::NoSuchDeliveryChannelException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDeliveryChannelStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDeliveryChannelStatusErrorKind::NoSuchDeliveryChannelException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDeliveryChannelStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDeliveryChannelStatusError {
    fn code(&self) -> Option<&str> {
        DescribeDeliveryChannelStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDeliveryChannelStatusError {
    pub fn new(kind: DescribeDeliveryChannelStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDeliveryChannelStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDeliveryChannelStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_delivery_channel_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeliveryChannelStatusErrorKind::NoSuchDeliveryChannelException(_)
        )
    }
}
impl std::error::Error for DescribeDeliveryChannelStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDeliveryChannelStatusErrorKind::NoSuchDeliveryChannelException(_inner) => {
                Some(_inner)
            }
            DescribeDeliveryChannelStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrganizationConfigRulesError {
    pub kind: DescribeOrganizationConfigRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrganizationConfigRulesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConfigRuleException(crate::error::NoSuchOrganizationConfigRuleException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrganizationConfigRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrganizationConfigRulesErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigRulesErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigRulesErrorKind::NoSuchOrganizationConfigRuleException(
                _inner,
            ) => _inner.fmt(f),
            DescribeOrganizationConfigRulesErrorKind::OrganizationAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrganizationConfigRulesError {
    fn code(&self) -> Option<&str> {
        DescribeOrganizationConfigRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrganizationConfigRulesError {
    pub fn new(kind: DescribeOrganizationConfigRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrganizationConfigRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrganizationConfigRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRulesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRulesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRulesErrorKind::NoSuchOrganizationConfigRuleException(_)
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRulesErrorKind::OrganizationAccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeOrganizationConfigRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrganizationConfigRulesErrorKind::InvalidLimitException(_inner) => Some(_inner),
            DescribeOrganizationConfigRulesErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeOrganizationConfigRulesErrorKind::NoSuchOrganizationConfigRuleException(
                _inner,
            ) => Some(_inner),
            DescribeOrganizationConfigRulesErrorKind::OrganizationAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeOrganizationConfigRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrganizationConfigRuleStatusesError {
    pub kind: DescribeOrganizationConfigRuleStatusesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrganizationConfigRuleStatusesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConfigRuleException(crate::error::NoSuchOrganizationConfigRuleException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrganizationConfigRuleStatusesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::NoSuchOrganizationConfigRuleException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrganizationConfigRuleStatusesError {
    fn code(&self) -> Option<&str> {
        DescribeOrganizationConfigRuleStatusesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrganizationConfigRuleStatusesError {
    pub fn new(
        kind: DescribeOrganizationConfigRuleStatusesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrganizationConfigRuleStatusesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrganizationConfigRuleStatusesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRuleStatusesErrorKind::NoSuchOrganizationConfigRuleException(
                _
            )
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigRuleStatusesErrorKind::OrganizationAccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeOrganizationConfigRuleStatusesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::NoSuchOrganizationConfigRuleException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConfigRuleStatusesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrganizationConformancePacksError {
    pub kind: DescribeOrganizationConformancePacksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrganizationConformancePacksErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConformancePackException(
        crate::error::NoSuchOrganizationConformancePackException,
    ),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrganizationConformancePacksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrganizationConformancePacksErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePacksErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePacksErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePacksErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePacksErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrganizationConformancePacksError {
    fn code(&self) -> Option<&str> {
        DescribeOrganizationConformancePacksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrganizationConformancePacksError {
    pub fn new(
        kind: DescribeOrganizationConformancePacksErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrganizationConformancePacksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrganizationConformancePacksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePacksErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePacksErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_conformance_pack_exception(&self) -> bool {
        matches!(&self.kind, DescribeOrganizationConformancePacksErrorKind::NoSuchOrganizationConformancePackException(_))
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePacksErrorKind::OrganizationAccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeOrganizationConformancePacksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrganizationConformancePacksErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePacksErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePacksErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePacksErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePacksErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrganizationConformancePackStatusesError {
    pub kind: DescribeOrganizationConformancePackStatusesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrganizationConformancePackStatusesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConformancePackException(
        crate::error::NoSuchOrganizationConformancePackException,
    ),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrganizationConformancePackStatusesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrganizationConformancePackStatusesError {
    fn code(&self) -> Option<&str> {
        DescribeOrganizationConformancePackStatusesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrganizationConformancePackStatusesError {
    pub fn new(
        kind: DescribeOrganizationConformancePackStatusesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrganizationConformancePackStatusesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrganizationConformancePackStatusesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_conformance_pack_exception(&self) -> bool {
        matches!(&self.kind, DescribeOrganizationConformancePackStatusesErrorKind::NoSuchOrganizationConformancePackException(_))
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConformancePackStatusesErrorKind::OrganizationAccessDeniedException(
                _
            )
        )
    }
}
impl std::error::Error for DescribeOrganizationConformancePackStatusesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeOrganizationConformancePackStatusesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePendingAggregationRequestsError {
    pub kind: DescribePendingAggregationRequestsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePendingAggregationRequestsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePendingAggregationRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePendingAggregationRequestsErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            DescribePendingAggregationRequestsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribePendingAggregationRequestsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribePendingAggregationRequestsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePendingAggregationRequestsError {
    fn code(&self) -> Option<&str> {
        DescribePendingAggregationRequestsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePendingAggregationRequestsError {
    pub fn new(
        kind: DescribePendingAggregationRequestsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePendingAggregationRequestsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePendingAggregationRequestsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePendingAggregationRequestsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePendingAggregationRequestsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePendingAggregationRequestsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribePendingAggregationRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePendingAggregationRequestsErrorKind::InvalidLimitException(_inner) => {
                Some(_inner)
            }
            DescribePendingAggregationRequestsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribePendingAggregationRequestsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribePendingAggregationRequestsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRemediationConfigurationsError {
    pub kind: DescribeRemediationConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRemediationConfigurationsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRemediationConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRemediationConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRemediationConfigurationsError {
    fn code(&self) -> Option<&str> {
        DescribeRemediationConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRemediationConfigurationsError {
    pub fn new(
        kind: DescribeRemediationConfigurationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRemediationConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRemediationConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeRemediationConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRemediationConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRemediationExceptionsError {
    pub kind: DescribeRemediationExceptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRemediationExceptionsErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRemediationExceptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRemediationExceptionsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeRemediationExceptionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeRemediationExceptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRemediationExceptionsError {
    fn code(&self) -> Option<&str> {
        DescribeRemediationExceptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRemediationExceptionsError {
    pub fn new(kind: DescribeRemediationExceptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRemediationExceptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRemediationExceptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRemediationExceptionsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRemediationExceptionsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeRemediationExceptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRemediationExceptionsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeRemediationExceptionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeRemediationExceptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRemediationExecutionStatusError {
    pub kind: DescribeRemediationExecutionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRemediationExecutionStatusErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchRemediationConfigurationException(crate::error::NoSuchRemediationConfigurationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRemediationExecutionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRemediationExecutionStatusErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeRemediationExecutionStatusErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeRemediationExecutionStatusErrorKind::NoSuchRemediationConfigurationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeRemediationExecutionStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRemediationExecutionStatusError {
    fn code(&self) -> Option<&str> {
        DescribeRemediationExecutionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRemediationExecutionStatusError {
    pub fn new(
        kind: DescribeRemediationExecutionStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRemediationExecutionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRemediationExecutionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRemediationExecutionStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRemediationExecutionStatusErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_remediation_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRemediationExecutionStatusErrorKind::NoSuchRemediationConfigurationException(_)
        )
    }
}
impl std::error::Error for DescribeRemediationExecutionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRemediationExecutionStatusErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            DescribeRemediationExecutionStatusErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DescribeRemediationExecutionStatusErrorKind::NoSuchRemediationConfigurationException(_inner) =>
            Some(_inner)
            ,
            DescribeRemediationExecutionStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRetentionConfigurationsError {
    pub kind: DescribeRetentionConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRetentionConfigurationsErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchRetentionConfigurationException(crate::error::NoSuchRetentionConfigurationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRetentionConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRetentionConfigurationsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeRetentionConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeRetentionConfigurationsErrorKind::NoSuchRetentionConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            DescribeRetentionConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRetentionConfigurationsError {
    fn code(&self) -> Option<&str> {
        DescribeRetentionConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRetentionConfigurationsError {
    pub fn new(kind: DescribeRetentionConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRetentionConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRetentionConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRetentionConfigurationsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRetentionConfigurationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_retention_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRetentionConfigurationsErrorKind::NoSuchRetentionConfigurationException(_)
        )
    }
}
impl std::error::Error for DescribeRetentionConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRetentionConfigurationsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            DescribeRetentionConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeRetentionConfigurationsErrorKind::NoSuchRetentionConfigurationException(
                _inner,
            ) => Some(_inner),
            DescribeRetentionConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAggregateComplianceDetailsByConfigRuleError {
    pub kind: GetAggregateComplianceDetailsByConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAggregateComplianceDetailsByConfigRuleErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAggregateComplianceDetailsByConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAggregateComplianceDetailsByConfigRuleError {
    fn code(&self) -> Option<&str> {
        GetAggregateComplianceDetailsByConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAggregateComplianceDetailsByConfigRuleError {
    pub fn new(
        kind: GetAggregateComplianceDetailsByConfigRuleErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAggregateComplianceDetailsByConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAggregateComplianceDetailsByConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, GetAggregateComplianceDetailsByConfigRuleErrorKind::NoSuchConfigurationAggregatorException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAggregateComplianceDetailsByConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetAggregateComplianceDetailsByConfigRuleErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAggregateConfigRuleComplianceSummaryError {
    pub kind: GetAggregateConfigRuleComplianceSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAggregateConfigRuleComplianceSummaryErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAggregateConfigRuleComplianceSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAggregateConfigRuleComplianceSummaryError {
    fn code(&self) -> Option<&str> {
        GetAggregateConfigRuleComplianceSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAggregateConfigRuleComplianceSummaryError {
    pub fn new(
        kind: GetAggregateConfigRuleComplianceSummaryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAggregateConfigRuleComplianceSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAggregateConfigRuleComplianceSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, GetAggregateConfigRuleComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConfigRuleComplianceSummaryErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAggregateConfigRuleComplianceSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConfigRuleComplianceSummaryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAggregateConformancePackComplianceSummaryError {
    pub kind: GetAggregateConformancePackComplianceSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAggregateConformancePackComplianceSummaryErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAggregateConformancePackComplianceSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAggregateConformancePackComplianceSummaryError {
    fn code(&self) -> Option<&str> {
        GetAggregateConformancePackComplianceSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAggregateConformancePackComplianceSummaryError {
    pub fn new(
        kind: GetAggregateConformancePackComplianceSummaryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAggregateConformancePackComplianceSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAggregateConformancePackComplianceSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(&self.kind, GetAggregateConformancePackComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateConformancePackComplianceSummaryErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAggregateConformancePackComplianceSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetAggregateConformancePackComplianceSummaryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAggregateDiscoveredResourceCountsError {
    pub kind: GetAggregateDiscoveredResourceCountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAggregateDiscoveredResourceCountsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAggregateDiscoveredResourceCountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAggregateDiscoveredResourceCountsError {
    fn code(&self) -> Option<&str> {
        GetAggregateDiscoveredResourceCountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAggregateDiscoveredResourceCountsError {
    pub fn new(
        kind: GetAggregateDiscoveredResourceCountsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAggregateDiscoveredResourceCountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAggregateDiscoveredResourceCountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateDiscoveredResourceCountsErrorKind::NoSuchConfigurationAggregatorException(
                _
            )
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateDiscoveredResourceCountsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAggregateDiscoveredResourceCountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::NoSuchConfigurationAggregatorException(_inner) =>
            Some(_inner)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetAggregateDiscoveredResourceCountsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAggregateResourceConfigError {
    pub kind: GetAggregateResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAggregateResourceConfigErrorKind {
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    OversizedConfigurationItemException(crate::error::OversizedConfigurationItemException),
    ResourceNotDiscoveredException(crate::error::ResourceNotDiscoveredException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAggregateResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(_inner) => {
                _inner.fmt(f)
            }
            GetAggregateResourceConfigErrorKind::OversizedConfigurationItemException(_inner) => {
                _inner.fmt(f)
            }
            GetAggregateResourceConfigErrorKind::ResourceNotDiscoveredException(_inner) => {
                _inner.fmt(f)
            }
            GetAggregateResourceConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAggregateResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAggregateResourceConfigError {
    fn code(&self) -> Option<&str> {
        GetAggregateResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAggregateResourceConfigError {
    pub fn new(kind: GetAggregateResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAggregateResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAggregateResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
    pub fn is_oversized_configuration_item_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateResourceConfigErrorKind::OversizedConfigurationItemException(_)
        )
    }
    pub fn is_resource_not_discovered_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateResourceConfigErrorKind::ResourceNotDiscoveredException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAggregateResourceConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAggregateResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(_inner) => {
                Some(_inner)
            }
            GetAggregateResourceConfigErrorKind::OversizedConfigurationItemException(_inner) => {
                Some(_inner)
            }
            GetAggregateResourceConfigErrorKind::ResourceNotDiscoveredException(_inner) => {
                Some(_inner)
            }
            GetAggregateResourceConfigErrorKind::ValidationException(_inner) => Some(_inner),
            GetAggregateResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetComplianceDetailsByConfigRuleError {
    pub kind: GetComplianceDetailsByConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetComplianceDetailsByConfigRuleErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetComplianceDetailsByConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetComplianceDetailsByConfigRuleErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetComplianceDetailsByConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => {
                _inner.fmt(f)
            }
            GetComplianceDetailsByConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetComplianceDetailsByConfigRuleError {
    fn code(&self) -> Option<&str> {
        GetComplianceDetailsByConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetComplianceDetailsByConfigRuleError {
    pub fn new(kind: GetComplianceDetailsByConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetComplianceDetailsByConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetComplianceDetailsByConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetComplianceDetailsByConfigRuleErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetComplianceDetailsByConfigRuleErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for GetComplianceDetailsByConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            GetComplianceDetailsByConfigRuleErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetComplianceDetailsByConfigRuleErrorKind::NoSuchConfigRuleException(_inner) => {
                Some(_inner)
            }
            GetComplianceDetailsByConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetComplianceDetailsByResourceError {
    pub kind: GetComplianceDetailsByResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetComplianceDetailsByResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetComplianceDetailsByResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetComplianceDetailsByResourceErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetComplianceDetailsByResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetComplianceDetailsByResourceError {
    fn code(&self) -> Option<&str> {
        GetComplianceDetailsByResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetComplianceDetailsByResourceError {
    pub fn new(kind: GetComplianceDetailsByResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetComplianceDetailsByResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetComplianceDetailsByResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetComplianceDetailsByResourceErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for GetComplianceDetailsByResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetComplianceDetailsByResourceErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetComplianceDetailsByResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetComplianceSummaryByConfigRuleError {
    pub kind: GetComplianceSummaryByConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetComplianceSummaryByConfigRuleErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetComplianceSummaryByConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetComplianceSummaryByConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetComplianceSummaryByConfigRuleError {
    fn code(&self) -> Option<&str> {
        GetComplianceSummaryByConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetComplianceSummaryByConfigRuleError {
    pub fn new(kind: GetComplianceSummaryByConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetComplianceSummaryByConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetComplianceSummaryByConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetComplianceSummaryByConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetComplianceSummaryByConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetComplianceSummaryByResourceTypeError {
    pub kind: GetComplianceSummaryByResourceTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetComplianceSummaryByResourceTypeErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetComplianceSummaryByResourceTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetComplianceSummaryByResourceTypeErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetComplianceSummaryByResourceTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetComplianceSummaryByResourceTypeError {
    fn code(&self) -> Option<&str> {
        GetComplianceSummaryByResourceTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetComplianceSummaryByResourceTypeError {
    pub fn new(
        kind: GetComplianceSummaryByResourceTypeErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetComplianceSummaryByResourceTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetComplianceSummaryByResourceTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetComplianceSummaryByResourceTypeErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for GetComplianceSummaryByResourceTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetComplianceSummaryByResourceTypeErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetComplianceSummaryByResourceTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConformancePackComplianceDetailsError {
    pub kind: GetConformancePackComplianceDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConformancePackComplianceDetailsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleInConformancePackException(
        crate::error::NoSuchConfigRuleInConformancePackException,
    ),
    NoSuchConformancePackException(crate::error::NoSuchConformancePackException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConformancePackComplianceDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConformancePackComplianceDetailsErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetConformancePackComplianceDetailsErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetConformancePackComplianceDetailsErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            GetConformancePackComplianceDetailsErrorKind::NoSuchConfigRuleInConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            GetConformancePackComplianceDetailsErrorKind::NoSuchConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            GetConformancePackComplianceDetailsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConformancePackComplianceDetailsError {
    fn code(&self) -> Option<&str> {
        GetConformancePackComplianceDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConformancePackComplianceDetailsError {
    pub fn new(
        kind: GetConformancePackComplianceDetailsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConformancePackComplianceDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConformancePackComplianceDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceDetailsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceDetailsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceDetailsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_in_conformance_pack_exception(&self) -> bool {
        matches!(&self.kind, GetConformancePackComplianceDetailsErrorKind::NoSuchConfigRuleInConformancePackException(_))
    }
    pub fn is_no_such_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceDetailsErrorKind::NoSuchConformancePackException(_)
        )
    }
}
impl std::error::Error for GetConformancePackComplianceDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConformancePackComplianceDetailsErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetConformancePackComplianceDetailsErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetConformancePackComplianceDetailsErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            GetConformancePackComplianceDetailsErrorKind::NoSuchConfigRuleInConformancePackException(_inner) =>
            Some(_inner)
            ,
            GetConformancePackComplianceDetailsErrorKind::NoSuchConformancePackException(_inner) =>
            Some(_inner)
            ,
            GetConformancePackComplianceDetailsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConformancePackComplianceSummaryError {
    pub kind: GetConformancePackComplianceSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConformancePackComplianceSummaryErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConformancePackException(crate::error::NoSuchConformancePackException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConformancePackComplianceSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConformancePackComplianceSummaryErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            GetConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetConformancePackComplianceSummaryErrorKind::NoSuchConformancePackException(
                _inner,
            ) => _inner.fmt(f),
            GetConformancePackComplianceSummaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConformancePackComplianceSummaryError {
    fn code(&self) -> Option<&str> {
        GetConformancePackComplianceSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConformancePackComplianceSummaryError {
    pub fn new(
        kind: GetConformancePackComplianceSummaryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConformancePackComplianceSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConformancePackComplianceSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceSummaryErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_conformance_pack_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConformancePackComplianceSummaryErrorKind::NoSuchConformancePackException(_)
        )
    }
}
impl std::error::Error for GetConformancePackComplianceSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConformancePackComplianceSummaryErrorKind::InvalidLimitException(_inner) => {
                Some(_inner)
            }
            GetConformancePackComplianceSummaryErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            GetConformancePackComplianceSummaryErrorKind::NoSuchConformancePackException(
                _inner,
            ) => Some(_inner),
            GetConformancePackComplianceSummaryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDiscoveredResourceCountsError {
    pub kind: GetDiscoveredResourceCountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDiscoveredResourceCountsErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDiscoveredResourceCountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDiscoveredResourceCountsErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            GetDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetDiscoveredResourceCountsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetDiscoveredResourceCountsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDiscoveredResourceCountsError {
    fn code(&self) -> Option<&str> {
        GetDiscoveredResourceCountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDiscoveredResourceCountsError {
    pub fn new(kind: GetDiscoveredResourceCountsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDiscoveredResourceCountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDiscoveredResourceCountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiscoveredResourceCountsErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiscoveredResourceCountsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetDiscoveredResourceCountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDiscoveredResourceCountsErrorKind::InvalidLimitException(_inner) => Some(_inner),
            GetDiscoveredResourceCountsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            GetDiscoveredResourceCountsErrorKind::ValidationException(_inner) => Some(_inner),
            GetDiscoveredResourceCountsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOrganizationConfigRuleDetailedStatusError {
    pub kind: GetOrganizationConfigRuleDetailedStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOrganizationConfigRuleDetailedStatusErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConfigRuleException(crate::error::NoSuchOrganizationConfigRuleException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOrganizationConfigRuleDetailedStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::NoSuchOrganizationConfigRuleException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOrganizationConfigRuleDetailedStatusError {
    fn code(&self) -> Option<&str> {
        GetOrganizationConfigRuleDetailedStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOrganizationConfigRuleDetailedStatusError {
    pub fn new(
        kind: GetOrganizationConfigRuleDetailedStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOrganizationConfigRuleDetailedStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOrganizationConfigRuleDetailedStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConfigRuleDetailedStatusErrorKind::NoSuchOrganizationConfigRuleException(
                _
            )
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConfigRuleDetailedStatusErrorKind::OrganizationAccessDeniedException(_)
        )
    }
}
impl std::error::Error for GetOrganizationConfigRuleDetailedStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::NoSuchOrganizationConfigRuleException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConfigRuleDetailedStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOrganizationConformancePackDetailedStatusError {
    pub kind: GetOrganizationConformancePackDetailedStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOrganizationConformancePackDetailedStatusErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchOrganizationConformancePackException(
        crate::error::NoSuchOrganizationConformancePackException,
    ),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOrganizationConformancePackDetailedStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidLimitException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidNextTokenException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOrganizationConformancePackDetailedStatusError {
    fn code(&self) -> Option<&str> {
        GetOrganizationConformancePackDetailedStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOrganizationConformancePackDetailedStatusError {
    pub fn new(
        kind: GetOrganizationConformancePackDetailedStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOrganizationConformancePackDetailedStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOrganizationConformancePackDetailedStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_organization_conformance_pack_exception(&self) -> bool {
        matches!(&self.kind, GetOrganizationConformancePackDetailedStatusErrorKind::NoSuchOrganizationConformancePackException(_))
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetOrganizationConformancePackDetailedStatusErrorKind::OrganizationAccessDeniedException(_))
    }
}
impl std::error::Error for GetOrganizationConformancePackDetailedStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidLimitException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::InvalidNextTokenException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::NoSuchOrganizationConformancePackException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetOrganizationConformancePackDetailedStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourceConfigHistoryError {
    pub kind: GetResourceConfigHistoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourceConfigHistoryErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    ResourceNotDiscoveredException(crate::error::ResourceNotDiscoveredException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourceConfigHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourceConfigHistoryErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            GetResourceConfigHistoryErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            GetResourceConfigHistoryErrorKind::InvalidTimeRangeException(_inner) => _inner.fmt(f),
            GetResourceConfigHistoryErrorKind::NoAvailableConfigurationRecorderException(
                _inner,
            ) => _inner.fmt(f),
            GetResourceConfigHistoryErrorKind::ResourceNotDiscoveredException(_inner) => {
                _inner.fmt(f)
            }
            GetResourceConfigHistoryErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetResourceConfigHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourceConfigHistoryError {
    fn code(&self) -> Option<&str> {
        GetResourceConfigHistoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourceConfigHistoryError {
    pub fn new(kind: GetResourceConfigHistoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourceConfigHistoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourceConfigHistoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_time_range_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::InvalidTimeRangeException(_)
        )
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_resource_not_discovered_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::ResourceNotDiscoveredException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceConfigHistoryErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetResourceConfigHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourceConfigHistoryErrorKind::InvalidLimitException(_inner) => Some(_inner),
            GetResourceConfigHistoryErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            GetResourceConfigHistoryErrorKind::InvalidTimeRangeException(_inner) => Some(_inner),
            GetResourceConfigHistoryErrorKind::NoAvailableConfigurationRecorderException(
                _inner,
            ) => Some(_inner),
            GetResourceConfigHistoryErrorKind::ResourceNotDiscoveredException(_inner) => {
                Some(_inner)
            }
            GetResourceConfigHistoryErrorKind::ValidationException(_inner) => Some(_inner),
            GetResourceConfigHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStoredQueryError {
    pub kind: GetStoredQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStoredQueryErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStoredQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStoredQueryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetStoredQueryErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetStoredQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStoredQueryError {
    fn code(&self) -> Option<&str> {
        GetStoredQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStoredQueryError {
    pub fn new(kind: GetStoredQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStoredQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStoredQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStoredQueryErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetStoredQueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetStoredQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStoredQueryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetStoredQueryErrorKind::ValidationException(_inner) => Some(_inner),
            GetStoredQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAggregateDiscoveredResourcesError {
    pub kind: ListAggregateDiscoveredResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAggregateDiscoveredResourcesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAggregateDiscoveredResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAggregateDiscoveredResourcesErrorKind::InvalidLimitException(_inner) => {
                _inner.fmt(f)
            }
            ListAggregateDiscoveredResourcesErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListAggregateDiscoveredResourcesErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => _inner.fmt(f),
            ListAggregateDiscoveredResourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAggregateDiscoveredResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAggregateDiscoveredResourcesError {
    fn code(&self) -> Option<&str> {
        ListAggregateDiscoveredResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAggregateDiscoveredResourcesError {
    pub fn new(kind: ListAggregateDiscoveredResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAggregateDiscoveredResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAggregateDiscoveredResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAggregateDiscoveredResourcesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAggregateDiscoveredResourcesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAggregateDiscoveredResourcesErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAggregateDiscoveredResourcesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAggregateDiscoveredResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAggregateDiscoveredResourcesErrorKind::InvalidLimitException(_inner) => {
                Some(_inner)
            }
            ListAggregateDiscoveredResourcesErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            ListAggregateDiscoveredResourcesErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => Some(_inner),
            ListAggregateDiscoveredResourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ListAggregateDiscoveredResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDiscoveredResourcesError {
    pub kind: ListDiscoveredResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDiscoveredResourcesErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDiscoveredResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDiscoveredResourcesErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            ListDiscoveredResourcesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListDiscoveredResourcesErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            ListDiscoveredResourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDiscoveredResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDiscoveredResourcesError {
    fn code(&self) -> Option<&str> {
        ListDiscoveredResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDiscoveredResourcesError {
    pub fn new(kind: ListDiscoveredResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDiscoveredResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDiscoveredResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDiscoveredResourcesErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDiscoveredResourcesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDiscoveredResourcesErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDiscoveredResourcesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListDiscoveredResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDiscoveredResourcesErrorKind::InvalidLimitException(_inner) => Some(_inner),
            ListDiscoveredResourcesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListDiscoveredResourcesErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            ListDiscoveredResourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ListDiscoveredResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStoredQueriesError {
    pub kind: ListStoredQueriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStoredQueriesErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStoredQueriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStoredQueriesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListStoredQueriesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListStoredQueriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStoredQueriesError {
    fn code(&self) -> Option<&str> {
        ListStoredQueriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStoredQueriesError {
    pub fn new(kind: ListStoredQueriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStoredQueriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStoredQueriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStoredQueriesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStoredQueriesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListStoredQueriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStoredQueriesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListStoredQueriesErrorKind::ValidationException(_inner) => Some(_inner),
            ListStoredQueriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidLimitException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAggregationAuthorizationError {
    pub kind: PutAggregationAuthorizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAggregationAuthorizationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAggregationAuthorizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAggregationAuthorizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutAggregationAuthorizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAggregationAuthorizationError {
    fn code(&self) -> Option<&str> {
        PutAggregationAuthorizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAggregationAuthorizationError {
    pub fn new(kind: PutAggregationAuthorizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAggregationAuthorizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAggregationAuthorizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAggregationAuthorizationErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for PutAggregationAuthorizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAggregationAuthorizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutAggregationAuthorizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigRuleError {
    pub kind: PutConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigRuleErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MaxNumberOfConfigRulesExceededException(crate::error::MaxNumberOfConfigRulesExceededException),
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigRuleErrorKind::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            PutConfigRuleErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PutConfigRuleErrorKind::MaxNumberOfConfigRulesExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigRuleErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigRuleErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            PutConfigRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigRuleError {
    fn code(&self) -> Option<&str> {
        PutConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigRuleError {
    pub fn new(kind: PutConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigRuleErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigRuleErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_max_number_of_config_rules_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigRuleErrorKind::MaxNumberOfConfigRulesExceededException(_)
        )
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigRuleErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigRuleErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for PutConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigRuleErrorKind::InsufficientPermissionsException(_inner) => Some(_inner),
            PutConfigRuleErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PutConfigRuleErrorKind::MaxNumberOfConfigRulesExceededException(_inner) => Some(_inner),
            PutConfigRuleErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            PutConfigRuleErrorKind::ResourceInUseException(_inner) => Some(_inner),
            PutConfigRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationAggregatorError {
    pub kind: PutConfigurationAggregatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationAggregatorErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRoleException(crate::error::InvalidRoleException),
    LimitExceededException(crate::error::LimitExceededException),
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    OrganizationAllFeaturesNotEnabledException(
        crate::error::OrganizationAllFeaturesNotEnabledException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationAggregatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationAggregatorErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationAggregatorErrorKind::InvalidRoleException(_inner) => _inner.fmt(f),
            PutConfigurationAggregatorErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutConfigurationAggregatorErrorKind::NoAvailableOrganizationException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationAggregatorErrorKind::OrganizationAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationAggregatorErrorKind::OrganizationAllFeaturesNotEnabledException(
                _inner,
            ) => _inner.fmt(f),
            PutConfigurationAggregatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationAggregatorError {
    fn code(&self) -> Option<&str> {
        PutConfigurationAggregatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationAggregatorError {
    pub fn new(kind: PutConfigurationAggregatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationAggregatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationAggregatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::InvalidRoleException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::NoAvailableOrganizationException(_)
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::OrganizationAccessDeniedException(_)
        )
    }
    pub fn is_organization_all_features_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationAggregatorErrorKind::OrganizationAllFeaturesNotEnabledException(_)
        )
    }
}
impl std::error::Error for PutConfigurationAggregatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationAggregatorErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutConfigurationAggregatorErrorKind::InvalidRoleException(_inner) => Some(_inner),
            PutConfigurationAggregatorErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutConfigurationAggregatorErrorKind::NoAvailableOrganizationException(_inner) => {
                Some(_inner)
            }
            PutConfigurationAggregatorErrorKind::OrganizationAccessDeniedException(_inner) => {
                Some(_inner)
            }
            PutConfigurationAggregatorErrorKind::OrganizationAllFeaturesNotEnabledException(
                _inner,
            ) => Some(_inner),
            PutConfigurationAggregatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationRecorderError {
    pub kind: PutConfigurationRecorderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationRecorderErrorKind {
    InvalidConfigurationRecorderNameException(
        crate::error::InvalidConfigurationRecorderNameException,
    ),
    InvalidRecordingGroupException(crate::error::InvalidRecordingGroupException),
    InvalidRoleException(crate::error::InvalidRoleException),
    MaxNumberOfConfigurationRecordersExceededException(
        crate::error::MaxNumberOfConfigurationRecordersExceededException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationRecorderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationRecorderErrorKind::InvalidConfigurationRecorderNameException(_inner) =>
            _inner.fmt(f)
            ,
            PutConfigurationRecorderErrorKind::InvalidRecordingGroupException(_inner) =>
            _inner.fmt(f)
            ,
            PutConfigurationRecorderErrorKind::InvalidRoleException(_inner) =>
            _inner.fmt(f)
            ,
            PutConfigurationRecorderErrorKind::MaxNumberOfConfigurationRecordersExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PutConfigurationRecorderErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationRecorderError {
    fn code(&self) -> Option<&str> {
        PutConfigurationRecorderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationRecorderError {
    pub fn new(kind: PutConfigurationRecorderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationRecorderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationRecorderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_configuration_recorder_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationRecorderErrorKind::InvalidConfigurationRecorderNameException(_)
        )
    }
    pub fn is_invalid_recording_group_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationRecorderErrorKind::InvalidRecordingGroupException(_)
        )
    }
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationRecorderErrorKind::InvalidRoleException(_)
        )
    }
    pub fn is_max_number_of_configuration_recorders_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationRecorderErrorKind::MaxNumberOfConfigurationRecordersExceededException(
                _
            )
        )
    }
}
impl std::error::Error for PutConfigurationRecorderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationRecorderErrorKind::InvalidConfigurationRecorderNameException(_inner) =>
            Some(_inner)
            ,
            PutConfigurationRecorderErrorKind::InvalidRecordingGroupException(_inner) =>
            Some(_inner)
            ,
            PutConfigurationRecorderErrorKind::InvalidRoleException(_inner) =>
            Some(_inner)
            ,
            PutConfigurationRecorderErrorKind::MaxNumberOfConfigurationRecordersExceededException(_inner) =>
            Some(_inner)
            ,
            PutConfigurationRecorderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConformancePackError {
    pub kind: PutConformancePackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConformancePackErrorKind {
    ConformancePackTemplateValidationException(
        crate::error::ConformancePackTemplateValidationException,
    ),
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MaxNumberOfConformancePacksExceededException(
        crate::error::MaxNumberOfConformancePacksExceededException,
    ),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConformancePackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConformancePackErrorKind::ConformancePackTemplateValidationException(_inner) => {
                _inner.fmt(f)
            }
            PutConformancePackErrorKind::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            PutConformancePackErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PutConformancePackErrorKind::MaxNumberOfConformancePacksExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutConformancePackErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            PutConformancePackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConformancePackError {
    fn code(&self) -> Option<&str> {
        PutConformancePackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConformancePackError {
    pub fn new(kind: PutConformancePackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConformancePackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConformancePackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conformance_pack_template_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConformancePackErrorKind::ConformancePackTemplateValidationException(_)
        )
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConformancePackErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConformancePackErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_max_number_of_conformance_packs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConformancePackErrorKind::MaxNumberOfConformancePacksExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConformancePackErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for PutConformancePackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConformancePackErrorKind::ConformancePackTemplateValidationException(_inner) => {
                Some(_inner)
            }
            PutConformancePackErrorKind::InsufficientPermissionsException(_inner) => Some(_inner),
            PutConformancePackErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PutConformancePackErrorKind::MaxNumberOfConformancePacksExceededException(_inner) => {
                Some(_inner)
            }
            PutConformancePackErrorKind::ResourceInUseException(_inner) => Some(_inner),
            PutConformancePackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDeliveryChannelError {
    pub kind: PutDeliveryChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDeliveryChannelErrorKind {
    InsufficientDeliveryPolicyException(crate::error::InsufficientDeliveryPolicyException),
    InvalidDeliveryChannelNameException(crate::error::InvalidDeliveryChannelNameException),
    InvalidS3KeyPrefixException(crate::error::InvalidS3KeyPrefixException),
    InvalidS3KmsKeyArnException(crate::error::InvalidS3KmsKeyArnException),
    InvalidSnsTopicArnException(crate::error::InvalidSnsTopicArnException),
    MaxNumberOfDeliveryChannelsExceededException(
        crate::error::MaxNumberOfDeliveryChannelsExceededException,
    ),
    NoAvailableConfigurationRecorderException(
        crate::error::NoAvailableConfigurationRecorderException,
    ),
    NoSuchBucketException(crate::error::NoSuchBucketException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDeliveryChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDeliveryChannelErrorKind::InsufficientDeliveryPolicyException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliveryChannelErrorKind::InvalidDeliveryChannelNameException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliveryChannelErrorKind::InvalidS3KeyPrefixException(_inner) => _inner.fmt(f),
            PutDeliveryChannelErrorKind::InvalidS3KmsKeyArnException(_inner) => _inner.fmt(f),
            PutDeliveryChannelErrorKind::InvalidSnsTopicArnException(_inner) => _inner.fmt(f),
            PutDeliveryChannelErrorKind::MaxNumberOfDeliveryChannelsExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliveryChannelErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliveryChannelErrorKind::NoSuchBucketException(_inner) => _inner.fmt(f),
            PutDeliveryChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDeliveryChannelError {
    fn code(&self) -> Option<&str> {
        PutDeliveryChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDeliveryChannelError {
    pub fn new(kind: PutDeliveryChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDeliveryChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDeliveryChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_delivery_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::InsufficientDeliveryPolicyException(_)
        )
    }
    pub fn is_invalid_delivery_channel_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::InvalidDeliveryChannelNameException(_)
        )
    }
    pub fn is_invalid_s3_key_prefix_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::InvalidS3KeyPrefixException(_)
        )
    }
    pub fn is_invalid_s3_kms_key_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::InvalidS3KmsKeyArnException(_)
        )
    }
    pub fn is_invalid_sns_topic_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::InvalidSnsTopicArnException(_)
        )
    }
    pub fn is_max_number_of_delivery_channels_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::MaxNumberOfDeliveryChannelsExceededException(_)
        )
    }
    pub fn is_no_available_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::NoAvailableConfigurationRecorderException(_)
        )
    }
    pub fn is_no_such_bucket_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliveryChannelErrorKind::NoSuchBucketException(_)
        )
    }
}
impl std::error::Error for PutDeliveryChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDeliveryChannelErrorKind::InsufficientDeliveryPolicyException(_inner) => {
                Some(_inner)
            }
            PutDeliveryChannelErrorKind::InvalidDeliveryChannelNameException(_inner) => {
                Some(_inner)
            }
            PutDeliveryChannelErrorKind::InvalidS3KeyPrefixException(_inner) => Some(_inner),
            PutDeliveryChannelErrorKind::InvalidS3KmsKeyArnException(_inner) => Some(_inner),
            PutDeliveryChannelErrorKind::InvalidSnsTopicArnException(_inner) => Some(_inner),
            PutDeliveryChannelErrorKind::MaxNumberOfDeliveryChannelsExceededException(_inner) => {
                Some(_inner)
            }
            PutDeliveryChannelErrorKind::NoAvailableConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            PutDeliveryChannelErrorKind::NoSuchBucketException(_inner) => Some(_inner),
            PutDeliveryChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEvaluationsError {
    pub kind: PutEvaluationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEvaluationsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidResultTokenException(crate::error::InvalidResultTokenException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEvaluationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEvaluationsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PutEvaluationsErrorKind::InvalidResultTokenException(_inner) => _inner.fmt(f),
            PutEvaluationsErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            PutEvaluationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEvaluationsError {
    fn code(&self) -> Option<&str> {
        PutEvaluationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEvaluationsError {
    pub fn new(kind: PutEvaluationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEvaluationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEvaluationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEvaluationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_result_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEvaluationsErrorKind::InvalidResultTokenException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEvaluationsErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for PutEvaluationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEvaluationsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PutEvaluationsErrorKind::InvalidResultTokenException(_inner) => Some(_inner),
            PutEvaluationsErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            PutEvaluationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutExternalEvaluationError {
    pub kind: PutExternalEvaluationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutExternalEvaluationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutExternalEvaluationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutExternalEvaluationErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PutExternalEvaluationErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            PutExternalEvaluationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutExternalEvaluationError {
    fn code(&self) -> Option<&str> {
        PutExternalEvaluationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutExternalEvaluationError {
    pub fn new(kind: PutExternalEvaluationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutExternalEvaluationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutExternalEvaluationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutExternalEvaluationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutExternalEvaluationErrorKind::NoSuchConfigRuleException(_)
        )
    }
}
impl std::error::Error for PutExternalEvaluationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutExternalEvaluationErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PutExternalEvaluationErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            PutExternalEvaluationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutOrganizationConfigRuleError {
    pub kind: PutOrganizationConfigRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutOrganizationConfigRuleErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MaxNumberOfOrganizationConfigRulesExceededException(
        crate::error::MaxNumberOfOrganizationConfigRulesExceededException,
    ),
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    OrganizationAllFeaturesNotEnabledException(
        crate::error::OrganizationAllFeaturesNotEnabledException,
    ),
    ResourceInUseException(crate::error::ResourceInUseException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutOrganizationConfigRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutOrganizationConfigRuleErrorKind::InsufficientPermissionsException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::MaxNumberOfOrganizationConfigRulesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::OrganizationAllFeaturesNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::ResourceInUseException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConfigRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutOrganizationConfigRuleError {
    fn code(&self) -> Option<&str> {
        PutOrganizationConfigRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutOrganizationConfigRuleError {
    pub fn new(kind: PutOrganizationConfigRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutOrganizationConfigRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutOrganizationConfigRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_max_number_of_organization_config_rules_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::MaxNumberOfOrganizationConfigRulesExceededException(
                _
            )
        )
    }
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::NoAvailableOrganizationException(_)
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_)
        )
    }
    pub fn is_organization_all_features_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::OrganizationAllFeaturesNotEnabledException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConfigRuleErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutOrganizationConfigRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutOrganizationConfigRuleErrorKind::InsufficientPermissionsException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::MaxNumberOfOrganizationConfigRulesExceededException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::OrganizationAllFeaturesNotEnabledException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::ResourceInUseException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConfigRuleErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutOrganizationConformancePackError {
    pub kind: PutOrganizationConformancePackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutOrganizationConformancePackErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    MaxNumberOfOrganizationConformancePacksExceededException(
        crate::error::MaxNumberOfOrganizationConformancePacksExceededException,
    ),
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    OrganizationAccessDeniedException(crate::error::OrganizationAccessDeniedException),
    OrganizationAllFeaturesNotEnabledException(
        crate::error::OrganizationAllFeaturesNotEnabledException,
    ),
    OrganizationConformancePackTemplateValidationException(
        crate::error::OrganizationConformancePackTemplateValidationException,
    ),
    ResourceInUseException(crate::error::ResourceInUseException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutOrganizationConformancePackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutOrganizationConformancePackErrorKind::InsufficientPermissionsException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::MaxNumberOfOrganizationConformancePacksExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationAllFeaturesNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationConformancePackTemplateValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::ResourceInUseException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutOrganizationConformancePackErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutOrganizationConformancePackError {
    fn code(&self) -> Option<&str> {
        PutOrganizationConformancePackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutOrganizationConformancePackError {
    pub fn new(kind: PutOrganizationConformancePackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutOrganizationConformancePackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutOrganizationConformancePackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_max_number_of_organization_conformance_packs_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutOrganizationConformancePackErrorKind::MaxNumberOfOrganizationConformancePacksExceededException(_))
    }
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::NoAvailableOrganizationException(_)
        )
    }
    pub fn is_organization_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_)
        )
    }
    pub fn is_organization_all_features_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::OrganizationAllFeaturesNotEnabledException(_)
        )
    }
    pub fn is_organization_conformance_pack_template_validation_exception(&self) -> bool {
        matches!(&self.kind, PutOrganizationConformancePackErrorKind::OrganizationConformancePackTemplateValidationException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutOrganizationConformancePackErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutOrganizationConformancePackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutOrganizationConformancePackErrorKind::InsufficientPermissionsException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::MaxNumberOfOrganizationConformancePacksExceededException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationAllFeaturesNotEnabledException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::OrganizationConformancePackTemplateValidationException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::ResourceInUseException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutOrganizationConformancePackErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRemediationConfigurationsError {
    pub kind: PutRemediationConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRemediationConfigurationsErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRemediationConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRemediationConfigurationsErrorKind::InsufficientPermissionsException(_inner) => {
                _inner.fmt(f)
            }
            PutRemediationConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutRemediationConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRemediationConfigurationsError {
    fn code(&self) -> Option<&str> {
        PutRemediationConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRemediationConfigurationsError {
    pub fn new(kind: PutRemediationConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRemediationConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRemediationConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRemediationConfigurationsErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRemediationConfigurationsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for PutRemediationConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRemediationConfigurationsErrorKind::InsufficientPermissionsException(_inner) => {
                Some(_inner)
            }
            PutRemediationConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutRemediationConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRemediationExceptionsError {
    pub kind: PutRemediationExceptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRemediationExceptionsErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRemediationExceptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRemediationExceptionsErrorKind::InsufficientPermissionsException(_inner) => {
                _inner.fmt(f)
            }
            PutRemediationExceptionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutRemediationExceptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRemediationExceptionsError {
    fn code(&self) -> Option<&str> {
        PutRemediationExceptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRemediationExceptionsError {
    pub fn new(kind: PutRemediationExceptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRemediationExceptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRemediationExceptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRemediationExceptionsErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRemediationExceptionsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for PutRemediationExceptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRemediationExceptionsErrorKind::InsufficientPermissionsException(_inner) => {
                Some(_inner)
            }
            PutRemediationExceptionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutRemediationExceptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourceConfigError {
    pub kind: PutResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourceConfigErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    MaxActiveResourcesExceededException(crate::error::MaxActiveResourcesExceededException),
    NoRunningConfigurationRecorderException(crate::error::NoRunningConfigurationRecorderException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourceConfigErrorKind::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            PutResourceConfigErrorKind::MaxActiveResourcesExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutResourceConfigErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            PutResourceConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PutResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourceConfigError {
    fn code(&self) -> Option<&str> {
        PutResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourceConfigError {
    pub fn new(kind: PutResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceConfigErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_max_active_resources_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceConfigErrorKind::MaxActiveResourcesExceededException(_)
        )
    }
    pub fn is_no_running_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceConfigErrorKind::NoRunningConfigurationRecorderException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourceConfigErrorKind::InsufficientPermissionsException(_inner) => Some(_inner),
            PutResourceConfigErrorKind::MaxActiveResourcesExceededException(_inner) => Some(_inner),
            PutResourceConfigErrorKind::NoRunningConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            PutResourceConfigErrorKind::ValidationException(_inner) => Some(_inner),
            PutResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRetentionConfigurationError {
    pub kind: PutRetentionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRetentionConfigurationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MaxNumberOfRetentionConfigurationsExceededException(
        crate::error::MaxNumberOfRetentionConfigurationsExceededException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRetentionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRetentionConfigurationErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            PutRetentionConfigurationErrorKind::MaxNumberOfRetentionConfigurationsExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PutRetentionConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRetentionConfigurationError {
    fn code(&self) -> Option<&str> {
        PutRetentionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRetentionConfigurationError {
    pub fn new(kind: PutRetentionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRetentionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRetentionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_max_number_of_retention_configurations_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionConfigurationErrorKind::MaxNumberOfRetentionConfigurationsExceededException(
                _
            )
        )
    }
}
impl std::error::Error for PutRetentionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRetentionConfigurationErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            PutRetentionConfigurationErrorKind::MaxNumberOfRetentionConfigurationsExceededException(_inner) =>
            Some(_inner)
            ,
            PutRetentionConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutStoredQueryError {
    pub kind: PutStoredQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutStoredQueryErrorKind {
    ResourceConcurrentModificationException(crate::error::ResourceConcurrentModificationException),
    TooManyTagsException(crate::error::TooManyTagsException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutStoredQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutStoredQueryErrorKind::ResourceConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            PutStoredQueryErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            PutStoredQueryErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PutStoredQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutStoredQueryError {
    fn code(&self) -> Option<&str> {
        PutStoredQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutStoredQueryError {
    pub fn new(kind: PutStoredQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutStoredQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutStoredQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutStoredQueryErrorKind::ResourceConcurrentModificationException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, PutStoredQueryErrorKind::TooManyTagsException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, PutStoredQueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for PutStoredQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutStoredQueryErrorKind::ResourceConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            PutStoredQueryErrorKind::TooManyTagsException(_inner) => Some(_inner),
            PutStoredQueryErrorKind::ValidationException(_inner) => Some(_inner),
            PutStoredQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SelectAggregateResourceConfigError {
    pub kind: SelectAggregateResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SelectAggregateResourceConfigErrorKind {
    InvalidExpressionException(crate::error::InvalidExpressionException),
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    NoSuchConfigurationAggregatorException(crate::error::NoSuchConfigurationAggregatorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SelectAggregateResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SelectAggregateResourceConfigErrorKind::InvalidExpressionException(_inner) => {
                _inner.fmt(f)
            }
            SelectAggregateResourceConfigErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            SelectAggregateResourceConfigErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            SelectAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => _inner.fmt(f),
            SelectAggregateResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SelectAggregateResourceConfigError {
    fn code(&self) -> Option<&str> {
        SelectAggregateResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SelectAggregateResourceConfigError {
    pub fn new(kind: SelectAggregateResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SelectAggregateResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SelectAggregateResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_expression_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectAggregateResourceConfigErrorKind::InvalidExpressionException(_)
        )
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectAggregateResourceConfigErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectAggregateResourceConfigErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_no_such_configuration_aggregator_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(_)
        )
    }
}
impl std::error::Error for SelectAggregateResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SelectAggregateResourceConfigErrorKind::InvalidExpressionException(_inner) => {
                Some(_inner)
            }
            SelectAggregateResourceConfigErrorKind::InvalidLimitException(_inner) => Some(_inner),
            SelectAggregateResourceConfigErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            SelectAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException(
                _inner,
            ) => Some(_inner),
            SelectAggregateResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SelectResourceConfigError {
    pub kind: SelectResourceConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SelectResourceConfigErrorKind {
    InvalidExpressionException(crate::error::InvalidExpressionException),
    InvalidLimitException(crate::error::InvalidLimitException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SelectResourceConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SelectResourceConfigErrorKind::InvalidExpressionException(_inner) => _inner.fmt(f),
            SelectResourceConfigErrorKind::InvalidLimitException(_inner) => _inner.fmt(f),
            SelectResourceConfigErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            SelectResourceConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SelectResourceConfigError {
    fn code(&self) -> Option<&str> {
        SelectResourceConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SelectResourceConfigError {
    pub fn new(kind: SelectResourceConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SelectResourceConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SelectResourceConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_expression_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectResourceConfigErrorKind::InvalidExpressionException(_)
        )
    }
    pub fn is_invalid_limit_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectResourceConfigErrorKind::InvalidLimitException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            SelectResourceConfigErrorKind::InvalidNextTokenException(_)
        )
    }
}
impl std::error::Error for SelectResourceConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SelectResourceConfigErrorKind::InvalidExpressionException(_inner) => Some(_inner),
            SelectResourceConfigErrorKind::InvalidLimitException(_inner) => Some(_inner),
            SelectResourceConfigErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            SelectResourceConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartConfigRulesEvaluationError {
    pub kind: StartConfigRulesEvaluationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartConfigRulesEvaluationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchConfigRuleException(crate::error::NoSuchConfigRuleException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartConfigRulesEvaluationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartConfigRulesEvaluationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            StartConfigRulesEvaluationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartConfigRulesEvaluationErrorKind::NoSuchConfigRuleException(_inner) => _inner.fmt(f),
            StartConfigRulesEvaluationErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartConfigRulesEvaluationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartConfigRulesEvaluationError {
    fn code(&self) -> Option<&str> {
        StartConfigRulesEvaluationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartConfigRulesEvaluationError {
    pub fn new(kind: StartConfigRulesEvaluationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartConfigRulesEvaluationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartConfigRulesEvaluationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigRulesEvaluationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigRulesEvaluationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_config_rule_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigRulesEvaluationErrorKind::NoSuchConfigRuleException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigRulesEvaluationErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for StartConfigRulesEvaluationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartConfigRulesEvaluationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            StartConfigRulesEvaluationErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartConfigRulesEvaluationErrorKind::NoSuchConfigRuleException(_inner) => Some(_inner),
            StartConfigRulesEvaluationErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartConfigRulesEvaluationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartConfigurationRecorderError {
    pub kind: StartConfigurationRecorderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartConfigurationRecorderErrorKind {
    NoAvailableDeliveryChannelException(crate::error::NoAvailableDeliveryChannelException),
    NoSuchConfigurationRecorderException(crate::error::NoSuchConfigurationRecorderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartConfigurationRecorderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartConfigurationRecorderErrorKind::NoAvailableDeliveryChannelException(_inner) => {
                _inner.fmt(f)
            }
            StartConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            StartConfigurationRecorderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartConfigurationRecorderError {
    fn code(&self) -> Option<&str> {
        StartConfigurationRecorderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartConfigurationRecorderError {
    pub fn new(kind: StartConfigurationRecorderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartConfigurationRecorderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartConfigurationRecorderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_available_delivery_channel_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigurationRecorderErrorKind::NoAvailableDeliveryChannelException(_)
        )
    }
    pub fn is_no_such_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_)
        )
    }
}
impl std::error::Error for StartConfigurationRecorderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartConfigurationRecorderErrorKind::NoAvailableDeliveryChannelException(_inner) => {
                Some(_inner)
            }
            StartConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            StartConfigurationRecorderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartRemediationExecutionError {
    pub kind: StartRemediationExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartRemediationExecutionErrorKind {
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoSuchRemediationConfigurationException(crate::error::NoSuchRemediationConfigurationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartRemediationExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartRemediationExecutionErrorKind::InsufficientPermissionsException(_inner) => {
                _inner.fmt(f)
            }
            StartRemediationExecutionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            StartRemediationExecutionErrorKind::NoSuchRemediationConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            StartRemediationExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartRemediationExecutionError {
    fn code(&self) -> Option<&str> {
        StartRemediationExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartRemediationExecutionError {
    pub fn new(kind: StartRemediationExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartRemediationExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartRemediationExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRemediationExecutionErrorKind::InsufficientPermissionsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRemediationExecutionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_such_remediation_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRemediationExecutionErrorKind::NoSuchRemediationConfigurationException(_)
        )
    }
}
impl std::error::Error for StartRemediationExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartRemediationExecutionErrorKind::InsufficientPermissionsException(_inner) => {
                Some(_inner)
            }
            StartRemediationExecutionErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            StartRemediationExecutionErrorKind::NoSuchRemediationConfigurationException(_inner) => {
                Some(_inner)
            }
            StartRemediationExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopConfigurationRecorderError {
    pub kind: StopConfigurationRecorderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopConfigurationRecorderErrorKind {
    NoSuchConfigurationRecorderException(crate::error::NoSuchConfigurationRecorderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopConfigurationRecorderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                _inner.fmt(f)
            }
            StopConfigurationRecorderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopConfigurationRecorderError {
    fn code(&self) -> Option<&str> {
        StopConfigurationRecorderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopConfigurationRecorderError {
    pub fn new(kind: StopConfigurationRecorderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopConfigurationRecorderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopConfigurationRecorderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_configuration_recorder_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_)
        )
    }
}
impl std::error::Error for StopConfigurationRecorderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException(_inner) => {
                Some(_inner)
            }
            StopConfigurationRecorderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyTagsException(crate::error::TooManyTagsException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The requested action is not valid.</p>
/// <p>For PutStoredQuery, you will see this exception if there are missing required fields or if the input value fails the validation, or if you are trying to create more than 300 queries.</p>
/// <p>For GetStoredQuery, ListStoredQuery, and DeleteStoredQuery you will see this exception if there are missing required fields or if the input value fails the validation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>You have specified a resource that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>You have reached the limit of the number of tags you can use. You have more than 50 tags.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>You have specified a configuration recorder that does not
/// exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchConfigurationRecorderException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchConfigurationRecorderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchConfigurationRecorderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchConfigurationRecorderException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchConfigurationRecorderException {}
/// See [`NoSuchConfigurationRecorderException`](crate::error::NoSuchConfigurationRecorderException)
pub mod no_such_configuration_recorder_exception {
    /// A builder for [`NoSuchConfigurationRecorderException`](crate::error::NoSuchConfigurationRecorderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchConfigurationRecorderException`](crate::error::NoSuchConfigurationRecorderException)
        pub fn build(self) -> crate::error::NoSuchConfigurationRecorderException {
            crate::error::NoSuchConfigurationRecorderException {
                message: self.message,
            }
        }
    }
}
impl NoSuchConfigurationRecorderException {
    /// Creates a new builder-style object to manufacture [`NoSuchConfigurationRecorderException`](crate::error::NoSuchConfigurationRecorderException)
    pub fn builder() -> crate::error::no_such_configuration_recorder_exception::Builder {
        crate::error::no_such_configuration_recorder_exception::Builder::default()
    }
}

/// <p>You specified an AWS Config rule without a remediation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchRemediationConfigurationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchRemediationConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchRemediationConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchRemediationConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchRemediationConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchRemediationConfigurationException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchRemediationConfigurationException {}
/// See [`NoSuchRemediationConfigurationException`](crate::error::NoSuchRemediationConfigurationException)
pub mod no_such_remediation_configuration_exception {
    /// A builder for [`NoSuchRemediationConfigurationException`](crate::error::NoSuchRemediationConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchRemediationConfigurationException`](crate::error::NoSuchRemediationConfigurationException)
        pub fn build(self) -> crate::error::NoSuchRemediationConfigurationException {
            crate::error::NoSuchRemediationConfigurationException {
                message: self.message,
            }
        }
    }
}
impl NoSuchRemediationConfigurationException {
    /// Creates a new builder-style object to manufacture [`NoSuchRemediationConfigurationException`](crate::error::NoSuchRemediationConfigurationException)
    pub fn builder() -> crate::error::no_such_remediation_configuration_exception::Builder {
        crate::error::no_such_remediation_configuration_exception::Builder::default()
    }
}

/// <p>One or more of the specified parameters are invalid. Verify
/// that your parameters are valid and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>Indicates one of the following errors:</p>
/// <ul>
/// <li>
/// <p>For PutConfigRule, the rule cannot be created because the IAM role assigned to AWS Config lacks permissions to perform the config:Put* action.</p>
/// </li>
/// <li>
/// <p>For PutConfigRule, the AWS Lambda function cannot be invoked. Check the function ARN, and check the function's permissions.</p>
/// </li>
/// <li>
/// <p>For PutOrganizationConfigRule, organization config rule cannot be created because you do not have permissions to call IAM <code>GetRole</code> action or create a service linked role.</p>
/// </li>
/// <li>
/// <p>For PutConformancePack and PutOrganizationConformancePack, a conformance pack cannot be created because you do not have permissions: </p>
/// <ul>
/// <li>
/// <p>To call IAM <code>GetRole</code> action or create a service linked role.</p>
/// </li>
/// <li>
/// <p>To read Amazon S3 bucket.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientPermissionsException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientPermissionsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientPermissionsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientPermissionsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientPermissionsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientPermissionsException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientPermissionsException {}
/// See [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException)
pub mod insufficient_permissions_exception {
    /// A builder for [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException)
        pub fn build(self) -> crate::error::InsufficientPermissionsException {
            crate::error::InsufficientPermissionsException {
                message: self.message,
            }
        }
    }
}
impl InsufficientPermissionsException {
    /// Creates a new builder-style object to manufacture [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException)
    pub fn builder() -> crate::error::insufficient_permissions_exception::Builder {
        crate::error::insufficient_permissions_exception::Builder::default()
    }
}

/// <p>There is no delivery channel available to record
/// configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoAvailableDeliveryChannelException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoAvailableDeliveryChannelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoAvailableDeliveryChannelException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoAvailableDeliveryChannelException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoAvailableDeliveryChannelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoAvailableDeliveryChannelException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoAvailableDeliveryChannelException {}
/// See [`NoAvailableDeliveryChannelException`](crate::error::NoAvailableDeliveryChannelException)
pub mod no_available_delivery_channel_exception {
    /// A builder for [`NoAvailableDeliveryChannelException`](crate::error::NoAvailableDeliveryChannelException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoAvailableDeliveryChannelException`](crate::error::NoAvailableDeliveryChannelException)
        pub fn build(self) -> crate::error::NoAvailableDeliveryChannelException {
            crate::error::NoAvailableDeliveryChannelException {
                message: self.message,
            }
        }
    }
}
impl NoAvailableDeliveryChannelException {
    /// Creates a new builder-style object to manufacture [`NoAvailableDeliveryChannelException`](crate::error::NoAvailableDeliveryChannelException)
    pub fn builder() -> crate::error::no_available_delivery_channel_exception::Builder {
        crate::error::no_available_delivery_channel_exception::Builder::default()
    }
}

/// <p>You see this exception in the following cases: </p>
/// <ul>
/// <li>
/// <p>For DeleteConfigRule, AWS Config is deleting this rule. Try your request again later.</p>
/// </li>
/// <li>
/// <p>For DeleteConfigRule, the rule is deleting your evaluation results. Try your request again later.</p>
/// </li>
/// <li>
/// <p>For DeleteConfigRule, a remediation action is associated with the rule and AWS Config cannot delete this rule. Delete the remediation action associated with the rule before deleting the rule and try your request again later.</p>
/// </li>
/// <li>
/// <p>For PutConfigOrganizationRule, organization config rule deletion is in progress. Try your request again later.</p>
/// </li>
/// <li>
/// <p>For DeleteOrganizationConfigRule, organization config rule creation is in progress. Try your request again later.</p>
/// </li>
/// <li>
/// <p>For PutConformancePack and PutOrganizationConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.</p>
/// </li>
/// <li>
/// <p>For DeleteConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>One or more AWS Config rules in the request are invalid. Verify
/// that the rule names are correct and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchConfigRuleException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchConfigRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchConfigRuleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchConfigRuleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchConfigRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchConfigRuleException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchConfigRuleException {}
/// See [`NoSuchConfigRuleException`](crate::error::NoSuchConfigRuleException)
pub mod no_such_config_rule_exception {
    /// A builder for [`NoSuchConfigRuleException`](crate::error::NoSuchConfigRuleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchConfigRuleException`](crate::error::NoSuchConfigRuleException)
        pub fn build(self) -> crate::error::NoSuchConfigRuleException {
            crate::error::NoSuchConfigRuleException {
                message: self.message,
            }
        }
    }
}
impl NoSuchConfigRuleException {
    /// Creates a new builder-style object to manufacture [`NoSuchConfigRuleException`](crate::error::NoSuchConfigRuleException)
    pub fn builder() -> crate::error::no_such_config_rule_exception::Builder {
        crate::error::no_such_config_rule_exception::Builder::default()
    }
}

/// <p>For <code>StartConfigRulesEvaluation</code> API, this exception
/// is thrown if an evaluation is in progress or if you call the <a>StartConfigRulesEvaluation</a> API more than once per
/// minute.</p>
/// <p>For <code>PutConfigurationAggregator</code> API, this exception
/// is thrown if the number of accounts and aggregators exceeds the
/// limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The specified next token is invalid. Specify the
/// <code>nextToken</code> string that was returned in the previous
/// response to get the next page of results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>The specified limit is outside the allowable range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidLimitException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidLimitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidLimitException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidLimitException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLimitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLimitException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLimitException {}
/// See [`InvalidLimitException`](crate::error::InvalidLimitException)
pub mod invalid_limit_exception {
    /// A builder for [`InvalidLimitException`](crate::error::InvalidLimitException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLimitException`](crate::error::InvalidLimitException)
        pub fn build(self) -> crate::error::InvalidLimitException {
            crate::error::InvalidLimitException {
                message: self.message,
            }
        }
    }
}
impl InvalidLimitException {
    /// Creates a new builder-style object to manufacture [`InvalidLimitException`](crate::error::InvalidLimitException)
    pub fn builder() -> crate::error::invalid_limit_exception::Builder {
        crate::error::invalid_limit_exception::Builder::default()
    }
}

/// <p>The syntax of the query is incorrect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExpressionException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExpressionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExpressionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExpressionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExpressionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExpressionException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExpressionException {}
/// See [`InvalidExpressionException`](crate::error::InvalidExpressionException)
pub mod invalid_expression_exception {
    /// A builder for [`InvalidExpressionException`](crate::error::InvalidExpressionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExpressionException`](crate::error::InvalidExpressionException)
        pub fn build(self) -> crate::error::InvalidExpressionException {
            crate::error::InvalidExpressionException {
                message: self.message,
            }
        }
    }
}
impl InvalidExpressionException {
    /// Creates a new builder-style object to manufacture [`InvalidExpressionException`](crate::error::InvalidExpressionException)
    pub fn builder() -> crate::error::invalid_expression_exception::Builder {
        crate::error::invalid_expression_exception::Builder::default()
    }
}

/// <p>You have specified a configuration aggregator that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchConfigurationAggregatorException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchConfigurationAggregatorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchConfigurationAggregatorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchConfigurationAggregatorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchConfigurationAggregatorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchConfigurationAggregatorException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchConfigurationAggregatorException {}
/// See [`NoSuchConfigurationAggregatorException`](crate::error::NoSuchConfigurationAggregatorException)
pub mod no_such_configuration_aggregator_exception {
    /// A builder for [`NoSuchConfigurationAggregatorException`](crate::error::NoSuchConfigurationAggregatorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchConfigurationAggregatorException`](crate::error::NoSuchConfigurationAggregatorException)
        pub fn build(self) -> crate::error::NoSuchConfigurationAggregatorException {
            crate::error::NoSuchConfigurationAggregatorException {
                message: self.message,
            }
        }
    }
}
impl NoSuchConfigurationAggregatorException {
    /// Creates a new builder-style object to manufacture [`NoSuchConfigurationAggregatorException`](crate::error::NoSuchConfigurationAggregatorException)
    pub fn builder() -> crate::error::no_such_configuration_aggregator_exception::Builder {
        crate::error::no_such_configuration_aggregator_exception::Builder::default()
    }
}

/// <p>Two users are trying to modify the same query at the same time. Wait for a moment and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConcurrentModificationException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceConcurrentModificationException {}
/// See [`ResourceConcurrentModificationException`](crate::error::ResourceConcurrentModificationException)
pub mod resource_concurrent_modification_exception {
    /// A builder for [`ResourceConcurrentModificationException`](crate::error::ResourceConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConcurrentModificationException`](crate::error::ResourceConcurrentModificationException)
        pub fn build(self) -> crate::error::ResourceConcurrentModificationException {
            crate::error::ResourceConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ResourceConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ResourceConcurrentModificationException`](crate::error::ResourceConcurrentModificationException)
    pub fn builder() -> crate::error::resource_concurrent_modification_exception::Builder {
        crate::error::resource_concurrent_modification_exception::Builder::default()
    }
}

/// <p>Failed to add the retention configuration because a retention configuration with that name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfRetentionConfigurationsExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfRetentionConfigurationsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfRetentionConfigurationsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfRetentionConfigurationsExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfRetentionConfigurationsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfRetentionConfigurationsExceededException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfRetentionConfigurationsExceededException {}
/// See [`MaxNumberOfRetentionConfigurationsExceededException`](crate::error::MaxNumberOfRetentionConfigurationsExceededException)
pub mod max_number_of_retention_configurations_exceeded_exception {
    /// A builder for [`MaxNumberOfRetentionConfigurationsExceededException`](crate::error::MaxNumberOfRetentionConfigurationsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfRetentionConfigurationsExceededException`](crate::error::MaxNumberOfRetentionConfigurationsExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfRetentionConfigurationsExceededException {
            crate::error::MaxNumberOfRetentionConfigurationsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfRetentionConfigurationsExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfRetentionConfigurationsExceededException`](crate::error::MaxNumberOfRetentionConfigurationsExceededException)
    pub fn builder(
    ) -> crate::error::max_number_of_retention_configurations_exceeded_exception::Builder {
        crate::error::max_number_of_retention_configurations_exceeded_exception::Builder::default()
    }
}

/// <p>There is no configuration recorder running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoRunningConfigurationRecorderException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoRunningConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoRunningConfigurationRecorderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoRunningConfigurationRecorderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoRunningConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoRunningConfigurationRecorderException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoRunningConfigurationRecorderException {}
/// See [`NoRunningConfigurationRecorderException`](crate::error::NoRunningConfigurationRecorderException)
pub mod no_running_configuration_recorder_exception {
    /// A builder for [`NoRunningConfigurationRecorderException`](crate::error::NoRunningConfigurationRecorderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoRunningConfigurationRecorderException`](crate::error::NoRunningConfigurationRecorderException)
        pub fn build(self) -> crate::error::NoRunningConfigurationRecorderException {
            crate::error::NoRunningConfigurationRecorderException {
                message: self.message,
            }
        }
    }
}
impl NoRunningConfigurationRecorderException {
    /// Creates a new builder-style object to manufacture [`NoRunningConfigurationRecorderException`](crate::error::NoRunningConfigurationRecorderException)
    pub fn builder() -> crate::error::no_running_configuration_recorder_exception::Builder {
        crate::error::no_running_configuration_recorder_exception::Builder::default()
    }
}

/// <p>You have reached the limit (100,000) of active custom resource types in your account.
/// Delete unused resources using <code>DeleteResourceConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxActiveResourcesExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxActiveResourcesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxActiveResourcesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxActiveResourcesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxActiveResourcesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxActiveResourcesExceededException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxActiveResourcesExceededException {}
/// See [`MaxActiveResourcesExceededException`](crate::error::MaxActiveResourcesExceededException)
pub mod max_active_resources_exceeded_exception {
    /// A builder for [`MaxActiveResourcesExceededException`](crate::error::MaxActiveResourcesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxActiveResourcesExceededException`](crate::error::MaxActiveResourcesExceededException)
        pub fn build(self) -> crate::error::MaxActiveResourcesExceededException {
            crate::error::MaxActiveResourcesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxActiveResourcesExceededException {
    /// Creates a new builder-style object to manufacture [`MaxActiveResourcesExceededException`](crate::error::MaxActiveResourcesExceededException)
    pub fn builder() -> crate::error::max_active_resources_exceeded_exception::Builder {
        crate::error::max_active_resources_exceeded_exception::Builder::default()
    }
}

/// <p>You have specified a template that is not valid or supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrganizationConformancePackTemplateValidationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OrganizationConformancePackTemplateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("OrganizationConformancePackTemplateValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OrganizationConformancePackTemplateValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationConformancePackTemplateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationConformancePackTemplateValidationException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationConformancePackTemplateValidationException {}
/// See [`OrganizationConformancePackTemplateValidationException`](crate::error::OrganizationConformancePackTemplateValidationException)
pub mod organization_conformance_pack_template_validation_exception {
    /// A builder for [`OrganizationConformancePackTemplateValidationException`](crate::error::OrganizationConformancePackTemplateValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConformancePackTemplateValidationException`](crate::error::OrganizationConformancePackTemplateValidationException)
        pub fn build(self) -> crate::error::OrganizationConformancePackTemplateValidationException {
            crate::error::OrganizationConformancePackTemplateValidationException {
                message: self.message,
            }
        }
    }
}
impl OrganizationConformancePackTemplateValidationException {
    /// Creates a new builder-style object to manufacture [`OrganizationConformancePackTemplateValidationException`](crate::error::OrganizationConformancePackTemplateValidationException)
    pub fn builder(
    ) -> crate::error::organization_conformance_pack_template_validation_exception::Builder {
        crate::error::organization_conformance_pack_template_validation_exception::Builder::default(
        )
    }
}

/// <p>AWS Config resource cannot be created because your organization does not have all features enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrganizationAllFeaturesNotEnabledException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OrganizationAllFeaturesNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrganizationAllFeaturesNotEnabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OrganizationAllFeaturesNotEnabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationAllFeaturesNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationAllFeaturesNotEnabledException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationAllFeaturesNotEnabledException {}
/// See [`OrganizationAllFeaturesNotEnabledException`](crate::error::OrganizationAllFeaturesNotEnabledException)
pub mod organization_all_features_not_enabled_exception {
    /// A builder for [`OrganizationAllFeaturesNotEnabledException`](crate::error::OrganizationAllFeaturesNotEnabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationAllFeaturesNotEnabledException`](crate::error::OrganizationAllFeaturesNotEnabledException)
        pub fn build(self) -> crate::error::OrganizationAllFeaturesNotEnabledException {
            crate::error::OrganizationAllFeaturesNotEnabledException {
                message: self.message,
            }
        }
    }
}
impl OrganizationAllFeaturesNotEnabledException {
    /// Creates a new builder-style object to manufacture [`OrganizationAllFeaturesNotEnabledException`](crate::error::OrganizationAllFeaturesNotEnabledException)
    pub fn builder() -> crate::error::organization_all_features_not_enabled_exception::Builder {
        crate::error::organization_all_features_not_enabled_exception::Builder::default()
    }
}

/// <p>For <code>PutConfigurationAggregator</code> API, you can see this exception for the following reasons:</p>
/// <ul>
/// <li>
/// <p>No permission to call <code>EnableAWSServiceAccess</code> API</p>
/// </li>
/// <li>
/// <p>The configuration aggregator cannot be updated because your AWS Organization management account or the delegated administrator role changed.
/// Delete this aggregator and create a new one with the current AWS Organization.</p>
/// </li>
/// <li>
/// <p>The configuration aggregator is associated with a previous AWS Organization and AWS Config cannot aggregate data with current AWS Organization.
/// Delete this aggregator and create a new one with the current AWS Organization.</p>
/// </li>
/// <li>
/// <p>You are not a registered delegated administrator for AWS Config with permissions to call <code>ListDelegatedAdministrators</code> API.
/// Ensure that the management account registers delagated administrator for AWS Config service principle name before the delegated administrator creates an aggregator.</p>
/// </li>
/// </ul>  
/// <p>For all <code>OrganizationConfigRule</code> and <code>OrganizationConformancePack</code> APIs, AWS Config throws an exception if APIs are called from member accounts. All APIs must be called from organization master account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrganizationAccessDeniedException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OrganizationAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrganizationAccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OrganizationAccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationAccessDeniedException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationAccessDeniedException {}
/// See [`OrganizationAccessDeniedException`](crate::error::OrganizationAccessDeniedException)
pub mod organization_access_denied_exception {
    /// A builder for [`OrganizationAccessDeniedException`](crate::error::OrganizationAccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationAccessDeniedException`](crate::error::OrganizationAccessDeniedException)
        pub fn build(self) -> crate::error::OrganizationAccessDeniedException {
            crate::error::OrganizationAccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl OrganizationAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`OrganizationAccessDeniedException`](crate::error::OrganizationAccessDeniedException)
    pub fn builder() -> crate::error::organization_access_denied_exception::Builder {
        crate::error::organization_access_denied_exception::Builder::default()
    }
}

/// <p>Organization is no longer available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoAvailableOrganizationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoAvailableOrganizationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoAvailableOrganizationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoAvailableOrganizationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoAvailableOrganizationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoAvailableOrganizationException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoAvailableOrganizationException {}
/// See [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException)
pub mod no_available_organization_exception {
    /// A builder for [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException)
        pub fn build(self) -> crate::error::NoAvailableOrganizationException {
            crate::error::NoAvailableOrganizationException {
                message: self.message,
            }
        }
    }
}
impl NoAvailableOrganizationException {
    /// Creates a new builder-style object to manufacture [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException)
    pub fn builder() -> crate::error::no_available_organization_exception::Builder {
        crate::error::no_available_organization_exception::Builder::default()
    }
}

/// <p>You have reached the limit (6) of the number of organization conformance packs in an account (6 conformance pack with 25 AWS Config rules per pack per account).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfOrganizationConformancePacksExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfOrganizationConformancePacksExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("MaxNumberOfOrganizationConformancePacksExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfOrganizationConformancePacksExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfOrganizationConformancePacksExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MaxNumberOfOrganizationConformancePacksExceededException"
        )?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfOrganizationConformancePacksExceededException {}
/// See [`MaxNumberOfOrganizationConformancePacksExceededException`](crate::error::MaxNumberOfOrganizationConformancePacksExceededException)
pub mod max_number_of_organization_conformance_packs_exceeded_exception {
    /// A builder for [`MaxNumberOfOrganizationConformancePacksExceededException`](crate::error::MaxNumberOfOrganizationConformancePacksExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfOrganizationConformancePacksExceededException`](crate::error::MaxNumberOfOrganizationConformancePacksExceededException)
        pub fn build(
            self,
        ) -> crate::error::MaxNumberOfOrganizationConformancePacksExceededException {
            crate::error::MaxNumberOfOrganizationConformancePacksExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfOrganizationConformancePacksExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfOrganizationConformancePacksExceededException`](crate::error::MaxNumberOfOrganizationConformancePacksExceededException)
    pub fn builder(
    ) -> crate::error::max_number_of_organization_conformance_packs_exceeded_exception::Builder
    {
        crate::error::max_number_of_organization_conformance_packs_exceeded_exception::Builder::default()
    }
}

/// <p>You have reached the limit of the number of organization config rules you can create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfOrganizationConfigRulesExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfOrganizationConfigRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfOrganizationConfigRulesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfOrganizationConfigRulesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfOrganizationConfigRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfOrganizationConfigRulesExceededException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfOrganizationConfigRulesExceededException {}
/// See [`MaxNumberOfOrganizationConfigRulesExceededException`](crate::error::MaxNumberOfOrganizationConfigRulesExceededException)
pub mod max_number_of_organization_config_rules_exceeded_exception {
    /// A builder for [`MaxNumberOfOrganizationConfigRulesExceededException`](crate::error::MaxNumberOfOrganizationConfigRulesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfOrganizationConfigRulesExceededException`](crate::error::MaxNumberOfOrganizationConfigRulesExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfOrganizationConfigRulesExceededException {
            crate::error::MaxNumberOfOrganizationConfigRulesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfOrganizationConfigRulesExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfOrganizationConfigRulesExceededException`](crate::error::MaxNumberOfOrganizationConfigRulesExceededException)
    pub fn builder(
    ) -> crate::error::max_number_of_organization_config_rules_exceeded_exception::Builder {
        crate::error::max_number_of_organization_config_rules_exceeded_exception::Builder::default()
    }
}

/// <p>The specified <code>ResultToken</code> is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResultTokenException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResultTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResultTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResultTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResultTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResultTokenException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResultTokenException {}
/// See [`InvalidResultTokenException`](crate::error::InvalidResultTokenException)
pub mod invalid_result_token_exception {
    /// A builder for [`InvalidResultTokenException`](crate::error::InvalidResultTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResultTokenException`](crate::error::InvalidResultTokenException)
        pub fn build(self) -> crate::error::InvalidResultTokenException {
            crate::error::InvalidResultTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidResultTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidResultTokenException`](crate::error::InvalidResultTokenException)
    pub fn builder() -> crate::error::invalid_result_token_exception::Builder {
        crate::error::invalid_result_token_exception::Builder::default()
    }
}

/// <p>The specified Amazon S3 bucket does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchBucketException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchBucketException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchBucketException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchBucketException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchBucketException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchBucketException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchBucketException {}
/// See [`NoSuchBucketException`](crate::error::NoSuchBucketException)
pub mod no_such_bucket_exception {
    /// A builder for [`NoSuchBucketException`](crate::error::NoSuchBucketException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchBucketException`](crate::error::NoSuchBucketException)
        pub fn build(self) -> crate::error::NoSuchBucketException {
            crate::error::NoSuchBucketException {
                message: self.message,
            }
        }
    }
}
impl NoSuchBucketException {
    /// Creates a new builder-style object to manufacture [`NoSuchBucketException`](crate::error::NoSuchBucketException)
    pub fn builder() -> crate::error::no_such_bucket_exception::Builder {
        crate::error::no_such_bucket_exception::Builder::default()
    }
}

/// <p>There are no configuration recorders available to provide the
/// role needed to describe your resources. Create a configuration
/// recorder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoAvailableConfigurationRecorderException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoAvailableConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoAvailableConfigurationRecorderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoAvailableConfigurationRecorderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoAvailableConfigurationRecorderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoAvailableConfigurationRecorderException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoAvailableConfigurationRecorderException {}
/// See [`NoAvailableConfigurationRecorderException`](crate::error::NoAvailableConfigurationRecorderException)
pub mod no_available_configuration_recorder_exception {
    /// A builder for [`NoAvailableConfigurationRecorderException`](crate::error::NoAvailableConfigurationRecorderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoAvailableConfigurationRecorderException`](crate::error::NoAvailableConfigurationRecorderException)
        pub fn build(self) -> crate::error::NoAvailableConfigurationRecorderException {
            crate::error::NoAvailableConfigurationRecorderException {
                message: self.message,
            }
        }
    }
}
impl NoAvailableConfigurationRecorderException {
    /// Creates a new builder-style object to manufacture [`NoAvailableConfigurationRecorderException`](crate::error::NoAvailableConfigurationRecorderException)
    pub fn builder() -> crate::error::no_available_configuration_recorder_exception::Builder {
        crate::error::no_available_configuration_recorder_exception::Builder::default()
    }
}

/// <p>You have reached the limit of the number of delivery channels
/// you can create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfDeliveryChannelsExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfDeliveryChannelsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfDeliveryChannelsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfDeliveryChannelsExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfDeliveryChannelsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfDeliveryChannelsExceededException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfDeliveryChannelsExceededException {}
/// See [`MaxNumberOfDeliveryChannelsExceededException`](crate::error::MaxNumberOfDeliveryChannelsExceededException)
pub mod max_number_of_delivery_channels_exceeded_exception {
    /// A builder for [`MaxNumberOfDeliveryChannelsExceededException`](crate::error::MaxNumberOfDeliveryChannelsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfDeliveryChannelsExceededException`](crate::error::MaxNumberOfDeliveryChannelsExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfDeliveryChannelsExceededException {
            crate::error::MaxNumberOfDeliveryChannelsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfDeliveryChannelsExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfDeliveryChannelsExceededException`](crate::error::MaxNumberOfDeliveryChannelsExceededException)
    pub fn builder() -> crate::error::max_number_of_delivery_channels_exceeded_exception::Builder {
        crate::error::max_number_of_delivery_channels_exceeded_exception::Builder::default()
    }
}

/// <p>The specified Amazon SNS topic does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSnsTopicArnException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSnsTopicArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSnsTopicArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSnsTopicArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnsTopicArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidSnsTopicArnException [InvalidSNSTopicARNException]"
        )?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnsTopicArnException {}
/// See [`InvalidSnsTopicArnException`](crate::error::InvalidSnsTopicArnException)
pub mod invalid_sns_topic_arn_exception {
    /// A builder for [`InvalidSnsTopicArnException`](crate::error::InvalidSnsTopicArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnsTopicArnException`](crate::error::InvalidSnsTopicArnException)
        pub fn build(self) -> crate::error::InvalidSnsTopicArnException {
            crate::error::InvalidSnsTopicArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidSnsTopicArnException {
    /// Creates a new builder-style object to manufacture [`InvalidSnsTopicArnException`](crate::error::InvalidSnsTopicArnException)
    pub fn builder() -> crate::error::invalid_sns_topic_arn_exception::Builder {
        crate::error::invalid_sns_topic_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon KMS Key ARN is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3KmsKeyArnException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3KmsKeyArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3KmsKeyArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3KmsKeyArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3KmsKeyArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3KmsKeyArnException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3KmsKeyArnException {}
/// See [`InvalidS3KmsKeyArnException`](crate::error::InvalidS3KmsKeyArnException)
pub mod invalid_s3_kms_key_arn_exception {
    /// A builder for [`InvalidS3KmsKeyArnException`](crate::error::InvalidS3KmsKeyArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3KmsKeyArnException`](crate::error::InvalidS3KmsKeyArnException)
        pub fn build(self) -> crate::error::InvalidS3KmsKeyArnException {
            crate::error::InvalidS3KmsKeyArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidS3KmsKeyArnException {
    /// Creates a new builder-style object to manufacture [`InvalidS3KmsKeyArnException`](crate::error::InvalidS3KmsKeyArnException)
    pub fn builder() -> crate::error::invalid_s3_kms_key_arn_exception::Builder {
        crate::error::invalid_s3_kms_key_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon S3 key prefix is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3KeyPrefixException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3KeyPrefixException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3KeyPrefixException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3KeyPrefixException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3KeyPrefixException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3KeyPrefixException")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3KeyPrefixException {}
/// See [`InvalidS3KeyPrefixException`](crate::error::InvalidS3KeyPrefixException)
pub mod invalid_s3_key_prefix_exception {
    /// A builder for [`InvalidS3KeyPrefixException`](crate::error::InvalidS3KeyPrefixException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3KeyPrefixException`](crate::error::InvalidS3KeyPrefixException)
        pub fn build(self) -> crate::error::InvalidS3KeyPrefixException {
            crate::error::InvalidS3KeyPrefixException {
                message: self.message,
            }
        }
    }
}
impl InvalidS3KeyPrefixException {
    /// Creates a new builder-style object to manufacture [`InvalidS3KeyPrefixException`](crate::error::InvalidS3KeyPrefixException)
    pub fn builder() -> crate::error::invalid_s3_key_prefix_exception::Builder {
        crate::error::invalid_s3_key_prefix_exception::Builder::default()
    }
}

/// <p>The specified delivery channel name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDeliveryChannelNameException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDeliveryChannelNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDeliveryChannelNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDeliveryChannelNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeliveryChannelNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeliveryChannelNameException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeliveryChannelNameException {}
/// See [`InvalidDeliveryChannelNameException`](crate::error::InvalidDeliveryChannelNameException)
pub mod invalid_delivery_channel_name_exception {
    /// A builder for [`InvalidDeliveryChannelNameException`](crate::error::InvalidDeliveryChannelNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeliveryChannelNameException`](crate::error::InvalidDeliveryChannelNameException)
        pub fn build(self) -> crate::error::InvalidDeliveryChannelNameException {
            crate::error::InvalidDeliveryChannelNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidDeliveryChannelNameException {
    /// Creates a new builder-style object to manufacture [`InvalidDeliveryChannelNameException`](crate::error::InvalidDeliveryChannelNameException)
    pub fn builder() -> crate::error::invalid_delivery_channel_name_exception::Builder {
        crate::error::invalid_delivery_channel_name_exception::Builder::default()
    }
}

/// <p>Your Amazon S3 bucket policy does not permit AWS Config to
/// write to it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDeliveryPolicyException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDeliveryPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientDeliveryPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDeliveryPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDeliveryPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientDeliveryPolicyException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDeliveryPolicyException {}
/// See [`InsufficientDeliveryPolicyException`](crate::error::InsufficientDeliveryPolicyException)
pub mod insufficient_delivery_policy_exception {
    /// A builder for [`InsufficientDeliveryPolicyException`](crate::error::InsufficientDeliveryPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDeliveryPolicyException`](crate::error::InsufficientDeliveryPolicyException)
        pub fn build(self) -> crate::error::InsufficientDeliveryPolicyException {
            crate::error::InsufficientDeliveryPolicyException {
                message: self.message,
            }
        }
    }
}
impl InsufficientDeliveryPolicyException {
    /// Creates a new builder-style object to manufacture [`InsufficientDeliveryPolicyException`](crate::error::InsufficientDeliveryPolicyException)
    pub fn builder() -> crate::error::insufficient_delivery_policy_exception::Builder {
        crate::error::insufficient_delivery_policy_exception::Builder::default()
    }
}

/// <p>You have reached the limit (6) of the number of conformance packs in an account (6 conformance pack with 25 AWS Config rules per pack).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfConformancePacksExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfConformancePacksExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfConformancePacksExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfConformancePacksExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfConformancePacksExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfConformancePacksExceededException")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfConformancePacksExceededException {}
/// See [`MaxNumberOfConformancePacksExceededException`](crate::error::MaxNumberOfConformancePacksExceededException)
pub mod max_number_of_conformance_packs_exceeded_exception {
    /// A builder for [`MaxNumberOfConformancePacksExceededException`](crate::error::MaxNumberOfConformancePacksExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfConformancePacksExceededException`](crate::error::MaxNumberOfConformancePacksExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfConformancePacksExceededException {
            crate::error::MaxNumberOfConformancePacksExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfConformancePacksExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfConformancePacksExceededException`](crate::error::MaxNumberOfConformancePacksExceededException)
    pub fn builder() -> crate::error::max_number_of_conformance_packs_exceeded_exception::Builder {
        crate::error::max_number_of_conformance_packs_exceeded_exception::Builder::default()
    }
}

/// <p>You have specified a template that is not valid or supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConformancePackTemplateValidationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConformancePackTemplateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConformancePackTemplateValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConformancePackTemplateValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConformancePackTemplateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConformancePackTemplateValidationException")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConformancePackTemplateValidationException {}
/// See [`ConformancePackTemplateValidationException`](crate::error::ConformancePackTemplateValidationException)
pub mod conformance_pack_template_validation_exception {
    /// A builder for [`ConformancePackTemplateValidationException`](crate::error::ConformancePackTemplateValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackTemplateValidationException`](crate::error::ConformancePackTemplateValidationException)
        pub fn build(self) -> crate::error::ConformancePackTemplateValidationException {
            crate::error::ConformancePackTemplateValidationException {
                message: self.message,
            }
        }
    }
}
impl ConformancePackTemplateValidationException {
    /// Creates a new builder-style object to manufacture [`ConformancePackTemplateValidationException`](crate::error::ConformancePackTemplateValidationException)
    pub fn builder() -> crate::error::conformance_pack_template_validation_exception::Builder {
        crate::error::conformance_pack_template_validation_exception::Builder::default()
    }
}

/// <p>You have reached the limit of the number of recorders you can
/// create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfConfigurationRecordersExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfConfigurationRecordersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfConfigurationRecordersExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfConfigurationRecordersExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfConfigurationRecordersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfConfigurationRecordersExceededException")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfConfigurationRecordersExceededException {}
/// See [`MaxNumberOfConfigurationRecordersExceededException`](crate::error::MaxNumberOfConfigurationRecordersExceededException)
pub mod max_number_of_configuration_recorders_exceeded_exception {
    /// A builder for [`MaxNumberOfConfigurationRecordersExceededException`](crate::error::MaxNumberOfConfigurationRecordersExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfConfigurationRecordersExceededException`](crate::error::MaxNumberOfConfigurationRecordersExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfConfigurationRecordersExceededException {
            crate::error::MaxNumberOfConfigurationRecordersExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfConfigurationRecordersExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfConfigurationRecordersExceededException`](crate::error::MaxNumberOfConfigurationRecordersExceededException)
    pub fn builder(
    ) -> crate::error::max_number_of_configuration_recorders_exceeded_exception::Builder {
        crate::error::max_number_of_configuration_recorders_exceeded_exception::Builder::default()
    }
}

/// <p>You have provided a null or empty role ARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRoleException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRoleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRoleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRoleException")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRoleException {}
/// See [`InvalidRoleException`](crate::error::InvalidRoleException)
pub mod invalid_role_exception {
    /// A builder for [`InvalidRoleException`](crate::error::InvalidRoleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRoleException`](crate::error::InvalidRoleException)
        pub fn build(self) -> crate::error::InvalidRoleException {
            crate::error::InvalidRoleException {
                message: self.message,
            }
        }
    }
}
impl InvalidRoleException {
    /// Creates a new builder-style object to manufacture [`InvalidRoleException`](crate::error::InvalidRoleException)
    pub fn builder() -> crate::error::invalid_role_exception::Builder {
        crate::error::invalid_role_exception::Builder::default()
    }
}

/// <p>AWS Config throws an exception if the recording group does not contain a valid list of resource types. Invalid values might also be incorrectly formatted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRecordingGroupException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRecordingGroupException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRecordingGroupException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRecordingGroupException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRecordingGroupException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRecordingGroupException")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRecordingGroupException {}
/// See [`InvalidRecordingGroupException`](crate::error::InvalidRecordingGroupException)
pub mod invalid_recording_group_exception {
    /// A builder for [`InvalidRecordingGroupException`](crate::error::InvalidRecordingGroupException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRecordingGroupException`](crate::error::InvalidRecordingGroupException)
        pub fn build(self) -> crate::error::InvalidRecordingGroupException {
            crate::error::InvalidRecordingGroupException {
                message: self.message,
            }
        }
    }
}
impl InvalidRecordingGroupException {
    /// Creates a new builder-style object to manufacture [`InvalidRecordingGroupException`](crate::error::InvalidRecordingGroupException)
    pub fn builder() -> crate::error::invalid_recording_group_exception::Builder {
        crate::error::invalid_recording_group_exception::Builder::default()
    }
}

/// <p>You have provided a configuration recorder name that is not
/// valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConfigurationRecorderNameException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConfigurationRecorderNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConfigurationRecorderNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConfigurationRecorderNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConfigurationRecorderNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConfigurationRecorderNameException")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConfigurationRecorderNameException {}
/// See [`InvalidConfigurationRecorderNameException`](crate::error::InvalidConfigurationRecorderNameException)
pub mod invalid_configuration_recorder_name_exception {
    /// A builder for [`InvalidConfigurationRecorderNameException`](crate::error::InvalidConfigurationRecorderNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConfigurationRecorderNameException`](crate::error::InvalidConfigurationRecorderNameException)
        pub fn build(self) -> crate::error::InvalidConfigurationRecorderNameException {
            crate::error::InvalidConfigurationRecorderNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidConfigurationRecorderNameException {
    /// Creates a new builder-style object to manufacture [`InvalidConfigurationRecorderNameException`](crate::error::InvalidConfigurationRecorderNameException)
    pub fn builder() -> crate::error::invalid_configuration_recorder_name_exception::Builder {
        crate::error::invalid_configuration_recorder_name_exception::Builder::default()
    }
}

/// <p>Failed to add the AWS Config rule because the account already
/// contains the maximum number of 150 rules. Consider deleting any
/// deactivated rules before you add new rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxNumberOfConfigRulesExceededException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxNumberOfConfigRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxNumberOfConfigRulesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxNumberOfConfigRulesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxNumberOfConfigRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxNumberOfConfigRulesExceededException")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxNumberOfConfigRulesExceededException {}
/// See [`MaxNumberOfConfigRulesExceededException`](crate::error::MaxNumberOfConfigRulesExceededException)
pub mod max_number_of_config_rules_exceeded_exception {
    /// A builder for [`MaxNumberOfConfigRulesExceededException`](crate::error::MaxNumberOfConfigRulesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxNumberOfConfigRulesExceededException`](crate::error::MaxNumberOfConfigRulesExceededException)
        pub fn build(self) -> crate::error::MaxNumberOfConfigRulesExceededException {
            crate::error::MaxNumberOfConfigRulesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaxNumberOfConfigRulesExceededException {
    /// Creates a new builder-style object to manufacture [`MaxNumberOfConfigRulesExceededException`](crate::error::MaxNumberOfConfigRulesExceededException)
    pub fn builder() -> crate::error::max_number_of_config_rules_exceeded_exception::Builder {
        crate::error::max_number_of_config_rules_exceeded_exception::Builder::default()
    }
}

/// <p>You have specified a resource that is either unknown or has not
/// been discovered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotDiscoveredException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotDiscoveredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotDiscoveredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotDiscoveredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotDiscoveredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotDiscoveredException")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotDiscoveredException {}
/// See [`ResourceNotDiscoveredException`](crate::error::ResourceNotDiscoveredException)
pub mod resource_not_discovered_exception {
    /// A builder for [`ResourceNotDiscoveredException`](crate::error::ResourceNotDiscoveredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotDiscoveredException`](crate::error::ResourceNotDiscoveredException)
        pub fn build(self) -> crate::error::ResourceNotDiscoveredException {
            crate::error::ResourceNotDiscoveredException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotDiscoveredException {
    /// Creates a new builder-style object to manufacture [`ResourceNotDiscoveredException`](crate::error::ResourceNotDiscoveredException)
    pub fn builder() -> crate::error::resource_not_discovered_exception::Builder {
        crate::error::resource_not_discovered_exception::Builder::default()
    }
}

/// <p>The specified time range is not valid. The earlier time is not
/// chronologically before the later time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTimeRangeException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTimeRangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTimeRangeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTimeRangeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTimeRangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTimeRangeException")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTimeRangeException {}
/// See [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
pub mod invalid_time_range_exception {
    /// A builder for [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
        pub fn build(self) -> crate::error::InvalidTimeRangeException {
            crate::error::InvalidTimeRangeException {
                message: self.message,
            }
        }
    }
}
impl InvalidTimeRangeException {
    /// Creates a new builder-style object to manufacture [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
    pub fn builder() -> crate::error::invalid_time_range_exception::Builder {
        crate::error::invalid_time_range_exception::Builder::default()
    }
}

/// <p>AWS Config organization conformance pack that you passed in the filter does not exist.</p>
/// <p>For DeleteOrganizationConformancePack, you tried to delete an organization conformance pack that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchOrganizationConformancePackException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchOrganizationConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchOrganizationConformancePackException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchOrganizationConformancePackException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchOrganizationConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchOrganizationConformancePackException")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchOrganizationConformancePackException {}
/// See [`NoSuchOrganizationConformancePackException`](crate::error::NoSuchOrganizationConformancePackException)
pub mod no_such_organization_conformance_pack_exception {
    /// A builder for [`NoSuchOrganizationConformancePackException`](crate::error::NoSuchOrganizationConformancePackException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchOrganizationConformancePackException`](crate::error::NoSuchOrganizationConformancePackException)
        pub fn build(self) -> crate::error::NoSuchOrganizationConformancePackException {
            crate::error::NoSuchOrganizationConformancePackException {
                message: self.message,
            }
        }
    }
}
impl NoSuchOrganizationConformancePackException {
    /// Creates a new builder-style object to manufacture [`NoSuchOrganizationConformancePackException`](crate::error::NoSuchOrganizationConformancePackException)
    pub fn builder() -> crate::error::no_such_organization_conformance_pack_exception::Builder {
        crate::error::no_such_organization_conformance_pack_exception::Builder::default()
    }
}

/// <p>You specified one or more organization config rules that do not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchOrganizationConfigRuleException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchOrganizationConfigRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchOrganizationConfigRuleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchOrganizationConfigRuleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchOrganizationConfigRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchOrganizationConfigRuleException")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchOrganizationConfigRuleException {}
/// See [`NoSuchOrganizationConfigRuleException`](crate::error::NoSuchOrganizationConfigRuleException)
pub mod no_such_organization_config_rule_exception {
    /// A builder for [`NoSuchOrganizationConfigRuleException`](crate::error::NoSuchOrganizationConfigRuleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchOrganizationConfigRuleException`](crate::error::NoSuchOrganizationConfigRuleException)
        pub fn build(self) -> crate::error::NoSuchOrganizationConfigRuleException {
            crate::error::NoSuchOrganizationConfigRuleException {
                message: self.message,
            }
        }
    }
}
impl NoSuchOrganizationConfigRuleException {
    /// Creates a new builder-style object to manufacture [`NoSuchOrganizationConfigRuleException`](crate::error::NoSuchOrganizationConfigRuleException)
    pub fn builder() -> crate::error::no_such_organization_config_rule_exception::Builder {
        crate::error::no_such_organization_config_rule_exception::Builder::default()
    }
}

/// <p>You specified one or more conformance packs that do not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchConformancePackException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchConformancePackException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchConformancePackException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchConformancePackException")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchConformancePackException {}
/// See [`NoSuchConformancePackException`](crate::error::NoSuchConformancePackException)
pub mod no_such_conformance_pack_exception {
    /// A builder for [`NoSuchConformancePackException`](crate::error::NoSuchConformancePackException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchConformancePackException`](crate::error::NoSuchConformancePackException)
        pub fn build(self) -> crate::error::NoSuchConformancePackException {
            crate::error::NoSuchConformancePackException {
                message: self.message,
            }
        }
    }
}
impl NoSuchConformancePackException {
    /// Creates a new builder-style object to manufacture [`NoSuchConformancePackException`](crate::error::NoSuchConformancePackException)
    pub fn builder() -> crate::error::no_such_conformance_pack_exception::Builder {
        crate::error::no_such_conformance_pack_exception::Builder::default()
    }
}

/// <p>AWS Config rule that you passed in the filter does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchConfigRuleInConformancePackException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchConfigRuleInConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchConfigRuleInConformancePackException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchConfigRuleInConformancePackException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchConfigRuleInConformancePackException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchConfigRuleInConformancePackException")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchConfigRuleInConformancePackException {}
/// See [`NoSuchConfigRuleInConformancePackException`](crate::error::NoSuchConfigRuleInConformancePackException)
pub mod no_such_config_rule_in_conformance_pack_exception {
    /// A builder for [`NoSuchConfigRuleInConformancePackException`](crate::error::NoSuchConfigRuleInConformancePackException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchConfigRuleInConformancePackException`](crate::error::NoSuchConfigRuleInConformancePackException)
        pub fn build(self) -> crate::error::NoSuchConfigRuleInConformancePackException {
            crate::error::NoSuchConfigRuleInConformancePackException {
                message: self.message,
            }
        }
    }
}
impl NoSuchConfigRuleInConformancePackException {
    /// Creates a new builder-style object to manufacture [`NoSuchConfigRuleInConformancePackException`](crate::error::NoSuchConfigRuleInConformancePackException)
    pub fn builder() -> crate::error::no_such_config_rule_in_conformance_pack_exception::Builder {
        crate::error::no_such_config_rule_in_conformance_pack_exception::Builder::default()
    }
}

/// <p>The configuration item size is outside the allowable range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OversizedConfigurationItemException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OversizedConfigurationItemException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OversizedConfigurationItemException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OversizedConfigurationItemException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OversizedConfigurationItemException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OversizedConfigurationItemException")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for OversizedConfigurationItemException {}
/// See [`OversizedConfigurationItemException`](crate::error::OversizedConfigurationItemException)
pub mod oversized_configuration_item_exception {
    /// A builder for [`OversizedConfigurationItemException`](crate::error::OversizedConfigurationItemException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OversizedConfigurationItemException`](crate::error::OversizedConfigurationItemException)
        pub fn build(self) -> crate::error::OversizedConfigurationItemException {
            crate::error::OversizedConfigurationItemException {
                message: self.message,
            }
        }
    }
}
impl OversizedConfigurationItemException {
    /// Creates a new builder-style object to manufacture [`OversizedConfigurationItemException`](crate::error::OversizedConfigurationItemException)
    pub fn builder() -> crate::error::oversized_configuration_item_exception::Builder {
        crate::error::oversized_configuration_item_exception::Builder::default()
    }
}

/// <p>You have specified a retention configuration that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchRetentionConfigurationException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchRetentionConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchRetentionConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchRetentionConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchRetentionConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchRetentionConfigurationException")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchRetentionConfigurationException {}
/// See [`NoSuchRetentionConfigurationException`](crate::error::NoSuchRetentionConfigurationException)
pub mod no_such_retention_configuration_exception {
    /// A builder for [`NoSuchRetentionConfigurationException`](crate::error::NoSuchRetentionConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchRetentionConfigurationException`](crate::error::NoSuchRetentionConfigurationException)
        pub fn build(self) -> crate::error::NoSuchRetentionConfigurationException {
            crate::error::NoSuchRetentionConfigurationException {
                message: self.message,
            }
        }
    }
}
impl NoSuchRetentionConfigurationException {
    /// Creates a new builder-style object to manufacture [`NoSuchRetentionConfigurationException`](crate::error::NoSuchRetentionConfigurationException)
    pub fn builder() -> crate::error::no_such_retention_configuration_exception::Builder {
        crate::error::no_such_retention_configuration_exception::Builder::default()
    }
}

/// <p>You have specified a delivery channel that does not
/// exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchDeliveryChannelException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchDeliveryChannelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchDeliveryChannelException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchDeliveryChannelException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchDeliveryChannelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchDeliveryChannelException")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchDeliveryChannelException {}
/// See [`NoSuchDeliveryChannelException`](crate::error::NoSuchDeliveryChannelException)
pub mod no_such_delivery_channel_exception {
    /// A builder for [`NoSuchDeliveryChannelException`](crate::error::NoSuchDeliveryChannelException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchDeliveryChannelException`](crate::error::NoSuchDeliveryChannelException)
        pub fn build(self) -> crate::error::NoSuchDeliveryChannelException {
            crate::error::NoSuchDeliveryChannelException {
                message: self.message,
            }
        }
    }
}
impl NoSuchDeliveryChannelException {
    /// Creates a new builder-style object to manufacture [`NoSuchDeliveryChannelException`](crate::error::NoSuchDeliveryChannelException)
    pub fn builder() -> crate::error::no_such_delivery_channel_exception::Builder {
        crate::error::no_such_delivery_channel_exception::Builder::default()
    }
}

/// <p>You tried to delete a remediation exception that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchRemediationExceptionException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchRemediationExceptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchRemediationExceptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchRemediationExceptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchRemediationExceptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchRemediationExceptionException")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchRemediationExceptionException {}
/// See [`NoSuchRemediationExceptionException`](crate::error::NoSuchRemediationExceptionException)
pub mod no_such_remediation_exception_exception {
    /// A builder for [`NoSuchRemediationExceptionException`](crate::error::NoSuchRemediationExceptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchRemediationExceptionException`](crate::error::NoSuchRemediationExceptionException)
        pub fn build(self) -> crate::error::NoSuchRemediationExceptionException {
            crate::error::NoSuchRemediationExceptionException {
                message: self.message,
            }
        }
    }
}
impl NoSuchRemediationExceptionException {
    /// Creates a new builder-style object to manufacture [`NoSuchRemediationExceptionException`](crate::error::NoSuchRemediationExceptionException)
    pub fn builder() -> crate::error::no_such_remediation_exception_exception::Builder {
        crate::error::no_such_remediation_exception_exception::Builder::default()
    }
}

/// <p>Remediation action is in progress. You can either cancel execution in AWS Systems Manager or wait and try again later. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemediationInProgressException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemediationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemediationInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RemediationInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RemediationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RemediationInProgressException")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for RemediationInProgressException {}
/// See [`RemediationInProgressException`](crate::error::RemediationInProgressException)
pub mod remediation_in_progress_exception {
    /// A builder for [`RemediationInProgressException`](crate::error::RemediationInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationInProgressException`](crate::error::RemediationInProgressException)
        pub fn build(self) -> crate::error::RemediationInProgressException {
            crate::error::RemediationInProgressException {
                message: self.message,
            }
        }
    }
}
impl RemediationInProgressException {
    /// Creates a new builder-style object to manufacture [`RemediationInProgressException`](crate::error::RemediationInProgressException)
    pub fn builder() -> crate::error::remediation_in_progress_exception::Builder {
        crate::error::remediation_in_progress_exception::Builder::default()
    }
}

/// <p>You cannot delete the delivery channel you specified because
/// the configuration recorder is running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LastDeliveryChannelDeleteFailedException {
    /// <p>Error executing the command</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LastDeliveryChannelDeleteFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LastDeliveryChannelDeleteFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LastDeliveryChannelDeleteFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LastDeliveryChannelDeleteFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LastDeliveryChannelDeleteFailedException")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for LastDeliveryChannelDeleteFailedException {}
/// See [`LastDeliveryChannelDeleteFailedException`](crate::error::LastDeliveryChannelDeleteFailedException)
pub mod last_delivery_channel_delete_failed_exception {
    /// A builder for [`LastDeliveryChannelDeleteFailedException`](crate::error::LastDeliveryChannelDeleteFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error executing the command</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LastDeliveryChannelDeleteFailedException`](crate::error::LastDeliveryChannelDeleteFailedException)
        pub fn build(self) -> crate::error::LastDeliveryChannelDeleteFailedException {
            crate::error::LastDeliveryChannelDeleteFailedException {
                message: self.message,
            }
        }
    }
}
impl LastDeliveryChannelDeleteFailedException {
    /// Creates a new builder-style object to manufacture [`LastDeliveryChannelDeleteFailedException`](crate::error::LastDeliveryChannelDeleteFailedException)
    pub fn builder() -> crate::error::last_delivery_channel_delete_failed_exception::Builder {
        crate::error::last_delivery_channel_delete_failed_exception::Builder::default()
    }
}
